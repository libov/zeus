*CMZ :  1.01/11 09/12/97  16.44.11  by  Tancredi Carli
*CMZ :  1.01/07 10/10/97  19.46.50  by  Tancredi Carli
*CMZ :  1.01/05 15/07/97  10.41.45  by  Tancredi Carli
*-- Author :  Tancredi Carli   10/01/96
      subroutine HZEMC086(IFLAG)
****************************************************************************
*
* written by: Tancredi Carli and Renate Mohr
*             (carli@mail.desy.de)
* Seagull plot from EMC data
* Ref.: Z. Phys. C 36 (1987) 527
****************************************************************************
      IMPLICIT NONE
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      Integer iflag,ihep,i,j,k,l
      Character*6 xxxx
*
      Real pi,rd,ee,eb
      Logical take,evcut,lp
      Integer iel,idum,id
      Parameter (pi=3.1415927,rd=180./pi,ee=280.)
      Integer nentry
      Double precision pbeam(4),pgam(4),pcm(4),ph(5),phc(4)
      Real x,y,q2,w2,enel,ptel,thel,efwd,th,rap,pt,et,p
      Integer nwt,loc
      Character chtitl*80
      Integer nev
      Real xf,pt2,w
      Integer ierr,ibeam,igam
      Data lp/.false./
*     EMC Zeit f Phys
      Data xxxx/'emc086'/
*
******************************************************************************
* Data points from plots
*
*
       Integer nx
       Parameter (nx=16)
       Real pts(nx),epts(nx)
* Seagull
       Data pts/0.29,0.28,0.32,0.26,0.32,0.23,0.20,0.15,
     &          0.16,0.22,0.32,0.45,0.55,0.61,0.72,0.76/
* error
       Data epts/0.02,0.001,0.03,0.001,0.04,0.01,0.001,0.001,
     &           0.001,0.001,0.001,0.02,0.03,0.02,0.14,0.06/
*
******************************************************************************
      NENTRY=NENTRY+1
*
      IF (iflag.eq.1) then
*
*      Initialisation: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (i) make subdirectory in o/p file
*
       Call hcdir('//PAWC',' ')
       call hmdir(xxxx,'S')
       Call hcdir('//HISTO',' ')
       call hmdir(xxxx,'S')
*
*      book your histograms  (data: ID<0)
*                                     (VZERO, VMIN, VMAX see CERNLIB F121)
*     MC Histo with non-equid. Data-Binning
*
      CALL HBOOK1(50,'Mean Pt**2 vs xF  ',16,-0.8,0.8,0.)
      CALL HBOOK1(51,'Mean Pt**2 vs xF  ',16,-0.8,0.8,0.)
      CALL HBOOK1(-50,'Mean Pt**2 vs xF ',16,-0.8,0.8,0.)
      nev=0
*
*********************************************************************
*
      Else if(iflag.eq.2) then
*      Filling: The following MUST always be done
*      (i) move to the correct sub-directory in PAWC
*
       call hcdir('//PAWC/'//xxxx,' ')
*
*      Event selection
*
       q2=real(HZDISKIN(1))
       x =real(HZDISKIN(2))
       y =real(HZDISKIN(3))
       w2=real(HZDISKIN(4))
       w=sqrt(w2)
C       if (lp) write(6,*) 'Hz'//xxxx,
C     & ' x= ',x,' q2 ',q2,' y= ',y,' w2= ',w2
*
*      get position of scattered electron, energy,Pt and polar angle
*
       iel=HZIDELEC(idum)
       if (iel.eq.-1) then
        write(6,*) 'Hz'//xxxx,' electron not found '
        return
       endif
       ptel= real(sqrt(PHEP(1,iel)**2+PHEP(2,iel)**2))
       enel=real(PHEP(4,iel))
       Thel=real(HZPHMANG(PHEP(3,iel),
     &               sqrt(PHEP(1,iel)**2+PHEP(2,iel)**2)))*rd
       if (lp) write(6,*) 'Hz'//xxxx,
     &                       ' enel= ',enel,' thel= ',thel
*
*      cut on kinematics
*
       evcut= enel.gt.20.
       evcut= thel.gt.0.57.and. evcut
       evcut= w2.ge.16..and. w2.le.400 .and. evcut
       evcut= q2.gt.4. and. evcut
       evcut=y.lt.0.9.and.evcut
       if (lp) write(6,*) 'Hz'//xxxx,
     &                         ' efwd= ',efwd,' evcut= ',evcut
*
*      set up CMS boost needed later
*
       ierr=HZIBEAM(ibeam,idum)
       if (.not.(ierr.eq.1)) then
        write(6,*) 'HZ'//xxxx,' beams not found ! '
        return
       else
        Do i=1,4
         pbeam(i)=PHEP(i,IBEAM)
        enddo
       endif
*
       eb=real(PHEP(4,idum))
       if (abs(abs(eb)-ee).gt.0.2) then
        if (nentry.lt.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &  ' but ',eb,' abs= ',abs(abs(eb)-ee)
        elseif (nentry.eq.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &   ' ...last message ! '
        endif
C        return
       endif
*
       ierr=HZIPGAM(ph)
       if (ierr.eq.-1) then
        write(6,*) 'HZ'//xxxx,' boson vector not found ! '
C        call VZERO(ph,5)
        Do i=1,4
         ph(i)=0.
        enddo
       else
        Do i=1,4
         pgam(i)=ph(i)
        enddo
       endif
*
       call HZHCMINI(pbeam,pgam,ierr)
       if (ierr.eq.1) then
        write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
        return
       endif
*
*      count entries for normalization
*
       if (evcut) nev=nev+1
*
*      particle loop
       do 20 ihep=1,nhep
*
*       skip unstable particles and electron
        if (isthep(ihep).ne.1.or.ihep.eq.iel) goto 20
*
*       transform in CMS
*
        Do i=1,4
         Phc(i)=PHEP(i,ihep)
        enddo
        call HZHCM(phc,pcm,ierr)
        if (ierr.eq.1) then
         write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
         return
        endif
*                                       acceptance cut
*
        if (IHCHRG(IHEP).ne.0) then
         p      = real(sqrt(pcm(1)**2+pcm(2)**2+pcm(3)**2 ))
         pt     = real(sqrt( pcm(1)**2+pcm(2)**2 ))
         et     = real(pcm(4)) * pt / p
         th     = (acos(real(pcm(3))/p))
         th     = sign(max(abs(th),1.0e-05),th)
*
         if (lp) write(6,*) 'Hz'//xxxx,
     &   'lab: et,pt,rap,th ',et,pt,rap,th*rd
*
         xf=2.*real(pcm(3))/w
         pt2=real(pcm(1)**2 + pcm(2)**2)
*
         CALL HF1(50,XF,PT2*wtx)
         CALL HF1(51,XF,wtx)
        endif
*
 20    continue
*
************************************************************************
*
      Else if(iflag.eq.3) then
*      Termination: The following MUST always be done
*      (i) Move to the correct PAW subdirectory
*
       call hcdir('//PAWC/'//xxxx,' ')
*
* Histo normalization
*
       CALL HOPERA(50,'/ ',51,50,1.,1.)
       CALL HDELET(51)
*
* seagull
*
       call hpak (-50,pts)
       call hpake (-50,epts)
*
* Evaluate chi**2
*
* seagull
*
      call hzchisq(-50,50)
C       call hzchisq(-117,117)
*
      Endif
*
      RETURN
      END
*CMZ :  2.00/06 02/05/2002  14.48.09  by  Tancredi Carli
*CMZ :  1.01/11 09/12/97  16.44.11  by  Tancredi Carli
*CMZ :  1.01/07 10/10/97  19.46.50  by  Tancredi Carli
*CMZ :  1.01/01 28/03/96  15.40.42  by  Tancredi Carli
*-- Author :
      subroutine HZTH001(IFLAG)
****************************************************************************
* Purpose: produce histograms for:
*           o) transverse energy distribution in cms for the central
*              pseudorapidity bin as a fct. of x,Q**2
*
* Event selection:
* Eel>12 GeV, 173.0>Thel>157.0, w2>4400 GeV**2 and cut on forward energy
*
* Running: Ee=26.7, Ep=820, no polarization, HERA running 1993
* Reference: Event selection as in Phys. Lett. B356 (1995) 118, DESY 95-108
*            Pseudo data produced by Ariadne 4.03 in fair agreement with
*            uncorrected published data.
* Arguments: iflag=1 initialisation
*            iflag=1 filling
*            iflag=3 termination
*
* written by: Leif Lonnblad <leif@nordita.dk> adapted from the hz95108
*             routine by Michael Kuhlen (kuhlen@desy.de)
****************************************************************************
      IMPLICIT NONE
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
      Integer iflag,ihep,i
*     Not DESY Preprint number
      Character*5 xxxx
      character*30 string
*
      Real pi,rd,ee,eb
      Logical evcut,lp
      Integer iel,idum,id
      Parameter (pi=3.1415927,rd=180./pi,ee=26.7)
      Integer nev(9),nentry
      real zeroes(9), etcent
      Real x,y,q2,w2,enel,thel,efwd,th,rap,pt,et,p,thl
      Real etf11,etf12,etf13,etf21,etf22,etf23
      Integer ibin
*
      Integer ierr,ibeam
      Double precision pbeam(4),pgam(4),pcm(4),ph(5)
*
*
*********************************************************************
*
*                      data points from Ariadne 4.03
*
*********************************************************************
      Real xmin,xmax,binw,scale
      Integer nb,nbin
      Parameter (nb=20,xmin=0.0,xmax=10.0,nbin=9)
      Real et3(nb),eet3(nb)
      save xxxx,nev,lp,nentry,zeroes,binw
*
*     energy flow data in the 9 bins
*     note: systematic errors are not included
*
      Data  et3/0.3387,    0.3156,    0.3445,    0.2673,    0.2059,
     $          0.1233,    0.9901E-01,0.7632E-01,0.4579E-01,0.3878E-01,
     $          0.2970E-01,0.2310E-01,0.2104E-01,0.1403E-01,0.1196E-01,
     $          0.8663E-02,0.7838E-02,0.7426E-02,0.3713E-02,0.4125E-02/
      Data eet3/0.01183216,0.01141052,0.01192057,0.01050238,0.00921520,
     $          0.00713372,0.00639140,0.00561160,0.00434626,0.00400000,
     $          0.00350000,0.00308723,0.00294618,0.00240541,0.00222171,
     $          0.00189050,0.00179833,0.00174241,0.00123774,0.00130461/
*
      data zeroes /9*0/
      Data nev/9*0/,lp/.false./,nentry/0/
      Data xxxx/'TH001'/
*********************************************************************
*
*                      Initialization
*
*********************************************************************
      NENTRY=NENTRY+1
*
      IF (iflag.eq.1) then
*
*
*      Initialisation: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (i) make subdirectory in o/p file
*
       Call hcdir('//PAWC',' ')
       call hmdir(xxxx,'S')
       Call hcdir('//HISTO',' ')
       call hmdir(xxxx,'S')
*                                             book data et-flow histos
       call hbook1(-13,'DATA |eta|<0.5  dN/dEt CMS bin= 3',
     $                  nb,xmin,xmax, 0.)
       Do i=1,nbin
         write(string,'(A,I2)') ' dN/dEt CMS bin= ',i
         call hbook1(10+i,'(etamax<4) |eta|<0.5 '//string,
     $        nb,xmin,xmax, 0.)
         call hbook1(30+i,'(etamax<4) -1.5<eta<-0.5'//string,
     $        nb,xmin,xmax, 0.)
         call hbook1(40+i,'(etamax<4) -2.5<eta<-1.5'//string,
     $        nb,xmin,xmax, 0.)
         call hbook1(50+i,'(etamax<5) -1.5<eta<-0.5'//string,
     $        nb,xmin,xmax, 0.)
         call hbook1(60+i,'(etamax<5) -2.5<eta<-1.5'//string,
     $        nb,xmin,xmax, 0.)
         call hbook1(70+i,'(etamax<7) -1.5<eta<-0.5'//string,
     $        nb,xmin,xmax, 0.)
         call hbook1(80+i,'(etamax<7) -2.5<eta<-1.5'//string,
     $        nb,xmin,xmax, 0.)
       enddo
       binw=real(nb)/(xmax-xmin)
*
*
*      pack data into histograms
*      pack data et/deta in the 9 bins into histograms
*
       Call hpak (-13,et3)
       Call hpake(-13,eet3)
*
*                                       book your histograms  (data: ID<0)

*          Count events in each x,Q2 bin

       call hbook1( 24,'# events vs kin. bin',9,1.,10.,0.)

       call hbarx(24)
*
*********************************************************************
*
*                      Event Processing
*
*********************************************************************

      Else if(iflag.eq.2) then

*      Filling: The following MUST always be done
*      (i) move to the correct sub-directory in PAWC
*
       call hcdir('//PAWC/'//xxxx,' ')
*
*                                             Event selection
*
       q2=real(HZDISKIN(1))
       x =real(HZDISKIN(2))
       y =real(HZDISKIN(3))
       w2=real(HZDISKIN(4))
*
       if (lp) write(6,*) 'Hz'//xxxx,
     & ' x= ',x,' q2 ',q2,' y= ',y,' w2= ',w2
*
*                                             get electron variables
*
       iel=HZIDELEC(idum)
       if (iel.eq.-1) then
        write(6,*) 'Hz'//xxxx,' electron not found '
        goto 9990
       endif
       enel=real(PHEP(4,iel))
       thel=real(HZPHMANG(PHEP(3,iel),
     &               sqrt(PHEP(1,iel)**2+PHEP(2,iel)**2)))*rd
       if (lp) write(6,*) 'Hz'//xxxx,
     & ' enel= ',enel,' thel= ',thel*rd
*
*                                             kinematic selection
*
       evcut= enel.gt.12.
       evcut= thel.gt.157. .and. thel.lt.173.0 .and. evcut
       evcut= w2.ge.4400..and. evcut
       if(.not.evcut) goto 9990
*
*                                             cut on forward energy
*
       efwd=0.
       Do ihep=1,nhep
        if (isthep(ihep).eq.1.and.ihep.ne.iel) then
         th=real(HZPHMANG(PHEP(3,ihep),
     &              sqrt(PHEP(1,ihep)**2+PHEP(2,ihep)**2)))*rd
         if(th.gt.4.4.and.th.lt.15.) then
          efwd=real(PHEP(4,ihep))+efwd
         endif
        endif
       enddo
       if (lp) write(6,*) 'Hz'//xxxx,
     & ' efwd= ',efwd,' evcut= ',evcut
       if(efwd.lt.0.5) goto 9990
*
*                                             find the kinematic bin number
       ibin = 0
       if(    q2.gt. 5..and.q2.le.10.) then
         if(x.gt.0.0001.and.x.le.0.0002) ibin=1
         if(x.gt.0.0002.and.x.le.0.0005.and.q2.gt.6.) ibin=2
       elseif(q2.gt.10..and.q2.le.20.) then
         if(x.gt.0.0002.and.x.le.0.0005) ibin=3
         if(x.gt.0.0005.and.x.le.0.0008) ibin=4
         if(x.gt.0.0008.and.x.le.0.0015) ibin=5
         if(x.gt.0.0015.and.x.le.0.0040) ibin=6
       elseif(q2.gt.20..and.q2.le.50.) then
         if(x.gt.0.0005.and.x.le.0.0014) ibin=7
         if(x.gt.0.0014.and.x.le.0.0030) ibin=8
         if(x.gt.0.0030.and.x.le.0.0100) ibin=9
       endif
*
*                                             events in 9 bins only
       if( ibin.eq.0) goto 9990
*                                             set up CMS boost needed later
*
       ierr=HZIBEAM(ibeam,idum)
       if (.not.(ierr.eq.1)) then
        write(6,*) 'HZ'//xxxx,' beams not found ! '
        goto 9990
       else
        Do i=1,4
         pbeam(i)=PHEP(i,IBEAM)
        enddo
       endif
*
       eb=real(PHEP(4,idum))
       if (abs(abs(eb)-ee).gt.0.2) then
        if (nentry.lt.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,'  ! '
        elseif (nentry.eq.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &   ' ...last message ! '
        endif
C        goto 9990
       endif
*
       ierr=HZIPGAM(ph)
       if (ierr.eq.-1) then
        write(6,*) 'HZ'//xxxx,' boson vector not found ! '
C        call VZERO(ph,5)
        do i=1,5
         ph(i)=0.
        enddo
       else
        Do i=1,4
         pgam(i)=ph(i)
        enddo
       endif
*
       call HZHCMINI(pbeam,pgam,ierr)
       if (ierr.eq.1) then
        write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
        goto 9990
       endif
*
* loop over objects
*
*
* et in central rapidity bin
       etcent = 0.
       etf11=0.0
       etf12=0.0
       etf13=0.0
       etf21=0.0
       etf22=0.0
       etf23=0.0
       do 2000 ihep=1,nhep
*                                             skip unstable particles and el.
         if (isthep(ihep).ne.1.or.ihep.eq.iel) goto 2000
*
*                                             transform in CMS
*
         thl=real(HZPHMANG(PHEP(3,ihep),
     &        sqrt(PHEP(1,ihep)**2+PHEP(2,ihep)**2)))*rd

         Do i=1,4
           Ph(i)=PHEP(i,ihep)
         enddo
         call HZHCM(ph,pcm,ierr)
         if (ierr.eq.1) then
           write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
           goto 9990
         endif
* get particle momenta
         p=real(sqrt(pcm(1)**2+pcm(2)**2+pcm(3)**2 ))
         pt=real(sqrt( pcm(1)**2+pcm(2)**2 ))
         if (p.eq.0.) then
           if (lp) write(6,*) xxxx,' p = ',p
           goto 2000
         else
           et     = real(pcm(4)) * pt / p
           th     = (acos(real(pcm(3))/p))
           if (abs(     th*rd).lt.1.e-4 .or.
     &          abs(180.-th*rd).lt.1.e-4 ) then
             if (lp) write(6,*) xxxx,' th = ',th
             goto 2000
           else
             rap    = -log(tan( th/2. ))
* check on rap=nan (e.g. pt=0)
             if (rap.ne.rap) then
               if (lp) write(6,*) xxxx,'Warning:  rap = ',rap
     &              ,' th= ',th*rd,' particle skipped ! '
               goto 2000
             endif
           endif
         endif
*
         if (lp) write(6,*) 'Hz'//xxxx,
     &        'lab: et,pt,rap,th ',et,pt,rap,th*rd

* accumulate Et in central rap.
         if(rap.gt.-0.5.and.rap.lt.0.5) etcent = etcent + et
         if(rap.gt.-1.5.and.rap.lt.-0.5) then
           if (thl.gt.0.105) etf11=etf11+et
           if (thl.gt.0.772) etf12=etf12+et
           if (thl.gt.2.009) etf13=etf13+et
         endif
         if(rap.gt.-2.5.and.rap.lt.-1.5) then
           if (thl.gt.0.105) etf21=etf21+et
           if (thl.gt.0.772) etf22=etf22+et
           if (thl.gt.2.009) etf23=etf23+et
         endif

* end loop over objects
 2000  continue
*
* Fill Et histo
       nev(ibin)   = nev(ibin)+1
*
       call hf1(10+ibin,etcent,1.0)
       call hf1(30+ibin,etf13,1.0)
       call hf1(40+ibin,etf23,1.0)
       call hf1(50+ibin,etf12,1.0)
       call hf1(60+ibin,etf22,1.0)
       call hf1(70+ibin,etf11,1.0)
       call hf1(80+ibin,etf21,1.0)
* norm. histo for event counting
       call hf1(24,real(ibin),1.)
* end of event processing
 9990  continue


*********************************************************************
*
*                      Termination
*
*********************************************************************

      Else if(iflag.eq.3) then

* Termination: The following MUST always be done
* (i) Move to the correct PAW subdirectory
*
       call hcdir('//PAWC/'//xxxx,' ')
* normalize Et histos
       do id=1,9
         scale=binw/real(nev(id))
         Call hopera(id+10,'+E',id+10,id+10,scale,0.)
         Call hopera(id+30,'+E',id+30,id+30,scale,0.)
         Call hopera(id+40,'+E',id+40,id+40,scale,0.)
         Call hopera(id+50,'+E',id+50,id+50,scale,0.)
         Call hopera(id+60,'+E',id+60,id+60,scale,0.)
         Call hopera(id+70,'+E',id+70,id+70,scale,0.)
         Call hopera(id+80,'+E',id+80,id+80,scale,0.)
       enddo
        call hzchisq(-13,13)
* set errors of norm. histo 0
       call hpake(24,zeroes)
*
      endif
*
      RETURN
      END
*CMZ :  1.01/01 28/03/96  15.50.59  by  Tancredi Carli
*-- Author :
      subroutine HZTH002(IFLAG)
****************************************************************************
* Purpose: Produce fraction of events with a forward jet using a cone
* algorithm (R=1). The forward jet must have xjet > 0.025, 6 < Thetajet < 20
* degrees, 0.25 < pt2jet/q2 < 4 and ptjet > 5
*
* Event selection:
* Eel>12 GeV, 173.0>Thel>157.0, y>0.1 and cut on forward energy
*
* Running: Ee=26.7, Ep=820, no polarization, HERA running 1993
* Reference: Event selection as in Phys. Lett. B356 (1995) 118, DESY 95-108
*            data from publication corrected very crudely with Ariadne 4.03
* Arguments: iflag=1 initialisation
*            iflag=1 filling
*            iflag=3 termination
*
* written by: Leif Lonnblad <leif@nordita.dk> adapted from the hz95108
*             routine by Michael Kuhlen (kuhlen@desy.de)
****************************************************************************
      IMPLICIT NONE
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      double precision pp(4,2000),pp4(4,2000),pp5(4,2000),pj(5,100)
      integer ia(2000),jm(100)
*
      Integer iflag,ihep
*     Not DESY Preprint number
      Character*5 xxxx
*
      Real pi,rd
      Integer iel,idum
      Parameter (pi=3.1415927,rd=180./pi)
      Integer nentry
      Real x,y,q2,enel,thel,efwd,th,lx,lxj
      Real pt2r,thj,xj
      Integer ibin,nj,ij,naj,naj2,np,np4,np5,j
*
      Integer ierr,nev(3),njet(3)
      Double precision ptj2
*
*
*********************************************************************
*
*                      data points from Ariadne 4.03
*
*********************************************************************
      real fjet(3),efjet(3)
      save xxxx,njet,nev
      Data xxxx/'TH002'/,fjet/0.01203,0.02306,0.003225/,
     $     efjet/0.00077,0.00148,0.000321/,njet/3*0/,nev/3*0/,
     $     NENTRY/0/
*********************************************************************
*
*                      Initialization
*
*********************************************************************
      NENTRY=NENTRY+1
*
      IF (iflag.eq.1) then
*
*
* Initialisation: The following MUST always be done
* (i) make subdirectory in PAWC
* - use the name as the xxxxxx in HZxxxxxx subroutine
* (i) make subdirectory in o/p file
*
        Call hcdir('//PAWC',' ')
        call hmdir(xxxx,'S')
        Call hcdir('//HISTO',' ')
        call hmdir(xxxx,'S')
* book data jetrate histos
        call hbook1(-11,'frac events w. f. jet vs kin. bin',3,0.,3.,0.)
*
*
* pack data into histograms
* pack data et/deta in the 9 bins into histograms
*
        Call hpak (-11,fjet)
        Call hpake(-11,efjet)
*
* book your histograms  (data: ID<0)
*
        call hbook1(11,'fraction events w.f.jet vs kin. bin',3,0.,3.,0.)
        call hbook1(12,'# events vs kin. bin',3,0.,3.,0.)
*
        call hbook2(21,'etamax<5 fraction events w.f.jet vs x and xjet',
     $      4,-4.0,-2.0,4,-2.0,-1.0,0.0)
        call hbook2(22,'# events vs x',4,-4.0,-2.0,4,-2.0,-1.0,0.0)
        call hbook2(31,'etamax<7 fraction events w.f.jet vs x and xjet',
     $      4,-4.0,-2.0,6,-2.0,-0.5,0.0)
        call hbook2(32,'# events vs x',4,-4.0,-2.0,6,-2.0,-0.5,0.0)
        call hbook2(41,'etamax<4 fraction events w.f.jet vs x and xjet',
     $      4,-4.0,-2.0,4,-2.0,-1.0,0.0)

*
*********************************************************************
*
*                      Event Processing
*
*********************************************************************

      Else if(iflag.eq.2) then

* Filling: The following MUST always be done
* (i) move to the correct sub-directory in PAWC
*
       call hcdir('//PAWC/'//xxxx,' ')
*
* Event selection
*
       q2=real(HZDISKIN(1))
       x =real(HZDISKIN(2))
       y =real(HZDISKIN(3))
*
* get electron variables for kinematic selection
*
       if (y.lt.0.1) return
       iel=HZIDELEC(idum)
       if (iel.eq.-1) then
         write(*,*) 'Hz'//xxxx,' electron not found '
         return
       endif
       enel=real(PHEP(4,iel))
       if (enel.lt.12.0) return
       thel=real(HZPHMANG(PHEP(3,iel),
     $      sqrt(PHEP(1,iel)**2+PHEP(2,iel)**2)))*rd
       if (thel.lt.160.0) return
       if (thel.gt.173.0) return
*
* cut on forward energy, copy into new vectors
*
       np=0
       np5=0
       np4=0
       efwd=0.
       Do 1200 ihep=1,nhep
         if (isthep(ihep).ne.1.or.ihep.eq.iel) goto 1200
         th=real(HZPHMANG(PHEP(3,ihep),
     &        sqrt(PHEP(1,ihep)**2+PHEP(2,ihep)**2)))*rd
         if(th.gt.4.4.and.th.lt.15.) then
           efwd=real(PHEP(4,ihep))+efwd
         endif
         if (th.lt.0.105) goto 1200
         np=np+1
         do 2200 j=1,4
           pp(j,np)=phep(j,ihep)
 2200    continue
         if (th.lt.0.772) goto 1200
         np5=np5+1
         do 2300 j=1,4
           pp5(j,np5)=phep(j,ihep)
 2300    continue
         if (th.lt.2.099) goto 1200
         np4=np4+1
         do 2400 j=1,4
           pp4(j,np4)=phep(j,ihep)
 2400    continue
 1200  continue
       if (efwd.lt.0.5) return

*
* Check x-limits
*
       lx=log(x)/log(10.0)
       if (lx.lt.-4.0.or.lx.gt.-2.0) return
*
* Normalization
*
       do 1000 j=1,6
         if (j.le.4) call hf2(22,lx,real(j)*0.25-2.125,1.0)
         call hf2(32,lx,real(j)*0.25-2.125,1.0)
 1000  continue

       ibin = 0
       if(x.gt.0.0002.and.x.le.0.001) ibin=1
       if(x.gt.0.0010.and.x.le.0.002) ibin=2
       if (ibin.eq.0) goto 3000

       call hf1(12,real(ibin)-0.5,1.0)
       call hf1(12,2.5,1.0)
       nev(ibin)=nev(ibin)+1
       nev(3)=nev(3)+1
*
* Current detector reach. Old data
*
       call pxcone(2,np4,4,pp4,0.7d0,5.0d0,0.75d0,100,nj,pj,ia,jm,ierr)
       if (ierr.ne.0) goto 3000

       naj=0
       naj2=0
       do 2000 ij=1,nj
         ptj2=pj(1,ij)**2+pj(2,ij)**2
         if (ptj2.lt.25.0) goto 2000
         pt2r=ptj2/q2
         if (pt2r.gt.4.0.or.pt2r.lt.0.25) goto 2000
         thj=real(HZPHMANG(pj(3,ij),sqrt(ptj2)))*rd
         if (thj.gt.20.0.or.thj.lt.6.0) goto 2000
         xj=(pj(3,ij)+pj(4,ij))/1640.0
         lxj=log(xj)/log(10.0)
         call hf2(41,lx,lxj,1.0)
         if (xj.lt.0.025) goto 2000
         naj=naj+1
         if (xj.lt.0.05) goto 2000
         naj2=naj2+1
 2000  continue

       if (naj.gt.0) then
         call hf1(11,real(ibin)-0.5,1.0)
         njet(ibin)=njet(ibin)+1
       endif

       if (naj2.gt.0) then
         call hf1(11,2.5,1.0)
         njet(3)=njet(3)+1
       endif
*
* Forward plug at ZEUS
*
 3000  call pxcone(2,np5,4,pp5,0.7d0,5.0d0,0.75d0,100,nj,pj,ia,jm,ierr)
       if (ierr.ne.0) goto 4000

       do 3100 ij=1,nj
         ptj2=pj(1,ij)**2+pj(2,ij)**2
         if (ptj2.lt.25.0) goto 3100
         pt2r=ptj2/q2
         if (pt2r.gt.4.0.or.pt2r.lt.0.25) goto 3100
         thj=real(HZPHMANG(pj(3,ij),sqrt(ptj2)))*rd
         if (thj.lt.2.099) goto 3100
         xj=(pj(3,ij)+pj(4,ij))/1640.0
         lxj=log(xj)/log(10.0)
         call hf2(21,lx,lxj,1.0)
 3100  continue
*
* full acceptance detector, sort of...
*
 4000  call pxcone(2,np,4,pp,0.7d0,5.0d0,0.75d0,100,nj,pj,ia,jm,ierr)
       if (ierr.ne.0)  return

       do 4100 ij=1,nj
         ptj2=pj(1,ij)**2+pj(2,ij)**2
         if (ptj2.lt.25.0) goto 4100
         pt2r=ptj2/q2
         if (pt2r.gt.4.0.or.pt2r.lt.0.25) goto 4100
         thj=real(HZPHMANG(pj(3,ij),sqrt(ptj2)))*rd
         if (thj.lt.0.284) goto 4100
         xj=(pj(3,ij)+pj(4,ij))/1640.0
         lxj=log(xj)/log(10.0)
         call hf2(31,lx,lxj,1.0)
 4100  continue


*********************************************************************
*
*                      Termination
*
*********************************************************************

      Else if(iflag.eq.3) then

* Termination: The following MUST always be done
* (i) Move to the correct PAW subdirectory
*
       call hcdir('//PAWC/'//xxxx,' ')
*
       call hopera(11,'/E',12,11,1.0,1.0)
       call hopera(21,'/E',22,21,1.0,1.0)
       call hopera(31,'/E',32,31,1.0,1.0)
       call hopera(41,'/E',22,41,1.0,1.0)

       write(*,610) 'Hz'//xxxx//' fwd jetrates:'
       write(*,600) ' 0.0002 < x < 0.001',
     $       njet(1),nev(1),real(njet(1))/real(nev(1))
       write(*,600) ' 0.001  < x < 0.002',
     $       njet(2),nev(2),real(njet(2))/real(nev(2))
       write(*,600) ' xjet > 0.05       ',
     $       njet(3),nev(3),real(njet(3))/real(nev(3))
 610   format(a)
 600   format(a,i6,' /',i6,' =',f12.5)

      endif
*
      RETURN
      END
*CMZ :  1.01/07 08/10/97  17.41.35  by  Tancredi Carli
*CMZ :  1.01/05 29/01/97  14.27.55  by  Tancredi Carli
*CMZ :  1.01/03 15/05/96  18.54.11  by  Tancredi Carli
*CMZ :  1.01/02 09/04/96  19.08.20  by  Tancredi Carli
*-- Author :    Tancredi Carli   08/04/96
	Subroutine HZth003(iflag)
*****************************************************************************
* Produce (2+1) jet rates vs Q2, Jet profiles etc.
*
*****************************************************************************
*
	IMPLICIT NONE
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*
      Integer chjet,iflag,ihep
      DATA chjet/5/
      CHARACTER*6 jetf,xxxx
      Data xxxx/'TH003'/
*
      Integer iel,idum,numjet,njets
      Integer ijetb,ijetf
      Real nev
      Real thmax,thmin,th,et
      Real x,y,q2,w2,thel,enel,rd,pi,dpi,thjet
      Parameter (pi=3.14159,rd=180./pi,dpi=2*pi)
      Logical lp,evcut,evcut1,evcut2
      Data lp/.false./
      Integer njet
      DOUBLE PRECISION Jets(50,8),coner
      Real qb(6),deta,dphi,eta,phi
      Data qb/10.,18.,30.,100.,400.,4000./
*
      INTEGER i,j,k
*
      IF (iflag.eq.1) then
*
*
*      Initialisation: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (i) make subdirectory in o/p file
*
       Call hcdir('//PAWC',' ')
       call hmdir(xxxx,'S')
       Call hcdir('//HISTO',' ')
       call hmdir(xxxx,'S')
*
       call hbookb(1,'sample 1+1',5,qb,0.)
       call  hcopy(1,2,'sample 2+1')
       call  hcopy(1,3,'total')
       call hbook1(10,' Dphi eflow forw.',50,-pi,pi,0.)
       call hbook1(11,' Dphi eflow back.',50,-pi,pi,0.)
       call hbook1(12,' Deta eflow forw.',50,-3.,4.,0.)
       call hbook1(13,' Deta eflow back.',50,-3.,4.,0.)
*
* print-out name of jet-algo used
*
      CALL HZJTNAME(chjet,jetf)
      WRITE(6,*) '**********************************************'
      WRITE(6,*) '* HZ,',xxxx,' called                         *'
      WRITE(6,*) '* Jet finder selected : ',jetf,'             *'
      WRITE(6,*) '**********************************************'
*
      nev=0.
*
*                      Event Processing
*
      Else if(iflag.eq.2) then
*      Filling: The following MUST always be done
*      (i) move to the correct sub-directory in PAWC
*
       call hcdir('//PAWC/'//xxxx,' ')
*
*                                             Event selection
*
       q2=real(HZDISKIN(1))
       x =real(HZDISKIN(2))
       y =real(HZDISKIN(3))
       w2=real(HZDISKIN(4))
*
       if (lp) write(6,*) 'Hz'//xxxx,
     & ' x= ',x,' q2 ',q2,' y= ',y,' w2= ',w2
*
*                                             get electron variables
*
       iel=HZIDELEC(idum)
       if (iel.eq.-1) then
        write(6,*) 'Hz'//xxxx,' electron not found '
        goto 9990
       endif
       enel=real(PHEP(4,iel))
       thel=real(HZPHMANG(PHEP(3,iel),
     &               sqrt(PHEP(1,iel)**2+PHEP(2,iel)**2)))*rd
*
       if (lp) write(6,*) 'Hz'//xxxx,
     & ' enel= ',enel,' thel= ',thel
*
*                                             kinematic selection
*
       evcut= q2.gt.10. .and. q2.lt.100. .and. enel.gt.14.
       evcut= thel.gt.160. .and. thel.lt.172.5 .and. evcut
       evcut1=evcut
       evcut= q2.gt.100. .and. y.lt.0.7 .and.thel .lt.148.
       evcut= w2.ge.5000..and. evcut
       evcut2=evcut
*
       evcut=w2.gt. 5000. and. (evcut1 .or. evcut2)
*
       if(.not.evcut) goto 9990
*	
       coner=0.02
       if (lp) then
        write(6,*) ' ..calling hzjtfind chjet= ',chjet,' ycut= ',coner
       endif
*
       CALL hzjtfind(chjet,CONER,NJET,Jets)
*
       thmin=999.
       thmax=-999.
*
       numjet=0
       do i=1,njet
        if (lp) then
         write(6,'(a,4(x,f9.3))') ' e,px,py,pz= ',
     &   (real(jets(i,j)),j=4,7)
        endif
*
        thjet=real(acos(jets(i,7)/jets(i,4)))*rd
        if (thjet.ge.10. .and. thjet.le.145.) then
         numjet=numjet+1
         if (thjet.gt.thmax) then
          thmax=thjet
          ijetf=i
         endif
         if (thjet.lt.thmin) then
          thmin=thjet
          ijetb=i
         endif
        endif
       enddo
*
       if (lp) then
        write(6,*) ' njet= ',njet,' numjet= ',numjet
       endif
*
       if (numjet.eq.1 .and. njet.eq.2) then
        call hfill(1,q2,0.,wtx)
       elseif (numjet.eq.2 .and. njet.eq.3) then
        call hfill(2,q2,0.,wtx)
        nev=nev+wtx
*
        if (lp) then
         write(6,*) ' ijetf= ',ijetf,' ijetb= ',ijetb
        endif
*
        iel=HZIDELEC(idum)
        if (iel.eq.-1) then
         write(6,*) 'Hz'//xxxx,' electron not found '
         return
        endif
        Do 10 ihep=1,nhep
         if (isthep(ihep).ne.1.or.ihep.eq.iel) goto 10
*
         th=real(HZPHMANG(PHEP(3,ihep),
     &              sqrt(PHEP(1,ihep)**2+PHEP(2,ihep)**2)))
         et=real(PHEP(4,ihep))*sin(th)
         eta=-log(tan( th/2. ))
         phi=real(HZPHMANG(PHEP(1,ihep),PHEP(2,ihep)))
*
         deta=real(JETS(ijetb,1))-eta
         dphi=real(JETS(ijetb,2))-phi
*
         call hfill(13,deta,0.,et*wtx)
         call hfill(11,dphi,0.,et*wtx)
*
         deta=real(JETS(ijetf,1))-eta
         dphi=real(JETS(ijetf,2))-phi
         call hfill(12,deta,0.,et*wtx)
         call hfill(10,dphi,0.,et*wtx)
*
 10     continue
       endif
*
*********************************************************************
*
*                      Termination
*
*********************************************************************
      Else if(iflag.eq.3) then
*      Termination: The following MUST always be done
*      (i) Move to the correct PAW subdirectory
*
       call hcdir('//PAWC/'//xxxx,' ')
       call HZHINRM(10,0,nev,1)
       call HZHINRM(11,0,nev,1)
       call HZHINRM(12,0,nev,1)
       call HZHINRM(13,0,nev,1)
*
      ENDIF
*
 9990 continue
      RETURN
      END
*
*CMZ :  2.00/06 02/05/2002  14.23.52  by  Tancredi Carli
*-- Author :
*
*CMZ :  1.01/15 15/04/98  10.55.08  by  Tancredi Carli
*CMZ :  1.01/11 09/12/97  16.44.12  by  Tancredi Carli
*CMZ :  1.01/07 10/10/97  19.46.50  by  Tancredi Carli
*CMZ :  1.01/05 06/09/96  18.41.26  by   Tancredi Carli
*CMZ :  1.01/01 28/03/96  16.22.17  by  Tancredi Carli
*CMZ :  1.00/02 12/03/96  18.53.24  by  Tancredi Carli
*CMZ :  1.00/01 23/02/96  15.10.08  by  Tancredi Carli
*CMZ :  0.00/10 16/02/96  18.08.45  by  Tancredi Carli
*CMZ :  0.00/09 16/02/96  17.16.06  by  Tancredi Carli
*CMZ :  0.00/08 15/02/96  15.41.39  by  Renate Mohr
*CMZ :  0.00/06 02/02/96  19.54.21  by  Tancredi Carli
*-- Author :  Tancredi Carli   10/01/96
      subroutine HZ94033(IFLAG)
****************************************************************************
* Purpose: produced histograms for:
*           o) energy flows in lab and cms for x<10^-3 and x>10^-3
*           o) energy-energy correlation   for x<10^-3 and x>10^-3
*           o) charged particle spectra (Xf, seagull)
* Event selection:
* Eel>14 172.5 Thel>157 w2>3000 and cut on forward energy
*
* Running: Ee=26.7 HERA running 1992
* Reference: Z. Phys C63,377-389 (1994)
* Arguments: iflag=1 initialisation
*            iflag=1 filling
*            iflag=3 termination
*
* written by: Tancredi Carli and Renate Mohr
*             (carli@mail.desy.de mohr@mail.desy.de)
****************************************************************************
      IMPLICIT NONE
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      Integer iflag,ihep,i,j,k,l
      Character*5 xxxx
*
      Real pi,rd,ee,eb
      Logical take,evcut,lp
      Integer jcut,ncut,iel,idum,id
      Parameter (ncut=4,pi=3.1415927,rd=180./pi,ee=26.7)
      Integer nentry,nevnt(2)
      Real nev(ncut)
      Real x,y,q2,w2,enel,ptel,thel,efwd,th,rap,pt,et,p,costh
      Real xmi,xma,ymi,yma
      Integer nx,ny,nwt,loc
      Character chtitl*80
*
      Real VMIN,VMAX
      Integer ncbin,nlbin,nee1bin,nee2bin,nxfbin,nxfsbin
      Real nw(3),nww
      Integer nweight,npte
      Real neecor1,neecor2
      Parameter (ncbin=27,nlbin=30,nee1bin=36,nee2bin=28)
      Parameter (nxfbin=12,nxfsbin=8)
      Real om1(nee1bin+1),omeg1(nee1bin),eest1(nee1bin),eesys1(nee1bin)
      Real om2(nee2bin+1),omeg2(nee2bin),eest2(nee2bin),eesys2(nee2bin)
*
*
      Real erre1(nee1bin),erre2(nee2bin)
      Real xfd(nxfbin+1),w1(nxfbin),w2a(nxfbin),w3(nxfbin)
      real w4(nxfbin)
      Real xfdaux(nxfbin),xfsaux(nxfsbin)
      Real estatw1(nxfbin),estatw2(nxfbin)
      Real estatw3(nxfbin)
      Real esysw1(nxfbin),esysw2(nxfbin),esysw3(nxfbin)
      Real errw1(nxfbin),errw2(nxfbin),errw3(nxfbin),errw4(nxfbin)
      Real xfs(nxfsbin+1),pts(nxfsbin)
      Real xf,pt2,w
      real eptsstat(nxfsbin),eptssys(nxfsbin),errpts(nxfsbin)
      Real etl(ncbin),els(ncbin),ely(ncbin)
      Real etg(ncbin),egs(ncbin),egy(ncbin)
      Real el(nlbin),eel(nlbin),eg(nlbin),deg(nlbin)
      Real errl(nlbin),errg(nlbin)
      Real etal(nlbin+1),etac(ncbin+1),etalm(nlbin),etacm(ncbin)
      Real phi1,phi2,eta1,eta2,deltaphi,th2,om,et2,wt
      Real xlmin,xlmax,xcmin,xcmax,xe1min,xe1max,xe2min,xe2max
      Integer ierr,ibeam,igam
      Double precision pbeam(4),pgam(4),pcm(4),ph(5),phc(4)
*
      Data nev/0.,0.,0.,0./,lp/.false./,nentry/0/
*     DESY Preprint number
      Data xxxx/'94033'/
*
******************************************************************************
* Data points from plots
*
*                                            dEt/deta CMS
*
* et-flow low x
      Data etl/0.34,1.06,1.43,1.91,1.76,1.89,1.90,2.07,2.00,2.19,
     &         1.95,1.95,2.10,2.51,2.01,3.00,2.00,2.41,2.14,1.75,
     &         1.36,0.85,0.55,0.50,0.27,0.17,0.10/
* stat error et-flow
      Data els/0.07,0.13,0.13,0.16,0.16,0.17,0.17,0.18,0.17,0.22,
     &         0.20,0.22,0.23,0.29,0.22,0.44,0.24,0.26,0.25,0.23,
     &         0.17,0.11,0.09,0.08,0.06,0.04,0.03/
* sy error et-flow
      Data ely/0.04,0.09,0.10,0.12,0.10,0.11,0.10,0.10,0.10,0.11,
     &         0.09,0.10,0.11,0.13,0.10,0.15,0.10,0.12,0.11,0.09,
     &         0.08,0.05,0.04,0.04,0.03,0.03,0.02/
* et-flow high x
      Data etg/0.00,0.10,0.40,0.81,1.24,1.52,1.90,1.82,1.81,1.89,
     &         2.05,2.18,2.09,2.26,2.35,2.31,2.33,2.06,1.35,0.90,
     &         0.69,0.41,0.31,0.15,0.08,0.04,0.03/
* stat error high x
      Data egs/0.00,0.02,0.05,0.08,0.09,0.10,0.13,0.12,0.11,0.13,
     &         0.13,0.16,0.16,0.17,0.17,0.16,0.18,0.16,0.12,0.09,
     &         0.08,0.05,0.04,0.02,0.02,0.01,0.01/
      Data egy/0.00,0.01,0.03,0.04,0.05,0.06,0.08,0.07,0.07,0.07,
     &         0.08,0.08,0.08,0.09,0.10,0.10,0.11,0.11,0.08,0.06,
     &         0.05,0.04,0.03,0.02,0.01,0.01,0.01/
*
      Data etac/-1.25,-1.00,-0.75,-0.50,-0.25,0.00,0.25,0.50,0.75,
     &          1.00, 1.25, 1.50, 1.75, 2.00,2.25,2.50,2.75,3.00,
     &          3.25, 3.50, 3.75, 4.00, 4.25,4.50,4.75,5.00,5.25,
     &          5.50/
*
*                                            dEt/d(eta-eta_q) lab
*
* et-flow low x
      Data  el/ 0.  , 0.  , 0.  , 0.03, 0.08,0.29,0.62,1.07,1.73,
     &          2.16, 2.72, 2.64, 2.70, 2.28,2.47,2.54,2.04,2.01,
     &          1.92, 1.87, 2.08, 2.41, 2.04,2.07,2.08,1.76,1.50,
     &          1.18, 0.70, 0.33/
* total error et-flow
      Data eel/ 0.  , 0.  , 0.  ,0.03 , 0.06,0.09,0.12,0.17,0.23,
     &          0.25, 0.32, 0.33,0.36 , 0.31,0.35,0.31,0.26,0.23,
     &          0.20, 0.21, 0.25,0.21 , 0.21,0.22,0.19,0.19,0.20,
     &          0.18, 0.13, 0.08/
* et-flow high x
      Data  eg/ 0.  , 0.  , 0.  ,0.11 , 0.20,0.42,0.86,2.07,3.92,
     &          4.25, 3.80, 3.20,3.03 , 2.49,2.13,2.02,2.00,2.04,
     &          1.83, 1.43, 1.44,1.03 , 0.74,0.57,0.26,0.15,0.13,
     &          0.  , 0.  , 0./
*
* total error high x
      Data deg/ 0.  , 0.  , 0.  ,0.11 , 0.07,0.11,0.13,0.22,0.36,
     &          0.36, 0.31, 0.25,0.25 , 0.21,0.17,0.15,0.17,0.17,
     &          0.15, 0.13, 0.14,0.11 , 0.08,0.08,0.09,0.08,0.06,
     &          0.  ,  0. ,  0./
*
      Data etal/-2.00,-1.75,-1.50,-1.25,-1.00,-0.75,-0.50,-0.25,
     &           0.00, 0.25, 0.50, 0.75, 1.00, 1.25, 1.50, 1.75,
     &           2.00, 2.25, 2.50, 2.75, 3.00, 3.25, 3.50, 3.75,
     &           4.00, 4.25, 4.50, 4.75, 5.00, 5.25, 5.50/
*

*
* energy-energy correlation
*
*x<10**-3
*
*x-axis
      Data  om1/0.15,0.30,0.45,0.60,0.75,0.90,1.05,1.20,1.35,
     &          1.50,1.65,1.80,1.95,2.10,2.25,2.40,2.55,2.70,
     &          2.85,3.00,3.15,3.30,3.45,3.60,3.75,3.90,4.05,
     &          4.20,4.35,4.50,4.65,4.80,4.95,5.10,5.25,5.40,
     &          5.55/
*y-axis
      Data omeg1/1.28,1.34,1.28,1.38,1.25,1.36,1.44,1.39,1.48,1.43,1.50,
     &           1.59,1.63,1.69,1.84,1.90,2.02,2.28,2.57,2.66,2.17,1.71,
     &           1.47,1.14,1.02,0.82,0.68,0.58,0.51,0.37,0.28,0.27,0.16,
     &           0.13,0.07,0.03/
*stat. error e-e-cor
      Data eest1/0.28,0.17,0.15,0.17,0.14,0.15,0.17,0.15,0.16,0.17,0.17,
     &           0.18,0.18,0.18,0.20,0.20,0.22,0.27,0.31,0.33,0.31,0.25,
     &           0.18,0.13,0.13,0.10,0.08,0.07,0.07,0.06,0.04,0.05,0.03,
     &           0.03,0.01,0.01/
*syst. error e-e-cor
      Data eesys1/0.20,0.14,0.06,0.05,0.09,0.14,0.17,0.17,0.18,0.16,
     &           0.16,0.15,0.14,0.12,0.12,0.10,0.07,0.05,0.02,0.07,
     &           0.11,0.14,0.18,0.18,0.21,0.21,0.21,0.18,0.16,0.12,
     &           0.10,0.09,0.05,0.04,0.02,0.01/
*
* x>10**-3
*
*x-axis
      Data   om2/0.15,0.30,0.45,0.60,0.75,0.90,1.05,1.20,1.35,1.50,1.65,
     &           1.80,1.95,2.10,2.25,2.40,2.55,2.70,2.85,3.00,3.15,3.30,
     &           3.45,3.60,3.75,3.90,4.05,4.20,4.35/
*y-axis
      Data omeg2/0.46,0.57,0.53,0.52,0.47,0.44,0.42,0.41,0.42,0.43,0.44,
     &           0.43,0.43,0.43,0.45,0.45,0.48,0.53,0.54,0.52,0.37,0.25,
     &           0.19,0.13,0.08,0.06,0.04,0.03/
*stat. error e-e-cor
      Data eest2/0.04,0.05,0.04,0.03,0.03,0.03,0.03,0.03,0.03,0.03,0.03,
     &           0.03,0.03,0.03,0.03,0.03,0.04,0.04,0.04,0.04,0.03,0.02,
     &           0.02,0.01,0.01,0.01,0. ,0./
*syst error e-e-cor
      Data eesys2/0.04,0.05,0.04,0.04,0.04,0.03,0.03,0.03,0.03,0.03,
     &           0.03,0.03,0.03,0.03,0.03,0.03,0.03,0.04,0.04,0.03,0.02,
     &           0.01,0.01,0.01,0.01,0.01,0.01,0.01/

*
*
*    charged particle spectra
*
*  xf distribution
* x-axis
      Data   xfd/0.00,0.02,0.04,0.06,0.08,0.12,0.16,0.20,0.24,0.28,0.36,
     &          0.44,0.52/
*y-axis ,errors
*
*  <W>=77 GeV
      Data      w1/0.,67.,36.,24.,18.3,9.0,5.9,3.8,2.1,2.5,1.3,0.6/
*  stat error
      Data estatw1/0.,5.,3.,2.,1.4,0.9,0.8,0.6,0.4,0.4,0.3,0.2/
*  syst error
      Data esysw1/0.,5.,3.,2.,1.8,1.2,0.8,0.5,0.3,0.4,0.3,0.2/
*
*  <W>=122 GeV
      Data     w2a/0.,69.,37.,21.,14.8,11.0,5.9,5.0,2.4,1.5,0.62,0.33/
      Data estatw2/0.,4.,3.,2.,1.2,1.1,0.8,0.7,0.5,0.3,0.18,0.12/
      Data esysw2/0.,3.,2.,2.,1.3,1.1,0.7,0.6,0.3,0.2,0.09,0.07/
*
*  <W>=169 GeV
      Data   w3/250.,59.,42.,29.,15.,8.8,5.8,4.7,4.2,1.8,1.2,0.4/
      Data   estatw3/12.,5.,4.,3.,2.,1.3,1.1,0.9,1.0,0.4,0.4,0.2/
      Data   esysw3/18.,5.,5.,4.,2.,1.1,0.8,0.7,0.6,0.4,0.3,0.1/
*
*
* Seagull
       Data   xfs/0.00,0.03,0.07,0.11,0.15,0.20,0.28,0.40,0.54/
       Data pts/0.21,0.39,0.57,0.72,0.88,1.20,1.38,2.40/
* stat error
       Data eptsstat/0.01,0.03,0.07,0.17,0.13,0.28,0.28,0.72/
* syst error
       Data eptssys/0.01,0.03,0.05,0.06,0.10,0.17,0.21,0.65/
*
*
******************************************************************************
      NENTRY=NENTRY+1
*
      IF (iflag.eq.1) then
*
*      Initialisation: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (i) make subdirectory in o/p file
*
       Call hcdir('//PAWC',' ')
       call hmdir(xxxx,'S')
       Call hcdir('//HISTO',' ')
       call hmdir(xxxx,'S')
*
*
*      book your histograms  (data: ID<0)
*                                     (VZERO, VMIN, VMAX see CERNLIB F121)
       xcmin=VMIN(etac,ncbin+1)
       xcmax=VMAX(etac,ncbin+1)
       call hbook1(-10,'dEt/deta CMS low x',ncbin,xcmin,xcmax, 0.)
       call hbook1(-11,'dEt/deta CMS high x',ncbin,xcmin,xcmax, 0.)
       call hbook1( 10,'dEt/deta CMS low x',ncbin,xcmin,xcmax, 0.)
       call hbook1( 11,'dEt/deta CMS high x',ncbin,xcmin,xcmax, 0.)
*
       xlmin=VMIN(etal,nlbin+1)
       xlmax=VMAX(etal,nlbin+1)
       call hbook1( 12,'dEt/deta lab low x ',nlbin,xlmin,xlmax, 0.)
       call hbook1(-13,'dEt/deta lab high x',nlbin,xlmin,xlmax, 0.)
       call hbook1(-12,'dEt/deta lab low x ',nlbin,xlmin,xlmax, 0.)
       call hbook1( 13,'dEt/deta lab high x',nlbin,xlmin,xlmax, 0.)
*
       xe1min=VMIN(om1,nee1bin+1)
       xe1max=VMAX(om1,nee1bin+1)
       call hbook1(-14,'eecor low X',nee1bin,xe1min,xe1max, 0.)
       call hbook1( 14,'eecor low X',nee1bin,xe1min,xe1max, 0.)
       call hbook1(114,'eecor low X',50,0.,6., 0.)
*
       xe2min=VMIN(om2,nee2bin+1)
       xe2max=VMAX(om2,nee2bin+1)
       call hbook1(-15,'eecor high X',nee2bin,xe2min,xe2max, 0.)
       call hbook1( 15,'eecor high X',nee2bin,xe2min,xe2max, 0.)
       call hbook1(115,'eecor high X',50,0.,6., 0.)
*
       call hbook1( 16,'Xf-spec. <W>=77GeV ',70,0.,1., 0.)
       call hbook1( 17,'Xf-spec. <W>=122GeV',70,0.,1., 0.)
       call hbook1( 18,'Xf-spec. <W>=169GeV',70,0.,1., 0.)
*
*     MC Histo with non-equid. Data-Binning
       call hbookb(116,'non-equ. MC Xf-spec W=77 ',nxfbin,xfd,0.)
       call hbookb(117,'non-equ. MC Xf-spec W=122',nxfbin,xfd,0.)
       call hbookb(118,'non-equ. MC Xf-spec W=169',nxfbin,xfd,0.)
*
       call hbook1(-161,'X-ax Xf Spec',nxfbin+1,0.,real(nxfbin),0.)
       call hbook1(-162,'Y-ax W=77 ',nxfbin,0.,real(nxfbin),0.)
       call hbook1(-172,'Y-ax W=122',nxfbin,0.,real(nxfbin),0.)
       call hbook1(-182,'Y-ax W=169',nxfbin,0.,real(nxfbin),0.)
*
*     Data histo non-equid.
       call hbookb(-116,'non-equ. data Xf-spec W=77 ',nxfbin,xfd,0.)
       call hbookb(-117,'non-equ. data Xf-spec W=122',nxfbin,xfd,0.)
       call hbookb(-118,'non-equ. data Xf-spec W=169',nxfbin,xfd,0.)
*
       call hbook1(-191,'X-axis Seagull',nxfsbin+1,0.,real(nxfsbin),0.)
       call hbook1(-192,'Y-axis Seagull',nxfsbin,0.,real(nxfsbin),0.)
       call hbook1( 19,'Seagull Plot',20,0.,0.6, 0.)
       call hbook1( 21,'aux hist. xf',20,0.,0.6, 0.)
       call hbook1( 22,'Seagull without norm. ..',20,0.,0.6,0.)
       call hbook1( 20,'Seagull Plot (remn region)',20,-1.,1., 0.)
       call hbook1( 23,'Seagull aux (remn region)',20,-1.,1., 0.)
       call hbook1( 24,'Seagull remn.without norm. ..',20,-1.,1., 0.)
*
*     MC Histo with Data-Binning
       call hbookb(119,'non-equ. MC Seagull',nxfsbin,xfs,0.)
       call hbookb(121,'non-equ. MC aux hist xf',nxfsbin,xfs,0.)
       call hbookb(221,'non-equ. MC aux pt   ',nxfsbin,xfs,0.)
       call hbookb(122,'non-equ. MC seag. without norm.',nxfsbin,xfs,0.)
*     Data histo non-equid.
       call hbookb(-119,'non-equ. data Seagull',nxfsbin,xfs,0.)
*
* Data-histos with statistical errors only
*
       call hbook1(-210,'(st.err.)dEt/deta CMS low x',ncbin,
     &      xcmin,xcmax, 0.)
       call hbook1(-211,'(st.err.)dEt/deta CMS high x',ncbin,
     &     xcmin,xcmax, 0.)
       call hbook1(-214,'(st.err.)eecor low X',nee1bin,
     &       xe1min,xe1max, 0.)
       call hbook1(-215,'(st.err.)eecor high X',nee2bin,
     &        xe2min,xe2max, 0.)
       call hbookb(-216,'(st.err.) data Xf-spec W=77 ',nxfbin,xfd,0.)
       call hbookb(-217,'(st.err.) data Xf-spec W=122',nxfbin,xfd,0.)
       call hbookb(-218,'(st.err.) data Xf-spec W=169',nxfbin,xfd,0.)
       call hbookb(-219,'(st.err.) data Seagull',nxfsbin,xfs,0.)
*
       nw(1)=0.
       nw(2)=0.
       nw(3)=0.
       nww=0.
       neecor1=0.
       neecor2=0.
*
*********************************************************************
*
      Else if(iflag.eq.2) then
*      Filling: The following MUST always be done
*      (i) move to the correct sub-directory in PAWC
*
       call hcdir('//PAWC/'//xxxx,' ')
*
*      Event selection
*
       q2=real(HZDISKIN(1))
       x =real(HZDISKIN(2))
       y =real(HZDISKIN(3))
       w2=real(HZDISKIN(4))
       w=sqrt(w2)
       if (lp) write(6,*) 'Hz'//xxxx,
     & ' x= ',x,' q2 ',q2,' y= ',y,' w2= ',w2
*
*      get position of scattered electron, energy,Pt and polar angle
*
       iel=HZIDELEC(idum)
       if (iel.eq.-1) then
        write(6,*) 'Hz'//xxxx,' electron not found '
        return
       endif
       ptel= real(sqrt(PHEP(1,iel)**2+PHEP(2,iel)**2))
       enel=real(PHEP(4,iel))
       Thel=real(HZPHMANG(PHEP(3,iel),
     &               sqrt(PHEP(1,iel)**2+PHEP(2,iel)**2)))*rd
       if (lp) write(6,*) 'Hz'//xxxx,
     &                       ' enel= ',enel,' thel= ',thel
*
*
*      cut on forward energy
*
       efwd=0.
       Do 5 ihep=1,nhep
        if (isthep(ihep).ne.1.or.ihep.eq.iel) goto 5
        th=real(HZPHMANG(PHEP(3,ihep),
     &              sqrt(PHEP(1,ihep)**2+PHEP(2,ihep)**2)))*rd
        if(th.gt.4.4.and.th.lt.15.) then
         efwd=real(PHEP(4,ihep))+efwd
        endif
 5     continue
*
*      cut on kinematics
*
       evcut= enel.gt.14.
       evcut= thel.gt.157. .and. thel.lt.172.5 .and. evcut
       evcut= w2.ge.3000..and. evcut
       evcut=efwd.gt.0.5.and.evcut
       if (lp) write(6,*) 'Hz'//xxxx,
     &                         ' efwd= ',efwd,' evcut= ',evcut
*
*      set up CMS boost needed later
*
       ierr=HZIBEAM(ibeam,idum)
       if (.not.(ierr.eq.1)) then
        write(6,*) 'HZ'//xxxx,' beams not found ! '
        return
       else
        Do i=1,4
         pbeam(i)=PHEP(i,IBEAM)
        enddo
       endif
*
       eb=real(PHEP(4,idum))
       if (abs(abs(eb)-ee).gt.0.2) then
        if (nentry.lt.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &  ' but ',eb,' abs= ',abs(abs(eb)-ee)
        elseif (nentry.eq.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &   ' ...last message ! '
        endif
C       return
       endif
*
       ierr=HZIPGAM(ph)
       if (ierr.eq.-1) then
        write(6,*) 'HZ'//xxxx,' boson vector not found ! '
C        call VZERO(ph,5)
        Do i=1,5
         ph(i)=0.
        enddo
       else
        Do i=1,4
         pgam(i)=ph(i)
        enddo
       endif
*
       call HZHCMINI(pbeam,pgam,ierr)
       if (ierr.eq.1) then
        write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
        return
       endif
*
*      count entries for normalization
*
       if (evcut) then
        if(w.gt.50..and.w.le.100.)  nw(1)=nw(1)+wtx
        if(w.gt.100..and.w.le.150.) nw(2)=nw(2)+wtx
        if(w.gt.150..and.w.le.200.) nw(3)=nw(3)+wtx
        if (x.lt.0.001) then
         neecor1=neecor1+wtx
        else
         neecor2=neecor2+wtx
        endif
       endif
*
*    -----------------------------------------------------------
*
*      loop over bins in x jcut.ge.3 lab ,  else cms
*
       do 10 jcut = 1,ncut
*                               find the correct bin for this evt.
        take=.false.
        if (jcut.eq.1 .and.x.lt.0.001) take=.true.
        if (jcut.eq.2 .and.x.ge.0.001) take=.true.
        if (jcut.eq.3 .and.x.lt.0.001) take=.true.
        if (jcut.eq.4 .and.x.ge.0.001) take=.true.
*
        if (lp) write(6,*) 'Hz'//xxxx,
     &  ' jcut= ',jcut,' take= ',take
*
       if(take.and.evcut) then
*
*       count events in each bin for norm.
        nev(jcut)=nev(jcut)+wtx
        if(w.gt.50..and.w.lt.200.) then
         nww=nww+wtx
        endif
*
*       particle loop
        do 20 ihep=1,nhep
*
*        skip unstable particles and electron
         if (isthep(ihep).ne.1.or.ihep.eq.iel) goto 20
         th=real(HZPHMANG(PHEP(3,ihep),
     &              sqrt(PHEP(1,ihep)**2+PHEP(2,ihep)**2)))
*                                        lab plot
         if (jcut.ge.3) then
*                                        acceptance cut
          if (th*rd.gt.4.4) then
           p = real(sqrt(PHEP(1,ihep)**2+
     &                   PHEP(2,ihep)**2+PHEP(3,ihep)**2))
           pt= real(sqrt(PHEP(1,ihep)**2+PHEP(2,ihep)**2))
           et= real(PHEP(4,ihep)* pt/p)
           rap= -log(tan( th/2. ))
*
           if (lp) write(6,*) 'Hz'//xxxx,' id= ',idhep(ihep),
     &     ' lab: et,pt,rap,th= ',et,pt,rap,th*rd
*
           if (th*rd.lt.174.) then
*           get scattered quark angle
            costh=2.*ee*y/(ee*y+(q2*(1.-y)/(4.*ee*y)))
            costh=1.-costh
            rap=rap-1.*(-log(tan( acos(costh)/2. )))
            call hf1(10+jcut-1, rap, et*wtx )
           endif
*
*          calculation of energy energy correlation values
*
           phi1=real(atan2(PHEP(2,IHEP),PHEP(1,IHEP)))
           phi1=phi1+pi
*
*          eecor acceptance cut
           if(th*rd.gt.8.) then
            eta1=-log(tan(th/2.))
            do 30 j=ihep+1,nhep
             if (isthep(j).ne.1.or.j.eq.iel) goto 30
             th2=real(HZPHMANG(PHEP(3,j),
     &              sqrt(PHEP(1,j)**2+PHEP(2,j)**2)))
             if(th2*rd.gt.8.) then
              eta2=-log(tan(th2/2.))
              phi2=real(atan2(PHEP(2,j),PHEP(1,j)))
              phi2=phi2+pi
              p = real(sqrt(PHEP(1,j)**2+
     &                      PHEP(2,j)**2+PHEP(3,j)**2))
              pt= real(sqrt(PHEP(1,j)**2+PHEP(2,j)**2))
              et2= real(PHEP(4,j)* pt/p)
              deltaphi=phi1-phi2
              if(abs(deltaphi).gt.pi) then
               deltaphi=abs(abs(deltaphi)-2.*pi)
              endif
              om=sqrt((eta1-eta2)**2.+deltaphi**2.)
              wt=(et*et2)/ptel**2.
*
              if (x.lt.0.001) then
               call hf1 (14,om,wt*wtx)
               call hf1 (114,om,wt*wtx)
              else
               call hf1 (15,om,wt*wtx)
               call hf1 (115,om,wt*wtx)
              endif
             endif
*                    end of 2.particle loop
 30         continue
*                    eecor acceptance cut
           endif
*                    endif acceptance cuts
          endif
*
*      ---------------------------------------------
*
         else

*          CMS plots      -> transform in CMS
*
           Do i=1,4
            Phc(i)=PHEP(i,ihep)
           enddo
           call HZHCM(phc,pcm,ierr)
           if (ierr.eq.1) then
            write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
            return
           endif
*
*                                       acceptance cut
          if (th*rd.gt.4.4) then
*
           p      = real(sqrt(pcm(1)**2+pcm(2)**2+pcm(3)**2 ))
           pt     = real(sqrt( pcm(1)**2+pcm(2)**2 ))
           et     = real(pcm(4)) * pt / p
           th     = (acos(real(pcm(3))/p))
           th     = sign(max(abs(th),1.0e-05),th)
           rap    = -log(tan( th/2. ))
           if (lp) write(6,*) 'Hz'//xxxx,
     &     'lab: et,pt,rap,th ',et,pt,rap,th*rd
*
           call hf1(10+jcut-1, rap, et*wtx )
*
*          filling of charged part. spectra
*
           xf=2.*real(pcm(3))/w
           pt2=real(pcm(1)**2 + pcm(2)**2)
           if (IHCHRG(IHEP).ne.0) then
            if(w.gt.50..and.w.le.100.) then
              call hf1 (16,xf,wtx)
              call hf1 (116,xf,wtx)
            endif
            if(w.gt.100..and.w.le.150.) then
             call hf1 (17,xf,wtx)
             call hf1 (117,xf,wtx)
            endif
            if(w.gt.150..and.w.le.200.) then
             call hf1 (18,xf,wtx)
             call hf1 (118,xf,wtx)
            endif
* seagull
            if(w.gt.50..and.w.lt.200.) then
             call hf1 (22,xf,pt2*wtx)
             call hf1 (21,xf,wtx)
             call hf1 (122,xf,pt2*wtx)
             call hf1 (121,xf,wtx)
             call hf1 (221,xf,pt2*pt2*wtx)
            endif
           endif
*                       endif acceptance cut
          endif
*
* seagull remnant region
          xf=2.*real(pcm(3))/w
          pt2=real(pcm(1)**2 + pcm(2)**2)
          if (IHCHRG(IHEP).ne.0) then
           if(w.gt.50..and.w.lt.200.) then
            call hf1 (24,xf,pt2*wtx)
            call hf1 (23,xf,wtx)
           endif
          endif
*                  !  lab or cms
         endif
*                  ! end loop over objects
 20     continue
*                  ! endif for bins
       endif
*                  ! end loop over bins
 10   continue
*
************************************************************************
*
      Else if(iflag.eq.3) then
*      Termination: The following MUST always be done
*      (i) Move to the correct PAW subdirectory
*
       call hcdir('//PAWC/'//xxxx,' ')
*
* Histo normalization
*
       do jcut=1,ncut
        id=10+jcut-1
        call HZHINRM(id,0,nev(jcut),1)
C*TC>
        call hzhinfo(id,nev(jcut))
C*TC<
       enddo
       id=0
       do j=1,3
        id=j+15
        call HZHINRM(id,0,nw(j),1)
        call HZHINRM(id+100,0,nw(j),1)
C*TC>
        call hzhinfo(id,nw(j))
        call hzhinfo(id+100,nw(j))
C*TC<
       enddo
       call HZHINRM(14,0,neecor1,1)
       call HZHINRM(114,0,neecor1,1)
       call HZHINRM(15,0,neecor2,1)
       call HZHINRM(115,0,neecor2,1)
C*TC>
        call hzhinfo(14,neecor1)
        call hzhinfo(114,neecor1)
        call hzhinfo(15,neecor2)
        call hzhinfo(115,neecor2)
C*TC<
*
* for seagull
       Call hopera(22 ,'/',21,  19,1.,1.)
       Call hopera(24 ,'/',23,  20,1.,1.)
       Call hopera(122,'/',121,119,1.,1.)
C*TC>
        call hzhinfo(121,nww)
C*TC<
*
* correct error treatment for MC-seagull
*      sig_a**2 = <a**2> - <a>**2
*      err_a**2 = sig_a**2/n
*      a=pt2 n=121  119=<a>
*      221=<a**2>
       Call Hopera(221,'/',121,221,1.,1.)
*      321=<a>**2
       Call Hopera(119,'*',119,321,1.,1.)
*      321=<a**2> - <a>**2
       call Hopera(221,'-',321,321,1.,1.)
*      321=(<a**2> - <a>**2)/n
       Call Hopera(321,'/',121,321,1.,1.)
       Call Hunpak(321,errpts,' ',0)
       Do i=1,nxfsbin
C        write(6,*) ' errpts= ',errpts(i)
        errpts(i)= sqrt(errpts(i))
       enddo
       Call Hpake(119,errpts)
C*TC>
        call hzhinfo(119,nww)
C*TC<
*
* Add stat. and syst. errors for data
*
* energy flow  cms
       Do i=1,ncbin
        errl(i)=sqrt(els(i)**2+ely(i)**2)
        errg(i)=sqrt(egs(i)**2+egy(i)**2)
       enddo
*
* eecor low X
       Do i=1,nee1bin
        erre1(i)=sqrt(eest1(i)**2+eesys1(i)**2)
       enddo
* eecor high X
       Do i=1,nee2bin
        erre2(i)=sqrt(eest2(i)**2+eesys2(i)**2)
       enddo
* xf spectra
       Do i=1,nxfbin
        errw1(i)=sqrt(estatw1(i)**2+esysw1(i)**2)
        errw2(i)=sqrt(estatw2(i)**2+esysw2(i)**2)
        errw3(i)=sqrt(estatw3(i)**2+esysw3(i)**2)
       enddo
* seagull
       Do i=1,nxfsbin
        errpts(i)=sqrt(eptsstat(i)**2+eptssys(i)**2)
       enddo
*
*
*      Deal with data plots
* lab
       Call hpak (-12,el)
       Call hpak (-13,eg)
       Call hpake(-12,eel)
       Call hpake(-13,deg)
* cms
       Call hpak (-10,etl)
       Call hpak (-11,etg)
       Call hpake(-10,errl)
       Call hpake(-11,errg)
       Call hpak (-210,etl)
       Call hpak (-211,etg)
       Call hpake(-210,els)
       Call hpake(-211,egs)
*
* energy energy cor
*
* low X
       Call hpak (-14,omeg1)
       Call hpake(-14,erre1)
       Call hpak (-214,omeg1)
       Call hpake(-214,eest1)
*
* high X
       Call hpak (-15,omeg2)
       Call hpake(-15,erre2)
       Call hpak (-215,omeg2)
       Call hpake(-215,eest2)
*
* xf spectra
       Call hpak (-161,xfd)
       Call hpak (-162,w1)
       Call hpak (-116,w1)
       Call hpak (-216,w1)
       Call hpak (-172,w2a)
       Call hpak (-117,w2a)
       Call hpak (-217,w2a)
       Call hpak (-182,w3)
       Call hpak (-118,w3)
       Call hpak (-218,w3)
       Call hpake (-162,errw1)
       Call hpake (-172,errw2)
       Call hpake (-182,errw3)
       Call hpake (-216,estatw1)
       Call hpake (-217,estatw2)
       Call hpake (-218,estatw3)
*
* seagull

       call hpak (-191,xfs)
       call hpak (-192,pts)
       call hpake (-192,errpts)
       call hpak (-119,pts)
       call hpake (-119,errpts)
       call hpak (-219,pts)
       call hpake (-219,eptsstat)
*
*
* Evaluate chi**2
*
*energy flows
       call hzchisq(-10,10)
       call hzchisq(-11,11)
       call hzchisq(-12,12)
       call hzchisq(-13,13)
       call hzchisq(-210,10)
       call hzchisq(-211,11)
*
*  eecor
       call hzchisq(-14,114)
       call hzchisq(-15,115)
       call hzchisq(-214,114)
       call hzchisq(-215,115)
*
* xf spectra / seagull
       call hzchisq(-116,116)
       call hzchisq(-117,117)
       call hzchisq(-118,118)
       call hzchisq(-119,119)
       call hzchisq(-216,116)
       call hzchisq(-217,117)
       call hzchisq(-218,118)
       call hzchisq(-219,119)
*
* delete aux. histos
       call hdelet (21)
       call hdelet (22)
       call hdelet (23)
       call hdelet (24)
       call hdelet (121)
       call hdelet (221)
       call hdelet (321)
       call hdelet (122)
*
      Endif
*
      RETURN
      END
*CMZ :  1.02/01 23/10/98  17.53.31  by  Tancredi Carli
*CMZ :  1.02/00 02/10/98  17.53.07  by  Tancredi Carli
*-- Author :
	Subroutine HZ94176(iflag)
*****************************************************************************
* This photoproduction rou tine has to be run twice with the following
* code additions:
* 	+1000 for the DIRECT component run.
*	+2000 for the RESOLVED component run.
* for all three phases (iflag=1,2,3)
*
* iflag = 1,2 or 3 depending on wether it is the initialization,
*		processing or termination phase (respectively)
*
* The default jetfinder is PXCONE
* To change jetfinder use these values to call the initialisation phase.
* 1 + 10 * (jetfinder number)
*
* This routine produces ten Monte Carlo graphs.
* id 10-14 are only the number of unweighted events which pass the cuts
* id 20-24 are the normalised cross sections in nb. These graph will be
*		meaningless unless Xsec and Ntot are set before
*		calling the termination routine.
*		(Xsec - total cross section returned by MC)
*		(Ntot - number of events passed to this routine)
* This routine produces ten Data graphs
* id -20 to -24 correspond to 20-24 with statistical errors only.
* id -120 to -124 correspond to 20-24 with statistical and systematic errors.
*
* Cuts : 	Q2 < 4
*		0.2 < y_bj <0.85
*		Depending on graph Et > 8, 11, 17
*			and -1 < eta < 2, 1
*
* Recommended value for Ptmin is 5 GeV (to be set in MC set up)
*
* Author : Mark Hayes (mhayes@zow.desy.de)
*
* Reference : DESY-94-176
*             Phys. Lett. B342 (1995) 417-432.
*
*****************************************************************************
*
* HERA Tuning defined commons

	IMPLICIT NONE

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.

	CHARACTER*6 jetf

	INTEGER NJET
	DOUBLE PRECISION Jets(50,8)
	DOUBLE PRECISION CONER
	
	INTEGER loop,loop2,count
	DOUBLE PRECISION rap,Et
	DOUBLE PRECISION ybj,q2
	DOUBLE PRECISION ybjcut(2),q2cut(2)
	DOUBLE PRECISION rapcut(2,5),Etcut(5)
	DOUBLE PRECISION mhxsec(2)
	INTEGER mhntot(2)

C *** Data for Et.gt.8 GeV
	REAL xbins(13)
	REAL pteta(12),ptcr(12),ptcre(12)
	REAL ptcresys(12),hiband(12),loband(12)
C *** Data points for Et.gt.8 GeV
	DATA xbins/-1.0, -0.75, -0.5, -0.25, 0, 0.25,
     &             0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0/
	DATA pteta /-0.88, -0.62, -0.38, -0.12, 0.12, 0.38,
     &               0.62, 0.88, 1.12, 1.38, 1.62, 1.88/
	DATA ptcr / 4.1, 6.6, 8.5, 10.9, 12.4, 12.8,
     &                13.7, 13.8, 15.2, 14.9, 16.4, 18.2/
	DATA ptcre/ 0.2, 0.2, 0.3, 0.3, 0.3, 0.3,
     &               0.3, 0.3, 0.4, 0.3, 0.4, 0.4/
	DATA ptcresys/ 0.6, 0.7, 0.7, 0.5, 0.8, 1.1,
     &                  0.9, 1.7, 1.4, 1.6, 2.8, 1.3/
	DATA hiband/1.1, 1.3, 1.7, 1.6, 1.9, 1.5,
     &               2.0, 2.0, 2.1, 2.2, 2.4, 2.6/
	DATA loband/-0.6, -1.0, -1.0, -1.2, -1.5, -1.4,
     &               -1.5, -1.3, -1.5, -1.4, -1.6, -2.0/
C *** Data for Et.gt.11 GeV
	REAL xbins2(13)
	REAL pt2eta(12),pt2cr(12),pt2cre(12)
	REAL pt2cresys(12),hi2band(12),lo2band(12)
C *** Data points for Et.gt.11 GeV
	DATA xbins2/-1.0, -0.75, -0.5, -0.25, 0, 0.25,
     &             0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0/
	DATA pt2eta /-0.88, -0.62, -0.38, -0.12, 0.12, 0.38,
     &               0.62, 0.88, 1.12, 1.38, 1.62, 1.88/
	DATA pt2cr / 0.46, 1.36, 2.05, 2.84, 3.08, 3.37,
     &               3.92, 3.85, 3.71, 3.94, 4.31, 4.83/
	DATA pt2cre/ 0.08, 0.13, 0.14, 0.16, 0.16, 0.16,
     &               0.18, 0.18, 0.19, 0.18, 0.19, 0.19/
	DATA pt2cresys/ 0.18, 0.24, 0.46, 0.47, 0.56, 0.56,
     &                  0.65, 0.72, 0.67, 0.65, 1.04, 0.63/
	DATA hi2band/0.46, 0.66, 0.49, 0.58, 0.68, 0.80,
     &               0.93, 1.17, 0.88, 0.81, 0.99, 1.14/
	DATA lo2band/-0.11, -0.45, -0.51, -0.67, -0.52, -0.55,
     &               -0.78, -0.70, -0.54, -0.58, -0.64, -0.71/
C *** Data for Et.gt.17 GeV
	REAL xbins3(9)
	REAL pt3eta(8),pt3cr(8),pt3cre(8)
	REAL pt3cresys(8),hi3band(8),lo3band(8)
C *** Data points for Et.gt.17 GeV
	DATA xbins3/-0.75, -0.25, 0.25,
     &             0.75, 1.0, 1.25, 1.5, 1.75, 2.0/
	DATA pt3eta /-0.50, 0.00, 0.50, 0.88, 1.12, 1.38, 1.62, 1.88/
	DATA pt3cr / 0.08, 0.29, 0.52, 0.65, 0.58, 0.63, 0.63, 0.60/
	DATA pt3cre/ 0.02, 0.04, 0.05, 0.08, 0.08, 0.08, 0.08, 0.07/
	DATA pt3cresys/0.05, 0.04, 0.06, 0.11, 0.14, 0.15, 0.18, 0.15/
	DATA hi3band/0.05, 0.14, 0.15, 0.12, 0.14, 0.10, 0.16, 0.17/
	DATA lo3band/-0.03,-0.06,-0.11,-0.14,-0.08,-0.14,-0.15,-0.15/
C *** Data for Et.gt.8 & -1<eta<2
	REAL xbins4(9)
	REAL pt4eta(8),pt4cr(8),pt4cre(8)
	REAL pt4cresys(8),hi4band(8),lo4band(8)
C *** Data points for Et.gt.8 & -1<eta<2
	DATA xbins4/8, 11, 14, 17, 21, 25, 29, 35, 41/
	DATA pt4eta/9.2, 12.2, 15.2, 18.6, 22.6, 26.7, 31.6, 37.6/
	DATA pt4cr/9.0, 2.17, 0.59, 0.199,
     &    0.058, 0.0195, 0.0084, 0.0041/
	DATA pt4cre/0.1, 0.04, 0.02, 0.011,
     &    0.006, 0.0032, 0.0019, 0.0012/
	DATA pt4cresys/0.4, 0.31, 0.05, 0.024,
     &    0.007, 0.0026, 0.0013, 0.0009/
	DATA hi4band/1.1, 0.51, 0.15, 0.052,
     &    0.014, 0.0063, 0.0024, 0.0021/
	DATA lo4band/-0.7, -0.38, -0.11, -0.040,
     &    -0.012, -0.0045, -0.0017, -0.0010/
C *** Data for Et.gt.8 & -1<eta<1
	REAL xbins5(7)
	REAL pt5eta(6),pt5cr(6),pt5cre(6)
	REAL pt5cresys(6),hi5band(6),lo5band(6)
C *** Data points for Et.gt.8 & -1<eta<1
	DATA xbins5/8, 11, 14, 17, 21, 25, 29/
	DATA pt5eta/9.2, 12.2, 15.2, 18.6, 22.6, 26.7/
	DATA pt5cr/5.10, 1.18, 0.322, 0.103, 0.0297, 0.0075/
	DATA pt5cre/0.05, 0.03, 0.015, 0.008, 0.0044, 0.0021/
	DATA pt5cresys/0.23, 0.14, 0.030, 0.009, 0.0059, 0.0012/
	DATA hi5band/0.66, 0.30, 0.082, 0.036, 0.0058, 0.0026/
	DATA lo5band/-0.44, -0.22, -0.067, -0.020, -0.0053, -0.0022/

	INTEGER intiflag, chjet, iproc, iflag
	SAVE chjet
C --- same jet finder as in paper -- PXCONE
	DATA chjet/2/

	REAL pttemp(12)
	INTEGER ivec,jvec

C --- choose direct/resolved
C --- recommend 1 - DIRECT, 2 - RESOLVED
	IF (iflag.gt.1000) THEN
	  iproc=INT(iflag/1000)
	  intiflag=MOD(iflag,1000)
	ENDIF
	IF ((iproc.gt.2).or.(iproc.lt.1)) THEN
	  PRINT*,'HZ94176 : Badly called routine'
	  PRINT*,'          please set intiflag +1000 or +2000'
	ENDIF

C --- choose jet finder
	IF ((intiflag.gt.10).and.(MOD(intiflag,10).eq.1)) THEN
	  chjet=INT(intiflag/10)
	  intiflag=MOD(intiflag,10)
	ENDIF

	IF (intiflag.eq.1) THEN
C *** Initialisation run ***
C *** Create directories ***
	  IF (iproc.eq.1) THEN
	    CALL HCDIR('//HISTO',' ')
	    CALL HMDIR('94176','S')
	    CALL HCDIR('//PAWC',' ')
	    CALL HMDIR('94176','S')

	    CALL HBOOKB(20,'Monte Carlo cross section (nb) Et.gt.8 GeV'
     &		,12 ,xbins ,0.)
	    CALL HBOOKB(21,'Monte Carlo cross section (nb) Et.gt.11 GeV'
     &		,12 ,xbins2 ,0.)
	    CALL HBOOKB(22,'Monte Carlo cross section (nb) Et.gt.17 GeV'
     &		,8 ,xbins3 ,0.)
	    CALL HBOOKB(23,'Monte Carlo cross section (nb) -1.lt.eta.lt.2'
     &          ,8 ,xbins4 ,0.)
	    CALL HBOOKB(24,'Monte Carlo cross section (nb) -1.lt.eta.lt.1'
     &          ,6 ,xbins5 ,0.)
	  ENDIF

	  CALL HCDIR('//HISTO/94176',' ')
	  CALL HCDIR('//PAWC/94176',' ')
	  CALL HBOOKB(10+iproc*100,'Monte Carlo X-sec Et.gt.8 GeV'
     &          ,12 ,xbins ,0.)
	  CALL HBOOKB(11+iproc*100,'Monte Carlo X-sec Et.gt.11 GeV'
     &          ,12 ,xbins2 ,0.)
	  CALL HBOOKB(12+iproc*100,'Monte Carlo X-sec Et.gt.17 GeV'
     &          ,8 ,xbins3 ,0.)
	  CALL HBOOKB(13+iproc*100,'Monte Carlo X-sec -1.lt.eta.lt.2'
     &          ,8 ,xbins4 ,0.)
	  CALL HBOOKB(14+iproc*100,'Monte Carlo X-sec -1.lt.eta.lt.1'
     &          ,6 ,xbins5 ,0.)

          CALL HIDOPT(0,'stat')
	  CALL HBARX(0)

	  ybjcut(1)=0.2
	  ybjcut(2)=0.85
	  q2cut(1)=0.
	  q2cut(2)=4.

C --- cuts for three rapidity plots
	  rapcut(1,1)=-1.
	  rapcut(2,1)=2.
	  Etcut(1)=8.0

	  rapcut(1,2)=-1.
	  rapcut(2,2)=2.
	  Etcut(2)=11.0

	  rapcut(1,3)=-1.
	  rapcut(2,3)=2.
	  Etcut(3)=17.0
C --- cuts for two Et plots
	  rapcut(1,4)=-1.
	  rapcut(2,4)=2.
	  Etcut(4)=8.0

	  rapcut(1,5)=-1.
	  rapcut(2,5)=1.
	  Etcut(5)=8.0

C --- standard cone radius is 1.0
	  CALL HZJETRAD(2,CONER)
	  IF (CONER.lt.0.0) THEN
	    CONER=1.0
	  ENDIF
	  CALL HZJTNAME(chjet,jetf)
	  WRITE(6,*)'**********************************************'
	  WRITE(6,*)'* HZ94176 called, histograms will be output. *'
	  WRITE(6,*)'*     Jet finder selected : ',jetf,'           *'
	  WRITE(6,1001)'*        with cone radius : ',CONER,'   *'
	  WRITE(6,*)'**********************************************'

 1001	  FORMAT(A29,F5.2,A13)

	ELSE IF (intiflag.eq.2) THEN
C *** Filling runs ***
	
C *** Change directory to our graphs ***
	  CALL HCDIR('//PAWC/94176',' ')

	  q2=hzphokin(1)
	  IF (q2.eq.-1) THEN
	    PRINT*,'HZ94176: HZPHOKIN returns error for Q2'
	  ELSEIF (q2.lt.0) THEN
	    q2=abs(q2)
	  ENDIF
	  ybj=hzphokin(3)
	  IF (ybj.eq.-1) THEN
	    PRINT*,'HZ94176: HZPHOKIN returns error for ybj'
	  ENDIF

C *** Fill our histogram ***

	  IF ((ybj.ge.ybjcut(1)).and.(ybj.le.ybjcut(2))
     &		.and.(q2.lt.q2cut(2))) Then

      	    CALL hzjtfind(chjet,CONER,NJET,Jets)

	    DO loop=1,NJET
	      Et=Jets(loop,3)
	      rap=Jets(loop,1)
	      DO loop2=1,3
	        IF ((rap.ge.rapcut(1,loop2)).and.(rap.le.rapcut(2,loop2))
     &		 .and.(Et.gt.Etcut(loop2))) THEN
	          CALL HFILL(INT(iproc*100+9+loop2), REAL(rap) , 0. ,wtx)
	        ENDIF
	      ENDDO
	
	      DO loop2=4,5
	        IF ((rap.ge.rapcut(1,loop2)).and.(rap.le.rapcut(2,loop2))
     &		 .and.(Et.gt.Etcut(loop2))) THEN
	          CALL HFILL(INT(iproc*100+9+loop2), REAL(Et) , 0. ,wtx)
	        ENDIF
	      ENDDO
	
      	    EndDo ! loop
	 ENDIF

	ELSE IF (intiflag.eq.3) THEN
C *** Termination run ***
C *** Change directory ***
	  CALL HCDIR('//PAWC/94176',' ')
C *** Finish off histograms ***
	  IF (iproc.eq.2) THEN
C --- only bother outputting file if we are on the second run.
	    CALL HBOOKB(-20,'Data cross section (nb) Et.gt.8 GeV'
     &		,12 ,xbins ,0.)
	    CALL HBOOKB(-21,'Data cross section (nb) Et.gt.11 GeV'
     &		,12 ,xbins2 ,0.)
	    CALL HBOOKB(-22,'Data cross section (nb) Et.gt.17 GeV'
     &		,8 ,xbins3 ,0.)
	    CALL HBOOKB(-23,'Data cross section (nb) -1.lt.eta.lt.2'
     &          ,8 ,xbins4 ,0.)
	    CALL HBOOKB(-24,'Data cross section (nb) -1.lt.eta.lt.1'
     &          ,6 ,xbins5 ,0.)
	    CALL HBOOKB(-120,'Data cross section (nb) Et.gt.8 GeV'
     &		,12 ,xbins ,0.)
	    CALL HBOOKB(-121,'Data cross section (nb) Et.gt.11 GeV'
     &		,12 ,xbins2 ,0.)
	    CALL HBOOKB(-122,'Data cross section (nb) Et.gt.17 GeV'
     &		,8 ,xbins3 ,0.)
	    CALL HBOOKB(-123,'Data cross section (nb) -1.lt.eta.lt.2'
     &          ,8 ,xbins4 ,0.)
	    CALL HBOOKB(-124,'Data cross section (nb) -1.lt.eta.lt.1'
     &          ,6 ,xbins5 ,0.)

	    CALL HPAK(-20,ptcr)
	    CALL HPAKE(-20,ptcre)
	    CALL HPAK(-21,pt2cr)
	    CALL HPAKE(-21,pt2cre)
	    CALL HPAK(-22,pt3cr)
	    CALL HPAKE(-22,pt3cre)
	    CALL HPAK(-23,pt4cr)
	    CALL HPAKE(-23,pt4cre)
	    CALL HPAK(-24,pt5cr)
	    CALL HPAKE(-24,pt5cre)

	    DO ivec=1,12
	     pttemp(ivec)=sqrt(ptcre(ivec)**2+ptcresys(ivec)**2)
	    ENDDO
	    CALL HPAK(-120,ptcr)
	    CALL HPAKE(-120,pttemp)

	    DO ivec=1,12
	     pttemp(ivec)=sqrt(pt2cre(ivec)**2+pt2cresys(ivec)**2)
	    ENDDO
	    CALL HPAK(-121,pt2cr)
	    CALL HPAKE(-121,pttemp)

	    DO ivec=1,8
	     pttemp(ivec)=sqrt(pt3cre(ivec)**2+pt3cresys(ivec)**2)
	    ENDDO
	    CALL HPAK(-122,pt3cr)
	    CALL HPAKE(-122,pttemp)

	    DO ivec=1,8
	     pttemp(ivec)=sqrt(pt4cre(ivec)**2+pt4cresys(ivec)**2)
	    ENDDO
	    CALL HPAK(-123,pt4cr)
	    CALL HPAKE(-123,pttemp)

	    DO ivec=1,6
	     pttemp(ivec)=sqrt(pt5cre(ivec)**2+pt5cresys(ivec)**2)
	    ENDDO
	    CALL HPAK(-124,pt5cr)
	    CALL HPAKE(-124,pttemp)

	  ENDIF

	  IF (Xsec.eq.0) THEN
	    PRINT*,'HZ94176: termination called with zero cross section'
	    PRINT*,'          cross section graph meaningless'
	    PRINT*,'	      in process :',iproc*1000
	    Xsec=1
	  ENDIF
	  IF (Ntot.eq.0) THEN
	    PRINT*,'HZ94176: termination called with no total events'
	    PRINT*,'          cross section graph meaningless'
	    PRINT*,'	      in process :',iproc*1000
	    Ntot=1
	  ENDIF

C --- store Xsec and Ntot for both direct and resolved events.
	  mhXsec(iproc)=Xsec
	  mhntot(iproc)=Ntot

	  IF (iproc.eq.2) THEN
C --- only finally
C --- create proper cross-section graph
	    CALL HBOOKB(50,'renorm Monte Carlo events Et.gt.8 GeV'
     &          ,12 ,xbins ,0.)
	    CALL HBOOKB(51,'renorm Monte Carlo events Et.gt.11 GeV'
     &          ,12 ,xbins2 ,0.)
	    CALL HBOOKB(52,'renorm Monte Carlo events Et.gt.17 GeV'
     &          ,8 ,xbins3 ,0.)
	    CALL HBOOKB(53,'renorm Carlo events -1.lt.eta.lt.2'
     &          ,8 ,xbins4 ,0.)
	    CALL HBOOKB(54,'renorm Carlo events -1.lt.eta.lt.1'
     &          ,6 ,xbins5 ,0.)

            CALL HIDOPT(0,'stat')
	    CALL HBARX(0)

	    DO ivec=1,12
	     xbins(ivec)=1/(xbins(ivec+1)-xbins(ivec))
	     xbins2(ivec)=1/(xbins2(ivec+1)-xbins2(ivec))
	    ENDDO
	    DO ivec=1,8
	     xbins3(ivec)=1/(xbins3(ivec+1)-xbins3(ivec))
	     xbins4(ivec)=1/(xbins4(ivec+1)-xbins4(ivec))
	    ENDDO
	    DO ivec=1,6
	     xbins5(ivec)=1/(xbins5(ivec+1)-xbins5(ivec))
	    ENDDO
	    CALL  HPAK (50,xbins)
	    CALL  HPAK (51,xbins2)
	    CALL  HPAK (52,xbins3)
	    CALL  HPAK (53,xbins4)
	    CALL  HPAK (54,xbins5)
C --- above is the bin cross-section weighting factors

C --- now calculate cross-section graphs 20-24
C --- Modified 20/8/98 by R.Taylor to output normalised/cross-section
C     graphs for direct & resolved components (+100 & +200)
	    DO ivec=1,2
	     DO jvec=1,5
	      CALL HOPERA(ivec*100+jvec+9,'*e',49+jvec,ivec*100+19+jvec,
     &		REAL(mhXsec(ivec)/mhNtot(ivec)),1.)
	     ENDDO
	    ENDDO
	    CALL HOPERA(120,'+e',220,20,1.,1.)
	    CALL HOPERA(121,'+e',221,21,1.,1.)
	    CALL HOPERA(122,'+e',222,22,1.,1.)
	    CALL HOPERA(123,'+e',223,23,1.,1.)
	    CALL HOPERA(124,'+e',224,24,1.,1.)
	
	    CALL HZCHISQ(-20,20)
	    CALL HZCHISQ(-21,21)
	    CALL HZCHISQ(-22,22)
	    CALL HZCHISQ(-23,23)
	    CALL HZCHISQ(-24,24)
	  ENDIF
	ELSE
C *** End ***
	  PRINT*,'HZ94176: Please run routine with iflag set to 1,2 or 3'
	ENDIF

	RETURN
	END
*CMZ :  2.00/06 02/05/2002  14.57.20  by  Tancredi Carli
*CMZ :  1.01/15 14/05/98  11.05.42  by  Tancredi Carli
*CMZ :  1.01/11 09/12/97  16.44.12  by  Tancredi Carli
*CMZ :  1.01/07 10/10/97  19.46.50  by  Tancredi Carli
*CMZ :  1.01/05 04/09/96  17.56.33  by   Tancredi Carli
*CMZ :  1.00/02 12/03/96  18.57.45  by  Tancredi Carli
*CMZ :  0.00/11 19/02/96  10.25.14  by  Tancredi Carli
*CMZ :  0.00/09 16/02/96  17.15.47  by  Tancredi Carli
*CMZ :  0.00/08 15/02/96  11.03.41  by  Tancredi Carli
*CMZ :  0.00/04 26/01/96  13.36.15  by  Tancredi Carli
*CMZU:  0.00/03 16/01/96  18.07.56  by  Tancredi Carli
*CMZ :  0.00/01 05/01/96  18.27.51  by  HZtool
*-- Author :
************************************************************************
      Subroutine hz95007(iflag)
************************************************************************
* Subroutine hz95007                                                   *
* ==================                                                   *
*                                                                      *
* Author: Nick Brook (brook@v2.ph.gla.ac.uk)                           *
*                                                                      *
* This routine plots the multiplicit and log(1./xp) distbns            *
* in the current region of the Breit frame.                            *
* The distbn are corrected for particles coming from K0s and Lambdas   *
*                                                                      *
*                                                                      *
* Reference: Z Phys C67(1995) 93.                                      *
*            DESY 95-007                                               *
*                                                                      *
* Modified: add data histogram with stat error only   13.2.96          *
*           include hzchisq                                            *
*            add check on beam energy
************************************************************************
*
* HERA tuning defined commons
*
      Implicit Double Precision(A-H,O-Z)
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEND.
*
      COMMON/QUEST/IQUEST(100)
*
* Set up local variables
*
      Integer idum,ierr,nentry
      Character xxxx*5
      Real eb,ee
      Parameter (ee=26.7)
      Character*80 chtitl
      Character*2 cid
      Dimension plab(4), pbrt(4), pbeam(4), pgam(4), pgam5(5)
      Real chmult(25), chmulte(25), chmults(25)
      Real chlogx(25), chlogxe(25), chlogxs(25)
      Dimension qbins(8), xbins(5), qmean(10)
      Real chmean(10), chsig(10), xpmean
      Real par(3), step(3), pmin(3),pmax(3),sigpar(3),chi2
      Real xmi, xma, ymi, yma
      Integer ids(10), id
      Real  Nacc(10)
      Character*8 Tags(11)
      Real event(11)
      Integer iqu, iql, ixu, ixl
      Data Tags/'Qmean','Q2low','Q2high','xbjlow','xbjhigh',
     +          'nch','nchstat','nchsys','logxp','logxstat',
     1          'logxsys'/
*
      Real data1(25,10), erro1(25,10), syse1(25,10)
      Real data2(22,10), erro2(22,10), syse2(22,10)
      Real qdat(10)
      Real chdat(10), chdate(10), chdats(10)
      Real xpdat(10), xpdate(10), xpdats(10)
*
      Data nentry/0/
      Data xxxx/'95007'/
      data ids/12,13,23,33,24,34,44,54,65,75/
      data Nacc /10*0./
*
* Data points from plots
*
      data data1/
     + .334,.335,.227,.084,.018,.0027,.0002,18*0.,
     1 .289,.343,.241,.097,.025,.0039,.0016,.00003,17*0.,
     2 .190,.279,.266,.167,.073,.022,.0025,.0008,17*0.,
     3 .115,.190,.261,.227,.119,.059,.018,.010,.0006,16*0.,
     4 .151,.283,.285,.185,.070,.022,.0044,.0016,17*0.,
     5 .076,.185,.276,.237,.133,.066,.019,.0050,.0014,16*0.,
     6 .069,.118,.215,.232,.173,.105,.054,.020,.010,.0038,.0009,14*0.,
     7 .045,.084,.127,.235,.169,.143,.106,.048,.027,.012,.0041,14*0.,
     8 .014,.052,.090,.175,.211,.159,.119,.096,.052,.026,.0060,14*0.,
     9 .015,.040,.065,.130,.107,.173,.078,.139,.085,.111,.048,2*0.,
     + .0089,11*0./
      data erro1/
     + .008,.008,.007,.004,.002,.0006,.0002,18*0.,
     1 .008,.009,.007,.005,.002,.0010,.0017,.0003,17*0.,
     2 .008,.011,.010,.009,.006,.003,.0010,.0007,17*0.,
     3 .010,.012,.016,.014,.010,.007,.004,.003,.0007,16*0.,
     4 .007,.010,.010,.077,.005,.003,.0012,.0010,17*0.,
     5 .006,.009,.012,.010,.007,.005,.028,.0013,.0007,16*0.,
     6 .008,.011,.015,.015,.013,.010,.007,.004,.003,.0020,.0009,14*0.,
     7 .015,.019,.020,.030,.023,.021,.021,.013,.011,.007,.0028,14*0.,
     8 .008,.018,.022,.035,.036,.028,.023,.021,.015,.009,.0036,14*0.,
     9 .014,.023,.028,.037,.043,.049,.028,.047,.032,.052,.033,2*0.,
     + .0104,11*0./
      data syse1/
     + .050,.025,.043,.021,.011,.0017,.0005,18*0.,
     1 .094,.021,.043,.033,.010,.0053,.0017,.0004,17*0.,
     2 .033,.032,.018,.032,.025,.017,.0019,.0013,17*0.,
     3 .055,.038,.033,.013,.012,.011,.014,.007,.0014,16*0.,
     4 .039,.053,.011,.049,.024,.012,.0062,.0018,17*0.,
     5 .024,.043,.027,.013,.027,.031,.067,.0021,.0021,16*0.,
     6 .045,.038,.037,.016,.024,.035,.012,.013,.005,.0030,.0010,14*0.,
     7 .057,.042,.028,.050,.049,.045,.063,.012,.014,.007,.0063,14*0.,
     8 .020,.038,.027,.055,.058,.055,.038,.100,.049,.015,.0091,14*0.,
     9 .029,.024,.041,.161,.049,.079,.122,.046,.074,.085,.054,2*0.,
     + .0252,11*0./
      data data2/
     + .001,.014,.061,.201,.262,.419,.613,.661,.675,.580,.420,.306,.259,
     + .133,.104,.019,.101,5*0.,
     1 .003,.008,.059,.145,.289,.485,.660,.699,.694,.616,.506,.366,.383,
     1 .138,.069,.048,.020,5*0.,
     2 0.,.007,.035,.123,.294,.394,.723,.971,1.002,.945,.741,.675,.520,
     2 .277,.271,.132,.046,.022,4*0.,
     3 0.,.002,.022,.129,.336,.549,.629,.778,1.176,1.209,1.013,.906,
     3 .828,.723,.431,.294,.245,.093,4*0.,
     4 2*0.,.006,.065,.093,.304,.419,.641,1.016,.932,.984,.727,.622,
     4 .512,.304,.177,.166,.068,.057,.040,2*0.,
     5 2*0.,.009,.022,.096,.299,.449,.632,.940,1.031,1.299,1.119,1.077,
     5 .746,.640,.457,.310,.138,.071,.042,.080,0.,
     6 3*0.,.048,.096,.225,.307,.750,.803,1.099,1.245,1.240,1.457,1.111,
     6 1.023,.761,.642,.338,.351,.105,.005,0.,
     7 3*0.,.003,.076,.191,.402,.484,.907,1.226,1.457,1.299,2.073,1.272,
     7 1.302,1.022,.823,.667,.774,.186,.151,.091,
     8 3*0.,.117,.131,.456,.382,.745,1.525,1.141,1.140,1.707,1.662,
     8 1.538,1.964,1.478,1.191,.799,.552,.310,.019,.029,
     9 4*0.,.168,.144,.449,.701,.772,1.418,2.151,1.818,2.394,1.616,
     9 1.843,1.307,1.723,2.593,.993,.884,.210,.075/
      data erro2/
     + .001,.005,.012,.026,.027,.035,.044,.046,.046,.043,.036,.031,.032,
     + .023,.024,.009,.118,5*0.,
     1 .002,.003,.012,.020,.030,.040,.048,.049,.049,.046,.044,.038,.036,
     1 .027,.018,.017,.013,5*0.,
     2 0.,.005,.012,.023,.044,.045,.067,.083,.083,.078,.065,.068,.064,
     2 .042,.047,.037,.021,.017,4*0.,
     3 0.,.003,.012,.040,.076,.094,.094,.097,.138,.141,.118,.111,.113,
     3 .116,.082,.077,.087,.054,4*0.,
     4 2*0.,.004,.019,.017,.039,.041,.055,.075,.065,.071,.056,.055,.053,
     4 .039,.028,.035,.023,.032,.056,2*0.,
     5 2*0.,.009,.010,.022,.048,.055,.061,.077,.081,.097,.086,.090,.069,
     5 .071,.058,.049,.032,.023,.021,.071,0.,
     6 3*0.,.046,.037,.054,.060,.106,.100,.120,.128,.121,.143,.118,.118,
     6 .105,.104,.070,.106,.043,.052,0.,
     7 3*0.,.005,.054,.086,.137,.136,.203,.238,.273,.231,.348,.233,.240,
     7 .214,.195,.186,.267,.113,.100,.097,
     8 3*0.,.156,.083,.199,.132,.240,.427,.268,.247,.353,.308,.335,.431,
     8 .347,.317,.236,.229,.190,.022,.035,
     9 4*0.,.194,.125,.270,.323,.348,.539,.744,.523,.647,.496,.541,.436,
     9 .538,.883,.466,.490,.175,.094/
      data syse2/
     + .002,.009,.015,.090,.029,.073,.079,.098,.073,.113,.025,.056,.080,
     + .019,.018,.033,.119,5*0.,
     1 .003,.007,.008,.027,.034,.088,.140,.094,.039,.050,.117,.043,.128,
     1 .053,.010,.029,.025,5*0.,
     2 0.,.005,.010,.043,.074,.023,.099,.130,.215,.198,.058,.097,.138,
     2 .082,.059,.033,.034,.015,4*0.,
     3 0.,.032,.038,.026,.076,.181,.104,.086,.372,.285,.166,.156,.285,
     3 .121,.114,.104,.125,.060,4*0.,
     4 2*0.,.007,.029,.014,.089,.032,.089,.187,.120,.176,.157,.161,.089,
     4 .092,.027,.086,.068,.043,.040,2*0.,
     5 2*0.,.007,.028,.081,.109,.083,.086,.095,.101,.251,.138,.196,.102,
     5 .081,.043,.089,.048,.034,.058,.113,0.,
     6 3*0.,.057,.013,.045,.113,.243,.107,.091,.268,.131,.281,.417,.141,
     6 .143,.231,.065,.244,.182,.083,0.,
     7 3*0.,.044,.054,.172,.141,.096,.156,.263,.573,.304,.810,.146,.113,
     7 .223,.197,.122,.368,.208,.260,.070,
     8 3*0.,.074,.442,.265,.202,.224,.891,.181,1.308,.318,.712,.451,
     8 .526,.343,.143,.267,.294,.187,.097,.033,
     9 4*0.,.135,.148,.296,.689,1.869,1.024,1.183,.576,.877,.457,.943,
     9 .205,1.047,1.744,.633,.436,.229,.150/
*
      data qdat/3.8,3.8,5.3,7.3,5.3,7.4,10.4,14.5,20.4,29.2/
      data chdat/1.12,1.25,1.73,2.35,1.83,2.47,3.05,3.77,4.49,5.57/
      data chdate/.02,.02,.04,.07,.03,.05,.09,.22,.30,.65/
      data chdats/.15,.25,.23,.11,.27,.23,.31,.40,.54,1.21/
      data xpdat/1.49,1.50,1.70,1.94,1.70,1.92,2.18,2.25,2.78,2.85/
      data xpdate/.02,.03,.03,.06,.03,.03,.06,.10,.22,.21/
      data xpdats/.06,.06,.06,.11,.09,.07,.10,.23,.26,.24/
*
      If(iflag.eq.1) then
*
* Initialisation: The following MUST always be done
* (i) make subdirectory in PAWC
*      - use the name as the xxxxxx in HZxxxxxx subroutine
* (i) make subdirectory in o/p file
*
        Call hcdir('//PAWC',' ')
        call hmdir('95007','S')
        Call hcdir('//HISTO',' ')
        call hmdir('95007','S')
*
* book your histograms
*
        Do kd = 1, 10
          write(cid,'(I2)') ids(kd)
          call hbook1(ids(kd),' multi ('//cid//')',25,0.,25.,0.)
          call hidopt(ids(kd),'STAT')
          call hbook1(100+ids(kd),' log(1/xp) ('//cid//')',
     +                22,-0.55,4.95,0.)
        Enddo
        Call hbookn(1000,'Monte Carlo',11,' ',200,TAGS)
        Call hbookn(1001,'Data',11,' ',200,TAGS)
*
* set your plot/paper specific cuts
*
        qbins(1) = 10.
        qbins(2) = 20.
        qbins(3) = 40.
        qbins(4) = 80.
        qbins(5) = 160.
        qbins(6) = 320.
        qbins(7) = 640.
        qbins(8) = 1280.
        xbins(1) = 6.0e-04
        xbins(2) = 1.2e-03
        xbins(3) = 2.4e-03
        xbins(4) = 1.0e-02
        xbins(5) = 5.0e-02
*
      Else if(iflag.eq.2) then
* Filling: The following MUST always be done
* (i) move to the correct sub-directory in PAWC
*
        call hcdir('//PAWC/95007',' ')
        q2  = hzdiskin(1)
        xbj = hzdiskin(2)
        If(q2.ge.qbins(1).and.q2.lt.qbins(2).and.
     +     xbj.ge.xbins(1).and.xbj.lt.xbins(2)) then
           id = 12
           Nacc(1) = Nacc(1) + wtx
           qmean(1) = qmean(1) + sqrt(q2)
        Else If(q2.ge.qbins(1).and.q2.lt.qbins(2).and.
     +     xbj.ge.xbins(2).and.xbj.lt.xbins(3)) then
           id = 13
           Nacc(2) = Nacc(2) + wtx
           qmean(2) = qmean(2) + sqrt(q2)
        Else If(q2.ge.qbins(2).and.q2.lt.qbins(3).and.
     +     xbj.ge.xbins(2).and.xbj.lt.xbins(3)) then
           id = 23
           Nacc(3) = Nacc(3) + wtx
           qmean(3) = qmean(3) + sqrt(q2)
        Else If(q2.ge.qbins(3).and.q2.lt.qbins(4).and.
     +     xbj.ge.xbins(2).and.xbj.lt.xbins(3)) then
           id = 33
           Nacc(4) = Nacc(4) + wtx
           qmean(4) = qmean(4) + sqrt(q2)
        Else If(q2.ge.qbins(2).and.q2.lt.qbins(3).and.
     +     xbj.ge.xbins(3).and.xbj.lt.xbins(4)) then
           id = 24
           Nacc(5) = Nacc(5) + wtx
           qmean(5) = qmean(5) + sqrt(q2)
        Else If(q2.ge.qbins(3).and.q2.lt.qbins(4).and.
     +     xbj.ge.xbins(3).and.xbj.lt.xbins(4)) then
           id = 34
           Nacc(6) = Nacc(6) + wtx
           qmean(6) = qmean(6) + sqrt(q2)
        Else If(q2.ge.qbins(4).and.q2.lt.qbins(5).and.
     +     xbj.ge.xbins(3).and.xbj.lt.xbins(4)) then
           id = 44
           Nacc(7) = Nacc(7) + wtx
           qmean(7) = qmean(7) + sqrt(q2)
        Else If(q2.ge.qbins(5).and.q2.lt.qbins(6).and.
     +     xbj.ge.xbins(3).and.xbj.lt.xbins(4)) then
           id = 54
           Nacc(8) = Nacc(8) + wtx
           qmean(8) = qmean(8) + sqrt(q2)
        Else If(q2.ge.qbins(6).and.q2.lt.qbins(7).and.
     +     xbj.ge.xbins(4).and.xbj.lt.xbins(5)) then
           id = 65
           Nacc(9) = Nacc(9) + wtx
           qmean(9) = qmean(9) + sqrt(q2)
        Else If(q2.ge.qbins(7).and.q2.lt.qbins(8).and.
     +     xbj.ge.xbins(4).and.xbj.lt.xbins(5)) then
           id = 75
           Nacc(10) = Nacc(10) + wtx
           qmean(10) = qmean(10) + sqrt(q2)
        Else
           Return
        Endif
*
* Fill your histograms
*
          jel = hzidelec(idum)
          if(jel.lt.0) Return
          if(hzipgam(pgam5).lt.0) Return
          if(hzibeam(ip,il).ne.1) Return
* check on electron beam energy
          nentry=nentry+1
          ierr=HZIBEAM(ibeam,idum)
          if (.not.(ierr.eq.1)) then
           write(6,*) 'HZ'//xxxx,' beams not found ! '
           return
          endif
*
          eb=real(PHEP(4,idum))
          if (abs(abs(eb)-ee).gt.0.2) then
           if (nentry.lt.10) then
            write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,'  ! '
           elseif (nentry.eq.10) then
            write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &      ' ...last message ! '
           endif
C           return
          endif
*
          do ivec = 1, 4
            pbeam(ivec) = phep(ivec,ip)
            pgam(ivec) = pgam5(ivec)
          enddo
          Call hzbrtini(pbeam,pgam,ierr)
          nch = 0
          do 30 ihep = 1, nhep
            If(isthep(ihep).eq.1.and.ihchrg(ihep).ne.0
     +         .and.ihep.ne.jel) then
             idpart=abs(idhep(jmohep(1,ihep)))
             If(idpart.eq.310.or.idpart.eq.3122) goto 30
             do ivec=1,4
               plab(ivec) = phep(ivec,ihep)
             enddo
             Call hzbrt(plab,pbrt,ierr)
             if(pbrt(3).lt.0.) then
               nch = nch + 1
               xp = 2.*sqrt(pbrt(1)**2+pbrt(2)**2+pbrt(3)**2)
     +               /sqrt(q2)
               call hfill(100+id,-1.*real(log(xp)),0.,wtx)
             endif
            Endif
 30       continue
          call hfill(id,real(nch),0.,wtx)
*
      Else if(iflag.eq.3) then
* Termination: The following MUST always be done
* (i) Move to the correct PAW subdirectory
*
        call hcdir('//PAWC/95007',' ')
*
* Histo manipulation
* Deal with data plots
*
        Do kd = 1, 10
          nacc(kd) = max(1.,nacc(kd))
          qmean(kd) = qmean(kd)/dble(nacc(kd))
          chmean(kd) = hstati(ids(kd),1,' ',1)
          chsig(kd)  = chmean(kd)/sqrt(real(nacc(kd)))
          Call hgive(ids(kd),chtitl,nx,xmi,xma,ny,ymi,yma,nwt,loc)
          Call hopera(ids(kd),'+e',ids(kd),ids(kd),
     +            1./real(nacc(kd))*real(nx)/(xma-xmi),0.)
C*TC>
          call hzhinfo(ids(kd),nacc(kd))
C*TC<
          id=-1000-ids(kd)
          call hbook1(id,chtitl,25,0.,25.,0.)
          Call ucopy(data1(1,kd),chmult,25)
          Call ucopy(erro1(1,kd),chmulte,25)
          Call hpak(id,chmult)
          Call hpake(id,chmulte)
          call hbook1(-ids(kd),chtitl,25,0.,25.,0.)
          Call ucopy(data1(1,kd),chmult,25)
          Call ucopy(erro1(1,kd),chmulte,25)
          Call ucopy(syse1(1,kd),chmults,22)
          do ipt = 1, 25
            chmulte(ipt) = sqrt(chmulte(ipt)**2+chmults(ipt)**2)
          enddo
          Call hpak(-ids(kd),chmult)
          Call hpake(-ids(kd),chmulte)
          kids = 100+ids(kd)
          xpmean = hstati(kids,1,' ',1)
          Call hgive(kids,chtitl,nx,xmi,xma,ny,ymi,yma,nwt,loc)
          call hxi(kids,xpmean+1.,limup)
          call hxi(kids,xpmean-1.,limlo)
          iquest(11) = limlo
          iquest(12) = limup
          par(1)= hmax(kids)
          par(2) = xpmean
          par(3) = hstati(kids,2,' ',1)
          Call hfithn(kids,'G','NQR',3,par,step,pmin,pmax,sigpar,chi2)
          Call hopera(kids,'+e',kids,kids,
     +            1./real(nacc(kd))*real(nx)/(xma-xmi),0.)
C*TC>
          call hzhinfo(kids,nacc(kd))
C*TC<
          id=-1000-kids
          call hbook1(id,chtitl,22,-0.55,4.95,0.)
          Call ucopy(data2(1,kd),chlogx,22)
          Call ucopy(erro2(1,kd),chlogxe,22)
          Call hpak(id,chlogx)
          Call hpake(id,chlogxe)
          call hbook1(-kids,chtitl,22,-0.55,4.95,0.)
          Call ucopy(data2(1,kd),chlogx,22)
          Call ucopy(erro2(1,kd),chlogxe,22)
          Call ucopy(syse2(1,kd),chlogxs,22)
          do ipt = 1, 22
            chlogxe(ipt) = sqrt(chlogxe(ipt)**2+chlogxs(ipt)**2)
          enddo
          Call hpak(-kids,chlogx)
          Call hpake(-kids,chlogxe)
*
          Write(6,*) ' Monte Carlo Data '//gen
          Write(6,1001) kd,qmean(kd)
          Write(6,1002) ' n_ch         = ',chmean(kd),' +/- ',chsig(kd)
          Write(6,1002) ' log(1/xp)max = ',par(2),' +/- ',sigpar(2)
          Write(6,*) ' '
          Write(6,*) ' ZEUS data '
          Write(6,1001) kd,qdat(kd)
          Write(6,1003) ' n_ch         = ',chdat(kd),' +/- ',
     +                         chdate(kd),' +/- ',chdats(kd)
          Write(6,1003) ' log(1/xp)max = ',xpdat(kd),' +/- ',
     +                         xpdate(kd),' +/- ',xpdats(kd)
          Write(6,*) ' '
          if(kd.eq.1) then
            iql = 1
            iqu = 2
            ixl = 1
            ixu = 2
          else if(kd.eq.2) then
            iql = 1
            iqu = 2
            ixl = 2
            ixu = 3
          else if(kd.eq.3) then
            iql = 2
            iqu = 3
            ixl = 2
            ixu = 3
          else if(kd.eq.4) then
            iql = 3
            iqu = 4
            ixl = 2
            ixu = 3
          else if(kd.eq.5) then
            iql = 2
            iqu = 3
            ixl = 3
            ixu = 4
          else if(kd.eq.6) then
            iql = 3
            iqu = 4
            ixl = 3
            ixu = 4
          else if(kd.eq.7) then
            iql = 4
            iqu = 5
            ixl = 3
            ixu = 4
          else if(kd.eq.8) then
            iql = 5
            iqu = 6
            ixl = 3
            ixu = 4
          else if(kd.eq.9) then
            iql = 6
            iqu = 7
            ixl = 4
            ixu = 5
          else if(kd.eq.10) then
            iql = 7
            iqu = 8
            ixl = 4
            ixu = 5
          Endif
          event(1) = real(qmean(kd))
          event(2) = real(qbins(iql))
          event(3) = real(qbins(iqu))
          event(4) = real(xbins(ixl))
          event(5) = real(xbins(ixu))
          event(6) = real(chmean(kd))
          event(7) = real(chsig(kd))
          event(8) = 0.
          event(9) = real(par(2))
          event(10) = real(sigpar(2))
          event(11) = 0.
          Call hfn(1000,event)
          event(1) = real(qdat(kd))
          event(6) = real(chdat(kd))
          event(7) = real(chdate(kd))
          event(8) = real(chdats(kd))
          event(9) = real(xpdat(kd))
          event(10) = real(xpdate(kd))
          event(11) = real(xpdats(kd))
          Call hfn(1001,event)
          call HZCHISQ(-ids(kd),ids(kd))
          call HZCHISQ(-1000-ids(kd),ids(kd))
          call HZCHISQ(-kids,kids)
          call HZCHISQ(-1000-kids,kids)
        Enddo

      Endif
*
      Return
 1001 Format(/,1X,' bin # ',I2,' Mean Q = ',F4.1)
 1002 Format(A,F4.2,A,F4.2)
 1003 Format(A,F4.2,A,F4.2,A,F4.2)
      End
*CMZ :  1.01/13 18/03/98  21.32.38  by  Hannes Jung
*CMZ :  1.01/07 08/10/97  16.08.04  by  Tancredi Carli
*CMZ :  1.01/03 13/05/96  12.02.14  by  Mark Hayes
*CMZU:  0.00/05 30/01/96  18.28.04  by  Mark Hayes
*-- Author :    Mark Hayes   18/12/95
*****************************************************************************
	Subroutine HZ95033(iflag)
*****************************************************************************
* This photoproduction routine has to be run twice with the following
* code additions:
* 	+1000 for the DIRECT component run.
*	+2000 for the RESOLVED component run.
* for all three phases (iflag=1,2,3)
*
* iflag = 1,2 or 3 depending on wether it is the initialization,
*		processing or termination phase (respectively)
*
* The default jetfinder is EUCELL
* To change jetfinder use these values to call the initialisation phase.
* 1 + 10 * (jetfinder number)
*
* This routine produces two Monte Carlo graphs.
* id 10 is the normalised cross section in nb for x_gamma.ge.0.75.
* id 20 is the normalised cross section in nb for x_gamma.lt.0.75.
*		These graph will be
*		meaningless unless Xsec and Ntot are set before
*		calling the termination routine.
*		(Xsec - total cross section returned by MC)
*		(Ntot - number of events passed to this routine)
*
* Cuts : 	Q2 < 4
*		0.2< y_bj < 0.8
*		/delta/eta < 0.5
*		Depending on graph Et > 6
*			and -1 < eta < or
*			 0 < eta < 2
*
* Recommended value for Ptmin is 3 GeV (to be set in MC set up)
*
* Author : Mark Hayes (Mark.Hayes@bris.ac.uk)
*
* Reference : DESY-95-033
*             Phys. Lett. B348 (1995) 665
*
*
*****************************************************************************
*
* HERA Tuning defined commons

	IMPLICIT NONE

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.

	CHARACTER*6 jetf

        INTEGER NJET
        DOUBLE PRECISION Jets(50,8)
        DOUBLE PRECISION CONER

	DOUBLE PRECISION elecE
	INTEGER myil,myip
	INTEGER loop,loop2,count
	DOUBLE PRECISION deltaeta,etabar,xgam
	DOUBLE PRECISION phi(2),px(2),py(2),pz(2),ptsq(2)
	DOUBLE PRECISION ppsq(2),energy(2),mass(2)
	DOUBLE PRECISION rap(2),Et(2)
	DOUBLE PRECISION ybj,q2

C --- cuts arrays
	DOUBLE PRECISION ybjcut(2),q2cut(2)
	DOUBLE PRECISION rapcut(2),Etcut(5)

C --- private copies of Xsec and Ntot from HERACMN
	DOUBLE PRECISION mhxsec(2),mhntot(2)

C *** Data for x_gamma.ge.0.75
	REAL eta(8),etacr(8),cresta(8)
	REAL cresys(8),band(8)
C *** Actual data for x_gamma.ge.0.75
	DATA eta/-0.75, -0.50, -0.25, 0.00, 0.25, 0.50, 0.75, 1.00/
	DATA etacr/0.63, 1.31, 1.32, 1.37, 1.29, 0.88, 0.50, 0.23/
	DATA cresta/0.08, 0.13, 0.14, 0.11, 0.11, 0.10, 0.06, 0.04/
	DATA cresys/0.16, 0.10, 0.08, 0.06, 0.17, 0.17, 0.27, 0.17/
	DATA band/0.08, 0.19, 0.20, 0.24, 0.15, 0.16, 0.06, 0.05/
C *** Data for x_gamma.lt.0.75
	REAL eta2(7),eta2cr(7),cre2sta(7)
	REAL cre2sys(7),band2(7)
C *** Actual data for x_gamma.lt.0.75
	DATA eta2/0.00, 0.25, 0.50, 0.75, 1.00, 1.25, 1.50/
	DATA eta2cr/1.74, 2.20, 2.64, 3.51, 3.83, 3.88, 4.32/
	DATA cre2sta/0.10, 0.13, 0.13, 0.16, 0.17, 0.16, 0.16/
	DATA cre2sys/0.22, 0.23, 0.33, 0.51, 0.63, 0.51, 0.66/
	DATA band2/0.66, 0.54, 0.59, 0.71, 0.66, 0.91, 0.99/

	INTEGER intiflag, chjet, iproc, iflag
	SAVE chjet
C --- choose same jet finder as in the paper --- EUCELL
	DATA chjet/1/
	INTEGER hzflag

	REAL pttemp(12)
	INTEGER ivec,jvec
	REAL sqrt

C --- choose direct/resolved
C --- recommend 1 - DIRECT, 2 - RESOLVED
	IF (iflag.gt.1000) THEN
	  iproc=INT(iflag/1000)
	  intiflag=MOD(iflag,1000)
	ENDIF
	IF ((iproc.gt.2).or.(iproc.lt.1)) THEN
	  PRINT*,'HZ95033 : Badly called routine'
	  PRINT*,'          please set intiflag +1000 or +2000'
	ENDIF

C --- choose jet finder
	IF ((intiflag.gt.10).and.(MOD(intiflag,10).eq.1)) THEN
	  chjet=INT(intiflag/10)
	  intiflag=MOD(intiflag,10)
	ENDIF
	
	IF (intiflag.eq.1) THEN
C *** Initialisation run ***
C *** Create directories ***
	  IF (iproc.eq.1) THEN
	    CALL HCDIR('//HISTO',' ')
	    CALL HMDIR('95033','S')
	    CALL HCDIR('//PAWC',' ')
	    CALL HMDIR('95033','S')

	    CALL HBOOK1(10,'Monte Carlo cross section (nb) x_gam ge 0.75'
     &		,8 ,-0.875 ,1.125 ,0.)
	    CALL HBOOK1(20,'Monte Carlo cross section (nb) x_gam lt 0.75'
     &		,7 ,-0.125 ,1.625 ,0.)
	  ENDIF
	    CALL HCDIR('//HISTO/95033',' ')
	    CALL HCDIR('//PAWC/95033',' ')
	    CALL HBOOK1(iproc*100+10,
     &          'Monte Carlo numbers x_gam ge 0.75'
     &		,8 ,-0.875 ,1.125 ,0.)
	    CALL HBOOK1(iproc*100+11,
     &          'Monte Carlo numbers x_gam lt 0.75'
     &		,7 ,-0.125 ,1.625 ,0.)

C --- photoproduction cuts

	  ybjcut(1)=0.2
	  ybjcut(2)=0.8
	  q2cut(1)=0.
	  q2cut(2)=4.

C --- basic cuts for rapidity plots
	  Etcut(1)=6.0

C --- standard cone radius is 1.0
	  CALL HZJETRAD(2,CONER)
	  IF (CONER.lt.0.0) THEN
	    CONER=1.0
	  ENDIF
          CALL HZJTNAME(chjet,jetf)

	  WRITE(6,*)'**********************************************'
	  WRITE(6,*)'* HZ95033 called, histograms will be output. *'
	  WRITE(6,*)'*     Jet finder selected : ',jetf,'           *'
	  WRITE(6,1001)'*        with cone radius : ',CONER,'   *'
	  WRITE(6,*)'**********************************************'

 1001	  FORMAT(A29,F5.2,A13)

	ELSE IF (intiflag.eq.2) THEN
C *** Filling runs ***
	
C *** Change directory to our graphs ***
	  CALL HCDIR('//PAWC/95033',' ')

	  q2=hzphokin(1)
	  IF (q2.eq.-1) THEN
	    PRINT*,'HZ95033: HZPHOKIN returns error for Q2'
	  ELSEIF (q2.lt.0) THEN
	    q2=abs(q2)
	  ENDIF
	  ybj=hzphokin(3)
	  IF (ybj.eq.-1) THEN
	    PRINT*,'HZ95033: HZPHOKIN returns error for ybj'
	  ENDIF

C *** Fill our histogram ***

	  IF ((ybj.ge.ybjcut(1)).and.(ybj.le.ybjcut(2))
     &		.and.(q2.lt.q2cut(2))) Then

	  elecE=26.7
	  hzflag=HZIBEAM(myip,myil)
	  IF (hzflag.ge.0) Then
 	    elecE=abs(PHEP(4,myil))
	  ELSE
	    PRINT*,'HZ95033: Electron not found. E=0.001'
	    PRINT*,'         event will be rejected'
	    elecE=0.001
	  ENDIF
	
            CALL hzjtfind(chjet,CONER,NJET,Jets)

	    IF (NJET.ge.2) THEN
	      DO loop=1,2
	        Et(loop)=Jets(loop,3)
	        rap(loop)=Jets(loop,1)
	      ENDDO
	      deltaeta=abs(rap(1)-rap(2))
	      etabar=(rap(1)+rap(2))/2
	      xgam=(Et(1)*exp(-1*rap(1))+Et(2)*exp(-1*rap(2)))
     &			/(2*ybj*elecE)

	      IF ((Et(2).gt.Etcut(1)).and.(deltaeta.lt.0.5)) THEN
		IF (xgam.ge.0.75) THEN
	         CALL HFILL(INT(iproc*100+10), REAL(etabar) , 0. ,wtx)
		ELSE
	         CALL HFILL(INT(iproc*100+11), REAL(etabar) , 0. ,wtx)
		ENDIF
	      ENDIF
	    ENDIF

	  ENDIF		! Q2 & y cuts

	ELSE IF (intiflag.eq.3) THEN
C *** Termination run ***
C *** Change directory ***
	  CALL HCDIR('//PAWC/95033',' ')
C *** Finish off histograms ***

	  IF (Xsec.eq.0) THEN
	    PRINT*,'HZ95033: termination called with zero cross section'
	    PRINT*,'          cross section graph meaningless'
	    PRINT*,'	      in process :',iproc*1000
	    Xsec=1
	  ENDIF
	  IF (Ntot.eq.0) THEN
	    PRINT*,'HZ95033: termination called with no total events'
	    PRINT*,'          cross section graph meaningless'
	    PRINT*,'	      in process :',iproc*1000
	    Ntot=1
	  ENDIF

C --- store Xsec and Ntot for both direct and resolved events.
	  mhXsec(iproc)=Xsec
	  mhntot(iproc)=Ntot

	  IF (iproc.eq.2) THEN
C --- only finally
C --- create proper cross-section data
	    CALL HBOOK1(-10,'Data cross section (nb) x_gam ge 0.75'
     &		,8 ,-0.875 ,1.125 ,0.)
	    CALL HBOOK1(-20,'Data cross section (nb) x_gam lt 0.75'
     &		,7 ,-0.125 ,1.625 ,0.)


	    CALL HPAK(-10,etacr)
	    CALL HPAKE(-10,cresta)
	    CALL HPAK(-20,eta2cr)
	    CALL HPAKE(-20,cre2sta)

	    CALL HBOOK1(-11,'Data full errors (nb) x_gam ge 0.75'
     &		,8 ,-0.875 ,1.125 ,0.)
	    CALL HBOOK1(-21,'Data full errors (nb) x_gam lt 0.75'
     &		,7 ,-0.125 ,1.625 ,0.)

	    CALL HPAK(-11,etacr)
	    DO ivec=1,8
	      pttemp(ivec)=sqrt(cresta(ivec)**2+cresys(ivec)**2)
	    ENDDO
	    CALL HPAKE(-11,pttemp)
	    CALL HPAK(-21,eta2cr)
	    DO ivec=1,7
	      pttemp(ivec)=sqrt(cre2sta(ivec)**2+cre2sys(ivec)**2)
	    ENDDO
	    CALL HPAKE(-21,pttemp)

C --- now calculate cross-section graphs 10,20
	    CALL HOPERA(110,'+e',210,10,
     &		REAL(4*mhXsec(1)/mhNtot(1)), REAL(4*mhXsec(2)/mhNtot(2)))
	    CALL HOPERA(111,'+e',211,20,
     &		REAL(4*mhXsec(1)/mhNtot(1)), REAL(4*mhXsec(2)/mhNtot(2)))
     	    CALL HZCHISQ(-10,10)
     	    CALL HZCHISQ(-20,20)
	  ENDIF

	ELSE
C *** End ***
	  PRINT*,'HZ95033: Please run routine with iflag set to 1,2 or 3'
	  PRINT*,'         with +1000 or +2000 for DIR or RES events.'
	ENDIF

	RETURN
	END
*CMZ :  1.01/15 14/05/98  11.01.37  by  Tancredi Carli
*CMZ :  1.01/11 14/11/97  10.34.18  by  Tancredi Carli
*CMZ :  1.01/07 08/10/97  16.10.08  by  Tancredi Carli
*CMZ :  1.01/04 01/08/96  19.06.45  by   Tancredi Carli
*-- Author :
*
*CMZ :  1.01/03 09/04/96  19.55.00  by  Tancredi Carli
*CMZ :  1.01/02 09/04/96  18.16.46  by  Tancredi Carli
*-- Author : Tancredi Carli
      subroutine HZ95036(IFLAG)
****************************************************************************
* Purpose: produced histograms for:
*           o) rap max distribution (not corrected)
*           o) Mx distribution (not corrected)
*           o) ...still missing F2d
* Event selection:
*
* Running: Ee=26.7 HERA running 1992
* Reference: Phys. Lett. B 348 (1995) 681-696
* Arguments: iflag=1 initialisation
*            iflag=1 filling
*            iflag=3 termination
*
* NOTE: The H1 data provided here are not corrected. They
*       can therefore not be compared directly to the
*       Monte Carlo curves !!!
*
* written by: Tancredi Carli and Renate Mohr
*             (carli@mail.desy.de mohr@mail.desy.de)
*             data put in non-equidistant bins by M. Sutton
****************************************************************************
      IMPLICIT NONE
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      Integer iflag,ihep,i,j,k,l
*     DESY Preprint number
      Character*5 xxxx
      Data xxxx/'95036'/
*
      Real pi,rd,ee,eb,wbin
      Logical evcut,lp
      Integer iel,idum,id,jhep,iturn,imax,jmax
      Real nev,nsel
      Parameter (pi=3.1415927,rd=180./pi,ee=26.7)
      Data lp/.false./
C     Data lp/.true./
      Real x,y,q2,enel,thel,th,thj,thcut,rapmax,pt,p
      Real xmi,xma,ymi,yma,rapi,rapj
      Integer ny
      Character chtitl*80
      Real thmin,thmax,ener,gapmax,rcrit
*
      Integer nx,mx,neta
      Real tmx,tnx,smx,smy,x0,y0
      Parameter (nx=16,mx=15)
      Real yn(nx),rap(nx),eyn(nx),erap(nx)
      Real xm(mx),xmy(mx),exmy(mx)
      Real VMIN,VMAX,xcmin,xcmax
      Real prem(4),pmx(4),xinvx,xinvr
      Real xeta(nmxhep)
      Real xpom,beta
      Integer ierr,ibeam,igam
      Integer n85,n12,n25,n50
      Parameter (n85=8,n12=22,n25=18,n50=14)
      Real beta85(n85),x85(n85),f285(n85),st85(n85),sy85(n85)
      Real beta12(n12),x12(n12),f212(n12),st12(n12),sy12(n12)
      Real beta25(n25),x25(n25),f225(n25),st25(n25),sy25(n25)
      Real beta50(n50),x50(n50),f250(n50),st50(n50),sy50(n50)
      Real rapbin(nx+1)
      Save nev,nsel
*
******************************************************************************
* Data points from plots (in postscript co-ordinates)
      Data rap /111.,129.,147.,164.,182.,199.,217.,235.,252.,270.,
     &          284.,293.,301.,308.,315.,322./
      Data  yn /663.,691.,697.,706.,706.,706.,704.,706.,708.,719.,
     &          729.,739.,755.,777.,781.,705./
      Data erap/120.,138.,156.,155.,191.,209.,226.,244.,263.,279.,
     &          290.,297.,304.,311.,318.,319./
      Data  eyn/667.,691.01,697.01,706.01,706.01,706.01,704.01,706.01,
     &          708.01,719.01,729.01,739.01,755.01,777.01,781.01,705.01/
*
      Data xmy /514.,554.,526.,515.,495.,486.,470.,469.,466.,463.,
     &          457.,457.,457.,456.,456./
      Data exmy/  9., 10.,  9.,  8.,  7.,  6.,  0.,  0.,  0.,  0.,
     &            0.,  0.,  0.,  0.,  0./
      Data  xm /418.,435.,450.,467.,482.,499.,515.,533.,547.,563.,
     &          579.,595.,611.,627.,643./
* Q2 8.5 GeV2
      Data beta85/0.065,0.065,2*0.175,0.375,0.375,0.65,0.65/
      Data    x85/0.00024,0.00042,0.00024,0.00042,0.00024,0.00042,
     &            0.00024,0.00042/
      Data   f285/4.21,3.65,24.4,25.14,84.85,40.85,139.25,37.66/
      Data   st85/1.68,1.23,7.33,5.62,23.72,11.48,56.85,17.77/
      Data   sy85/2.44,1.51,4.5,6.38,17.53,8.97,35.43,8.12/
* Q2 12 GeV2
      Data beta12/5*0.065,6*0.175,6*0.375,5*0.65/
      Data    x12/0.0024 ,0.00042,0.00075,0.00133,0.00237,
     &            0.00024,0.00042,0.00075,0.00133,0.00237,
     &            0.00421,0.00024,0.00042,0.00075,0.00133,
     &            0.00237,0.00421,0.00042,0.00075,0.00133,
     &            0.00237,0.00421/
      Data   f212/  12.45,   4.38,   4.43,   0.60,   1.31,
     &              34.99,  15.82,   6.20,   3.99,   1.85,
     &               1.00,  56.41,  41.30,  31.88,   9.54,
     &               6.05,   3.84,  58.00,  35.34,  25.57,
     &              25.04,   3.44/
      Data   st12/   3.39,   1.29,   0.87,   0.38,   0.38,
     &                9.6,   3.94,   1.72,   1.05,   0.54,
     &                0.51, 21.72,  10.18,   7.58,   2.64,
     &                1.53,  1.18,  19.94,   9.71,   6.03,
     &                 4.7,  1.88/
      Data  sy12/     4.72,  1.22,   1.84,   0.39,   0.47,
     &                 8.4,  2.67,   1.37,   0.77,    0.52,
     &                0.49, 17.15,   8.15,   4.65,    1.70,
     &                0.89,  1.17,   8.08,   4.78,    3.44,
     &                3.95,  1.93/
* Q2 25 GeV
      Data  beta25/3*0.065,5*0.175,5*0.375,5*0.650/
      Data     x25/0.00075,0.00133,0.00237,0.00075,0.00133,
     &             0.00237,0.00421,0.0075 ,0.00075,0.00133,
     &             0.00237,0.00421,0.0075 ,0.00075,0.00133,
     &             0.00237,0.00421,0.0075/
      Data    f225/   2.20,   1.08,   1.29,  12.89,   3.08,
     &                2.57,   1.71,   0.82,  37.64,  13.52,
     &                6.54,   2.42,   1.93,  37.02,  26.54,
     &               12.76,   7.43,   1.30/
      Data   st25/     0.7,   0.39,   0.30,   2.42,   0.90,
     &                0.57,   0.40,   0.37,   7.85,   3.09,
     &                1.52,   0.64,   0.65,  10.13,   6.31,
     &                2.95,   1.71,   0.74/
      Data   sy25/    0.51,   0.32,   0.43,   2.53,   0.85,
     &                0.95,   0.41,   0.33,   6.30,    1.94,
     &                0.90,   0.40,   0.55,   6.01,    3.99,
     &                1.87,   0.99,   0.63/
*Q2=50 GeV2
      Data beta50/4*0.175,5*0.375,5*0.675/
      Data    x50/0.00133,0.00237,0.00421,0.00750,0.00133,
     &            0.00237,0.00421,0.00750, 0.0133,0.00133,
     &            0.00237,0.00421,0.00750,0.0133/
      Data   f250/   7.04,   2.84,   2.33,   1.35,  22.68,
     &              11.03,   4.34,   1.89,   1.09,  21.33,
     &              17.47,   9.34,   1.69,  0.96/
      Data  st50/    2.44,   1.06,   0.80,   0.55,   7.85,
     &               3.32,   1.45,   0.74,   0.81,   13.07,
     &               6.95,   3.45,   1.13,    0.78/
      Data sy50/     3.12,   0.87,   1.09,    0.71,   3.64,
     &               1.83,   0.80,   0.54,    0.54,   3.75,
     &               2.95,   2.07,   0.89,    0.62/
******************************************************************************
*
      IF (iflag.eq.1) then
*
*      Initialisation: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (i) make subdirectory in o/p file
*
       Call hcdir('//PAWC',' ')
       call hmdir(xxxx,'S')
       Call hcdir('//HISTO',' ')
       call hmdir(xxxx,'S')
*
       nev=0.
       nsel=0.
*
*      transformation constants
*
       tmx=4./141.
       tnx=-5.404255319
*
*      do transformation form PS coordinates to physics coordinates
*
       do i=1,nx
          eyn(i)=10**(abs(eyn(i)-yn(i)/2.)/38.-20.1052)
          yn(i) =10**(yn(i)/38.-20.1052)
          erap(i)= abs(erap(i)-rap(i))*tmx
          rap(i) = rap(i)*tmx - tnx
       enddo
       rapbin(1)=rap(1)-erap(1)
       do i=1,nx
          rapbin(i+1) = rap(i)+erap(i)
       enddo
*
       smx=1./6.
       smy=1./9400.
       x0=410.
       y0=453.
*
       do i=1,mx
        xm(i)  =smx*(xm(i)-x0)
        xmy(i) =smy*(xmy(i)-y0)
        exmy(i)=smy*0.5*exmy(i)
       enddo
*
       xcmin=tmx*111.+tnx
       xcmax=tmx*322.+tnx
       wbin=abs(xcmax-xcmin)/float(nx)
       xcmin=xcmin-wbin/2.
       xcmax=xcmax+wbin/2.
       if (lp) then
        write(6,*) ' book= 10 xcmin= ',xcmin,' xcmax= ',xcmax,
     &  ' wbin= ',wbin
       endif
*
*      book your histograms  (data: ID<0)
*
C      call hbook1(-10,' dN/drapmax ',nx,xcmin,xcmax, 0.)
       call hbookb(-10,' dN/drapmax ',nx,rapbin, 0.)
       call hbook1( 10,' dN/drapmax ',28,xcmin,xcmax, 0.)
C      call hbookb( 10,' dN/drapmax ',nx,rapbin, 0.)
       call hbook1(110,' dN/drapmax ',50,-3.25,4.25,0.)
*
       xcmin=smx*(418.-x0)
       xcmax=smx*(643.-x0)
       wbin=abs(xcmax-xcmin)/float(mx)
       xcmin=xcmin-wbin/2.
       xcmax=xcmax+wbin/2.
       if (lp) then
        write(6,*) ' book= 11 xcmin= ',xcmin,' xcmax= ',xcmax,
     &  ' wbin = ',wbin
       endif
*
       call hbook1(-11,' Mx ',mx,xcmin,xcmax, 0.)
       call hbook1( 11,' Mx ',mx,xcmin,xcmax, 0.)
       call hbook1( 12,' Mremn     ',20, 0.,20.,0.)
       call hbook1( 13,' y         ',25, 0., 1.,0.)
       call hbook1( 14,' log(xpom) ',15,-4., 0.,0.)
       call hbook1( 15,' beta      ',20, 0., 1.,0.)
*
*********************************************************************
*
      Else if(iflag.eq.2) then
*      Filling: The following MUST always be done
*      (i) move to the correct sub-directory in PAWC
*
       call hcdir('//PAWC/'//xxxx,' ')
*
*      Event selection
*
       q2=real(HZDISKIN(1))
       x =real(HZDISKIN(2))
       y =real(HZDISKIN(3))
       if (lp) write(6,*) 'Hz'//xxxx,
     & ' x= ',x,' q2= ',q2,' y= ',y
*
*      get position of scattered electron, energy,Pt and polar angle
*
       iel=HZIDELEC(idum)
       if (iel.eq.-1) then
        write(6,*) 'Hz'//xxxx,' electron not found '
        return
       endif
*
       enel=real(PHEP(4,iel))
       Thel=real(HZPHMANG(PHEP(3,iel),
     &               sqrt(PHEP(1,iel)**2+PHEP(2,iel)**2)))
       if (lp) write(6,*) 'Hz'//xxxx,
     &                       ' enel= ',enel,' thel= ',thel*rd
*
*      cut on kinematics
*
       evcut= thel*rd.gt.155.
       evcut= q2.gt.7.5.and.q2.lt.70..and.evcut
       evcut= y.gt.0.03.and.y.lt.0.7 .and.evcut
       evcut= x.gt.0.00024.and.x.lt.0.0133.and.evcut
*
       if (lp) write(6,*) 'Hz'//xxxx,' evcut= ',evcut
*
       if (.not.evcut) return
*
*      calculate etamax (i.e. critical angle where sum of energy
*      in a cone with opening thcut exceeds 0.4 GeV)
*
       thmin=2.9777
       thmax=999.
       gapmax=-999.
       rcrit=0.
       neta=0
       thcut=thmin+0.1
       iturn=0
*
*      sum energy in cone between thmin and thcut
*      (if this energy exceed 0.4 than thcut is found
*
 10    iturn=iturn+1
       ener=0.
       do 20 ihep=1,nhep
*
*       skip first unstable particles and electron
*
        if (isthep(ihep).ne.1.or.ihep.eq.iel) goto 20
*
        th=real(HZPHMANG(PHEP(3,ihep),
     &              sqrt(PHEP(1,ihep)**2+PHEP(2,ihep)**2)))
*
        if (th.ge.1.e-4.and.abs(th-pi).gt.1.e-4 .and.iturn.eq.1) then
         neta=neta+1
         xeta(neta)=-log(tan(th/2.))
        endif
*
C        if (th*rd.gt.thmin .and. th*rd.lt.thcut) then
C          p = real(PHEP(4,ihep))
C          ener = p + ener
C         write(6,*) ' ener= ',ener,' p= ',p,' id= ',idhep(ihep)
C        endif
        if (th*rd.gt.thmin .and. th.lt.thmax .and.
     &       real(PHEP(4,ihep)).gt.0.4 ) then
         thmax=th
        endif
 20    continue
*
C      write(6,*) ' thcut= ',thcut,' ener= ',ener
C       if(ener.le.0.4) then
C        thcut=thcut+0.1
C        goto 10
C       endif
*
CC      if (thcut.lt.pi*rd .and. thcut.gt.1.e-4) then
CC       th=thcut/rd
CCC      rapmax= -log(tan(th/2.))
CC       rapmax= -log(tan(thmax/2.))
CC      else
CC       rapmax=999
CC       write(6,*)  'Hz'//xxxx,' thcut= ',thcut,' ???? '
CC      endif
*
      if (lp) then
       write(6,*) 'Hz'//xxxx,' rapmax= ',rapmax,' thcut= ',thcut,
     & ' thmax= ',thmax*rd
      endif
*

      if ((thmax.gt.1e-4) .and. (thmax.lt.(pi-1.e-4))) then
C     if ((thmax.gt.1e-4) .and. (thmax-pi).gt.1.e-4) then
         rapmax= -log(tan(thmax/2.))
         nev=nev+wtx
         call hfill(10, rapmax,0., wtx)
         call hfill(110,rapmax,0., wtx)
      endif
*
*     calculate invariant mass of remnant and Mx-system
*
       do i=1,4
        pmx(i)=0.
        prem(i)=0.
       enddo
*
* sort array xeta according to rapidity using M103 form CERNLIB
*
       call FLPSOR(xeta,neta)
*
* find largest gap
*
       do 15 i=1,neta-1
        rapi=xeta(i)
        rapj=xeta(i+1)
        if (abs(rapi-rapj).ge.gapmax) then
         gapmax=abs(rapi-rapj)
         rcrit=amin1(rapi,rapj)
        endif
 15    continue
*
        do 30 ihep=1,nhep
        if (isthep(ihep).ne.1.or.ihep.eq.iel) goto 30
        th=real(HZPHMANG(PHEP(3,ihep),
     &              sqrt(PHEP(1,ihep)**2+PHEP(2,ihep)**2)))
*
        if (abs(th).ge.1.e-4 .and. abs(th-pi).ge.1.e-4) then
         rapi= -log(tan(th/2.))
         if (rapi.lt.rcrit) then
          pmx(1)=pmx(1)+sngl(phep(1,ihep))
          pmx(2)=pmx(2)+sngl(phep(2,ihep))
          pmx(3)=pmx(3)+sngl(phep(3,ihep))
          pmx(4)=pmx(4)+sngl(phep(4,ihep))
         else
          prem(1)=prem(1)+sngl(phep(1,ihep))
          prem(2)=prem(2)+sngl(phep(2,ihep))
          prem(3)=prem(3)+sngl(phep(3,ihep))
          prem(4)=prem(4)+sngl(phep(4,ihep))
         endif
        endif
*
  30   continue
*
       xinvx=sqrt( pmx(4)**2-(pmx(3)**2+pmx(2)**2+pmx(1)**2))
       xinvr=sqrt(prem(4)**2-(prem(3)**2+prem(2)**2+prem(1)**2))
*
       if (q2+xinvx**2 .ne. 0.) then
        beta=q2/(q2+xinvx**2)
       else
        write(6,*) ' q2+xinv= 0 ! '
       endif
       if (q2.ne.0.) then
        xpom=(  (q2+xinvx**2)/q2)*x
       else
        write(6,*) ' q2= 0 ! '
       endif
*
       if (lp) then
        write(6,*) 'Hz'//xxxx,' gapmax= ',gapmax
        write(6,*) 'Hz'//xxxx,' rcrit= ',rcrit,' rapmx= ',rapmax
        write(6,*) 'Hz'//xxxx,' mx= ',xinvx,' Xr= ',xinvr
        write(6,*) 'Hz'//xxxx,' beta= ',beta,' xpom= ',xpom
       endif
*
*      Note that the H1 rap gap selection is approximatly
*      equivalent to a cut in Xpom
*
Ce      if (xpom.lt.0.05 .and. rapmax.lt.3.2) then
        if (xpom.lt.0.05) then
         nsel=nsel+wtx
         call hfill(11, xinvx       ,0., wtx)
         call hfill(12, xinvr       ,0., wtx)
         call hfill(13, y           ,0., wtx)
         call hfill(14, log10(xpom) ,0., wtx)
         call hfill(15, beta        ,0., wtx)
        endif
*
************************************************************************
*
      Else if(iflag.eq.3) then
*      Termination: The following MUST always be done
*      (i) Move to the correct PAW subdirectory
*
       call hcdir('//PAWC/'//xxxx,' ')
*
* Histo normalization
*
        write(6,*) ' nev= ',nev
        call HZHINRM(10,0,nev,1)
        call HZHINRM(110,0,nev,1)
*
        call HZHINRM(11,0,nsel,1)
        call HZHINRM(12,0,nsel,1)
        call HZHINRM(13,0,nsel,1)
        call HZHINRM(14,0,nsel,1)
        call HZHINRM(15,0,nsel,1)
*
*      Deal with data plots
*
       Call hpak (-10,yn)
       Call hpake(-10,eyn)
*
      Endif
*
      RETURN
      END
*CMZ :  1.01/11 09/12/97  16.44.12  by  Tancredi Carli
*CMZ :  1.01/07 10/10/97  19.46.50  by  Tancredi Carli
*CMZ :  1.01/05 04/09/96  17.44.20  by   Tancredi Carli
*CMZ :  1.00/02 12/03/96  19.18.00  by  Tancredi Carli
*CMZ :  0.00/09 16/02/96  17.15.47  by  Tancredi Carli
*CMZ :  0.00/08 15/02/96  12.30.10  by  Tancredi Carli
*CMZ :  0.00/06 02/02/96  19.54.21  by  Tancredi Carli
*-- Author :  Tancredi Carli   10/01/96
      subroutine HZ95072(IFLAG)
****************************************************************************
* Purpose: produced histograms for:
*          the charged particle multiplicity versus Q
*          the mean and the width of the ln(1/xp) distribution vs Q
*
* Event selection:
* Eel>14 ?
*
* Running:  HERA running 1993
* Reference:
* Arguments: iflag=1 initialisation
*            iflag=1 filling
*            iflag=3 termination
*
* written by: Tancredi Carli and Renate Mohr
*             (carli@mail.desy.de mohr@mail.desy.de)
****************************************************************************
      IMPLICIT NONE
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      Integer iquest
      COMMON/QUEST/IQUEST(100)
*
      Integer iflag,ihep,i,j,k,l
*     DESY Preprint number
      Character*5 xxxx
*
      Real VMIN,VMAX
      integer nxpbin
      parameter (nxpbin=11)
      Integer ierr,ibeam,igam
      Double precision pbeam(4),pgam(4),pbrt(4),plab(4),ph(5)
      Integer limup,limlo
      Real xp,xpmean
      Real par(3), step(3), pmin(3),pmax(3),sigpar(3),chi2
*
      Real pi,rd,ee,eb
      Logical evcut,lp
      Integer jcut,iel,idum,id,ibin,ivec
      Parameter (pi=3.1415927,rd=180./pi,ee=26.7)
      Integer nentry
      Real nev(nxpbin)
      Data lp/.false./,nentry/0/
      Real x,y,q2,w2,enel,efwd,th
      Real xmi,xma,ymi,yma
      Integer nx,ny,nwt,loc
      Character chtitl*80
*
      real sqrtq(nxpbin+1),q2aux(nxpbin+1)
      real peak(nxpbin),width(nxpbin),epeak(nxpbin),ewidth(nxpbin)
      real mult(nxpbin),emult(nxpbin)
      real q(nxpbin),qdata(nxpbin)
******************************************************************************
      Data xxxx/'95072'/
* Data points from plots
*
       data q2aux/12.,15.,20.,40.,60.,80.,100.,175.,250.
     &                   ,450.,1000.,8000./
       data qdata/3.59,4.11,5.25,6.93,8.28,0.,12.35,14.44,18.03,
     &                   24.90,29.28/
       do i=1,nxpbin+1
        sqrtq(i)=sqrt(q2aux(i))
       enddo
*
       data peak  /1.41,1.47,1.63,1.91,2.00,0.,2.23,2.12,2.72,2.70,2.62/
       data width /0.83,0.72,0.71,0.83,0.83,0.,1.00,1.28,1.24,0.80,0.88/
       data mult  /1.54,1.77,2.18,2.60,3.20,0.,4.05,4.73,4.75,5.43,6.27/
       data epeak /0.13,0.10,0.09,0.11,0.12,0.,0.39,0.34,0.29,0.13,0.28/
       data ewidth/0.14,0.07,0.04,0.10,0.12,0.,0.71,0.50,0.45,0.15,0.39/
       data emult /0.11,0.10,0.08,0.13,0.19,0.,0.58,0.35,0.32,0.39,1.20/
*
*******************************************************************************
*
******************************************************************************
      NENTRY=NENTRY+1
*
      IF (iflag.eq.1) then
*
*      Initialisation: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (i) make subdirectory in o/p file
*
       Call hcdir('//PAWC',' ')
       call hmdir(xxxx,'S')
       Call hcdir('//HISTO',' ')
       call hmdir(xxxx,'S')
*
       Do i=1,nxpbin
        nev(i)=0.
       enddo
*
*      book your histograms  (data: ID<0)
*                                     (VZERO, VMIN, VMAX see CERNLIB F121)
*      non-equidistant binning
       call hbookb(-10,'Q vs ln(1/Xp)peak ',nxpbin,sqrtq,0.)
       call hbookb(-20,'Q vs ln(1/Xp)width',nxpbin,sqrtq,0.)
       call hbookb(-30,'Q vs nch          ',nxpbin,sqrtq,0.)
       call hbook1(-101,'x-axis peak/width',nxpbin,0.,
     & real(nxpbin+1.),0.)
*      MC Histos
       call hbookb(10,'MC  Q vs ln(1/Xp)peak ',nxpbin,sqrtq,0.)
       call hbookb(20,'MC  Q vs ln(1/Xp)width',nxpbin,sqrtq,0.)
       call hbookb(30,'MC  Q vs nch          ',nxpbin,sqrtq,0.)
       call hbookb(31,'MC  Q vs nch aux      ',nxpbin,sqrtq,0.)
*      MC auxiliary histograms
       do ibin=1,nxpbin
        call hbook1(110+ibin,'MC  dN/dln(1/Xp)',50,0.,7.,0.)
       enddo
*
*********************************************************************
*
      Else if(iflag.eq.2) then
*      Filling: The following MUST always be done
*      (i) move to the correct sub-directory in PAWC
*
       call hcdir('//PAWC/'//xxxx,' ')
*
*      Event selection
*
       q2=real(HZDISKIN(1))
       x =real(HZDISKIN(2))
       y =real(HZDISKIN(3))
       w2=real(HZDISKIN(4))
*
       if (lp) write(6,*) 'Hz'//xxxx,
     & ' x= ',x,' q2 ',q2,' y= ',y,' w2= ',w2
*
*      get position of scattered electron, energy,Pt and polar angle
*
       iel=HZIDELEC(idum)
       if (iel.eq.-1) then
        write(6,*) 'Hz'//xxxx,' electron not found '
        return
       endif
       enel=real(PHEP(4,iel))
*
*      cut on forward energy
*
       efwd=0.
       Do 5 ihep=1,nhep
        if (isthep(ihep).ne.1.or.ihep.eq.iel) goto 5
        th=real(HZPHMANG(PHEP(3,ihep),
     &              sqrt(PHEP(1,ihep)**2+PHEP(2,ihep)**2)))*rd
        if(th.gt.4.4.and.th.lt.15.) then
         efwd=real(PHEP(4,ihep))+efwd
        endif
 5     continue
*
*      cut on kinematics
*
       evcut= enel.gt.14.
       evcut= w2.ge.3000..and. evcut
       evcut= y.lt.0.6.and. evcut
       evcut=efwd.gt.0.5.and.evcut
       if (lp) write(6,*) 'Hz'//xxxx,
     &                         ' efwd= ',efwd,' evcut= ',evcut
       if (.not.evcut) return
*
*      set up Breit frame boost needed later
*
       ierr=HZIBEAM(ibeam,idum)
       if (.not.(ierr.eq.1)) then
        write(6,*) 'HZ'//xxxx,' beams not found ! '
        return
       else
        Do i=1,4
         pbeam(i)=PHEP(i,IBEAM)
        enddo
       endif
*
       eb=real(PHEP(4,idum))
       if (abs(abs(eb)-ee).gt.0.2) then
        if (nentry.lt.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,'  ! '
        elseif (nentry.eq.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &   ' ...last message ! '
        endif
C        return
       endif
*
       ierr=HZIPGAM(ph)
       if (ierr.eq.-1) then
        write(6,*) 'HZ'//xxxx,' boson vector not found ! '
C        call VZERO(ph,5)
        Do i=1,5
         ph(i)=0.
        enddo
       else
        Do i=1,4
         pgam(i)=ph(i)
        enddo
       endif
*
       Call hzbrtini(pbeam,pgam,ierr)
       if (ierr.eq.1) then
        write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
        return
       endif
*
*      get bin number
*
       ibin=-1
       Do i=1,nxpbin
        if (lp) write(6,*) i,q2aux(i),' < ',q2,' < ',q2aux(i+1)
        if (q2.ge.q2aux(i).and.q2.lt.q2aux(i+1)) ibin=i
       enddo
       if (ibin.le.0) then
        if (lp) write(6,*) 'hz',xxxx,' q2 in no bin= ',q2
        return
       endif
*
       do 30 ihep = 1, nhep
        If(isthep(ihep).eq.1.and.ihchrg(ihep).ne.0
     +     .and.ihep.ne.iel) then
C        idpart=abs(idhep(jmohep(1,ihep)))
C        If(idpart.eq.310.or.idpart.eq.3122) goto 30
         do ivec=1,4
          plab(ivec) = phep(ivec,ihep)
         enddo
         Call hzbrt(plab,pbrt,ierr)
         if(real(pbrt(3)).lt.0.) then
          xp = 2.*real(sqrt(pbrt(1)**2+pbrt(2)**2+pbrt(3)**2))
     +        /sqrt(q2)
          call hfill(110+ibin,log(1./xp),0.,wtx)
          call hfill(30   ,sqrt(q2),0.,wtx)
         endif
        Endif
 30     continue
*
        call hfill(31   ,sqrt(q2),0.,wtx)
        nev(ibin)=nev(ibin)+wtx
*
************************************************************************
*
      Else if(iflag.eq.3) then
*      Termination: The following MUST always be done
*      (i) Move to the correct PAW subdirectory
*
       call hcdir('//PAWC/'//xxxx,' ')
*
* Deal with data plots
*
       Call hpak (-10,peak)
       Call hpak (-20,width)
       Call hpak (-30,mult)
       Call hpake(-10,epeak)
       Call hpake(-20,ewidth)
       Call hpake(-30,emult)
       call hpak (-101,qdata)
*
*      normalise and fit data histograms
*
       Call hopera(30,'/e',31,30,1.,1.)

*
       do ibin=1,nxpbin
        id=110+ibin
        xpmean = hstati(id,1,' ',1)
        Call hgive(id,chtitl,nx,xmi,xma,ny,ymi,yma,nwt,loc)
        call hxi(id,xpmean+1.2,limup)
        call hxi(id,xpmean-1.2,limlo)
        iquest(11) = limlo
        iquest(12) = limup
        par(1)= hmax(id)
        par(2)= xpmean
        par(3)= hstati(id,2,' ',1)
C       write(6,*) ' limup= ',limup,' limlo= ',limlo
C       write(6,*) ' par= ',par
        Call hfithn(id,'G','NQR',3,par,step,pmin,pmax,sigpar,chi2)
*
        write(6,'(a,a,a,i4,3(a,f9.3))') 'Hz',xxxx,
     &  ' id= ',id,' mean= ',par(2),' sig= ',par(3),' chi2= ',chi2
*
        call hfill(10,sqrtq(ibin)+0.1,0.,par(2)*wtx)
        call hfill(20,sqrtq(ibin)+0.1,0.,par(3)*wtx)
        call hdelet(id)
       enddo
*
       call hdelet(31)
*
       call HZchisq(-10,20)
       call HZchisq(-20,20)
       call HZchisq(-30,30)
*
      Endif
*
      RETURN
      END
*CMZ :  1.01/11 09/12/97  16.44.12  by  Tancredi Carli
*CMZ :  1.01/07 10/10/97  19.46.50  by  Tancredi Carli
*CMZ :  1.01/05 04/09/96  17.44.20  by   Tancredi Carli
*CMZ :  0.00/09 16/02/96  17.15.47  by  Tancredi Carli
*CMZ :  0.00/08 14/02/96  13.44.46  by  Tancredi Carli
*CMZ :  0.00/03 09/01/96  15.51.20  by  HZtool
*CMZ :  0.00/01 05/01/96  14.09.27  by  HZtool
*-- Author :
      Subroutine hz95084(iflag)
************************************************************************
* Subroutine hz95084                                                   *
* ==================                                                   *
*                                                                      *
* Author: Nick Brook (brook@v2.ph.gla.ac.uk)                           *
*                                                                      *
* This routine plots the differential multiplcities of K0 and Lambda   *
* versus both transverse momentum and pseudorapidity in a restricted   *
* pseudorapidity and pt range.                                         *
*                                                                      *
* Event selection:                                                     *
* 10 < Q2 < 640 GeV^2                                                  *
* .0003 < x < 0.01                                                     *
* y > 0.04                                                             *
*                                                                      *
* K0 selection                                                         *
* -1.3 < eta < 1.3                                                     *
* 0.5 < pt < 4.0 GeV                                                   *
*                                                                      *
* Lambda selection                                                     *
* -1.3 < eta < 1.3                                                     *
* 0.5 < pt < 3.5 GeV                                                   *
*                                                                      *
* Reference: Z Phys C68(1995) 29.                                      *
*            DESY 95-084                                               *
*                                                                      *
* Modified: add data histograms with statistical errors only           *
*           add check on electron beam energy
************************************************************************
*
* HERA tuning defined commons
*
      Implicit Double Precision(A-H,O-Z)
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEND.
*
* Set up local variables
*
      Real nacc
      Integer ierr,ibeam,idum,nentry
      Character xxxx*5
      Data xxxx/'95084'/,nentry/0/
      Real eb,ee
      Parameter (ee=26.7)
      Character*80 chtitl
      Dimension q2cut(2), xcut(2), ycut(2), etacut(2)
      Real ptk(7), ptke(7), ptks(7), etak(8), etake(8), etaks(8)
      Real ptl(4), ptle(4), ptls(4), etal(4), etale(4), etals(4)
      Real ptkerr(7), etakerr(8), ptlerr(4), etalerr(4)
      Real xmi, xma, ymi, yma
*
* Data points from plots
*
      Data ptk /.1976,.0547,.0201,.0088,.0040,.0018,.0011/
      Data ptks/.0211,.0074,.0031,.0016,.0009,.0006,.0009/
      Data ptke/.0159,.005,.0024,.0014,.0008,.0005,.0004/
      Data etak/.077,.095,.118,.109,.118,.138,.178,.118/
      Data etaks/.018,.0147,.0174,.0162,.0174,.0201,.0364,.0262/
      Data etake/.012,.012,.015,.013,.013,.017,.022,.018/
      Data ptl/.0210,.0033,.001,.0003/
      Data ptls/.0051,.0008,.0004,.0002/
      DATA ptle/.0045,.0008,.0004,.0002/
      Data etal/.0088,.0159,.0143,.0157/
      Data etals/.0032,.0054,.0038,.0046/
      DATA etale/.0031,.0052,.0036,.0044/
*
      If(iflag.eq.1) then
*
* Initialisation: The following MUST always be done
* (i) make subdirectory in PAWC
*      - use the name as the xxxxxx in HZxxxxxx subroutine
* (i) make subdirectory in o/p file
*
        Nacc= 0.
        Call hcdir('//PAWC',' ')
        call hmdir('95084','S')
        Call hcdir('//HISTO',' ')
        call hmdir('95084','S')
*
* book your histograms
*
        call hbook1(11,'1/N dn/d-pt(MC)',7,.5,4.0,0.)
        call hbook1(101,'1/N dn/d-pt(MC)',4,.5,3.5,0.)
        call hbook1(10,'1/N dn/d-eta(MC)',8,-1.3,1.3,0.)
        call hbook1(100,'1/N dn/d-eta(MC)',4,-1.3,1.3,0.)
*
* set your plot/paper specific cuts
*
        q2cut(1) = 10.
        q2cut(2) = 640.
        xcut(1) = 0.0003
        xcut(2) = 0.01
        ycut(1) = 0.04
        ycut(2) = 1.
        ptupk = 4.
        ptupl = 3.5
        ptlow = 0.5
        etacut(1) = -1.3
        etacut(2) =  1.3
*
      Else if(iflag.eq.2) then
* Filling: The following MUST always be done
* (i) move to the correct sub-directory in PAWC
*
       call hcdir('//PAWC/95084',' ')
*
* Check electron beam energy
*
        nentry=nentry+1
        ierr=HZIBEAM(ibeam,idum)
        if (.not.(ierr.eq.1)) then
         write(6,*) 'HZ'//xxxx,' beams not found ! '
         return
        endif
*
        eb=real(PHEP(4,idum))
        if (abs(abs(eb)-ee).gt.0.2) then
         if (nentry.lt.10) then
          write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,'  ! '
         elseif (nentry.eq.10) then
          write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &   ' ...last message ! '
         endif
C         return
        endif
*
        q2  = hzdiskin(1)
        xbj = hzdiskin(2)
        ybj = hzdiskin(3)
        If(q2.gt.q2cut(1).and.q2.lt.q2cut(2).and.
     +     xbj.gt.xcut(1).and.xbj.lt.xcut(2).and.
     1     ybj.gt.ycut(1).and.ybj.lt.ycut(2)) then
          Nacc = Nacc + wtx
*
* Fill your histograms
*
          do 30 ihep = 1, nhep
            ioff =0
            if(abs(idhep(ihep)).eq.310.or.abs(idhep(ihep)).eq.130) then
              ioff = 1
              ptcut = ptupk
            else if(abs(idhep(ihep)).eq.3122) then
              ioff = 10
              ptcut = ptupl
            else
              goto 30
            endif
            pt = sqrt(phep(1,ihep)**2+phep(2,ihep)**2)
            the = hzphmang(phep(3,ihep),pt)
            rap = -1.*log(tan(the/2.))
            if(rap.gt.etacut(1).and.rap.lt.etacut(2).and.
     +         pt.gt.ptlow.and.pt.lt.ptcut) Then
              call hfill(ioff*10,real(rap),0.,wtx)
              call hfill((ioff*10)+1,real(pt),0.,wtx*0.5/real(pt))
            endif
 30       continue
        endif
*
      Else if(iflag.eq.3) then
* Termination: The following MUST always be done
* (i) Move to the correct PAW subdirectory
*
        call hcdir('//PAWC/95084',' ')
*
* Histo manipulation
*
        Call hgive(10,chtitl,nx,xmi,xma,ny,ymi,yma,nwt,loc)
        Call hopera(10,'+e',10,10,
     +            1./real(nacc)*real(nx)/(xma-xmi),0.)
        Call hgive(100,chtitl,nx,xmi,xma,ny,ymi,yma,nwt,loc)
        Call hopera(100,'+e',100,100,
     +            1./real(nacc)*real(nx)/(xma-xmi),0.)
        Call hgive(11,chtitl,nx,xmi,xma,ny,ymi,yma,nwt,loc)
        Call hopera(11,'+e',11,11,
     +            1./real(nacc)*real(nx)/(xma-xmi),0.)
        Call hgive(101,chtitl,nx,xmi,xma,ny,ymi,yma,nwt,loc)
        Call hopera(101,'+e',101,101,
     +            1./real(nacc)*real(nx)/(xma-xmi),0.)
*
C*TC>
        call hzhinfo(10,nacc)
        call hzhinfo(100,nacc)
        call hzhinfo(11,nacc)
        call hzhinfo(101,nacc)
C*TC<
*
* Deal with data plots
*
        call hbook1(-11,'1/N dn/d-pt(data)',7,.5,4.0,0.)
        call hbook1(-101,'1/N dn/d-pt(data)',4,.5,3.5,0.)
        call hbook1(-10,'1/N dn/d-eta(data)',8,-1.3,1.3,0.)
        call hbook1(-100,'1/N dn/d-eta(data)',4,-1.3,1.3,0.)
C*TC>
        call hbook1(-1011,'1/N dn/d-pt(data)',7,.5,4.0,0.)
        call hbook1(-1101,'1/N dn/d-pt(data)',4,.5,3.5,0.)
        call hbook1(-1010,'1/N dn/d-eta(data)',8,-1.3,1.3,0.)
        call hbook1(-1100,'1/N dn/d-eta(data)',4,-1.3,1.3,0.)
C*TC<
        Do ivec = 1, 7
          ptkerr(ivec) = sqrt(ptke(ivec)**2 + ptks(ivec)**2)
        Enddo
        Do ivec = 1, 8
          etakerr(ivec) = sqrt(etake(ivec)**2 + etaks(ivec)**2)
        Enddo
        Do ivec = 1, 4
          ptlerr(ivec) = sqrt(ptle(ivec)**2 + ptls(ivec)**2)
          etalerr(ivec) = sqrt(etale(ivec)**2 + etals(ivec)**2)
        Enddo
        Call hpak(-11,ptk)
        Call hpake(-11,ptkerr)
        Call hpak(-10,etak)
        Call hpake(-10,etakerr)
        Call hpak(-101,ptl)
        Call hpake(-101,ptlerr)
        Call hpak(-100,etal)
        Call hpake(-100,etalerr)
C*TC>
        Call hpak (-1011,ptk)
        Call hpake(-1011,ptke)
        Call hpak (-1010,etak)
        Call hpake(-1010,etake)
        Call hpak (-1101,ptl)
        Call hpake(-1101,ptle)
        Call hpak (-1100,etal)
        Call hpake(-1100,etale)
*
*       calculate chi2
*
        Call hzchisq(-10  ,10)
        Call hzchisq(-11  ,11)
        Call hzchisq(-100 ,100)
        Call hzchisq(-101 ,101)
        Call hzchisq(-1010,10)
        Call hzchisq(-1011,11)
        Call hzchisq(-1100,100)
        Call hzchisq(-1101,101)

C*TC<
        Write(6,*) ' X-section is',xsec
      Endif
*
      Return
      End
*CMZ :  2.00/03 10/05/2000  19.37.50  by  Tancredi Carli
*CMZ :  1.01/11 09/12/97  16.44.12  by  Tancredi Carli
*CMZ :  1.01/07 10/10/97  19.46.50  by  Tancredi Carli
*CMZ :  1.01/05 06/09/96  18.38.41  by   Tancredi Carli
*CMZ :  1.01/03 15/05/96  19.46.03  by  Tancredi Carli
*CMZ :  1.01/02 08/04/96  15.46.47  by  Tancredi Carli
*CMZ :  1.00/02 12/03/96  18.45.28  by  Tancredi Carli
*CMZ :  0.00/09 16/02/96  17.15.48  by  Tancredi Carli
*CMZ :  0.00/08 15/02/96  12.24.24  by  Tancredi Carli
*CMZ :  0.00/06 05/02/96  11.29.20  by  Tancredi Carli
*CMZ :  0.00/05 24/01/96  13.46.24  by  Renate Mohr
*-- Author :  Tancredi Carli   10/01/96
      subroutine HZ95108(IFLAG)
****************************************************************************
* Purpose: produce histograms for:
*           o) energy flows in cms as a fct. of x,Q**2
*           o) mean Et in cms central rapidity bin vs. x,Q2
*
* Event selection:
* Eel>12 GeV, 173.0>Thel>157.0, w2>4400 GeV**2 and cut on forward energy
*
* Running: Ee=26.7, Ep=820, no polarization, HERA running 1993
* Reference: Phys. Lett. B356 (1995) 118, DESY 95-108
* Arguments: iflag=1 initialisation
*            iflag=1 filling
*            iflag=3 termination
*
* written by: Michael Kuhlen (kuhlen@desy.de)
* Modified: add hzchisq
*           add systematic error to e-flows added (overall 10% guess!!!)
*           avoide division by zero in normalisation, if nev(ibin)=0
*                                 T. Carli May 2000 (thanks B. Levtcheko)
****************************************************************************
      IMPLICIT NONE
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      Integer iflag,ihep,i,j,k,l
*     DESY Preprint number
      Character*5 xxxx
      Data xxxx/'95108'/
      character*30 string
*
      Real pi,dpi,rd,ee,eb,dphi
      Logical evcut,lp
      Integer jcut,ncut,iel,idum,id
      Parameter (ncut=4,pi=3.1415927,dpi=2.*pi,rd=180./pi,ee=26.7)
      Integer nentry,nevnt(2)
      Real nev(9)
      Data nev/9*0./,lp/.false./,nentry/0/
      real etmean(9),xmean(9),q2mean(9), zeroes(9), etcent
      data etmean,xmean,q2mean,zeroes /9*0.,9*0.,9*0.,9*0/
      Real x,y,q2,w2,enel,ptel,thel,efwd,th,rap,pt,et,p,costh
      Real xmi,xma,ymi,yma
      Integer nx,ny,nwt,loc,ibin
      Character chtitl*80
*
      Integer ierr,ibeam,igam
      Double precision pbeam(4),pgam(4),pcm(4),ph(5),phc(4)
*
*
*********************************************************************
*
*                      data points from H1
*
*********************************************************************
      Real xmin,xmax
      Integer nb,nbin
      Parameter (nb=24,xmin=-6.,xmax=6.,nbin=9)
      Real et1(nb),et2(nb),et3(nb),et4(nb),et5(nb)
      Real et6(nb),et7(nb),et8(nb),et9(nb)
      Real eet1(nb),eet2(nb),eet3(nb),eet4(nb),eet5(nb)
      Real eet6(nb),eet7(nb),eet8(nb),eet9(nb)
      Real set1(nb),set2(nb),set3(nb),set4(nb),set5(nb)
      Real set6(nb),set7(nb),set8(nb),set9(nb)
*
*     energy flow data in the 9 bins
*     note: systematic errors are not included
*
      Data  et1/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &          1.746,1.993,2.010,2.221,1.986,2.036,2.209,2.199,1.922,
     &          2.022,1.893,1.021,0.515,0.150,0.000/
      Data eet1/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &          0.116,0.113,0.115,0.126,0.119,0.142,0.178,0.170,0.129,
     &          0.144,0.144,0.088,0.060,0.026,0.000/
      Data  et2/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &          1.686,1.833,2.108,2.073,1.965,1.965,2.242,1.978,2.016,
     &          1.772,1.958,0.980,0.306,0.124,0.026/
      Data eet2/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &          0.164,0.083,0.094,0.094,0.093,0.098,0.131,0.121,0.110,
     &          0.094,0.115,0.069,0.029,0.017,0.005/
      Data  et3/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &          1.696,1.841,2.043,2.278,2.073,1.983,2.181,2.282,2.251,
     &          2.158,1.687,0.951,0.392,0.112,0.032/
      Data eet3/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &          0.112,0.079,0.087,0.104,0.095,0.098,0.116,0.142,0.125,
     &          0.113,0.098,0.064,0.032,0.014,0.006/
      Data  et4/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &          0.000,1.735,1.866,2.035,1.977,2.106,1.974,2.099,2.018,
     &          1.983,1.435,0.668,0.276,0.088,0.000/
      Data eet4/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &          0.000,0.087,0.093,0.098,0.097,0.121,0.122,0.133,0.118,
     &          0.115,0.092,0.049,0.029,0.013,0.000/
      Data  et5/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &          0.000,1.667,1.880,1.877,1.993,1.915,2.074,2.011,2.045,
     &          1.742,1.058,0.454,0.156,0.038,0.000/
      Data eet5/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &          0.000,0.124,0.091,0.085,0.096,0.108,0.115,0.110,0.111,
     &          0.099,0.065,0.037,0.017,0.007,0.000/
      Data  et6/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &          0.000,0.000,1.516,1.805,2.099,1.926,1.860,2.115,1.755,
     &          1.499,0.843,0.271,0.079,0.000,0.000/
      Data eet6/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &          0.000,0.000,0.095,0.104,0.126,0.122,0.117,0.139,0.110,
     &          0.122,0.074,0.027,0.011,0.000,0.000/
      Data  et7/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &          1.764,1.870,2.024,2.212,2.062,2.188,2.319,2.392,2.309,
     &          2.367,1.655,0.797,0.325,0.129,0.000/
      Data eet7/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &          0.142,0.088,0.095,0.106,0.102,0.126,0.145,0.149,0.137,
     &          0.137,0.099,0.056,0.029,0.017,0.000/
      Data  et8/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &          0.000,1.877,1.926,2.037,2.106,2.224,2.110,2.280,2.156,
     &          1.998,1.175,0.532,0.152,0.046,0.000/
      Data eet8/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &          0.000,0.140,0.101,0.105,0.115,0.129,0.128,0.151,0.144,
     &          0.124,0.075,0.043,0.017,0.008,0.000/
      Data  et9/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &          0.000,0.000,1.485,1.965,2.183,2.169,2.091,2.445,2.233,
     &          1.405,0.709,0.205,0.082,0.000,0.000/
      Data eet9/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &          0.000,0.000,0.107,0.133,0.156,0.146,0.154,0.181,0.176,
     &          0.105,0.061,0.023,0.015,0.000,0.000/
*
      Data set1/24*0.1/
      Data set2/24*0.1/
      Data set3/24*0.1/
      Data set4/24*0.1/
      Data set5/24*0.1/
      Data set6/24*0.1/
      Data set7/24*0.1/
      Data set8/24*0.1/
      Data set9/24*0.1/
*
*     Data total Et versus x
*     note: full systematic errors included, except a 9% overall scale error
*
      Real etx(nbin),eetx(nbin),xx(nbin),qq(nbin)
      Data  etx/2.12,2.09,2.17,1.95,1.87,1.60,2.12,1.99,1.75/
      Data eetx/0.15,0.12,0.12,0.12,0.11,0.12,0.12,0.13,0.17/
      Data   xx/0.16e-3,0.3e-3,0.37e-3,0.63e-3,1.10e-3,2.30e-3,
     &          0.93e-3,2.10e-3,4.90e-3/
      Data   qq/6.8,8.6,13.1,14.2,14.0,14.5,28.8,30.9,32.6/
*
*********************************************************************
*
*                      Initialization
*
*********************************************************************
      NENTRY=NENTRY+1
*
      IF (iflag.eq.1) then
*
*
*      Initialisation: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (i) make subdirectory in o/p file
*
       Call hcdir('//PAWC',' ')
       call hmdir(xxxx,'S')
       Call hcdir('//HISTO',' ')
       call hmdir(xxxx,'S')
*                                             book data et-flow histos
       Do i=1,nbin
        write(string,'(A,I2)') ' dEt/d[c] CMS bin= ',i
        call hbook1(-10-i,string,nb,xmin,xmax, 0.)
        call hbook1(   -i,string,nb,xmin,xmax, 0.)
*
        call hbook1(i,string,nb,xmin,xmax, 0.)
        write(string,'(A,I2)') ' stat dEt/d[c] CMS bin= ',i
        call hbook1(10+i,string,nb,xmin,xmax, 0.)
*
       enddo
*                                             book data mean et, x, q2
       call hbook1(-21,' <Et> ',9,1.,10., 0.)
       call hbook1(-22,' <x>  ',9,1.,10., 0.)
       call hbook1(-23,' <q2> ',9,1.,10., 0.)
*
*
*      pack data into histograms
*      pack data et/deta in the 9 bins into histograms
*
       Call hpak (-11,et1)
       Call hpake(-11,eet1)
       Call hpak (-12,et2)
       Call hpake(-12,eet2)
       Call hpak (-13,et3)
       Call hpake(-13,eet3)
       Call hpak (-14,et4)
       Call hpake(-14,eet4)
       Call hpak (-15,et5)
       Call hpake(-15,eet5)
       Call hpak (-16,et6)
       Call hpake(-16,eet6)
       Call hpak (-17,et7)
       Call hpake(-17,eet7)
       Call hpak (-18,et8)
       Call hpake(-18,eet8)
       Call hpak (-19,et9)
       Call hpake(-19,eet9)
*
*      add sytematic and statistical error
*
       Do i=1,nb

        set1(i)=et1(i)*set1(i)
        eet1(i)=sqrt(eet1(i)**2+set1(i)**2)
        set2(i)=et2(i)*set2(i)
        eet2(i)=sqrt(eet2(i)**2+set2(i)**2)
        set3(i)=et3(i)*set3(i)
        eet3(i)=sqrt(eet3(i)**2+set3(i)**2)
        set4(i)=et4(i)*set4(i)
        eet4(i)=sqrt(eet4(i)**2+set4(i)**2)
        set5(i)=et5(i)*set5(i)
        eet5(i)=sqrt(eet5(i)**2+set5(i)**2)
        set6(i)=et6(i)*set6(i)
        eet6(i)=sqrt(eet6(i)**2+set6(i)**2)
        set7(i)=et7(i)*set7(i)
        eet7(i)=sqrt(eet7(i)**2+set7(i)**2)
        set8(i)=et8(i)*set8(i)
        eet8(i)=sqrt(eet8(i)**2+set8(i)**2)
        set9(i)=et9(i)*set9(i)
        eet9(i)=sqrt(eet9(i)**2+set9(i)**2)
       enddo
*
       Call hpak (-1,et1)
       Call hpake(-1,eet1)
       Call hpak (-2,et2)
       Call hpake(-2,eet2)
       Call hpak (-3,et3)
       Call hpake(-3,eet3)
       Call hpak (-4,et4)
       Call hpake(-4,eet4)
       Call hpak (-5,et5)
       Call hpake(-5,eet5)
       Call hpak (-6,et6)
       Call hpake(-6,eet6)
       Call hpak (-7,et7)
       Call hpake(-7,eet7)
       Call hpak (-8,et8)
       Call hpake(-8,eet8)
       Call hpak (-9,et9)
       Call hpake(-9,eet9)
*                                       pack total Et against x into histos
       Call hpak (-22,xx)
       Call hpak (-21,etx)
       Call hpake(-21,eetx)
*
*                                       book your histograms  (data: ID<0)
*                                       Et flows in the 9 bins
C       call hbook1( 11,'dEt/deta CMS bin1',24,-6.,6.,0.)
C       call hbook1( 12,'dEt/deta CMS bin2',24,-6.,6.,0.)
C       call hbook1( 13,'dEt/deta CMS bin3',24,-6.,6.,0.)
C       call hbook1( 14,'dEt/deta CMS bin4',24,-6.,6.,0.)
C       call hbook1( 15,'dEt/deta CMS bin5',24,-6.,6.,0.)
C       call hbook1( 16,'dEt/deta CMS bin6',24,-6.,6.,0.)
C       call hbook1( 17,'dEt/deta CMS bin7',24,-6.,6.,0.)
C       call hbook1( 18,'dEt/deta CMS bin8',24,-6.,6.,0.)
C       call hbook1( 19,'dEt/deta CMS bin9',24,-6.,6.,0.)

*                                       <ET> in central rapidity bin

       call hbook1( 21,'<Et> vs kin. bin',9,1.,10.,0.)
       call hbook1( 22,'<x>  vs kin. bin',9,1.,10.,0.)
       call hbook1( 23,'<Q2> vs kin. bin',9,1.,10.,0.)
       call hbook1( 24,'# events vs kin. bin',9,1.,10.,0.)
*                                       correct errors
       call hbarx(21)
       call hbarx(22)
       call hbarx(23)
       call hbarx(24)
*
*********************************************************************
*
*                      Event Processing
*
*********************************************************************

      Else if(iflag.eq.2) then

*      Filling: The following MUST always be done
*      (i) move to the correct sub-directory in PAWC
*
       call hcdir('//PAWC/'//xxxx,' ')
*
*                                             Event selection
*
       q2=real(HZDISKIN(1))
       x =real(HZDISKIN(2))
       y =real(HZDISKIN(3))
       w2=real(HZDISKIN(4))
*
       if (lp) write(6,*) 'Hz'//xxxx,
     & ' x= ',x,' q2 ',q2,' y= ',y,' w2= ',w2
*
*                                             get electron variables
*
       iel=HZIDELEC(idum)
       if (iel.eq.-1) then
        write(6,*) 'Hz'//xxxx,' electron not found '
        goto 9990
       endif
       enel=real(PHEP(4,iel))
       thel=real(HZPHMANG(PHEP(3,iel),
     &               sqrt(PHEP(1,iel)**2+PHEP(2,iel)**2)))*rd
       if (lp) write(6,*) 'Hz'//xxxx,
     & ' enel= ',enel,' thel= ',thel
*
*                                             kinematic selection
*
       evcut= enel.gt.12.
       evcut= thel.gt.157. .and. thel.lt.173.0 .and. evcut
       evcut= w2.ge.4400..and. evcut
       if(.not.evcut) goto 9990
*
*                                             cut on forward energy
*
       efwd=0.
       Do ihep=1,nhep
        if (isthep(ihep).eq.1.and.ihep.ne.iel) then
         th=real(HZPHMANG(PHEP(3,ihep),
     &              sqrt(PHEP(1,ihep)**2+PHEP(2,ihep)**2)))*rd
         if(th.gt.4.4.and.th.lt.15.) then
          efwd=real(PHEP(4,ihep))+efwd
         endif
        endif
       enddo
       if (lp) write(6,*) 'Hz'//xxxx,
     & ' efwd= ',efwd,' evcut= ',evcut
       if(efwd.lt.0.5) goto 9990
*
*                                             find the kinematic bin number
       ibin = 0
       if(    q2.gt. 5..and.q2.le.10.) then
         if(x.gt.0.0001.and.x.le.0.0002) ibin=1
         if(x.gt.0.0002.and.x.le.0.0005.and.q2.gt.6.) ibin=2
       elseif(q2.gt.10..and.q2.le.20.) then
         if(x.gt.0.0002.and.x.le.0.0005) ibin=3
         if(x.gt.0.0005.and.x.le.0.0008) ibin=4
         if(x.gt.0.0008.and.x.le.0.0015) ibin=5
         if(x.gt.0.0015.and.x.le.0.0040) ibin=6
       elseif(q2.gt.20..and.q2.le.50.) then
         if(x.gt.0.0005.and.x.le.0.0014) ibin=7
         if(x.gt.0.0014.and.x.le.0.0030) ibin=8
         if(x.gt.0.0030.and.x.le.0.0100) ibin=9
       endif
*
*                                             events in 9 bins only
       if( ibin.eq.0) goto 9990
*                                             set up CMS boost needed later
*
       ierr=HZIBEAM(ibeam,idum)
       if (.not.(ierr.eq.1)) then
        write(6,*) 'HZ'//xxxx,' beams not found ! '
        goto 9990
       else
        Do i=1,4
         pbeam(i)=PHEP(i,IBEAM)
        enddo
       endif
*
       eb=real(PHEP(4,idum))
       if (abs(abs(eb)-ee).gt.0.2) then
        if (nentry.lt.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,'  ! '
        elseif (nentry.eq.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &   ' ...last message ! '
        endif
C        goto 9990
       endif
*
       ierr=HZIPGAM(ph)
       if (ierr.eq.-1) then
        write(6,*) 'HZ'//xxxx,' boson vector not found ! '
C        call VZERO(ph,5)
        Do i=1,5
         ph(i)=0.
        enddo
       else
        Do i=1,4
         pgam(i)=ph(i)
        enddo
       endif
*
       call HZHCMINI(pbeam,pgam,ierr)
       if (ierr.eq.1) then
        write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
        goto 9990
       endif
*
*                                             loop over objects
*
*
*                                             et in central rapidity bin
       etcent = 0.
       do 2000 ihep=1,nhep
*                                             skip unstable particles and el.
       if (isthep(ihep).ne.1.or.ihep.eq.iel) goto 2000
*
*                                             transform in CMS
*
           Do i=1,4
            Phc(i)=PHEP(i,ihep)
           enddo
           call HZHCM(phc,pcm,ierr)
           if (ierr.eq.1) then
            write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
            goto 9990
           endif

*                                             get particle momenta

           p      = real(sqrt(pcm(1)**2+pcm(2)**2+pcm(3)**2 ))
           pt     = real(sqrt( pcm(1)**2+pcm(2)**2 ))
           if (p.eq.0.) then
            write(6,*) xxxx,' p = ',p
            goto 2000
           else
            et     = real(pcm(4)) * pt / p
            th     = (acos(real(pcm(3))/p))
            if (abs(     th*rd).lt.1.e-4 .or.
     &          abs(180.-th*rd).lt.1.e-4 ) then
C             write(6,*) xxxx,' th = ',th
             goto 2000
            else
             rap    = -log(tan( th/2. ))
*                                            check on rap=nan (e.g. pt=0)
              if (rap.ne.rap) then
               write(6,*) xxxx,'Warning:  rap = ',rap,' th= ',th*rd,
     &         ' particle skipped ! '
               goto 2000
              endif
            endif
           endif
*
           if (lp) write(6,*) 'Hz'//xxxx,
     &     'lab: et,pt,rap,th ',et,pt,rap,th*rd

*                                             fill histos
           call hf1(10+ibin, rap, et*wtx )
           call hf1(   ibin, rap, et*wtx )
*                                             accumulate Et in central rap.
           if(rap.gt.-0.5.and.rap.lt.0.5) then
              etmean(ibin) = etmean(ibin) + et
              etcent = etcent + et
           endif
*                                             end loop over objects
 2000  continue
*
*                                             count the accepted events
       nev(ibin)   = nev(ibin)+wtx
*                                             average x
       xmean(ibin) = xmean(ibin) + x
*                                             average Q2
       q2mean(ibin)= q2mean(ibin) + q2
       call hf1(21,real(ibin),etcent*wtx)
       call hf1(22,real(ibin),x*wtx)
       call hf1(23,real(ibin),q2*wtx)
*                                             norm. histo for event counting
       call hf1(24,real(ibin),wtx)
*                                              end of event processing
 9990  continue


*********************************************************************
*
*                      Termination
*
*********************************************************************

      Else if(iflag.eq.3) then

*      Termination: The following MUST always be done
*      (i) Move to the correct PAW subdirectory
*
       call hcdir('//PAWC/'//xxxx,' ')
*                                              normalize Et flow histos
       do ibin=1,9
        id=10+ibin
        Call hgive(id,chtitl,nx,xmi,xma,ny,ymi,yma,nwt,loc)
        if (nev(ibin).ne.0) then
        Call hopera(id,'+E',id,id,
     +          1./real(nev(ibin))*real(nx)/(xma-xmi),0.)
        else
         write(6,*) id,' norm nev,nx,xma,xmi ',nev(ibin),nx,xma,xmi
        endif
C
C*TC>
        call hzhinfo(id,nev(ibin))
C*TC<
        call hzchisq(-id,id)
       enddo
       do ibin=1,9
        id=ibin
        Call hgive(id,chtitl,nx,xmi,xma,ny,ymi,yma,nwt,loc)
        if (nev(ibin).ne.0) then
        Call hopera(id,'+E',id,id,
     +          1./real(nev(ibin))*real(nx)/(xma-xmi),0.)
        else
         write(6,*) id,' norm nev,nx,xma,xmi ',nev(ibin),nx,xma,xmi
        endif
C        write(6,*) id,' norm nev,nx,xma,xmi ',nev(ibin),nx,xma,xmi
C*TC>
        call hzhinfo(id,nev(ibin))
C*TC<
        call hzchisq(-id,id)
       enddo
*                                              normalize mean Et,x,q2
*                                              fill histos with that info
*                                              set errors of norm. histo 0
       call hpake(24,zeroes)
       do id=21,23
        Call hopera(id,'/E',24,id,1.,1.)
       enddo
*
       call hzchisq(-21,21)
*
       do ibin=1,9
C*TC>
        call hzhinfo(1000+ibin,nev(ibin))
C*TC<
*
        if (nev(ibin).ne.0.) then
         etmean(ibin)=etmean(ibin)/nev(ibin)
         xmean(ibin) =xmean(ibin)/nev(ibin)
         q2mean(ibin)=q2mean(ibin)/nev(ibin)
        else
         etmean(ibin)=-999.
         xmean(ibin) =-999.
         q2mean(ibin)=-999.
        endif
       enddo
       write(6,'(a)')       'hz95108: <et> in central rap. bin: '
       write(6,'(a,9f9.3)') ' <et> = ',etmean
       write(6,'(a,9f9.3)') ' <x>  = ',xmean
       write(6,'(a,9f9.3)') ' <q2> = ',q2mean

      endif
*
      RETURN
      END
*CMZ :  1.01/14 23/03/98  19.13.05  by  Tancredi Carli
*CMZ :  1.01/11 20/11/97  13.48.54  by  Tancredi Carli
*CMZ :  1.01/07 08/10/97  17.37.07  by  Tancredi Carli
*CMZ :  1.01/03 13/05/96  12.02.13  by  Mark Hayes
*CMZU:  0.00/05 30/01/96  18.28.04  by  Mark Hayes
*-- Author :    Mark Hayes   18/12/95
*****************************************************************************
	Subroutine HZ95115(iflag)
*****************************************************************************
* This photoproduction routine has to be run twice with the following
* code additions:
* 	+1000 for the DIRECT component run.
*	+2000 for the RESOLVED component run.
* for all three phases (iflag=1,2,3)
*
* iflag = 1,2 or 3 depending on wether it is the initialization,
*		processing or termination phase (respectively)
*
* The default jetfinder is EUCELL
* To change jetfinder use these values to call the initialisation phase.
* 1 + 10 * (jetfinder number)
*
* This routine produces three Monte Carlo graphs.
* id 10 is the normalised cross section in nb for most forward jet event with a
*		forward rapgap.
* id 20 is the integrated normalised cross section in nb for different forward
*		rapgaps.
*		These graphs will be
*		meaningless unless Xsec and Ntot are set before
*		calling the termination routine.
*		(Xsec - total cross section returned by MC)
*		(Ntot - number of events passed to this routine)
* And two equivalent DATA graphs -10,-20
*
* Cuts : 	Q2 < 4
*		0.2< y_bj < 0.85
*		-1 < /eta_jet < 1
*		maximum energy in the forward gap 400 MeV
*
* Recommended value for Ptmin is 3.0 GeV (to be set in MC set up)
*
* Author : Mark Hayes (Mark.Hayes@bris.ac.uk)
*
* Reference : DESY-95-115
*             	Phys. Lett. B356 (1995) 129-146
*
*
*****************************************************************************
*
* HERA Tuning defined commons
	
	IMPLICIT NONE

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
        Integer chjet
	SAVE chjet
C --- choose same finder as in paper --- EUCELL
	DATA chjet/1/
	CHARACTER*6 jetf
	
        INTEGER NJET
        DOUBLE PRECISION Jets(50,8)
        DOUBLE PRECISION CONER

C --- HBOOK stuff ---
	REAL HI
C --- HBOOK stuff ---

	LOGICAL gap
	INTEGER loop,loop2,count,etamxlp
	DOUBLE PRECISION partrap,dummy,maxgapE
	DOUBLE PRECISION phi(2),px(2),py(2),pz(2),ptsq(2)
	DOUBLE PRECISION ppsq(2),energy(2),mass(2)
	DOUBLE PRECISION rap(2),Et(2)
	DOUBLE PRECISION ybj,q2

C --- cuts arrays
	DOUBLE PRECISION ybjcut(2),q2cut(2)
	DOUBLE PRECISION rapcut(2),Etcut(5)
	DOUBLE PRECISION etamxct(6)

C --- private copies of Xsec and Ntot from HERACMN
	DOUBLE PRECISION mhxsec(2),mhntot(2)

C *** Data for jet vs. cross section graph
	REAL deta(4),creta(4),crsta(4),crsys1(4),crsys2u(4),crsys2d(4)
C *** Actual data
	DATA deta/-0.75, -0.25, 0.25, 0.75/
	DATA creta/44, 39, 37, 16/
	DATA crsta/12, 11, 10, 6/
	DATA crsys1/8, 5, 10, 7/
	DATA crsys2u/10, 8, 8, 3/
	DATA crsys2d/-8, -5, -6, -3/
C *** Data for jet vs. integrated cross section graph varying eta0_max
	REAL bins(7)
	REAL d2eta(6),cr2eta(6),cr2sta(6),cr2sys1(6)
        Real cr2sys2u(6),cr2sys2d(6)
C *** Actual data
	DATA bins/0.75, 1.25, 1.75, 1.85, 2.15, 2.25, 2.55/
	DATA d2eta/1.0, 1.5, 1.8, 2.0, 2.2, 2.4/
	DATA cr2eta/27.3, 51.7, 67, 98, 145, 208/
	DATA cr2sta/5.5, 8.5, 10, 12, 15, 18/
	DATA cr2sys1/9.9, 9.2, 12, 14, 29, 43/
	DATA cr2sys2u/5.9, 10.7, 13, 20, 30, 40/
	DATA cr2sys2d/-4.5, -9.1, -11, -17, -23, -34/

	INTEGER intiflag, iproc, iflag

	REAL pttemp(4),pttemp2(6)
	INTEGER ivec,jvec

C --- choose direct/resolved
C --- recommend 1 - DIRECT, 2 - RESOLVED
	IF (iflag.gt.1000) THEN
	  iproc=INT(iflag/1000)
	  intiflag=MOD(iflag,1000)
	ENDIF
	IF ((iproc.gt.2).or.(iproc.lt.1)) THEN
	  PRINT*,'HZ95115 : Badly called routine'
	  PRINT*,'          please set intiflag +1000 or +2000'
	ENDIF

C --- choose jet finder
	IF ((intiflag.gt.10).and.(MOD(intiflag,10).eq.1)) THEN
	  chjet=INT(intiflag/10)
	  intiflag=MOD(intiflag,10)
	ENDIF

	IF (intiflag.eq.1) THEN
C *** Initialisation run ***
C *** Create directories ***
	  IF (iproc.eq.1) THEN
	    CALL HCDIR('//HISTO',' ')
	    CALL HMDIR('95115','S')
	    CALL HCDIR('//PAWC',' ')
	    CALL HMDIR('95115','S')

	    CALL HCDIR('//HISTO/95115',' ')
	    CALL HCDIR('//PAWC/95115',' ')
	    CALL HBOOK1(10,'MC cross section (nb) gap at 1.8'
     &		,4 ,-1.0 ,1.0 ,0.)
	    CALL HBOOKB(20,'MC cross section (nb) vary gap'
     &		,6 ,bins ,0.)
	  ENDIF
	    CALL HCDIR('//HISTO/95115',' ')
	    CALL HCDIR('//PAWC/95115',' ')
	    CALL HBOOK1(iproc*100+10,
     &	  	'MC cross section No. events gap at 1.8'
     &		,4 ,-1.0 ,1.0 ,0.)
	    CALL HBOOKB(iproc*100+20,
     &		'MC cross section No. events vary gap'
     &		,6 ,bins ,0.)

C --- photoproduction cuts

	  ybjcut(1)=0.2
	  ybjcut(2)=0.85
	  q2cut(1)=0.
	  q2cut(2)=4.

C --- basic cuts for rapidity plots
	  Etcut(1)=8.0
	  maxgapE =0.4
	  rapcut(1)=-1.0
	  rapcut(2)=1.0
	  etamxct(1)=1.0
	  etamxct(2)=1.5
	  etamxct(3)=1.8
	  etamxct(4)=2.0
	  etamxct(5)=2.2
	  etamxct(6)=2.4

C --- standard cone radius is 1.0
	  CALL HZJETRAD(2,CONER)
	  IF (CONER.lt.0.0) THEN
	    CONER=1.0
	  ENDIF
          CALL HZJTNAME(chjet,jetf)
	  WRITE(6,*)'**********************************************'
	  WRITE(6,*)'* HZ95115 called, histograms will be output. *'
	  WRITE(6,*)'*     Jet finder selected : ',jetf,'           *'
	  WRITE(6,1001)'*        with cone radius : ',CONER,'   *'
	  WRITE(6,*)'**********************************************'

 1001	  FORMAT(A29,F5.2,A13)

	ELSE IF (intiflag.eq.2) THEN
C *** Filling runs ***
	
C *** Change directory to our graphs ***
	  CALL HCDIR('//PAWC/95115',' ')

	  q2=hzphokin(1)
	  IF (q2.eq.-1) THEN
	    PRINT*,'HZ95115: HZPHOKIN returns error for Q2'
	  ELSEIF (q2.lt.0) THEN
	    q2=abs(q2)
	  ENDIF
	  ybj=hzphokin(3)
	  IF (ybj.eq.-1) THEN
	    PRINT*,'HZ95115: HZPHOKIN returns error for ybj'
	  ENDIF

C *** Fill our histogram ***

	  IF ((ybj.ge.ybjcut(1)).and.(ybj.le.ybjcut(2))
     &		.and.(q2.lt.q2cut(2))) Then

	    DO etamxlp=1,6
	    gap=.TRUE.
	    DO loop=1,NHEP
	      IF (ISTHEP(loop).eq.1) THEN
		px(1)=PHEP(1,loop)
	        py(1)=PHEP(2,loop)
	        pz(1)=PHEP(3,loop)
                ptsq(1)=px(1)**2+py(1)**2
                ppsq(1)=(SQRT(ptsq(1)+pz(1)**2)+ABS(pz(1)))**2
                IF (ptsq(1).le.4.25E-18*ppsq(1)) THEN
                  partrap=20
                ELSE
                  partrap=0.5*LOG(ppsq(1)/ptsq(1))
                ENDIF
                partrap=SIGN(partrap,pz(1))
		IF ((partrap.gt.etamxct(etamxlp))
     &			.and.(partrap.lt.4.3)
     &			.and.(PHEP(4,loop).gt.maxgapE))
     &			Then
			  gap=.FALSE.
			ENDIF
	      ENDIF ! final state particle
	    ENDDO	! scan of HEPEVT for gap
	    IF (gap) THEN
              CALL hzjtfind(chjet,CONER,NJET,Jets)

	      IF (NJET.gt.0) THEN
	        count=1
	        DO loop2=1,NJET
	          IF (Jets(loop2,1).gt.Jets(count,1).and.
     &		    Jets(loop2,1).lt.1.and.Jets(loop2,1).gt.-1) THEN
	            count=loop2
	          ENDIF
	        ENDDO ! loop2 find forward jet
	        Et(1)=Jets(count,3)
	        rap(1)=Jets(count,1)

	        If ( (Et(1).gt.Etcut(1)).and.(rap(1).lt.rapcut(2)).and.
     &		(rap(1).gt.rapcut(1))) Then
		  IF (etamxlp.eq.3)
     & 		     CALL HFILL(iproc*100+10, REAL(rap(1)), 0., wtx)

		  CALL HFILL(iproc*100+20, REAL(etamxct(etamxlp)), 0., wtx)
	        ENDIF	! cuts on Et and -1<rap<1
	      ENDIF	! Making sure NJET.gt.0
	    ENDIF	! had we a gap?
	    ENDDO 	! etamxlp
	  ENDIF ! y & Q2 cuts

	ELSE IF (intiflag.eq.3) THEN
C *** Termination run ***
C *** Change directory ***
	  CALL HCDIR('//PAWC/95115',' ')
C *** Finish off histograms ***

	  IF (Xsec.eq.0) THEN
	    PRINT*,'HZ95115: termination called with zero cross section'
	    PRINT*,'          cross section graph meaningless'
	    PRINT*,'	      in process :',iproc*1000
	    Xsec=1
	  ENDIF
	  IF (Ntot.eq.0) THEN
	    PRINT*,'HZ95115: termination called with no total events'
	    PRINT*,'          cross section graph meaningless'
	    PRINT*,'	      in process :',iproc*1000
	    Ntot=1
	  ENDIF

C --- store Xsec and Ntot for both direct and resolved events.
	  mhXsec(iproc)=Xsec*1000
	  mhntot(iproc)=Ntot*1000
C --- remembering in HZ95115 to convert to pb! IMPORTANT!

	  IF (iproc.eq.2) THEN
C --- only finally
C --- create proper cross-section data
	    CALL HBOOK1(-10,'Data cross section (nb) gap at 1.8'
     &		,4 ,-1.0 ,1.0 ,0.)
	    CALL HBOOKB(-20,'Data cross section (nb) vary gap'
     &		,6 ,bins ,0.)
	    CALL HBOOK1(-11,'Data cross section (nb) gap at 1.8 full err'
     &		,4 ,-1.0 ,1.0 ,0.)
	    CALL HBOOKB(-21,'Data cross section (nb) vary gap full errors'
     &		,6 ,bins ,0.)

	    CALL HPAK(-10,creta)
	    CALL HPAKE(-10,crsta)
	    DO loop=1,4
	      pttemp(loop)=sqrt(crsta(loop)**2+crsys1(loop)**2)
	    ENDDO
	    CALL HPAK(-11,creta)
	    CALL HPAKE(-11,pttemp)
	
	    CALL HPAK(-20,cr2eta)
	    CALL HPAKE(-20,cr2sta)
	    DO loop=1,6
	      pttemp2(loop)=sqrt(cr2sta(loop)**2+cr2sys1(loop)**2)
	    ENDDO
	    CALL HPAK(-21,cr2eta)
	    CALL HPAKE(-21,pttemp2)

C --- now calculate cross-section graphs 10,20
	    CALL HOPERA(110,'+e',210,10,
     &		REAL(2*mhXsec(1)/mhNtot(1)), REAL(2*mhXsec(2)/mhNtot(2)))

	    CALL HBOOKB(50,'renorm histo - temp'
     &		,6 ,bins ,0.)
	    DO ivec=1,6
	     bins(ivec)=1/(bins(ivec+1)-bins(ivec))
	    ENDDO
	    CALL  HPAK (50,bins)	
C	    CALL HOPERA(120,'*e',50,120,1.,1.)
C	    CALL HOPERA(220,'*e',50,220,1.,1.)
	    CALL HOPERA(120,'+e',220,20,
     &		REAL(mhXsec(1)/mhNtot(1)), REAL(mhXsec(2)/mhNtot(2)))

	    CALL HZCHISQ(-10,10)
	    CALL HZCHISQ(-20,20)
	    PRINT*,'Xsec(1)=',mhXsec(1)
	    PRINT*,'Xsec(2)=',mhXsec(2)
	    PRINT*,'Ntot(1)=',mhNtot(1)
	    PRINT*,'Ntot(2)=',mhNtot(2)
	  ENDIF

	ELSE
C *** End ***
	  PRINT*,'HZ95115: Please run routine with iflag set to 1,2 or 3'
	  PRINT*,'         with +1000 or +2000 for DIR or RES events.'
	ENDIF

	RETURN
	END































*CMZ :  1.01/14 25/03/98  18.26.00  by  Tancredi Carli
*CMZU:  0.00/05 30/01/96  18.28.04  by  Mark Hayes
*****************************************************************************
	Subroutine HZ95194(iflag)
*****************************************************************************
* This photoproduction routine has to be run twice with the following
* code additions:
* 	+1000 for the DIRECT component run.
*	+2000 for the RESOLVED component run.
* for all three phases (iflag=1,2,3)
*
* iflag = 1,2 or 3 depending on wether it is the initialization,
*		processing or termination phase (respectively)
*
* The default jetfinder is EUCELL
* To change jetfinder use these values to call the initialisation phase.
* 1 + 10 * (jetfinder number)
*
* This routine produces three Monte Carlo graphs.
* id 10 is the normalised cross section in nb for two jet events
* id 20 is the normalised cross section in nb for gap events
* id 30 is the fraction of 20 over 10
*		These graph will be
*		meaningless unless Xsec and Ntot are set before
*		calling the termination routine.
*		(Xsec - total cross section returned by MC)
*		(Ntot - number of events passed to this routine)
* And three equivalent DATA graphs -10,-20,-30
*
* Cuts : 	Q2 < 4
*		0.2< y_bj < 0.85
*		/eta_jet < 2.5
*		mod(/etabar) < 0.75
*		deltaeta > 2
*		maximum energy in the gap 300 MeV
*
* Recommended value for Ptmin is 2.5 GeV (to be set in MC set up)
*
* Author : Mark Hayes (Mark.Hayes@bris.ac.uk)
*
* Reference : DESY-95-194
*             Submitted to PLB
*
*
*****************************************************************************
*
* HERA Tuning defined commons
	
	IMPLICIT NONE

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
        Integer chjet
	SAVE chjet
C --- choose same finder as in paper --- EUCELL
	DATA chjet/1/
	CHARACTER*6 jetf
	
        INTEGER NJET
        DOUBLE PRECISION Jets(50,8)
        DOUBLE PRECISION CONER

C --- HBOOK stuff ---
	REAL HI
C --- HBOOK stuff ---

	LOGICAL ingap
	INTEGER loop,loop2,count
	DOUBLE PRECISION deltaeta,etabar
	DOUBLE PRECISION partrap,dummy,maxgapE
	DOUBLE PRECISION phi(2),px(2),py(2),pz(2),ptsq(2)
	DOUBLE PRECISION ppsq(2),energy(2),mass(2)
	DOUBLE PRECISION rap(2),Et(2)
	DOUBLE PRECISION ybj,q2

C --- cuts arrays
	DOUBLE PRECISION ybjcut(2),q2cut(2)
	DOUBLE PRECISION rapcut(2),Etcut(5)

C --- private copies of Xsec and Ntot from HERACMN
	DOUBLE PRECISION mhxsec(2),mhntot(2)

C *** Data for non-gap cross section
	REAL deta(4),creta(4),crsta(4),crsys1(4),crsys2(4)
C *** Actual data
	DATA deta/2.25, 2.75, 3.25, 3.75/
	DATA creta/4.93, 3.06, 1.67, 0.54/
	DATA crsta/0.24, 0.15, 0.07, 0.03/
	DATA crsys1/0.83, 0.54, 0.31, 0.08/
	DATA crsys2/-0.68, -0.52, -0.19, -0.03/
C *** Data for gap cross section
	REAL deta2(4),cr2eta(4),cr2sta(4),cr2sys1(4),cr2sys2(4)
C *** Actual data
	DATA deta2/2.25, 2.75, 3.25, 3.72/
	DATA cr2eta/2.85, 0.66, 0.16, 0.06/
	DATA cr2sta/0.17, 0.06, 0.02, 0.01/
	DATA cr2sys1/0.45, 0.11, 0.03, 0.01/
	DATA cr2sys2/-0.45, -0.15, -0.04, -0.01/
C *** Data for gap fraction
	REAL deta3(4),freta(4),frsta(4),frsys1(4),frsys2(4)
C *** Actual data
	DATA deta3/2.23, 2.73, 3.22, 3.70/
	DATA freta/0.58, 0.22, 0.10, 0.11/
	DATA frsta/0.04, 0.02, 0.01, 0.02/
	DATA frsys1/0.04, 0.02, 0.01, 0.01/
	DATA frsys2/-0.02, -0.02, -0.02, -0.02/

	INTEGER intiflag, iproc, iflag

	REAL pttemp(12)
	INTEGER ivec,jvec

C --- choose direct/resolved
C --- recommend 1 - DIRECT, 2 - RESOLVED
	IF (iflag.gt.1000) THEN
	  iproc=INT(iflag/1000)
	  intiflag=MOD(iflag,1000)
	ENDIF
	IF ((iproc.gt.2).or.(iproc.lt.1)) THEN
	  PRINT*,'HZ95194 : Badly called routine'
	  PRINT*,'          please set intiflag +1000 or +2000'
	ENDIF

C --- choose jet finder
	IF ((intiflag.gt.10).and.(MOD(intiflag,10).eq.1)) THEN
	  chjet=INT(intiflag/10)
	  intiflag=MOD(intiflag,10)
	ENDIF

	IF (intiflag.eq.1) THEN
C *** Initialisation run ***
C *** Create directories ***
	  IF (iproc.eq.1) THEN
	    CALL HCDIR('//HISTO',' ')
	    CALL HMDIR('95194','S')
	    CALL HCDIR('//PAWC',' ')
	    CALL HMDIR('95194','S')

	    CALL HCDIR('//HISTO/95194',' ')
	    CALL HCDIR('//PAWC/95194',' ')
	    CALL HBOOK1(10,'Monte Carlo cross section (nb) non-gap'
     &		,4 ,2.0 ,4.0 ,0.)
	    CALL HBOOK1(20,'Monte Carlo cross section (nb) gap'
     &		,4 ,2.0 ,4.0 ,0.)
	    CALL HBOOK1(30,'Monte Carlo gap fraction'
     &		,4 ,2.0 ,4.0 ,0.)
	  ENDIF
	    CALL HCDIR('//HISTO/95194',' ')
	    CALL HCDIR('//PAWC/95194',' ')
	    CALL HBOOK1(iproc*100+10,
     &	  	'Monte Carlo cross section No. events non-gap'
     &		,4 ,2.0 ,4.0 ,0.)
	    CALL HBOOK1(iproc*100+20,
     &		'Monte Carlo cross section No. events gap'
     &		,4 ,2.0 ,4.0 ,0.)

C --- photoproduction cuts

	  ybjcut(1)=0.2
	  ybjcut(2)=0.85
	  q2cut(1)=0.
	  q2cut(2)=4.

C --- basic cuts for rapidity plots
	  Etcut(1)=6.0
	  maxgapE =0.3

C --- standard cone radius is 1.0
	  CALL HZJETRAD(2,CONER)
	  IF (CONER.lt.0.0) THEN
	    CONER=1.0
	  ENDIF
          CALL HZJTNAME(chjet,jetf)
	  WRITE(6,*)'**********************************************'
	  WRITE(6,*)'* HZ95194 called, histograms will be output. *'
	  WRITE(6,*)'*     Jet finder selected : ',jetf,'           *'
	  WRITE(6,1001)'*        with cone radius : ',CONER,'   *'
	  WRITE(6,*)'**********************************************'

 1001	  FORMAT(A29,F5.2,A13)

	ELSE IF (intiflag.eq.2) THEN
C *** Filling runs ***
	
C *** Change directory to our graphs ***
	  CALL HCDIR('//PAWC/95194',' ')

	  q2=hzphokin(1)
	  IF (q2.eq.-1) THEN
	    PRINT*,'HZ95194: HZPHOKIN returns error for Q2'
	  ELSEIF (q2.lt.0) THEN
	    q2=abs(q2)
	  ENDIF
	  ybj=hzphokin(3)
	  IF (ybj.eq.-1) THEN
	    PRINT*,'HZ95194: HZPHOKIN returns error for ybj'
	  ENDIF

C *** Fill our histogram ***

	  IF ((ybj.ge.ybjcut(1)).and.(ybj.le.ybjcut(2))
     &		.and.(q2.lt.q2cut(2))) Then

            CALL hzjtfind(chjet,CONER,NJET,Jets)

	    IF (NJET.ge.2) THEN
	      DO loop=1,2
	        Et(loop)=Jets(loop,3)
	        rap(loop)=Jets(loop,1)
	      ENDDO
	      deltaeta=abs(rap(1)-rap(2))
	      etabar=abs((rap(1)+rap(2))/2)

	      If ( (Et(2).gt.Etcut(1)).and.(rap(1).lt.2.5).and.
     &		(rap(2).lt.2.5).and.(etabar.lt.0.75).and.
     &		(deltaeta.gt.2) ) Then

		CALL HFILL(iproc*100+10, REAL(deltaeta), 0., wtx)
		IF (rap(1).lt.rap(2)) THEN
		  dummy=rap(1)
		  rap(1)=rap(2)
		  rap(2)=dummy
		ENDIF
		ingap=.TRUE.
		DO loop=1,NHEP
		  IF (ISTHEP(loop).eq.1) THEN
		    px(1)=PHEP(1,loop)
	            py(1)=PHEP(2,loop)
	            pz(1)=PHEP(3,loop)
                    ptsq(1)=px(1)**2+py(1)**2
                    ppsq(1)=(SQRT(ptsq(1)+pz(1)**2)+ABS(pz(1)))**2
                    IF (ptsq(1).le.4.25E-18*ppsq(1)) THEN
                      partrap=20
                    ELSE
                      partrap=0.5*LOG(ppsq(1)/ptsq(1))
                    ENDIF
                    partrap=SIGN(partrap,pz(1))
		    IF ((partrap.gt.rap(2)+CONER+0.001)
     &			.and.(partrap.lt.rap(1)-CONER-0.001)
     &			.and.(sqrt(ptsq(1)).gt.maxgapE))
     &			Then
			ingap=.FALSE.
			ENDIF
		  ENDIF ! final state particle
		ENDDO	! scan of HEPEVT
		IF (ingap) Then
		  CALL HFILL(iproc*100+20, REAL(deltaeta), 0., wtx)
		ENDIF
	      ENDIF	! cuts
	    ENDIF	! End of Njet.ge.2

	  ENDIF ! y & Q2 cuts

	ELSE IF (intiflag.eq.3) THEN
C *** Termination run ***
C *** Change directory ***
	  CALL HCDIR('//PAWC/95194',' ')
C *** Finish off histograms ***

	  IF (Xsec.eq.0) THEN
	    PRINT*,'HZ95194: termination called with zero cross section'
	    PRINT*,'          cross section graph meaningless'
	    PRINT*,'	      in process :',iproc*1000
	    Xsec=1
	  ENDIF
	  IF (Ntot.eq.0) THEN
	    PRINT*,'HZ95194: termination called with no total events'
	    PRINT*,'          cross section graph meaningless'
	    PRINT*,'	      in process :',iproc*1000
	    Ntot=1
	  ENDIF

C --- store Xsec and Ntot for both direct and resolved events.
	  mhXsec(iproc)=Xsec
	  mhntot(iproc)=Ntot

	  IF (iproc.eq.2) THEN
C --- only finally
C --- create proper cross-section data
	    CALL HBOOK1(-10,'Data cross section (nb) non-gap'
     &		,4 ,2.0 ,4.0 ,0.)
	    CALL HBOOK1(-20,'Data cross section (nb) gap'
     &		,4 ,2.0 ,4.0 ,0.)
	    CALL HBOOK1(-30,'Data gap fraction'
     &		,4 ,2.0 ,4.0 ,0.)

	    CALL HPAK(-10,creta)
	    CALL HPAKE(-10,crsta)
	    CALL HPAK(-20,cr2eta)
	    CALL HPAKE(-20,cr2sta)
	    CALL HPAK(-30,freta)
	    CALL HPAKE(-30,frsta)

C --- now calculate cross-section graphs 10,20
	    CALL HOPERA(110,'+e',210,10,
     &		REAL(2*mhXsec(1)/mhNtot(1)), REAL(2*mhXsec(2)/mhNtot(2)))
	    CALL HOPERA(120,'+e',220,20,
     &		REAL(2*mhXsec(1)/mhNtot(1)), REAL(2*mhXsec(2)/mhNtot(2)))
C --- check that we can divide one by the other
	    ingap=.TRUE.
	    DO loop=1,4
		IF (HI(10,loop).lt.0.00001) ingap=.FALSE.
	    ENDDO
	    IF (ingap) Then
		CALL HOPERA(20,'/e',10, 30, 1., 1.)
	    ELSE
		PRINT*,'HZ95194 : Some channels in histogram 10 are zero'
		PRINT*,'          will not calculate fraction graph.'
	    ENDIF
	    CALL HZCHISQ(-10,10)
	    CALL HZCHISQ(-20,20)
	    CALL HZCHISQ(-30,30)
	    PRINT*,'Xsec(1)=',mhXsec(1)
	    PRINT*,'Xsec(2)=',mhXsec(2)
	    PRINT*,'Ntot(1)=',mhNtot(1)
	    PRINT*,'Ntot(2)=',mhNtot(2)
	  ENDIF

	ELSE
C *** End ***
	  PRINT*,'HZ95194: Please run routine with iflag set to 1,2 or 3'
	  PRINT*,'         with +1000 or +2000 for DIR or RES events.'
	ENDIF

	RETURN
	END































*CMZ :  2.00/05 04/10/2000  10.35.36  by  Tancredi Carli
*CMZ :  1.02/06 27/03/99  16.09.07  by  Tancredi Carli
*-- Author :
        Subroutine HZ95219(iflag)
*****************************************************************************
* This photoproduction routine has to be run twice with the following
* code additions:
* 	+1000 for the DIRECT component run.
*	+2000 for the RESOLVED component run.
* for all three phases (iflag=1,2,3)
*
* iflag = 1,2 or 3 depending on whether it is the initialization,
*               processing or termination phase (respectively)
*
* Output graphs:
*---------------
* DATA
* -1        d(sigma)/d(Et),  -1<eta<2 -stat.errors
* -2        d(sigma)/d(Et),  -1<eta<1
* -3        d(sigma)/d(eta), Et>7  GeV
* -4        d(sigma)/d(eta), Et>11 GeV
* -5        d(sigma)/d(eta), Et>15 GeV
*
* -11...-15: same as -1..-5 but with bin-by-bin systematic errors
* -21...-25: same as -1..-5 but with full systematic errors
*
* Monte-Carlo
*  1        d(sigma)/d(Et),  -1<eta<2
*  2        d(sigma)/d(Et),  -1<eta<1
*  3        d(sigma)/d(eta), Et>7  GeV
*  4        d(sigma)/d(eta), Et>11 GeV
*  5        d(sigma)/d(eta), Et>15 GeV
*               These graphs will be
*               meaningless unless Xsec and Ntot are set before
*               calling the termination routine.
*               (Xsec - total cross section returned by MC)
*               (Ntot - number of events passed to this routine)
*
*  101        d(sigma)/d(Et),  -1<eta<2
*  102        d(sigma)/d(Et),  -1<eta<1
*  103        d(sigma)/d(eta), Et>7  GeV        (DIRECT component)
*  104        d(sigma)/d(eta), Et>11 GeV
*  105        d(sigma)/d(eta), Et>15 GeV
*
*  201        d(sigma)/d(Et),  -1<eta<2
*  202        d(sigma)/d(Et),  -1<eta<1
*  203        d(sigma)/d(eta), Et>7  GeV        (RESOLVED component)
*  204        d(sigma)/d(eta), Et>11 GeV
*  205        d(sigma)/d(eta), Et>15 GeV
*
* Cuts :        Q2 < 0.01
*               0.25< y_bj <0.7
*               Depending on graph Et > 7, 11, 15
*                       and -1 < eta < 2, 1
*
* Recommended value for Ptmin is 2 GeV (to be set in MC set up)
*
* Author : Armen Buniatian (bunar@dice2.desy.de)
*          modified into separate direct and resolved components by R.Taylor
*
* Reference : DESY-95-219
*             Z.Phys. C70(1996) 17 [Figure 7]
*             hep-ex/9511012
*
*****************************************************************************
*
* HERA Tuning defined commons

        IMPLICIT NONE

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.

        INTEGER I
        Integer nbin1,nbin2,nbin3,nbin4,nbin5
        REAL xbins6(10)
        REAL xbins1(10)
        REAL pt1eta(9),pt1cr(9),pt1cre(9)
        REAL pt1cresys(9),hi1band(9)
        REAL pttemp1(9)
        REAL xbins2(8)
        REAL pt2eta(7),pt2cr(7),pt2cre(7)
        REAL pt2cresys(7),hi2band(7)
        REAL pttemp2(7)
        REAL xbins3(7)
        REAL pt3eta(6 ),pt3cr(6 ),pt3cre(6 )
        REAL pt3cresys(6 ),hi3band(6 )
        REAL pttemp3(6)
        REAL xbins4(6)
        REAL pt4eta(5),pt4cr(5),pt4cre(5)
        REAL pt4cresys(5),hi4band(5)
        REAL pttemp4(5)

        INTEGER iflag,iproc,intiflag,K
        DOUBLE PRECISION Q2,ybj

        REAL JET1(10,3)
        REAL ETALM,ETINI,RJET,ETBIN,ETMIN,ETMAX,ANORM(2)
        INTEGER NETA,NPHI,NJET1,NGOODJ,KL1,IER,J
*
        DATA nbin1,nbin2,nbin3,nbin4,nbin5 /9,7,6,5,4/

C *** Data for Et.gt.7 & -1<eta<2
C *** Data points for Et.gt.7 & -1<eta<2

        DATA xbins1/7.,9.,11.,13.,15.,17.,19.,21.,25.,29./
        DATA pt1eta/8.,10.,12.,14.,16.,18.,20.,23.,27./
        DATA pt1cr/20.8, 5.5, 1.74, 0.803, 0.283, 0.153, 0.0715,
     &    0.0223, 0.0172/
        DATA pt1cre/0.56, 0.26, 0.12, 0.079, 0.044, 0.036,
     &    0.021, 0.0081, 0.0063/
        DATA pt1cresys/4.4, 1.2, 0.37, 0.17, 0.059, 0.032,
     &    0.015, 0.0047, 0.0036/
        DATA hi1band/5.4, 1.4, 0.45, 0.21, 0.074, 0.040,
     &    0.019, 0.0058, 0.0045/

C *** Data for Et.gt.7 & -1<eta<1
C *** Data points for Et.gt.7   & -1<eta<1
        DATA xbins2/7., 9., 11., 13., 15., 17., 19., 21./
        DATA pt2eta/8., 10., 12., 14., 16., 18., 20./
        DATA pt2cr/10.3, 2.76, 0.787, 0.322, 0.141, 0.0672, 0.0263/
        DATA pt2cre/0.39, 0.19, 0.078, 0.049, 0.030, 0.021, 0.012/
        DATA pt2cresys/2.2, 0.58, 0.17, 0.067, 0.030, 0.014, 0.0055/
        DATA hi2band/2.7, 0.72, 0.20, 0.084, 0.037, 0.017, 0.0068/


C *** Data for Et.gt.7 GeV
C *** Data points for Et.gt.7 GeV
        DATA xbins3/-1.0, -0.5, 0., 0.5,  1.0, 1.5, 2.0/
        DATA pt3eta /-0.75, -0.25, 0.25, 0.75,  1.25, 1.75/
        DATA pt3cr  /  5.9,  13.2, 17.8, 21.6,  24.8, 30.1/
        DATA pt3cre / 0.64,  0.86,  1.1,  1.1,   1.2,  1.3/
        DATA pt3cresys/ 1.3, 2.8, 3.7, 4.5, 5.2, 6.3/
        DATA hi3band/1.5, 3.4, 4.6, 5.6, 6.5, 7.8/
C *** Data for Et.gt.11 GeV
C *** Data points for Et.gt.11 GeV
        DATA xbins4 / -0.5, 0., 0.5,  1.0, 1.5, 2.0/
        DATA pt4eta / -0.25, 0.25, 0.75,  1.25, 1.75/
        DATA pt4cr  / 1.23, 1.85, 2.36,  3.30, 3.27/
        dATA pt4cre /  0.20, 0.24, 0.30, 0.35, 0.33 /
        DATA pt4cresys/ 0.26, 0.39, 0.50, 0.69, 0.69/
        DATA hi4band/0.32, 0.48, 0.61, 0.86, 0.85/
C *** Data for Et.gt.15 GeV
        REAL xbins5(5)
        REAL pt5eta(4),pt5cr(4),pt5cre(4)
        REAL pt5cresys(4),hi5band(4)
        REAL pttemp5(4)
*
C *** Data points for Et.gt.15 GeV
        DATA xbins5 /  0., 0.5,  1.0, 1.5, 2.0/
        DATA pt5eta /  0.25, 0.75,  1.25, 1.75/
        DATA pt5cr  /  0.50, 0.48, 0.67, 0.65 /
        DATA pt5cre /   0.12, 0.12, 0.15, 0.14 /
        DATA pt5cresys/  0.11, 0.10, 0.14, 0.14/
C* Okt 2000 from S. Ferron >
         DATA hi5band/0.13, 0.13, 0.17, 0.17/
C<
*
C --- choose direct/resolved
C --- recommend 1 - DIRECT, 2 - RESOLVED
	IF (iflag.gt.1000) THEN
	  iproc=INT(iflag/1000)
	  intiflag=MOD(iflag,1000)
	ENDIF
	IF ((iproc.gt.2).or.(iproc.lt.1)) THEN
	  PRINT*,'HZ94176 : Badly called routine'
	  PRINT*,'          please set intiflag +1000 or +2000'
	ENDIF

        IF (intiflag.eq.1) THEN
C *** Initialisation run ***

          PRINT*,"**********************************************"
          PRINT*,"* HZ95219 called, histograms will be output. *"
          PRINT*,"**********************************************"

         IF (iproc.eq.1) THEN
           CALL HCDIR('//PAWC',' ')
           CALL HMDIR('95219','S')
           CALL HCDIR('//HISTO',' ')
           CALL HMDIR('95219','S')

* -1<eta<2
           CALL HBOOKB(-1
     &  ,'Data-d(sigma)/d(Et) (nb) -1.lt.eta.lt.2-stat.errors'
     &          ,9,xbins1 ,0.)
           CALL HPAK(-1,PT1CR)
           CALL HPAKE(-1,PT1CRE)


           CALL HBOOKB(-11,
     &    'Data-d(sigma)/d(Et) (nb) -1.lt.eta.lt.2-stat.+syst.errors'
     &          ,9,xbins1 ,0.)
           do i=1,nbin1
             pttemp1(i)=sqrt(PT1CRE(i)**2+pt1cresys(i)**2)
           enddo
           CALL HPAK(-11,PT1CR)
           CALL HPAKE(-11,PTTemp1)


           CALL HBOOKB(-21,
     &       'Data-d(sigma)/d(Et) (nb) -1.lt.eta.lt.2-full errors'
     &          ,9,xbins1 ,0.)
           do i=1,nbin1
             pttemp1(i)=sqrt(PT1CRE(i)**2+pt1cresys(i)**2
     &       +hi1band(i)**2)
           enddo
           CALL HPAK(-21,PT1CR)
           CALL HPAKE(-21,PTTEMP1)


* -1<eta<1

C --- Original routine contained a scaling of 0.1 on this data (in order
C --- to match with the published graph). I've (RT) deleted this 20/8/98.
C --- [Also changed weighting in MC histograms from 0.05 to 0.5].
           CALL HBOOKB(-2,
     &     'Data-d(sigma)/d(Et) (nb) -1.lt.eta.lt.1-stat.errors'
     &          ,7,xbins2 ,0.)
           CALL HPAK(-2,PT2CR)
           CALL HPAKE(-2,PT2CRE)

           CALL HBOOKB(-12,
     &     'Data-d(sigma)/d(Et) (nb) -1.lt.eta.lt.1-stat.+syst.errors'
     &          ,7,xbins2 ,0.)
           CALL HPAK(-12,PT2CR)
           do i=1,nbin2
             pttemp2(i)=sqrt(PT2CRE(i)**2+pt2cresys(i)**2)
           enddo
           CALL HPAKE(-12,PTTEMP2)

           CALL HBOOKB(-22,
     &     'Data-d(sigma)/d(Et) (nb) -1.lt.eta.lt.1-full errors'
     &          ,7,xbins2 ,0.)
           CALL HPAK(-22,PT2CR)
           do i=1,nbin2
             pttemp2(i)=sqrt(PT2CRE(i)**2+pt2cresys(i)**2
     &          +hi2band(i)**2)
           enddo
           CALL HPAKE(-22,PTTEMP2)

* ET>7
           CALL HBOOKB(-3,
     &     'Data-d(sigma)/d(eta) (nb) Et.gt.7 GeV-stat.errors'
     &          ,6,xbins3 ,0.)
           CALL HPAK(-3,PT3CR)
           CALL HPAKE(-3,PT3CRE)

           CALL HBOOKB(-13,
     &    'Data-d(sigma)/d(eta) (nb) Et.gt.7 GeV-stat+syst.errors'
     &          ,6,xbins3 ,0.)
           CALL HPAK(-13,PT3CR)
           do i=1,nbin3
             pttemp3(i)=sqrt(PT3CRE(i)**2+pt3cresys(i)**2)
           enddo
           CALL HPAKE(-13,PTTEMP3)

           CALL HBOOKB(-23,
     &    'Data-d(sigma)/d(eta) (nb) Et.gt.7 GeV-full errors'
     &          ,6,xbins3 ,0.)
           CALL HPAK(-23,PT3CR)
           do i=1,nbin3
             pttemp3(i)=sqrt(PT3CRE(i)**2+pt3cresys(i)**2
     &          +hi3band(i)**2)
           enddo
           CALL HPAKE(-23,PTTEMP3)

* ET>11
           CALL HBOOKB(-4,
     &    'Data-d(sigma)/d(eta) (nb) Et.gt.11 GeV-stat.errors'
     &          ,5,xbins4 ,0.)
           CALL HPAK(-4,PT4CR)
           CALL HPAKE(-4,PT4CRE)

           CALL HBOOKB(-14,
     &    'Data-d(sigma)/d(eta) (nb) Et.gt.11 GeV-stat+syst.errors'
     &          ,5,xbins4 ,0.)

           CALL HPAK(-14,PT4CR)
           do i=1,nbin4
             pttemp4(i)=sqrt(PT4CRE(i)**2+pt4cresys(i)**2)
           enddo
           CALL HPAKE(-14,PTTEMP4)

           CALL HBOOKB(-24,
     &    'Data-d(sigma)/d(eta) (nb) Et.gt.11 GeV-full errors'
     &          ,5,xbins4 ,0.)
           CALL HPAK(-24,PT4CR)
           do i=1,nbin4
             pttemp4(i)=sqrt(PT4CRE(i)**2+pt4cresys(i)**2
     &        +hi4band(i)**2)
           enddo
           CALL HPAKE(-24,PTTEMP4)

* ET>15
           CALL HBOOKB(-5,
     &    'Data-d(sigma)/d(eta) (nb) Et.gt.15 GeV-stat.errors'
     &          ,4,xbins5 ,0.)
           CALL HPAK(-5,PT5CR)
           CALL HPAKE(-5,PT5CRE)

           CALL HBOOKB(-15,
     &    'Data-d(sigma)/d(eta) (nb) Et.gt.15 GeV-stat+syst.errors'
     &          ,4,xbins5 ,0.)
           CALL HPAK(-15,PT5CR)
           do i=1,nbin5
             pttemp5(i)=sqrt(PT5CRE(i)**2+pt5cresys(i)**2)
           enddo
           CALL HPAKE(-15,PTTEMP5)

           CALL HBOOKB(-25,
     &    'Data-d(sigma)/d(eta) (nb) Et.gt.15 GeV-full errors'
     &          ,4,xbins5 ,0.)
           CALL HPAK(-25,PT5CR)
           do i=1,nbin5
             pttemp5(i)=sqrt(PT5CRE(i)**2+pt5cresys(i)**2
     &       +hi5band(i)**2)
           enddo
           CALL HPAKE(-25,PTTEMP5)


* Monte-Carlo

           CALL HBOOKB(1,'Monte-Carlo d(sigma)/dEt (nb) -1.lt.eta.lt.2'
     &          ,9,xbins1 ,0.)
           CALL HBOOKB(2,'Monte-Carlo d(sigma)/dEt  (nb) -1.lt.eta.lt.1'
     &          ,7,xbins2 ,0.)
           CALL HBOOKB(3,'Monte-Carlo d(sigma)/d(eta) (nb) Et.gt.7 GeV'
     &          ,6,xbins3 ,0.)
           CALL HBOOKB(4,'Monte-Carlo d(sigma)/d(eta) (nb) Et.gt.11 GeV'
     &          ,5,xbins4 ,0.)
           CALL HBOOKB(5,'Monte-Carlo d(sigma)/d(eta) (nb) Et.gt.15 GeV'
     &          ,4,xbins5 ,0.)

         ENDIF

         IF (iproc.eq.2) THEN
           CALL HCDIR('//HISTO/95219',' ')
           CALL HCDIR('//PAWC/95219',' ')
         ENDIF

         CALL HBOOKB(100*iproc+1,'MC d(sigma)/d(Et) -1.lt.eta.lt.2'
     &          ,9,xbins1 ,0.)
         CALL HBOOKB(100*iproc+2,'MC d(sigma)/d(Et) -1.lt.eta.lt.1'
     &          ,7,xbins2 ,0.)
         CALL HBOOKB(100*iproc+3,'MC d(sigma)/d(eta) Et.gt.7 GeV'
     &          ,6,xbins3 ,0.)
         CALL HBOOKB(100*iproc+4,'MC d(sigma)/d(eta) Et.gt.11 GeV'
     &          ,5,xbins4 ,0.)
         CALL HBOOKB(100*iproc+5,'MC d(sigma)/d(eta) Et.gt.15 GeV'
     &          ,4,xbins5 ,0.)

           ETALM = 3.0
           NETA = 30
           NPHI = 24
           ETINI = 0.1
           RJET = 1.00001
           ETBIN = 2.
           ETMIN = 7.0
           ETMAX=49.

        ELSE IF (intiflag.eq.2) THEN
C *** Filling runs ***

          CALL VZERO(jet1,30)
          njet1=0
          CALL H1GPCONE(ETALM,NETA,NPHI,ETINI,ETMIN,ETBIN,ETMAX,
     +                 RJET, NJET1,JET1)

C --- Original version did not include internal cuts on Q2 and y_bj
C --- Added below by Russell Taylor (21/8/98)
          Q2=HZPHOKIN(1)
          Q2=ABS(Q2)
          ybj=HZPHOKIN(3)

          ngoodj=0
          IF ((ybj.GE.0.25).AND.(ybj.LE.0.7).AND.(Q2.LT.0.01)) THEN
           DO 654 KL1=1,NJET1
C            PRINT '(2X,'' JETS 1=ET/ETA,PHI='',3F7.3)',
C     +         (JET1(KL1,J),J=1,3)
            IF(JET1(KL1,2).GT.2.0.OR.JET1(KL1,2).LE.-1.0 ) GOTO 654
            IF(jet1(kl1,1).LT.ETMIN) GOTO 654
            ngoodj=ngoodj+1
            if(JET1(KL1,2).LE.2..AND.JET1(KL1,2).GE.-1.0 ) THEN
              CALL HCDIR('//PAWC/95219',' ')
              CALL HF1(100*iproc+1,JET1(KL1,1),wtx)
              IF(JET1(KL1,2).LE.1.)
     +                       CALL HF1(100*iproc+2,JET1(KL1,1),0.5*wtx)
              IF(JET1(KL1,1).GE.7.) CALL HF1(100*iproc+3,JET1(KL1,2),2.)
             IF(JET1(KL1,1).GE.11.) CALL HF1(100*iproc+4,JET1(KL1,2),2.)
             IF(JET1(KL1,1).GE.15.) CALL HF1(100*iproc+5,JET1(KL1,2),2.)
            ENDIF
654        CONTINUE
        ENDIF         !Q2 and y_bj cuts

        ELSE IF (intiflag.eq.3) THEN

C --- The following lines allow for variable bin widths on MC histograms
C --- 1, 101 and 201. Added by Russell Taylor (21/8/98)
           IF (iproc.eq.1) THEN
             CALL HCDIR('//PAWC/95219',' ')
             CALL HBOOKB(50,'Temp',9,xbins1,0.)
             CALL HBARX(50)
             DO K=1,9
                xbins6(K)=1./(xbins1(K+1)-xbins1(K))
             ENDDO
             CALL HPAK(50,xbins6)
           ENDIF

          IF (Xsec.eq.0) THEN
	    PRINT*,'HZ95219: termination called with zero cross section'
	    PRINT*,'          cross section graph meaningless'
	    PRINT*,'	      in process :',iproc*1000
	    Xsec=1
	  ENDIF
	  IF (Ntot.eq.0) THEN
	    PRINT*,'HZ95219: termination called with no total events'
	    PRINT*,'          cross section graph meaningless'
	    PRINT*,'	      in process :',iproc*1000
	    Ntot=1
	  ENDIF
          ANORM(iproc)=0.
C          WRITE(6,*)  'Hz95219: Ntot,Xsec,GEN= ',Ntot,Xsec,' nb  ',GEN
          ANORM(iproc)=Xsec/Ntot
C          WRITE(6,*)  'Hz95219: normalization factor=',ANORM(iproc)

          IF (iproc.eq.2) THEN
            CALL HCDIR('//PAWC/95219',' ')
            CALL HOPERA(101,'*e',50,101,1.,1.)
            CALL HOPERA(201,'*e',50,201,1.,1.)

            CALL HOPERA(101,'+e',101,101,ANORM(1),0.)
            CALL HOPERA(102,'+e',102,102,ANORM(1),0.)
            CALL HOPERA(103,'+e',103,103,ANORM(1),0.)
            CALL HOPERA(104,'+e',104,104,ANORM(1),0.)
            CALL HOPERA(105,'+e',105,105,ANORM(1),0.)
            CALL HOPERA(201,'+e',201,201,ANORM(2),0.)
            CALL HOPERA(202,'+e',202,202,ANORM(2),0.)
            CALL HOPERA(203,'+e',203,203,ANORM(2),0.)
            CALL HOPERA(204,'+e',204,204,ANORM(2),0.)
            CALL HOPERA(205,'+e',205,205,ANORM(2),0.)

            CALL HOPERA(101,'+e',201,1,1.,1.)
            CALL HOPERA(102,'+e',202,2,1.,1.)
            CALL HOPERA(103,'+e',203,3,1.,1.)
            CALL HOPERA(104,'+e',204,4,1.,1.)
            CALL HOPERA(105,'+e',205,5,1.,1.)
          ENDIF

        ELSE
          WRITE(6,*) 'Hz95219: Unknown flag',iflag
        ENDIF
        RETURN
        END
*CMZ :  1.01/15 12/08/98  10.38.06  by  Tancredi Carli
*CMZ :  1.01/11 09/12/97  16.44.12  by  Tancredi Carli
*CMZ :  1.01/07 10/10/97  19.46.51  by  Tancredi Carli
*CMZ :  1.01/05 06/09/96  18.29.24  by   Tancredi Carli
*CMZ :  1.00/02 12/03/96  18.37.10  by  Tancredi Carli
*CMZ :  1.00/01 22/02/96  17.21.46  by  Tancredi Carli
*CMZ :  0.00/09 16/02/96  17.15.48  by  Tancredi Carli
*CMZ :  0.00/08 15/02/96  12.22.32  by  Tancredi Carli
*CMZ :  0.00/03 16/01/96  18.08.21  by  Tancredi Carli
*CMZ :  0.00/01 05/01/96  18.24.07  by  HZtool
*-- Author :
      Subroutine hz95221(iflag)
******************************************************************************
*  Subroutine hz95221                                                        *
*  ==================                                                        *
*                                                                            *
* Author: Jane Bromley (bromley@v2.ph.gla.ac.uk)                             *
*                                                                            *
* This routine plots distributions of charged hadron multiplicities in the   *
* hadronic centre of mass frame as a function of the scaled longitudinal     *
* momentum xF and the transverse momentum pT* in a restricted Q2 and W2      *
* range.  Data is given for events with and without a large rapidity gap.    *
*                                                                            *
* Beams: 26.7 GeV electrons, 820 GeV protons   [1993 HERA running]           *
*                                                                            *
* Event selection:                                                           *
* 75 < W < 175 GeV                                                           *
* 10 < Q2 < 160 GeV^2                                                        *
* For the pT* distributions, xF > 0.05                                       *
*                                                                            *
* Reference:  DESY 95-221                                                    *
* Modified: histogram identifier scheme changed as in other routines         *
*           IDdata=-IDmc                                                     *
*           In addition MC histograms with same bins as data                 *
*           Introduce check on electron beam energy
******************************************************************************
*
*        HERA tuning defined commons:
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEND.
*
* Local variables
*
      Character xxxx*5
      character*80 chtitl
      real xmi, xma, ymi, yma, nnrg, nlrg
      Save xmi, xma, ymi, yma, nnrg, nlrg
*
      Real Nacc
      Save Nacc
      double precision  pgam(5),pgam4(4),q2,w2,eta,etamax
      double precision pt,xf,theta,plab(4),phcm(4),pbeam(4)
      integer nx,ny,ip,il,ierr,I,J,L,ntrack,jflag,idum,lepid
      Real eb,ee
      Save eb
      Real tmperr(7)
      Integer id, ierrp
      Parameter (ee=26.7)
      Integer nentry
* CUTS:
      double precision q2cut(2), w2cut(2), xfcut
*
* Data points from plots:
*
      Real nrgxf(8), nrgpt(11), nrgmpt(7), lrgxf(8),lrgpt(8),lrgmpt(7)
      Real xfnbin(9), ptnbin(12), ptlbin(9), bothxf(8), bothpt(11)

      Real nrgxfe(8), nrgpte(11),nrgmpte(7),lrgxfe(8),lrgpte(8)
      Real lrgmpte(7)
      Real bothxfe(8),bothpte(11),bothmpt(7),bothmpte(7),mptbin(8)
*
      Data xxxx/'95221'/
      Data nentry/0/

      data nrgxf/64.96, 27.92, 12.89, 6.67, 2.86, 1.15, 0.36, 0.07/
      data nrgxfe/10.56,4.28,1.98,.98,.45,.15,.08,.02/
      data nrgpt/1.05,2.84,3.89,3.34,2.24,1.10,0.47,0.23,0.08,0.03,0.01/
      data nrgpte/.19,.51,.60,.47,.33,.18,.07,.03,.01,.004,.0014/
      data nrgmpt/0.47,0.63,0.85,1.19,1.50,2.30,2.09/
      data nrgmpte/.02,.04,.05,.08,.16,.38,.74 /
      data lrgxf/26.97,19.70,12.16,6.49,4.02,1.41,0.68,0.31/
      data lrgxfe/3.17,1.55,1.82,1.17,.94,.50,.16,.1 /
      data lrgpt/1.36,4.31,4.91,3.44,1.45,0.64,0.09,0.001/
      data lrgpte/.5,.16,.41,.34,.55,.046,.02,.004 /
      data lrgmpt/0.19,0.24,0.35,0.41,0.38,0.50,0.37/
      data lrgmpte/.02,.06,.09,.19,.13,.16,.61 /
      data xfnbin/0.03,0.05,0.10,0.15,0.22,0.32,0.45,0.65,0.90/
      data ptnbin/0.0,0.10,0.20,0.40,0.60,0.80,1.2,1.5,2.0,2.75,3.5,5.0/
      data ptlbin/0.0,0.1,0.2,0.4,0.6,0.8,1.2,2.0,5.0/
      data bothxf/62.99,27.48,12.86,6.67,2.90,1.18,0.37,0.08/
      data bothxfe/9.62,4.04,2.,1.09,.47,.17,.08,.03 /
      data bothpt/1.10,2.92,3.98,3.35,2.22,1.07,0.45,.22,.07,.02,.01/
      data bothpte/.18,.52,.6,.47,.32,.18,.08,.03,.01,.004,.0014 /
      data bothmpt/.46,.61,.82,1.14,1.4,2.13,1.82/
      data bothmpte/.02,.04,.05,.08,.14,.43,.63/
      data mptbin/0.05,.1,.15,.22,.32,.45,.65,.90/
*
      save nrgxf,nrgxfe, nrgpt, nrgpte, nrgmpt, nrgmpte
      save lrgxf, lrgxfe,lrgpt,lrgpte,lrgmpt,lrgmpte
      Save xfnbin,ptnbin,ptlbin,bothxf, bothxfe,bothmpt
      Save bothmpte,mptbin
*
* INITIALISATION
*
        if (iflag.eq.1) then
*
        Nacc = 0.
        nnrg = 0.
        nlrg = 0.
*
	call hcdir('//PAWC',' ')
        call hmdir('95221','S')
        Call hcdir('//HISTO',' ')
        call hmdir('95221','S')
*
* Book histos:
*
       call Hbook1(111, 'fin bin xF - NRG', 50, 0., 1., 0.)
       call Hbook1(112, 'fin bin pt* - NRG', 50, 0., 5., 0.)
       call Hbprof(113, 'fin bin ptsq vs xf - NRG',
     & 20,0.,1.,0.,100.,' ')
*
       call Hbook1(121, 'fin bin xF - LRG', 50, 0., 1., 0.)
       call Hbook1(122, 'fin bin pt* - LRG', 50 , 0., 5., 0.)
       call Hbprof(123, 'fin bin ptsq vs xf - LRG',
     & 20,0.,1.,0.,100.,' ')

       call Hbook1(131, 'fin bin xF - both', 50, 0., 1., 0.)
       call Hbook1(132, 'fin bin pt* - both', 50 , 0., 5., 0.)
       call Hbprof(133, 'fin bin ptsq vs xf - both'
     & ,20,0.,1.,0.,100.,' ')
*
* Book histos with same bining as data
*
        call hbookb(11,'1/N dn/dxf(NRG data)',8,xfnbin,0.)
        call hbookb(12,'1/N dn/d-pt(NRG data)',11,ptnbin,0.)
        call hbookb(13,'seagull (NRG data)',7,mptbin,0.)
        call hbookb(1013,'seagull (NRG data)',7,mptbin,0.)
        call hbookb(2013,'seagull (NRG data)',7,mptbin,0.)
        call hbookb(21,'1/N dn/dxf(LRG data)',8,xfnbin,0.)
        call hbookb(22,'1/N dn/d-pt(LRG data)',8,ptlbin,0.)
        call hbookb(23,'seagull (LRG data)',7,mptbin,0.)
        call hbookb(1023,'seagull (LRG data)',7,mptbin,0.)
        call hbookb(2023,'seagull (LRG data)',7,mptbin,0.)
        call hbookb(31,'1/N dn/dxf(combined data)',8,xfnbin,0.)
        call hbookb(32,'1/N dn/d-pt(combined data)',11,ptnbin,0.)
        call hbookb(33,'seagull (combined data)',7,mptbin,0.)
        call hbookb(1033,'seagull (combined data)',7,mptbin,0.)
        call hbookb(2033,'seagull (combined data)',7,mptbin,0.)
*
* set cuts:
        q2cut(1)= 10.
        q2cut(2)= 160.
        w2cut(1) = 5625.
        w2cut(2) = 30625.
*
* ANALYSIS:
*
      Else if(iflag.eq.2) then
*
        call hcdir('//PAWC/95221',' ')
*
*  Check electron beam energy
*
       nentry=nentry+1
       ierr=HZIBEAM(ibeam,idum)
       if (.not.(ierr.eq.1)) then
        write(6,*) 'HZ'//xxxx,' beams not found ! '
        return
       endif
*
       eb=real(PHEP(4,idum))
       if (abs(abs(eb)-ee).ge.0.2) then
        if (nentry.lt.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,'  ! '
        elseif (nentry.eq.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &   ' ...last message ! '
        endif
C        return
       endif
*
* Event Selection:
*
*
         q2=hzdiskin(1)
         w2=hzdiskin(4)
*
         jflag = 0
         etamax = -20.
         xf = 0.
         pt = 0.
*
         if (q2.gt.q2cut(1).and.q2.lt.q2cut(2).and.
     &        w2.gt.w2cut(1).and.w2.lt.w2cut(2)) then
              Nacc = Nacc + wtx
*
* INITIALISE BOOST:
*
                 if (hzibeam(ip,il).ne.1) then
                    write (6,*) 'Proton beam not found'
                    return
                 endif
                 if (Hzipgam(pgam).lt.0) then
                    write (6,*) 'Photon momentum not found'
                    return
                 endif
                 lepid=hzidelec(idum)
                 if (lepid.lt.0) then
                     write (6,*) 'Id of electron not found'
                     return
                 endif
              do J=1,4
                 pbeam(J) = phep(J,ip)
                 pgam4(J)=pgam(J)
              end do
              call HZHCMINI(pbeam,pgam4,Ierr)
              if(Ierr.eq.1) then
                 write (6,*) ' HZHCMINIT failed'
                 return
              endif
*
* Fill histos:
*
         do 29 J = 1,Nhep
            if(isthep(J).eq.1.and.J.ne.lepid.and.
     &        abs(idhep(jmohep(1,J))).ne.130.and.
     &        abs(idhep(jmohep(1,J))).ne.310.and.
     &        abs(idhep(jmohep(1,J))).ne.3122) then
              pt = sqrt(phep(1,J)**2+phep(2,J)**2)
              theta= hzphmang(phep(3,J),pt)
              if (theta.gt.1.e-4 .and. theta.lt.pi-1.e-4) then
               eta= -1.*log(tan(theta/2.))
              else
               eta=-999.
              endif
              if(sqrt(w2).gt.175) then
                 if(eta.lt.6.) then
                    if (eta.gt.etamax) etamax=eta
                 endif
              elseif(sqrt(w2).lt.175.and.sqrt(w2).gt.70.) then
                 if(eta.lt.5.5) then
                    if (eta.gt.etamax) etamax=eta
                 endif
              endif
           endif
 29      end do

             if (etamax.ge.1.5) then
                 jflag = 1
                 nnrg = nnrg + wtx
             endif
             if (etamax.lt.1.5) then
                 jflag = 2
                 nlrg = nlrg + wtx
             endif

         do 30 I = 1,Nhep
         if (isthep(I).eq.1.and.ihchrg(I).ne.0.and.
     &        abs(idhep(jmohep(1,I))).ne.130.and.
     &        abs(idhep(jmohep(1,I))).ne.310.and.
     &        abs(idhep(jmohep(1,I))).ne.3122.and.
     &        I.ne.lepid) then
             do J = 1,4
                 Plab(J)=phep(J,I)
             enddo
             call HZHCM(plab, phcm, Ierr)
             if(Ierr.eq.1)  then
                 write (6,*) ' HZHCM BOOST failed'
                 return
             endif
             pt = sqrt(phcm(1)**2+phcm(2)**2)
             xf = 2.*Phcm(3)/sqrt(W2)
             call Hf1(131, sngl(xf), wtx)
             call Hfill( 31, sngl(xf),0., wtx)
             if (xf.gt.0.05) then
                call Hf1(132, sngl(pt), wtx)
                call Hfill(133, sngl(xf), sngl(pt**2), wtx)
                call Hf1(32, sngl(pt), wtx)
                call Hf1(33, sngl(xf), sngl(pt**2)*wtx)
                call Hf1(1033, sngl(xf), wtx)
                call Hf1(2033, sngl(xf), sngl(pt**4)*wtx)
             endif
             call hf1(100+jflag*10+1,sngl(xf),wtx)
             call hfill(jflag*10+1,sngl(xf),0.,wtx)
             if (xf.gt.0.05) then
                call hf1(100+jflag*10+2, sngl(pt), wtx)
                call hfill(100+jflag*10+3,sngl(xf),sngl(pt**2),wtx)
                call hfill(jflag*10+2,sngl(pt),0., wtx)
                call hf1(jflag*10+3,sngl(xf),sngl(pt**2)*wtx)
                call hf1(1000+jflag*10+3,sngl(xf),wtx)
                call hf1(2000+jflag*10+3,sngl(xf),sngl(pt**4)*wtx)
             endif
         endif
 30	 continue
*                        for q2 and w2 cut
	 endif
*
* TERMINATION:
*
       Else if(iflag.eq.3) then
*
        call hcdir('//PAWC/95221',' ')
*
        write (6,*) 'Hz',xxxx,': '
        write (6,*) ' number accepted = ',Nacc
        write (6,*) ' num non Rap Gap events = ',nnrg
        write (6,*) ' num large Rap gap events = ',nlrg
*
        if (nlrg.eq.0.) nlrg = nacc
*
* Deal with data plots
*
        call hbookb(-11,'1/N dn/dxf(NRG data)',8,xfnbin,0.)
        call hbookb(-12,'1/N dn/d-pt(NRG data)',11,ptnbin,0.)
        call hbookb(-13,'seagull (NRG data)',7,mptbin,0.)
        call hbookb(-21,'1/N dn/dxf(LRG data)',8,xfnbin,0.)
        call hbookb(-22,'1/N dn/d-pt(LRG data)',8,ptlbin,0.)
        call hbookb(-23,'seagull (LRG data)',7,mptbin,0.)
        call hbookb(-31,'1/N dn/dxf(combined data)',8,xfnbin,0.)
        call hbookb(-32,'1/N dn/d-pt(combined data)',11,ptnbin,0.)
        call hbookb(-33,'seagull (combined data)',7,mptbin,0.)
        call hpak(-11,nrgxf)
        call hpake(-11,nrgxfe)
        call hpak(-12,nrgpt)
        call hpake(-12,nrgpte)
        call hpak(-13,nrgmpt)
        call hpake(-13,nrgmpte)
        call hpak(-21,lrgxf)
        call hpake(-21,lrgxfe)
        call hpak(-22,lrgpt)
        call hpake(-22,lrgpte)
        call hpak(-23,lrgmpt)
        call hpake(-23,lrgmpte)
        call hpak(-31,bothxf)
        call hpake(-31,bothxfe)
        call hpak(-32,bothpt)
        call hpake(-32,bothpte)
        call hpak(-33,bothmpt)
        call hpake(-33,bothmpte)
*
        do 33 J = 1,2
         Call hgive(110+J,chtitl,nx,xmi,xma,ny,ymi,yma,nwt,loc)
         Call hopera(110+J,'+e',110+J,110+J,
     +            1./real(nnrg)*real(nx)/(xma-xmi),0.)
*
         call hzhinfo(110+j,nnrg)
         call hzhinrm(10+j,0,nnrg,1)
         call hzhinfo(10+j,nnrg)
         call hzchisq(-10-j,10+j)
*
         Call hgive(120+J,chtitl,nx,xmi,xma,ny,ymi,yma,nwt,loc)
         Call hopera(120+J,'+e',120+J,120+J,
     +            1./real(nlrg)*real(nx)/(xma-xmi),0.)
*
         call hzhinfo(120+j,nlrg)
         call hzhinrm(20+j,0,nlrg,1)
         call hzchisq(-20-j,20+j)
*
         Call hgive(130+J,chtitl,nx,xmi,xma,ny,ymi,yma,nwt,loc)
         Call hopera(130+J,'+e',130+J,130+J,
     +            1./real(nacc)*real(nx)/(xma-xmi),0.)
         call hzhinfo(30+j,nacc)
         call hzhinrm(30+j,0,nacc,1)
         call hzchisq(-30-j,30+j)
*
 33     end do
*
        Do id = 13,33,10
        Call Hopera(id,'/',1000+id,id,1.,1.)
        Call Hopera(2000+id,'/',1000+id,2000+id,1.,1.)
        Call Hopera(id,'*',id,3000+id,1.,1.)
        call Hopera(2000+id,'-',3000+id,3000+id,1.,1.)
        Call Hopera(3000+id,'/',1000+id,3000+id,1.,1.)
        Call Hunpak(3000+id,tmperr,' ',0)
        Do ierrp = 1, 7
           tmperr(ierrp) = sqrt(tmperr(ierrp))
        Enddo
        Call Hpake(id,tmperr)
        Call hdelet(1000+id)
        Call hdelet(2000+id)
        Call hdelet(3000+id)
*
        call hzhinfo(id,nnrg)
        Call Hzchisq(-id,id)
       Enddo
*
      Endif
*
      Return
      End

*CMZ :  2.00/04 31/07/2000  17.43.50  by  Tancredi Carli
*CMZ :  1.02/00 02/10/98  19
*-- Author :
        Subroutine HZ96094(iflag)
*****************************************************************************
* This photoproduction routine has to be run twice with the following
* code additions:
*       +1000 for the DIRECT component run.
*       +2000 for the RESOLVED component run.
* for all three phases (iflag=1,2,3)
*
* iflag = 1,2 or 3 depending on wether it is the initialization,
*               processing or termination phase (respectively)
*
* The default jetfinder is EUCELL
* To change jetfinder use these values to call the initialisation phase.
* 1 + 10 * (jetfinder number)
*
* This routine produces two Monte Carlo graphs.
*               10 d\sigma/d|cos(theta*)| DIRECT
*               20 d\sigma/d|cos(theta*)| RESOLVED
*
*               -10 and -20 are the equivalent data graphs (stat. errors)
*               -11 and -21 include full stat+sys errors
*
* Cuts :        Q2 < 4 GeV^2
*               0.25 < y_jb < 0.8
*               Et > 6 GeV
*               M_jj > 23 GeV
*               |eta_bar| < 0.5
*
* Recommended value for Ptmin is 2.5 GeV (to be set in MC set up)
*
* Author : Mark Hayes (mhayes@zow.desy.de)
*
* Reference : DESY-96-094
*             Phys. Lett. B384 (1996) 401-413.
*
*
*****************************************************************************
*
* HERA Tuning defined commons

        IMPLICIT NONE

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.

c *** Data for DIRECT
        REAL cs(10),sta(10),syshi(10),syslo(10)
        DATA cs/0.80,0.83,0.98,0.90,1.26,1.50,1.41,2.70,3.81,5.99/
        DATA sta/0.12,.13,.15,.14,.19,.18,.17,.28,.33,.48/
        DATA syshi/.06,.07,.02,.02,.15,.08,.18,.36,.14,.81/
        DATA syslo/.09,.13,.13,.08,.16,.19,.08,.35,.29,.40/
c *** Data for RESOLVED
        REAL cs2(10),sta2(10),syshi2(10),syslo2(10)
        DATA cs2/0.21,0.23,0.23,0.28,0.27,0.42,0.77,1.13,2.03,4.31/
        DATA sta2/.08,.12,.10,.09,.10,.11,.17,.21,.25,.43/
        DATA syshi2/.06,.09,.04,.13,.10,.11,.08,.16,.36,.47/
        DATA syslo2/.08,.12,.07,.02,.06,.04,.08,.26,.19,.39/
c *** bin width
        REAL bw
        DATA bw/0.085/

C --- cuts arrays
        DOUBLE PRECISION ybjcut(2),q2cut(2)
        DOUBLE PRECISION rapcut(2),Etcut(4)
C --- photoproduction cuts
        DATA ybjcut/0.25,0.8/
        DATA q2cut/0.0,4/
        DATA Etcut/6.0,6.0,6.0,6.0/
        DATA rapcut/-3.8,4.1/
        Integer chjet
        SAVE chjet
C --- choose same jet finder as in the paper --- EUCELL
        DATA chjet/1/
        CHARACTER*6 jetf

C --- information returned by jet finder
        INTEGER NJET
        DOUBLE PRECISION Jets(50,8)
        DOUBLE PRECISION CONER

C --- private copies of Xsec and Ntot from HERACMN
        DOUBLE PRECISION mhxsec(2),mhntot(2)

c ---
        DOUBLE PRECISION elecE
        INTEGER myil,myip,loop
        DOUBLE PRECISION deltaeta,etabar,xgam,costh,mjj
        DOUBLE PRECISION rap(2),Et(2),phi(2)
        DOUBLE PRECISION ybj,q2

        INTEGER intiflag, iproc, iflag
        INTEGER hzflag

        REAL pttemp(12)
        INTEGER ivec,jvec
C        REAL sqrt

C --- choose direct/resolved
C --- recommend 1 - DIRECT, 2 - RESOLVED
        IF (iflag.gt.1000) THEN
          iproc=INT(iflag/1000)
          intiflag=MOD(iflag,1000)
        ENDIF
        IF ((iproc.gt.2).or.(iproc.lt.1)) THEN
          PRINT*,'HZ96094 : Badly called routine'
          PRINT*,'          please set intiflag +1000 or +2000'
        ENDIF

C --- choose jet finder
        IF ((intiflag.gt.10).and.(MOD(intiflag,10).eq.1)) THEN
          chjet=INT(intiflag/10)
          intiflag=MOD(intiflag,10)
        ENDIF

        IF (intiflag.eq.1) THEN
C *** Initialisation run ***
C *** Create directories ***
          IF (iproc.eq.1) THEN
            CALL HCDIR('//HISTO',' ')
            CALL HMDIR('96094','S')
            CALL HCDIR('//PAWC',' ')
            CALL HMDIR('96094','S')

            CALL HBOOK1(10,'Monte Carlo cos(theta) DIRECT'
     &          ,10 ,0.000 ,0.850 ,0.)
            CALL HBOOK1(20,'Monte Carlo cos(theta) RESOLVED'
     &          ,10 ,0.000 ,0.850 ,0.)
          ENDIF
            CALL HCDIR('//HISTO/96094',' ')
            CALL HCDIR('//PAWC/96094',' ')
            CALL HBOOK1(iproc*100+10,
     &          'Monte Carlo cos(theta) xg.gt.0.75'
     &          ,10 ,0.000 ,0.850 ,0.)
            CALL HBOOK1(iproc*100+11,
     &          'Monte Carlo cos(theta) xg.lt.0.75'
     &          ,10 ,0.000 ,0.850 ,0.)

C --- standard cone radius is 1.0
          CALL HZJETRAD(2,CONER)
          IF (CONER.lt.0.0) THEN
            CONER=1.0
          ENDIF
          CALL HZJTNAME(chjet,jetf)

          WRITE(6,*)'**********************************************'
          WRITE(6,*)'* HZ96094 called, histograms will be output. *'
          WRITE(6,*)'*     Jet finder selected : ',jetf,'           *'
          WRITE(6,1001)'*        with cone radius : ',CONER,'   *'
          WRITE(6,*)'**********************************************'

 1001     FORMAT(A29,F5.2,A13)

        ELSE IF (intiflag.eq.2) THEN
C *** Filling runs ***

C *** Change directory to our graphs ***
          CALL HCDIR('//PAWC/96094',' ')

          q2=hzphokin(1)
          IF (q2.eq.-1) THEN
            PRINT*,'HZ96094: HZPHOKIN returns error for Q2'
          ELSEIF (q2.lt.0) THEN
            q2=abs(q2)
          ENDIF
          ybj=hzphokin(3)
          IF (ybj.eq.-1) THEN
            PRINT*,'HZ96094: HZPHOKIN returns error for ybj'
          ENDIF

C *** Fill our histogram ***

          IF ((ybj.ge.ybjcut(1)).and.(ybj.le.ybjcut(2))
     &          .and.(q2.lt.q2cut(2))) Then

          elecE=27.5
          hzflag=HZIBEAM(myip,myil)
          IF (hzflag.ge.0) Then
            elecE=abs(PHEP(4,myil))
          ELSE
            PRINT*,'HZ96094: Electron not found. E=0.001'
            PRINT*,'         event will be rejected'
            elecE=0.001
          ENDIF

            CALL hzjtfind(chjet,CONER,NJET,Jets)

            IF (NJET.ge.2) THEN
              DO loop=1,2
                Et(loop)=Jets(loop,3)
                phi(loop)=Jets(loop,2)
                rap(loop)=Jets(loop,1)
              ENDDO
              deltaeta=abs(rap(1)-rap(2))
              etabar=(rap(1)+rap(2))/2
              xgam=(Et(1)*exp(-1*rap(1))+Et(2)*exp(-1*rap(2)))
     +           /(2*ybj*elecE)
              costh=abs(tanh(deltaeta/2))
              mjj=dsqrt(2*et(1)*et(2)*(cosh(rap(1)-rap(2))
     +                   -cos(phi(1)-phi(2))))

              IF (Et(2).gt.Etcut(1).and.Mjj.gt.23
     +            .and.abs(etabar).lt.0.5) THEN
                IF (xgam.gt.0.75) THEN
                  CALL HFILL(INT(iproc*100+10), REAL(costh) , 0. ,wtx)
                ELSE
                  CALL HFILL(INT(iproc*100+11), REAL(costh) , 0. ,wtx)
                ENDIF
              ENDIF
            ENDIF

          ENDIF         ! Q2 & y cuts

        ELSE IF (intiflag.eq.3) THEN
C *** Termination run ***
C *** Change directory ***
          CALL HCDIR('//PAWC/96094',' ')
C *** Finish off histograms ***

          IF (Xsec.eq.0) THEN
            PRINT*,'HZ96094: termination called with zero cross section'
            PRINT*,'          cross section graph meaningless'
            PRINT*,'          in process :',iproc*1000
            Xsec=1
          ENDIF
          IF (Ntot.eq.0) THEN
            PRINT*,'HZ96094: termination called with no total events'
            PRINT*,'          cross section graph meaningless'
            PRINT*,'          in process :',iproc*1000
            Ntot=1
          ENDIF

C --- store Xsec and Ntot for both direct and resolved events.
          mhXsec(iproc)=Xsec
          mhntot(iproc)=Ntot

          IF (iproc.eq.2) THEN
C --- only finally
C --- create proper cross-section data
            CALL HBOOK1(-10,'Data cos(theta) DIRECT'
     &          ,10 ,0.000 ,0.850 ,0.)
            CALL HBOOK1(-20,'Data cos(theta) RESOLVED'
     &          ,10 ,0.000 ,0.850 ,0.)


            CALL HPAK(-10,cs)
            CALL HPAKE(-10,sta)
            CALL HPAK(-20,cs2)
            CALL HPAKE(-20,sta2)

            CALL HBOOK1(-11,'Data full errors (nb) x_gam ge 0.75'
     &          ,10 ,0.000 ,0.850 ,0.)
            CALL HBOOK1(-21,'Data full errors (nb) x_gam lt 0.75'
     &          ,10 ,0.000 ,0.850 ,0.)

            CALL HPAK(-11,cs)
            DO ivec=1,10
              pttemp(ivec)=sqrt(sta(ivec)**2+syslo(ivec)**2)
            ENDDO
            CALL HPAKE(-11,pttemp)
            CALL HPAK(-21,cs2)
            DO ivec=1,10
              pttemp(ivec)=sqrt(sta2(ivec)**2+syslo2(ivec)**2)
            ENDDO
            CALL HPAKE(-21,pttemp)

C --- normalise resolved/direct component histograms
C --- added 20/8/98 by Russell Taylor
           CALL HOPERA(110,'+e',110,110,REAL(mhXsec(1)/mhNtot(1)/bw),0.)
           CALL HOPERA(111,'+e',111,111,REAL(mhXsec(1)/mhNtot(1)/bw),0.)
           CALL HOPERA(210,'+e',210,210,REAL(mhXsec(2)/mhNtot(2)/bw),0.)
           CALL HOPERA(211,'+e',211,211,REAL(mhXsec(2)/mhNtot(2)/bw),0.)

C --- now calculate cross-section graphs 10,20
            CALL HOPERA(110,'+e',210,10,1.,1.)
            CALL HOPERA(111,'+e',211,20,1.,1.)
C            CALL HZCHISQ(-10,10)
C            CALL HZCHISQ(-20,20)
          ENDIF

        ELSE
C *** End ***
          PRINT*,'HZ96094:Please run routine with iflag set to 1,2 or 3'
          PRINT*,'        with +1000 or +2000 for DIR or RES events.'
        ENDIF

        RETURN
        END
*CMZ :  1.01/15 18/04/98  21.01.57  by  Tancredi Carli
*CMZ :  1.01/11 30/12/97  09.34.09  by  Tancredi Carli
*CMZ :  1.01/07 13/10/97  12.12.22  by  Tancredi Carli
*CMZ :  1.01/05 25/11/96  19.42.25  by  Tancredi Carli
*-- Author :    Tancredi Carli   03/09/96
*-- Author :
      Subroutine hz96122(iflag)
******************************************************************************
*                                                                            *
* Author: Birger Koblitz (koblitz@dice2.desy.de)                             *
*                                                                            *
* This routine plots angular and pT2 distributions of k0 and lambda          *
* particles. Additionaly the mean number of K0s and this number divided by   *
* the mean number of Tracks is plotted with respect to x in three Q2 bins:   *
* 10GeV < Q2 < 15GeV, 15GeV < Q2 < 35GeV, 35GeV <Q2< 70GeV                   *
* At last the seagull plot is drawn in the hadronic center of mass system    *
* with mean pT2 over x_F                                                     *
*                                                                            *
* Beams: 27.6 GeV electrons, 820 GeV protons   [1994 HERA running]           *
*                                                                            *
* Event selection:                                                           *
* 10GeV2 < Q2 < 70 GeV2                                                      *
* 1E-4 < x < 0.01                                                            *
* 0.05 < y < 0.6                                                             *
* Energie deposited in polar angular range 4.4deg < theta < 15deg > 0.5 GeV  *
*                                                                            *
* Reference:                                                                 *
* Modified:                                                                  *
******************************************************************************
      implicit none
      integer iflag
*
*        HERA tuning defined commons:
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEND.
*
* Local variables
*
      Real                ee,eb
      Parameter           (ee=27.6)
      Character           xxxx*5
      Double Precision    w2,q2,eta,theta,pt,Xkin,Ykin,pt2,xF
      Double precision    pbeam(4), pgam(4),pgam4(4)
      Double Precision    plab(4),pcms(4)
      Integer             IErr
      Integer             ebid,pbid,lepid,ip
      Integer             HId,I,J,N
      Real                NAcc,NAcc2,NTotal
      Real                efwd,rd,pi,NormC
      Integer             EvInB(6)
      Real                a(6),e(6),s(6)

      Parameter           (pi=3.1415927,rd=180./pi)
* CUTS:
      Double Precision    q2cut(2), w2cut(2)
*
* Data points from plots:
*
*
      Real etak(8),etakt(8),etake(8)
      Real etal(4),etalt(4),etale(4)
      Real ptsl(4),ptslt(4),ptsle(4)
      Real seabin(5),logb1(5),logb2(5),logb3(4)
      Real seadat(4),seaerr(4)
      Real k0dat(8),k0err(8)

      Data xxxx/'96122'/

      Data etal/0.013405,0.0137718,0.0257133,0.028401/
      Data etalt/0.0046255,0.00363401,0.00593823,0.0056646/
      Data etale/ 0.00692702,0.00530095,0.00874126,0.00844715/

      Data ptsl/0.0334636,0.00766033,0.00394519,0.00572521/
      Data ptslt/0.0058265,0.00209549,0.000841117,0.00151743/
      Data ptsle/0.00876668,0.00304164,0.00129237,0.00226776/

      Data etak/0.0676159,0.0970571,0.102679,0.0999274,0.104132,
     &          0.117154,0.142281,0.12515/
      Data etakt/0.0062,0.0075,0.0078,0.0074,0.0077,0.0082,
     &          0.0093,0.0091/
      Data etake/0.0105,0.0141,0.0147,0.0140,0.0146,0.0163,
     &          0.0196,0.0182/


      Data seabin/0.05,0.1,0.15,0.2,0.4/

      Data logb1/2.7740E-4,5.1299E-4,9.4868E-04,1.7544E-3,3.2445E-3/
      Data logb2/5.1299E-4,9.4868E-04,1.7544E-3,3.2445E-3,6E-3/
      Data logb3/9.4868E-04,1.7544E-3,3.2445E-3,6E-3/
      Data seadat/0.47,0.84,0.85,1.70/
      Data seaerr/0.11,0.38,0.28,0.43/

      Data k0dat/0.05,0.11,0.11,0.16,0.14,0.14,0.18,0.11/
      Data k0err/0.01,0.02,0.02,0.02,0.02,0.02,0.04,0.02/
*
* INITIALISATION
*
      if (iflag.eq.1) then
*
        NTotal=0.
        NAcc = 0.
        NAcc2= 0.
        do I=1,6
          EvInB(I)=0
        end do
*
	call hcdir('//PAWC',' ')
        call hmdir(xxxx,'S')
        Call hcdir('//HISTO',' ')
        call hmdir(xxxx,'S')
*
* Book histos:
*
        call Hbook1(100, 'eta-spectrum of K0', 8, -1.3,1.3, 0.)
        call Hbook1(101, 'p_T2-spectrum of k0',8,0.25,4.5,0.)
        call Hbook1(110, 'eta-spectrum of lambda', 4, -1.3,1.3, 0.)
        call Hbook1(111, 'p_T2-spectrum of lambda',4,0.25,4.5,0.)
*
        call HbookB(120, '<K0> in 10<Q2<15',4,logb1,0.)
        call HbookB(121, '<K0> in 15<Q2<35',4,logb2,0.)
        call HbookB(122, '<K0> in 35<Q2<70',3,logb3,0.)
*
        call HbookB(130, '<K0>/<Tracks> in 10<Q2<15',4,logb1,0.)
        call HbookB(131, '<K0>/<Tracks> in 15<Q2<35',4,logb2,0.)
        call HbookB(132, '<K0>/<Tracks> in 35<Q2<70',3,logb3,0.)
*
        call HbookB(900, '<Tracks> in 10<Q2<15',4,logb1,0.)
        call HbookB(901, '<Tracks> in 15<Q2<35',4,logb2,0.)
        call HbookB(902, '<Tracks> in 35<Q2<70',3,logb3,0.)

        call HbookB(910, 'norm 10<Q2<15',4,logb1,0.)
        call HbookB(911, 'norm 15<Q2<35',4,logb2,0.)
        call HbookB(912, 'norm 35<Q2<70',3,logb3,0.)

        call HbookB(200, 'seagull',4,seabin,0.)
        call HbookB(10, 'seagull-norm',4,seabin,0.)

        call HBook1(300,'K0 eta spektrum (Instantons)',8, -1.3,1.3, 0.)
*
* set cuts:
*
        q2cut(1) = 10.
        q2cut(2) = 70.
      end if
*
* ANALYSIS:
*
      if(iflag.eq.2) then
*
        call hcdir('//PAWC',' ')
        call hcdir(xxxx,' ')
*
*  Check electron beam energy
*
        NTotal=NTotal+wtx
        ierr=HZIBEAM(pbid,ebid)
        if (.not.(ierr.eq.1)) then
          write(6,*) 'HZ'//xxxx,' Beams not found ! '
          return
        endif
        eb=real(PHEP(4,ebid))
        if (abs(abs(eb)-ee).ge.0.2) then
          if (NTotal.lt.10) then
            write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,'  ! '
          elseif (NTotal.eq.10.) then
            write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &   ' ...last message ! '
          endif
C          return
        endif
*
* Event Selection:
*
*
         q2=hzdiskin(1)
         w2=hzdiskin(4)
         XKin=HZDISKIN(2)
         Ykin=HZDISKIN(3)
*
         if (q2.gt.q2cut(1).and.q2.lt.q2cut(2)
     &       .and.Xkin.gt.1.D-4.and.Xkin.lt.0.01
     &       .and.Ykin.gt.0.05.and.Ykin.lt.0.6) then
*
* INITIALISE BOOST:
*
           if (Hzipgam(pgam).lt.0) then
             write (6,*) 'Photon momentum not found'
             return
           endif
           lepid=hzidelec(0)
           if (lepid.lt.0) then
             write (6,*) 'Id of electron not found'
             return
           endif
           do J=1,4
             pbeam(J) = PHEP(J,pbid)
             pgam4(J) = pgam(J)
           end do
           call HZHCMINI(pbeam,pgam4,IErr)
           if(IErr.eq.1) then
             write (6,*) ' HZHCMINIT failed'
             return
           endif
*
* Fill histos:
*
*      Cut on forward energie
           efwd=0.
           do I=1,NHEP
             if (isthep(I).eq.1.and.I.ne.lepid) then
               theta=real(HZPHMANG(PHEP(3,I),
     &              sqrt(PHEP(1,I)**2+PHEP(2,I)**2)))*rd
               if(theta.gt.4.4.and.theta.lt.15.) then
                 efwd=real(PHEP(4,I))+efwd
               endif
             endif
           enddo
*      Cut on positron angle
           theta=real(HZPHMANG(PHEP(3,lepid),
     &              sqrt(PHEP(1,lepid)**2+PHEP(2,lepid)**2)))*rd
           if (efwd.ge.0.5) then
             Nacc = Nacc + wtx
*    Fill in normalization Histograms for <K0>
             if(q2.lt.15)then
               call HF1(910,sngl(Xkin),wtx)
             elseif(q2.lt.35)then
               call HF1(911,sngl(Xkin),wtx)
             else
               call HF1(912,sngl(Xkin),wtx)
             endif


             do I = 1,Nhep
*     Get particle kinematics
               do J=1,4
                 plab(J) = phep(J,I)
               end do
               pt2=plab(1)**2+plab(2)**2
               pt=sqrt(pt2)
               theta= hzphmang(plab(3),pt)
               if (theta.gt.1.e-4 .and. theta.lt.pi-1.e-4) then
                eta= -1.*log(tan(theta/2.))
               else
                eta=-999
               endif
*
*     Count tracks
               if(I.ne.lepid.and.ISTHEP(I).eq.1
     &            .and.IHCHRG(I).ne.0.and.
     &            sqrt(pt2).gt.0.15.and.
     &           eta.gt.-1.3.and.eta.lt.1.3)then
*
                 if(q2.lt.15.)then
                   call HF1(900,sngl(Xkin),wtx)
                 elseif(q2.lt.35.)then
                   call HF1(901,sngl(Xkin),wtx)
                 else
                   call HF1(902,sngl(Xkin),wtx)
                 endif
               endif
*
*     Deal with lambdas
               if(abs(idhep(I)).eq.3122) then
                 if (pt2.gt.0.25.and.pt2.lt.4.5)then
                   call HF1(110,sngl(eta),wtx)
                 endif
                 if (eta.gt.-1.3.and.eta.lt.1.3)then
                   call HF1(111,sngl(pt2),wtx)
                 endif
               endif
*
*     Deal with K0
               if(abs(idhep(I)).eq.130.or.
     &            abs(idhep(I)).eq.310) then
                 if (pt2.gt.0.25.and.pt2.lt.4.5)then
                   call HF1(100,sngl(eta),wtx)
                   if(eta.gt.-1.3.and.eta.lt.1.3)then
                     if(q2.lt.15.)then
                       call HF1(120,sngl(Xkin),wtx)
                     elseif(q2.lt.35.)then
                       call HF1(121,sngl(Xkin),wtx)
                     else
                       call HF1(122,sngl(Xkin),wtx)
                     endif
                   endif
                 endif
                 if (eta.gt.-1.3.and.eta.lt.1.3)then
                   call HF1(101,sngl(pt2),wtx)
                 endif
                 call HZHCM(plab, pcms, Ierr)
                 if(Ierr.eq.1)  then
                   write (6,*) ' HZHCM BOOST failed'
                   return
                 endif
                 pt2=pcms(1)**2+pcms(2)**2
                 xF=2.*pcms(3)/sqrt(W2)
                 call HF1(200,sngl(xF),sngl(pt2)*wtx)
                 call HF1(10,sngl(xF),wtx)
               endif
             end do
           endif
         endif
*
         if (q2.gt.q2cut(1).and.q2.lt.q2cut(2)
     &       .and.Xkin.gt.1.D-3.and.Xkin.lt.0.01
     &       .and.Ykin.gt.0.1.and.Ykin.lt.0.6) then
*
*      Cut on forward energie
           efwd=0.
           do I=1,NHEP
             if (isthep(I).eq.1.and.I.ne.lepid) then
               theta=real(HZPHMANG(PHEP(3,I),
     &              sqrt(PHEP(1,I)**2+PHEP(2,I)**2)))*rd
               if(theta.gt.4.4.and.theta.lt.15.) then
                 efwd=real(PHEP(4,I))+efwd
               endif
             endif
           enddo
*
           if (efwd.ge.0.5) then
             Nacc2 = Nacc2 + wtx
             do I = 1,Nhep
*     Get particle kinematics
               do J=1,4
                 plab(J) = phep(J,I)
               end do
               pt2=plab(1)**2+plab(2)**2
               pt=sqrt(pt2)
               theta= hzphmang(plab(3),pt)
               if (theta.gt.1.e-4 .and. theta.lt.pi-1.e-4) then
                eta= -1.*log(tan(theta/2.))
               else
                eta=-999.
               endif
               if(abs(idhep(I)).eq.130.or.
     &            abs(idhep(I)).eq.310) then
                 if (pt2.gt.0.25.and.pt2.lt.4.5)then
                   call HF1(300,sngl(eta),wtx)
                 endif
               endif
             enddo
           endif
         endif
       endif
*
* TERMINATION:
*
      if(iflag.eq.3) then
*
        call hcdir('//PAWC',' ')
        call hcdir(xxxx,' ')
*
C        write (6,*) 'Hz',xxxx,': number accepted = ',Nacc
*
*
* Deal with data plots
*
        call Hbook1(-100, 'eta-spectrum of K0', 8, -1.3,1.3, 0.)
        call HPAK(-100,etak)
        call HPAKE(-100,etake)
        call Hbook1(-110, 'eta-spectrum of lambda', 4, -1.3,1.3, 0.)
        call Hbook1(-111, 'p_T^2-spectrum of lambda',4,0.25,4.5,0.)
        call HPAK(-110,etal)
        call HPAKE(-110,etale)
        call HPAK(-111,ptsl)
        call HPAKE(-111,ptsle)
        call HbookB(-200, 'seagull',4,seabin,0.)
        call HPAK(-200,seadat)
        call HPAKE(-200,seaerr)
        call HBook1(-300,'K0 eta spektrum (Instantons)',8,-1.3,1.3,0.)
        call HPAK(-300,k0dat)
        call HPAKE(-300,k0err)
*
*
        if(NAcc.eq.0..or.NAcc2.eq.0.)then
          write(6,*)'Error : Number of accepted events is 0!'
        else
* Normalize eta-spectrums
          call HOpera(100,'+E',100,100,1.0/Nacc/.325,0.0)
          call HOpera(110,'+E',110,110,1.0/Nacc/0.65,0.0)
          call HOpera(300,'+E',300,300,1.0/Nacc2/.325,0.0)
          call hzhinfo(100,nacc)
          call hzhinfo(110,nacc)
          call hzhinfo(300,nacc2)
*
* Normalize p_T^2-spectrums
          call HOpera(101,'+E',101,101,1.0/Nacc/.53125,0.0)
          call HOpera(111,'+E',111,111,1.0/Nacc/1.0625,0.0)
          call hzhinfo(101,nacc)
          call hzhinfo(111,nacc)
*
* Normalize <K0>
          call HOpera(120,'/E',910,120,1.0,1.0)
          call HOpera(121,'/E',911,121,1.0,1.0)
          call HOpera(122,'/E',912,122,1.0,1.0)

*
* Make histograms <K0>/<N_Tracks>
*
          do j=0,2
            call HOpera(900+j,'/E',910+j,900+j,1.0,1.0)
            call HOpera(120+j,'/E',900+j,130+j,1.0,1.0)
          enddo
*
* Normalize seagull
*
          call HOpera(200,'/E',10,200,1.0,1.0)
*
* Calculate Chi2
*
          call HZChiSQ(100,-100)
          call HZChiSQ(110,-110)
          call HZChiSQ(111,-111)
          call HZChiSQ(200,-200)
          call HZChiSQ(300,-300)
        Endif
*
      endif
*
      Return
      End
*CMZ :  2.00/06 02/05/2002  15.09.27  by  Tancredi Carli
*CMZ :  1.02/00 04/10/98  22.24.54  by  Tancredi Carli
*CMZ :  1.01/15 22/06/98  15.26.06  by  Tancredi Carli
*CMZ :  1.01/14 23/03/98  18.54.46  by  Tancredi Carli
*CMZ :  1.01/13 13/02/98  15.04.34  by  Tancredi Carli
*CMZ :  1.01/11 30/12/97  09.33.14  by  Tancredi Carli
*CMZ :  1.01/10 13/11/97  12.46.12  by  Tancredi Carli
*CMZ :  1.01/07 10/10/97  19.46.51  by  Tancredi Carli
*CMZ :  1.01/05 27/06/97  19.34.02  by  Tancredi Carli
*-- Author :  Frank Botterweck 25-05-96
      subroutine HZ96138(IFLAG)
***********************************************
* D*-data Fcc
*
***********************************************
      IMPLICIT NONE
*
      real et,rap,rapl
      real enel,thel
      real s_inter
      Real pi,dpi,rd,ee,eb,dphi
      Real xpt1,xpt2,xxd1,xxd2
      Logical evcut,lp
      data lp/.false./
*
      Character string*20
*
      Integer nev
      Data nev/0/
      Integer jcut,ncut,iel,idum,id,idq2,idx
      Parameter (ncut=4,pi=3.1415927,dpi=2.*pi,rd=180./pi,ee=27.6)
*
      Integer ierr,ibeam,igam
      Real nnf2cc
      Double precision pbeam(4),pgam(4),pcm(4),ph(5),phc(4)
*
      integer err_flag
      real parl270, parl271
      real qch(-6:6)
      integer kf,ix,nentry,iq
      real xpq(-6:6),sf2
      integer lst
      real cut,parl,x,y,w2,q2,u
      common/leptou/cut(14),lst(40),parl(30),x,y,w2,q2,u
       integer ixxl10
       real xxl10,xx,xf2,xf2cc
      real kd_delxq(10)
*
      Real nd0,ndplus
      integer ib_kd, iq_bin
      real dif1,dif2,dif3
      real kd_avx(0:10),kd_avq(0:10),tevt
      data kd_avx/11*0./,kd_avq/11*0./
      integer id0,id1,id2,id3
      integer id11,id21
      integer i_q1,i_q2,id_q1,id_q2
      real    kd_evt(10,0:10)
      data kd_evt/110*0./
      double precision p4l_q1(4),p4l_q2(4)
      double precision p4c_q1(4),p4c_q2(4)
      real shat12
     & ,pc_q1,ptc_q1,etc_q1,thc_q1,rapc_q1
     & ,pc_q2,ptc_q2,etc_q2,thc_q2,rapc_q2
     & ,pl_q1,ptl_q1,etl_q1,thl_q1,rapl_q1
     & ,pl_q2,ptl_q2,etl_q2,thl_q2,rapl_q2
     & ,xc_q1,xc_q2
      real phip1p2,p1p2

       integer my_q2,my_xb
       integer iq2bin,ixbbin
       Integer nmybins,nsq
       Parameter (nmybins=12,nsq=nmybins*nmybins)
       real xblow(nmybins)
       data xblow/0.0001,0.0004,0.0006,0.001,0.005,
     & 0.01,0.015,0.05,0.1,0.3,0.5,1./
       real q2low(nmybins)
       data q2low/10.,20.,30.,50.,100.,500.,1000.,
     & 2500.,5000.,10000.,15000.,20000./
*
       real av_xb(nmybins,nmybins),av_q2(nmybins,nmybins)
       real av_y (nmybins,nmybins),xevt(nmybins,nmybins),xntot
       real xevt_c(nmybins,nmybins)
       data av_xb/nsq*0./
       data av_q2/nsq*0./
       data av_y /nsq*0./
       data xevt/nsq*0./,xntot/0./
       data xevt_c/nsq*0./
*
       real xv
       real del_q2,del_xb
       real qqradp
       real xkinfac,qpi , xf21,xf21cc,xf22 , sigma_tot, xf23,xf23cc
       real xf24,xf25,xf26
       real avxb,avq2,avy
*
       integer max_xd,max_xd2
       parameter (max_xd=6,max_xd2=5)
       real xd_bin(max_xd+1)
       data xd_bin/0.,0.1,0.25,0.4,0.55,0.7,1./
       real xd_bin2(max_xd2+1)
       data xd_bin2/0.1,0.25,0.4,0.55,0.65,1./
       integer max_pt,max_pt2
       parameter (max_pt=6,max_pt2=5)
       real pt_bin(max_pt+1),pt_bin2(max_pt2+1)
       data pt_bin/0.,1.,2.,3.,4.,6.,10./
       data pt_bin2/1.,2.,3.,4.,6.,10./
*
* Pt spectra
*
       Real pty1d(max_pt2), ptey1d(max_pt2),ptx2d(max_pt2)
       Real pty2d(max_pt2), ptey2d(max_pt2)
       Real ptex1d(max_pt2),ptex2d(max_pt2)
       Real ptx1d(max_pt2)
*      D0
       data pty1d /0., 0.333,0.115,0.0404,0.0076/
       data ptey1d/0. ,  0.069,0.026,0.009, 0.0029/
       data ptx2d /1.5,  2.5  ,3.5  ,5.    ,8.    /
*      D*
       data pty2d /0.513,0.230,0.110,0.035 ,0.0028/
       data ptey2d/0.158,0.058,0.027,0.0093,0.0017/
       data ptex1d/max_pt2*0./
       data ptex2d/max_pt2*0./
*
* F2 data
*
       Integer nf2
       Parameter (nf2=9)
       Real xx1(nf2),yy1(nf2),xx2(nf2),yy2(nf2),xx3(nf2),yy3(nf2)
       Real eyy1(nf2),eyy2(nf2),eyy3(nf2)
*
       Data xx1/0.00032,0.0005, 0.0008, 0.0013, 0.002 , 0.0032, 0.005,
     &           0.008, 0.013/
       Data yy1/ 1.276, 1.168 , 1.067 , 0.942 , 0.866 , 0.749 , 0.685,
     &           0.618, 0.531/
       Data xx2/0.0005, 0.0008, 0.0013, 0.002 , 0.0032, 0.0050, 0.008,
     &          0.0130, 0.02/
       Data yy2/1.546 , 1.330 , 1.151 , 1.019 , 0.872 , 0.768 , 0.683,
     &          0.585 ,0.548/
       Data xx3/0.0013, 0.0020, 0.0032, 0.005 , 0.0080, 0.0130, 0.020,
     &          0.0320,0.05/
       Data yy3/1.3050, 1.2250, 1.1050, 0.912 , 0.7430, 0.6860, 0.599,
     &          0.5050,0.4110/
*
* F2cc data
*
       Integer nf2cc
       Parameter (nf2cc=2)
       Real xcc1(nf2cc), ycc1(nf2cc), eycc1(nf2cc), sycc1(nf2cc)
       Real xcc2(nf2cc), ycc2(nf2cc),  eycc2(nf2cc), sycc2(nf2cc)
       Real xcc3(nf2cc), ycc3(nf2cc) , eycc3(nf2cc), sycc3(nf2cc)
       Real excc(nf2cc),xbin1(nf2cc+1),xbin2(nf2cc+1),xbin3(nf2cc+1)
* bin 1 Q2=12 GeV2
       Data xbin1/0.000251,0.001,0.01/
       Data xcc1 /0.0008, 0.0032/
       Data ycc1/0.211  , 0.190/
       Data eycc1/0.049 , 0.054/
       Data sycc1/0.040 , 0.050/
* bin 2 Q2= 25 GeV2
       Data xbin2/0.000631,0.00158,0.01/
       Data xcc2 /0.0008, 0.0032/
       Data ycc2 /0.324 , 0.222/
       Data eycc2/0.099 , 0.066/
       Data sycc2/0.060 , 0.040/
* bin 3 Q2= 45 GeV2
       Data xbin3/0.00158,0.00398,0.0158/
       Data xcc3 /0.002 , 0.008/
       Data ycc3 /0.156 , 0.200/
       Data eycc3/0.070 , 0.064/
       Data sycc3/0.030 , 0.035/
       Data excc /nf2cc*0./
*
* Ratio F2/F2cc
*
       Real rxcc1(nf2cc), rycc1(nf2cc), reycc1(nf2cc), rsycc1(nf2cc)
       Real rxcc2(nf2cc), rycc2(nf2cc), reycc2(nf2cc), rsycc2(nf2cc)
       Real rxcc3(nf2cc), rycc3(nf2cc), reycc3(nf2cc), rsycc3(nf2cc)
       Real rexcc(nf2cc)
       Data rxcc1 /0.0008, 0.0032/
       Data rycc1 /0.198 , 0.254/
       Data reycc1/0.045 , 0.072/
       Data rsycc1/0.033 , 0.058/
       Data rxcc2 /0.0008, 0.0032/
       Data rycc2 /0.244 , 0.255/
       Data reycc2/0.075 , 0.076/
       Data rsycc2/0.038 , 0.038/
       Data rxcc3 /0.0020, 0.0080/
       Data rycc3 /0.127 , 0.269/
       Data reycc3/0.059 , 0.088/
       Data rsycc3/0.020 , 0.039/
       Data rexcc /nf2cc*0./
*
* Xd data
*
       Real x1d(max_xd2),y1d(max_xd2),ey1d(max_xd2),y2d(max_xd2)
       Real ey2d(max_xd2),ex1d(max_xd2),ex2d(max_xd2)
       Real x2d(max_xd2)
*
       data x1d / .175, .325,.475,.625,.85/
*      D0
       data y1d / 0.0, 2.4, 1.21, .68, .071/
       data ey1d/ 0.0, 0.4, 0.29,0.14,0.029/
*      D*
       data y2d / 2.4, 1.6, 1.2,  .4,  .086/
       data ey2d/ 0.6, 0.24,0.15,0.036,0.001/
       data ex1d/max_xd2*0./
       data ex2d/max_xd2*0./
*
       real efwd , th , pt , p ,x_d
       real xncc,xncc1,xncc2
       data xncc/0/,xncc1/0/,xncc2/0/
       logical lctag,lstag
       integer idhe,idda1,idda2,idmo1,idmo2
*
       real xnd0,alphem
       data xnd0/0./
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      Integer iflag,ihep,i,j,k,l
*     DESY Preprint number
      Character*5 xxxx
      Data xxxx/'96138'/
*
*
*********************************************************************
*
*                      Initialization
*
*********************************************************************
      NENTRY=NENTRY+1
*
      IF (iflag.eq.1) then
*
       nnf2cc=0.
       nd0=0.
       ndplus=0.
       parl270= 99999.
       parl271=-99999.
       write(6,*) 'Hz',xxxx,' CCbar Version'
       Qpi = 4.*atan(1.)
       qqradp = 180./qpi
*
*
*      Initialisation: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (i) make subdirectory in o/p file
*
       Call hcdir('//PAWC',' ')
       call hmdir(xxxx,'S')
       Call hcdir('//HISTO',' ')
       call hmdir(xxxx,'S')
*
       id0 = 3000
       id1 = 3100
       id11 = 3110
       id2 = 3200
       id21 = 3210
       id3 = 3300
* shat12 distribution
C         call hbook1(id0+1,' BGF Shat 12 all ',100,0.,100.,0.)
C         call hbook1(id0+3,' BGF Shat 12 CCb ',100,0.,100.,0.)
*
* theta lab distribution of BGF quarks
C         call hbook1(id1+1,' BGF quarks theta_lab All'
C     &  , 90.,0.,180.,0.)
C         call hbook1(id1+2,' BGF quarks theta_lab shat12 gt 10'
C     &  , 90.,0.,180.,0.)
C         call hbook1(id1+3,' BGF quarks theta_lab ccB '
C     &  , 90.,0.,180.,0.)
* theta lab distribution of BGF quarks
C         call hbook1(id11+1,' BGF quarks etacms All'
C     &  , 40,-10.,10.,0.)
C         call hbook1(id11+2,' BGF quarks etacms shat12 gt 10'
C     &  , 40,-10.,10.,0.)
C         call hbook1(id11+3,' BGF quarks etacms ccB '
C     &  , 40,-10.,10.,0.)
*
* x_c = 2*E_c* / w
C         call hbook2(id21+1,'BGF 2Ecms/W vs etacms quarks all '
C     &  , 40,-10.,10.,50.,0.,1.,0.)
C         call hbook2(id21+2,'BGF 2Ecms/W vs etacms quarks shat12 gt 10'
C     &  , 40,-10.,10.,50.,0.,1.,0.)
C         call hbook2(id21+3,'BGF 2Ecms/W vs etacms quarks ccB '
C     &  , 40,-10.,10.,50.,0.,1.,0.)
* x_c = 2*E_c* / w
C         call hbook2(id2+1,'BGF 2Ecms/W vs thetaLab quarks all '
C     &  , 90,0.,180.,50.,0.,1.,0.)
C         call hbook2(id2+2,'BGF 2Ecms/W vs thetaLab quarks shat12 gt 10'
C     &  , 90,0.,180.,50.,0.,1.,0.)
C         call hbook2(id2+3,'BGF 2Ecms/W vs thetaLab quarks ccB '
C     &  , 90,0.,180.,50.,0.,1.,0.)
* opening angle of quarks in Lab vs W
C         call hbook2(id3+1,' BGF Lab open ang qqB vs W All '
C     &    ,100,0.,200.,90.,0.,180.,0.)
C         call hbook2(id3+2,' BGF Lab open ang qqB vs W shat12 gt 10'
C     &    ,100,0.,200.,90.,0.,180.,0.)
C         call hbook2(id3+3,' BGF Lab open ang qqB vs W ccBar '
C     &    ,100,0.,200.,90.,0.,180.,0.)
C
C      call hbook1(1000,'d0 multi ',11,-0.5,10.5,0.)
C      call hbook1(2000,'cctag ',1,0.,1.,0.)
*
       call hbookb(1001,'pt d0 direct ',max_pt,pt_bin,0.)
       call hbookb(1002,'pt d0 from d*+',max_pt,pt_bin,0.)
       call hbookb(2001,'xd d0 direct ',max_xd,xd_bin,0.)
       call hbookb(2002,'xd d0 from d*+',max_xd,xd_bin,0.)
*
       call hbookb(1,'pt d0 direct   ',max_pt2,pt_bin2,0.)
       call hbookb(2,'pt d0 from d*+ ',max_pt2,pt_bin2,0.)
       call hbookb(-1,'pt d0 direct  ',max_pt2,pt_bin2,0.)
       call hbookb(-2,'pt d0 from d*+',max_pt2,pt_bin2,0.)
       call hbookb(101,'pt d0 direct   ',max_pt2,pt_bin2,0.)
       call hbookb(102,'pt d0 from d*+ ',max_pt2,pt_bin2,0.)
*
       call hpak(-1, pty1d)
       call hpake(-1,ptey1d)
       call hpak(-2, pty2d)
       call hpake(-2,ptey2d)
*
       call hbookb(11 ,'xd d0 direct  ',max_xd2,xd_bin2,0.)
       call hbookb(12 ,'xd d0 from d*+',max_xd2,xd_bin2,0.)
       call hbookb(-11,'xd d0 direct  ',max_xd2,xd_bin2,0.)
       call hbookb(-12,'xd d0 from d*+',max_xd2,xd_bin2,0.)
       call hbookb(111 ,'xd d0 direct  ',max_xd2,xd_bin2,0.)
       call hbookb(112 ,'xd d0 from d*+',max_xd2,xd_bin2,0.)
       call hpak(-11,y1d )
       call hpake(-11,ey1d)
       call hpak(-12,y2d )
       call hpake(-12,ey2d)
*
*****************************
*  Make histograms of F2 , F2CC and F2CC/F2 for pure PDF function
*****************************
*

       call hbook1( 4011,'f2CC Q2=12 ',100,-5.,0.,0.)
       call hbook1( 4012,'f2CC Q2=25 ',100,-5.,0.,0.)
       call hbook1( 4013,'f2CC Q2=45 ',100,-5.,0.,0.)
       call hbook1( 4021,'f2CC/F2 Q2=12 ',100,-5.,0.,0.)
       call hbook1( 4022,'f2CC/F2 Q2=25 ',100,-5.,0.,0.)
       call hbook1( 4023,'f2CC/F2 Q2=45 ',100,-5.,0.,0.)
*
       call hbook1( 141,'f2 Q2=12 ',100,-5.,0.,0.)
       call hbook1( 142,'f2 Q2=25 ',100,-5.,0.,0.)
       call hbook1( 143,'f2 Q2=45 ',100,-5.,0.,0.)
       call hbook1(-141,'f2 Q2=12 ',100,-5.,0.,0.)
       call hbook1(-142,'f2 Q2=25 ',100,-5.,0.,0.)
       call hbook1(-143,'f2 Q2=45 ',100,-5.,0.,0.)
       Do i=1,nf2
         eyy1(i)=0.
         eyy2(i)=0.
         eyy3(i)=0.
       enddo
       call hpak(-141,yy1)
       call hpake(-141,eyy1)
       call hpak(-142,yy2)
       call hpake(-142,eyy2)
       call hpak(-143,yy3)
       call hpake(-143,eyy3)
*
       call hbookb( 241,'f2CC Q2=12 ',nf2cc,xbin1,0.)
       call hbookb( 242,'f2CC Q2=25 ',nf2cc,xbin2,0.)
       call hbookb( 243,'f2CC Q2=45 ',nf2cc,xbin3,0.)
       call hbookb(-241,'f2CC Q2=12 ',nf2cc,xbin1,0.)
       call hbookb(-242,'f2CC Q2=25 ',nf2cc,xbin2,0.)
       call hbookb(-243,'f2CC Q2=45 ',nf2cc,xbin3,0.)
       Do i=1,nf2cc
         eycc1(i)= sqrt(eycc1(i)**2+sycc1(i)**2)
         eycc2(i)= sqrt(eycc2(i)**2+sycc2(i)**2)
         eycc3(i)= sqrt(eycc3(i)**2+sycc3(i)**2)
       enddo
       call hpak(-241,ycc1)
       call hpake(-241,eycc1)
       call hpak(-242,ycc2)
       call hpake(-242,eycc2)
       call hpak(-243,ycc3)
       call hpake(-243,eycc3)
*
       call hbookb( 341,'f2CC/F2 Q2=12 ',nf2cc,xbin1,0.)
       call hbookb( 342,'f2CC/F2 Q2=25 ',nf2cc,xbin2,0.)
       call hbookb( 343,'f2CC/F2 Q2=45 ',nf2cc,xbin3,0.)
       call hbookb( -341,'f2CC/F2 Q2=12 ',nf2cc,xbin1,0.)
       call hbookb( -342,'f2CC/F2 Q2=25 ',nf2cc,xbin2,0.)
       call hbookb( -343,'f2CC/F2 Q2=45 ',nf2cc,xbin3,0.)
*
       Do i=1,nf2cc
         reycc1(i)= sqrt(reycc1(i)**2+rsycc1(i)**2)
         reycc2(i)= sqrt(reycc2(i)**2+rsycc2(i)**2)
         reycc3(i)= sqrt(reycc3(i)**2+rsycc3(i)**2)
       enddo
*
       call hpak(-341,rycc1)
       call hpake(-341,reycc1)
       call hpak(-342,rycc2)
       call hpake(-342,reycc2)
       call hpak(-343,rycc3)
       call hpake(-343,reycc3)
*
C       call hbook1( 4031,'f2 BGF Q2=12 ',100,-5.,0.,0.)
C       call hbook1( 4032,'f2 BGF Q2=25 ',100,-5.,0.,0.)
C       call hbook1( 4033,'f2 BGF Q2=45 ',100,-5.,0.,0.)
C       call hbook1( 4041,'f2 BGF CC Q2=12 ',100,-5.,0.,0.)
C       call hbook1( 4042,'f2 BGF CC Q2=25 ',100,-5.,0.,0.)
C       call hbook1( 4043,'f2 BGF CC Q2=45 ',100,-5.,0.,0.)
C       call hbook1( 4051,'f2 BGF shat gt 10 Q2=12 ',100,-5.,0.,0.)
C       call hbook1( 4052,'f2 BGF shat gt 10 Q2=25 ',100,-5.,0.,0.)
C       call hbook1( 4053,'f2 BGF shat gt 10 Q2=45 ',100,-5.,0.,0.)
C       call hbook1( 4061,'f2 BGF CC shat gt 10 Q2=12 ',100,-5.,0.,0.)
C      call hbook1( 4062,'f2 BGF CC shat gt 10 Q2=25 ',100,-5.,0.,0.)
C      call hbook1( 4063,'f2 BGF CC shat gt 10 Q2=45 ',100,-5.,0.,0.)
C       call hbook1(-4001,'PDF f2 Q2=12 ',100,-5.,0.,0.)
C       call hbook1(-4002,'PDF f2 Q2=25 ',100,-5.,0.,0.)
C       call hbook1(-4003,'PDF f2 Q2=45 ',100,-5.,0.,0.)
C       call hbook1(-4011,'PDF f2CC Q2=12 ',100,-5.,0.,0.)
C       call hbook1(-4012,'PDF f2CC Q2=25 ',100,-5.,0.,0.)
C       call hbook1(-4013,'PDF f2CC Q2=45 ',100,-5.,0.,0.)
C       call hbook1(-4021,'PDF f2CC/F2 Q2=12 ',100,-5.,0.,0.)
C       call hbook1(-4022,'PDF f2CC/F2 Q2=25 ',100,-5.,0.,0.)
C       call hbook1(-4023,'PDF f2CC/F2 Q2=45 ',100,-5.,0.,0.)
C       do ixxl10=1,100
C        xxl10 = -4.975+ (5.*ixxl10-5.)/100
C        xx=10.**xxl10
C        write(6,*)' HZ96F2 calling PDFGET2 ',xx,12.
C            call pdfget2(xx,12.,xf2,xf2cc)
C        write(6,*)' HZ96F2 after PDFGET2 ',xf2,xf2cc
C        call hfilL(-4001,xxl10,1.,xf2)
C        call hfill(-4011,xxl10,1.,xf2cc)
C        call hfill(-4021,xxl10,1.,xf2cc/xf2)
C        write(6,*)' HZ96F2 calling PDFGET2 ',xx,12.
C            call pdfget2(xx,25.,xf2,xf2cc)
C        write(6,*)' HZ96F2 after PDFGET2 ',xf2,xf2cc
C        call hfill(-4002,xxl10,1.,xf2)
C        call hfill(-4012,xxl10,1.,xf2cc)
C        call hfill(-4022,xxl10,1.,xf2cc/xf2)
C        write(6,*)' HZ96F2 calling PDFGET2 ',xx,12.
C            call pdfget2(xx,45.,xf2,xf2cc)
C        write(6,*)' HZ96F2 after PDFGET2 ',xf2,xf2cc
C        call hfill(-4003,xxl10,1.,xf2)
C        call hfill(-4013,xxl10,1.,xf2cc)
C        call hfill(-4023,xxl10,1.,xf2cc/xf2)
C       enddo
*
*********************************************************************
*                      Event Processing
*
*********************************************************************
*
      Else if(iflag.eq.2) then
*
       call hcdir('//PAWC/'//xxxx,' ')
*
* total number of generated events
       xntot=xntot+1
*
       q2=real(hzdiskin(1))
       x=real(hzdiskin(2))
       y=real(hzdiskin(3))
       w2=real(hzdiskin(4))
*
       if (parl(27).gt.parl271 ) parl271=parl(27)
       if (parl(27).lt.parl270 ) parl270=parl(27)
       if (lp) write(6,*)'parl27 ' ,parl(27),parl271,parl271
*
*
* determine kin bin of event
*
       my_q2 = 0
       my_xb = 0
       do iq2bin = 1,nmybins
       if ( q2.gt. q2low(iq2bin) ) my_q2=iq2bin
       enddo
       do ixbbin = 1,nmybins
       if ( x .gt. xblow(ixbbin) ) my_xb=ixbbin
       enddo
*
       if (lp) write(6,*)' q2,x,my_q2,my_x= ',q2,x,my_q2,my_xb
*
* If event in bin, update event number, and averages x, Q2 and y
*
       if ( my_q2.gt.0 .and. my_q2.le.nmybins .AND.
     &      my_xb.gt.0 .and. my_xb.le.nmybins ) then
*
         xevt(my_q2,my_xb) = xevt(my_q2,my_xb)  +1
*
         if (lp) then
          write(6,*) ' my_q2,my_xb= ',my_q2,my_xb
          write(6,*) ' xevt(my_q2,my_xb) = ',xevt(my_q2,my_xb)
         endif
*
         xv = xevt(my_q2,my_xb)
         av_xb(my_q2,my_xb) = (xv-1.)/xv* av_xb(my_q2,my_xb)
     &  + 1./xv * x
         av_q2(my_q2,my_xb) = (xv-1.)/xv* av_q2 (my_q2,my_xb)
     &  + 1./xv * q2
         av_y (my_q2,my_xb) = (xv-1.)/xv* av_y (my_q2,my_xb)
     &  + 1./xv * y
*
        if (lp) then
*
         write(6,*) ' xv= ',xv,'  av_xb= ',av_xb(my_q2,my_xb)
         write(6,*) ' xv= ',xv,'  av_q2= ',av_q2(my_q2,my_xb)
         write(6,*) ' xv= ',xv,'  av_y = ',av_y (my_q2,my_xb)
*
        endif
*
       endif
*
* boost crap!
*
       iel=HZIDELEC(idum)
       if (iel.eq.-1) then
        write(6,*) 'Hz'//xxxx,' electron not found '
        goto 9990
       endif
       enel=real(PHEP(4,iel))
       thel=real(HZPHMANG(PHEP(3,iel),
     &               sqrt(PHEP(1,iel)**2+PHEP(2,iel)**2)))*rd
       if (lp) write(6,*) 'Hz'//xxxx,
     & ' enel= ',enel,' thel= ',thel
*
       ierr=HZIBEAM(ibeam,idum)
       if (.not.(ierr.eq.1)) then
        write(6,*) 'HZ'//xxxx,' beams not found ! '
        goto 9990
       else
        Do i=1,4
         pbeam(i)=PHEP(i,IBEAM)
        enddo
       endif
*
       eb=real(PHEP(4,idum))
       if (abs(abs(eb)-ee).gt.0.2) then
        if (nentry.lt.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,'  ! '
        elseif (nentry.eq.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &   ' ...last message ! '
        endif
C        goto 9990
       endif
*
       ierr=HZIPGAM(ph)
       if (ierr.eq.-1) then
        write(6,*) 'HZ'//xxxx,' boson vector not found ! '
C        call VZERO(ph,5)
        Do i=1,5
         ph(i)=0.
        enddo
       else
        Do i=1,4
         pgam(i)=ph(i)
        enddo
       endif
*
       call HZHCMINI(pbeam,pgam,ierr)
       if (ierr.eq.1) then
        write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
        goto 9990
       endif

*       write(6,*)'BGF event LST24/25/26 ',lst(24),lst(25),lst(26)
*       write(6,*)'BGF event PAR27/28/29/30 '
*     &  ,parl(27),parl(28),parl(29),parl(30)
*       if ( lst(24).eq.3) call lulist(2)
*
* Study QQbar event in BGF
*
        call get_kd_bin(x,q2,ib_kd)
*
        if (lp) then
         write(6,*) ' x q2= ',x,q2,' ib_kd= ',ib_kd
        endif
*
C       if (     10. .gt. q2 .and. q2 .lt. 100.
C     &   .and. 0.01 .lt.  y .and.  y .lt. .7  ) then
*
*  (1)  all events
*
         tevt =  kd_evt(1,0) + 1
         kd_evt(1,0) = tevt
         if (lp) then
          write(6,*) ' kd_evt(1,0)= ',kd_evt(1,0)
         endif

         kd_avq(0) =
     &    (tevt-1.)/tevt* kd_avq(ib_kd)+1./tevt*q2
         kd_avx(0) =
     &    (tevt-1.)/tevt* kd_avx(ib_kd)+1./tevt*x
        if (ib_kd .ge. 1. .and. ib_kd.le.6)then
         tevt =  kd_evt(1,ib_kd) + 1.
         kd_evt(1,ib_kd) = tevt
*
         if (lp) then
          write(6,*) ' kd_evt(1,ib_kd)= ',kd_evt(1,ib_kd)
         endif
*
         kd_avq(ib_kd) =
     &    (tevt-1.)/tevt* kd_avq(ib_kd)+1./tevt*q2
         kd_avx(ib_kd) =
     &    (tevt-1.)/tevt* kd_avx(ib_kd)+1./tevt*x
*
         if (lp) then
          write(6,*) ib_kd,' kd_avx(ib_kd)= ', kd_avx(ib_kd)
         endif
*
C        endif
*
C       if ( lst(24).eq.3) then
*  (2)  all BGF  events
C        kd_evt(2,0) = kd_evt(2,0) + 1.
C        if (ib_kd .ge. 1. .and. ib_kd.le.6)then
C        kd_evt(2,ib_kd) = kd_evt(2,ib_kd) + 1.
C        endif
C         i_q1 = lst(26)
C         i_q2 = lst(26)+1
C         id_q1 = idhep(i_q1)
C         id_q2 = idhep(i_q2)
C         if ( id_q1 + id_q2 .ne. 0) then
C           write(6,*)' Impossible BGF event '
C         endif
*
*  (3)  all BGF  events with ccbar
C        if ( abs(id_q1).eq.4) then
C         kd_evt(3,0) = kd_evt(3,0) + 1.
C         if (ib_kd .ge. 1. .and. ib_kd.le.6)then
C          kd_evt(3,ib_kd) = kd_evt(3,ib_kd) + 1.
C         endif
C        endif
*
C         do i=1,4
C         p4l_q1(i) = phep(i,i_q1)
C         p4l_q2(i) = phep(i,i_q2)
C         enddo
C           call HZHCM(p4l_q1,p4c_q1,ierr)
C           call HZHCM(p4l_q2,p4c_q2,ierr)
C         shat12 = (p4l_q1(4) + p4l_q2(4) ) **2
C     &          - (p4l_q1(1) + p4l_q2(1) ) **2
C     &          - (p4l_q1(2) + p4l_q2(2) ) **2
C     &          - (p4l_q1(3) + p4l_q2(3) ) **2
*
C         call get_my_var(p4l_q1
C     & ,pl_q1,ptl_q1,etl_q1,thl_q1,rapl_q1,err_flag)
C         if ( err_flag.ne.0) write(6,*)' qqbar error 1 '
C         call get_my_var(p4l_q2
C     & ,pl_q2,ptl_q2,etl_q2,thl_q2,rapl_q2,err_flag)
C         if ( err_flag.ne.0) write(6,*)' qqbar error 2 '
*
C         call get_my_var(p4c_q1
C     & ,pc_q1,ptc_q1,etc_q1,thc_q1,rapc_q1,err_flag)
C         if ( err_flag.ne.0) write(6,*)' qqbar error 1 '
C         call get_my_var(p4c_q2
C     & ,pc_q2,ptc_q2,etc_q2,thc_q2,rapc_q2,err_flag)
C         if ( err_flag.ne.0) write(6,*)' qqbar error 2 '
*
*   (4) all BGF  events with shat > 10
C         if (shat12.gt.10. )then
C          kd_evt(4,0) = kd_evt(4,0) + 1.
C          if (ib_kd .ge. 1. .and. ib_kd.le.6)then
C           kd_evt(4,ib_kd) = kd_evt(4,ib_kd) + 1.
C          endif
C         endif
*   (5) all BGF ccbar  events with shat > 10
C         if (shat12.gt.10. .and. abs(id_q1).eq.4 )then
C             kd_evt(5,0) = kd_evt(5,0) + 1.
C          if (ib_kd .ge. 1. .and. ib_kd.le.6)then
C           kd_evt(5,ib_kd) = kd_evt(5,ib_kd) + 1.
C          endif
C         endif
*
* shat12 distribution
C         call hfill(id0+1,shat12,1.,1.)
C         if ( abs(id_q1) .eq. 4 ) then
C         call hfill(id0+3,shat12,1.,1.)
C         endif
*
* eta cms  distribution of BGF quarks
C         call hfill(id11+1,rapc_q1,1.,1.)
C         call hfill(id11+1,rapc_q2,1.,1.)
C         if ( shat12.gt.10. ) then
C         call hfill(id11+2,rapc_q1,1.,1.)
C         call hfill(id11+2,rapc_q2,1.,1.)
C         endif
C         if ( abs(id_q1) .eq. 4 ) then
C         call hfill(id11+3,rapc_q1,1.,1.)
C         call hfill(id11+3,rapc_q2,1.,1.)
C         endif
*
* theta lab distribution of BGF quarks
C         call hfill(id1+1,thl_q1*qqradp,1.,1.)
C         call hfill(id1+1,thl_q2*qqradp,1.,1.)
C         if ( shat12.gt.10. ) then
C          call hfill(id1+2,thl_q1*qqradp,1.,1.)
C          call hfill(id1+2,thl_q2*qqradp,1.,1.)
C         endif
C         if ( abs(id_q1) .eq. 4 ) then
C          call hfill(id1+3,thl_q1*qqradp,1.,1.)
C          call hfill(id1+3,thl_q2*qqradp,1.,1.)
C         endif
*
* x_c = 2*E_c* / w
*
C         xc_q1 = 2.*p4c_q1(4)/sqrt(w2)
C         xc_q2 = 2.*p4c_q2(4)/sqrt(w2)
C         call hfill(id2+1,thl_q1*qqradp,xc_q1,1.)
C         call hfill(id2+1,thl_q2*qqradp,xc_q2,1.)
C         call hfill(id21+1,rapc_q1,xc_q1,1.)
C         call hfill(id21+1,rapc_q2,xc_q2,1.)
C         if ( shat12.gt.10. ) then
C          call hfill(id2+2,thl_q1*qqradp,xc_q1,1.)
C          call hfill(id2+2,thl_q2*qqradp,xc_q2,1.)
C          call hfill(id21+2,rapc_q1,xc_q1,1.)
C          call hfill(id21+2,rapc_q2,xc_q2,1.)
C         endif
C         if ( abs(id_q1) .eq. 4 ) then
C          call hfill(id2+3,thl_q1*qqradp,xc_q1,1.)
C          call hfill(id2+3,thl_q2*qqradp,xc_q2,1.)
C          call hfill(id21+3,rapc_q1,xc_q1,1.)
C          call hfill(id21+3,rapc_q2,xc_q2,1.)
C         endif
*
* opening angle of quarks in Lab vs W
*
C         p1p2 = ( p4l_q1(1)* p4l_q2(1)
C     &          + p4l_q1(2)* p4l_q2(2)
C     &          + p4l_q1(3)* p4l_q2(3) )/pl_q1/pl_q2
C         phip1p2 = acos(p1p2)*qqradp
C         call hfill(id3+1,sqrt(w2),phip1p2,1.)
C         if ( shat12.gt.10. ) then
C          call hfill(id3+2,sqrt(w2),phip1p2,1.)
C         endif
C         if ( abs(id_q1) .eq. 4 ) then
C          call hfill(id3+3,sqrt(w2),phip1p2,1.)
C         endif
*
* ENDIF BGF
C        endif
*
* ENDIF kin range
       endif
*
       efwd=0.
       lctag=.false.
       xnd0=0
       nev=nev+1
       Do 2000 ihep=1,nhep
        idhe=idhep(ihep)
*
        if ( abs(idhe).eq.4 ) lctag=.true.
        if ( abs(idhe).eq.311 ) lstag=.true.
*
        if ( abs(idhe) .eq. 421 ) then
           Do i=1,4
            Phc(i)=PHEP(i,ihep)
           enddo
* pcm in had cms
           call HZHCM(phc,pcm,ierr)
           if (ierr.eq.1) then
            write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
            goto 9990
           endif
*
*                                             get particle momenta
*
* Lab variables
*
           call get_my_var(phc,p,pt,et,th,rapl,err_flag)
           if ( err_flag.ne.0 ) goto 2000
*
* CMS variables
           call get_my_var(pcm,p,pt,et,th,rap,err_flag)
           if ( err_flag.ne.0 ) goto 2000
*
          idmo1=jmohep(1,ihep)
          idmo2=idhep(idmo1)
*          write(6,*)' D0 found ',xntot,lctag,idmo1,idmo2
          xnd0=xnd0+1
          x_d = 2*abs(p)/sqrt(w2)
*
          if (lp) write(6,*) ' x_d= ',x_d,' p= ',p,' w2= ',w2
*
          if ( idmo2 .eq. 413 ) then
*           write(6,*)' d0 from d*+ '
           call hfill(1002,pt,1.,wtx)
           call hfill(2002,x_d,1.,wtx)
           call hfill(2,pt,1.,wtx)
           call hfill(12,x_d,1.,wtx)
           ndplus=ndplus+wtx
           call hfill(102,pt,1.,wtx)
           call hfill(112,x_d,1.,wtx)
          else
           call hfill(1001,pt,1.,wtx)
           call hfill(2001,x_d,1.,wtx)
           call hfill(1,pt,1.,wtx)
           call hfill(11,x_d,1.,wtx)
           nd0=nd0+wtx
           call hfill(101,pt,1.,wtx)
           call hfill(111,x_d,1.,wtx)

*           if (abs(rapl).lt.1.5)call hfill(2001,x_d,1.,wtx)
          endif
*
          if (lp) write(6,*) ' pt x_d= ',pt,x_d,' ndplus= ',ndplus,nd0
*
        endif
*
*        if (isthep(ihep).eq.1.and.ihep.ne.iel) then
*         if(th.gt.4.4.and.th.lt.15.) then
*          efwd=real(PHEP(4,ihep))+efwd
*         endif
*        endif
*
 2000  continue
*
*       if ( lstag) call lulist(2)
C       if ( abs(lst(25)) .ne. 4. .and. lctag) then
C         write(6,*)' ccbar from? ',lst(25),lctag
C         xncc1=xncc1+1
*         call lulist(2)
C       endif
C       if ( abs(lst(25)) .eq. 4. .and. .NOT. lctag) then
C         write(6,*)' Impossible ',lst(25),lctag
C         xncc2=xncc2+1
C       endif
       if ( lctag ) then
C        if ( lst(24).eq.3)
C     &  write(6,*)' Ctagged BGF lst25/26 ',lst(25),lst(26)
C        xncc=xncc+1.
C        call hfill(2000,0.5,1.,1.)
C         if ( my_q2.gt.0 .and. my_q2.le.5 .AND.
C     &      my_xb.gt.0 .and. my_xb.le.5  ) then
C         xevt_c(my_q2,my_xb) = xevt_c(my_q2,my_xb)  +1
C         endif
C       if (     10. .lt. q2 .and. q2 .lt. 100.
C     &   .and. 0.01 .lt.  y .and.  y .lt. .7  ) then
         kd_evt(6,0) = kd_evt(6,0) + 1.
         if (ib_kd .ge. 1. .and. ib_kd.le.6)then
          kd_evt(6,ib_kd) = kd_evt(6,ib_kd) + 1.
         endif
C       endif
       endif
*
       call hfill(1000,xnd0,1.,wtx)
*
*
*
*                                             get electron variables
 9990  continue
*
*********************************************************************
*
*                      Termination
*
*********************************************************************
*
      Else if(iflag.eq.3) then
*
*      Termination: The following MUST always be done
*      (i) Move to the correct PAW subdirectory
*
       call hcdir('//PAWC/'//xxxx,' ')
*
       if (lp) then
*
C        write(6,*)' parl27 0 1 ' ,parl270,parl271
C        write(6,*)' xncc ',xncc,' of ',xntot
C        write(6,*)' strnge ',xncc1,' of ',xntot
C        write(6,*)' wrong ',xncc2,' of ',xntot
*
* Obtain total cross-section
        write(6,*)
     &  ' Total Cross section ',xsec,ntot
*
        write(6,*)'      '
        write(6,*)' KD evt counter ALL                  ',kd_evt(1,0)
C        write(6,*)' KD evt counter BGF                  ',kd_evt(2,0)
C     &     ,kd_evt(2,0)/kd_evt(1,0)
C        write(6,*)' KD evt counter BGF ccB              ',kd_evt(3,0)
C     &     ,kd_evt(3,0)/kd_evt(1,0)
C        write(6,*)' KD evt counter BGF     shat12 GT 10 ',kd_evt(4,0)
C     &     ,kd_evt(4,0)/kd_evt(1,0)
C        write(6,*)' KD evt counter BGF ccB shat12 GT 10 ',kd_evt(5,0)
C     &     ,kd_evt(5,0)/kd_evt(1,0)
C        write(6,*)'      '
       endif
*
* Normalize total cross-section to mbarns
      if (gen.eq.'INS') then
       sigma_tot = xsec/1000./1000.
      else
       sigma_tot = xsec/1000./1000./1000.
      endif
* Now express in Gev23
      sigma_tot = sigma_tot/0.38937966
*
      if (lp) write(6,*)' Lumi ',xntot/sigma_tot,' in nb -1 '
*
      kd_delxq(1)=abs((10.00-13.34)*(   0.000251-0.001   )) +
     &            abs((13.34-17.78)*(    0.000398-0.00158))
      kd_delxq(2)=abs((10.00-13.34)*(    0.001   -0.01   )) +
     &            abs((13.34-17.78)*(    0.00158 -0.01   ))
      kd_delxq(3)=abs((17.78-23.71)*(    0.000631-0.00158)) +
     &            abs((23.71-31.62)*(   0.000631-0.00158 ))
      kd_delxq(4)=abs((17.78-31.62)*(    0.00158 -0.01   ))
      kd_delxq(5)=abs((31.62-56.23)*(    0.001   -0.0039 )) +
     &            abs((56.23-100  )*(    0.00158 -0.00398))
      kd_delxq(6)=abs((31.62-100  )*(    0.0039  -0.0158 ))
*
* Fill Karin Daum's F2, F2cc and Ratio histogram
      do ib_kd = 1,6
        avxb = kd_avx(ib_kd)
        avq2 = kd_avq(ib_kd)
        s_inter = 4*820.*ee
        avy = avq2/avxb/s_inter
        if ( avy.lt.0. or. avy.gt.1.)then
         write(6,*)'wrong KD bins ',ib_kd,avq2,avxb,avy
        endif
*
* Kin factor  (parl(16)= alpha_em)
        alphem=1./137.
        xkinfac= 2.*qpi*alphem**2/avxb/avq2**2 *(2.-2.*avy+avy**2)
*
        if (lp) then
         write(6,*) ' xkinfac= ',xkinfac,' xntot= ',xntot,' ib= ',ib_kd
         write(6,*) ' avxb= ',avxb,' avq2= ',avq2
        endif
*
*  F2 1:from Number of events, not correcting for Delx and DelQ2
            xf21 = kd_evt(1,ib_kd)/xntot*sigma_tot
     &      /xkinfac/kd_delxq(ib_kd)
C            xf22 = kd_evt(2,ib_kd)/xntot*sigma_tot
C     &      /xkinfac/kd_delxq(ib_kd)
C            xf23 = kd_evt(3,ib_kd)/xntot*sigma_tot
C     &      /xkinfac/kd_delxq(ib_kd)
C            xf24 = kd_evt(4,ib_kd)/xntot*sigma_tot
C     &      /xkinfac/kd_delxq(ib_kd)
C            xf25 = kd_evt(5,ib_kd)/xntot*sigma_tot
C     &      /xkinfac/kd_delxq(ib_kd)
C            xf21cc = kd_evt(6,ib_kd)/xntot*sigma_tot
C     &      /xkinfac/kd_delxq(ib_kd)
*
        dif1 = abs(avq2-12.)
        dif2 = abs(avq2-25.)
        dif3 = abs(avq2-45.)
        if    (avq2.gt.5..and.avq2.le.20.) then
          iq_bin=1
        elseif(avq2.gt.20.  .and. avq2.le.40. ) then
          iq_bin=2
        elseif(avq2.gt.40.  .and. avq2.lt.100 ) then
          iq_bin=3
        endif
*
        if (lp) then
        write(6,*) ' iq= ',iq_bin,' avxb= ',avxb,' xf21= ', xf21
        endif
*
        if (ib_kd.eq.1) then
         write(string,'(a,f9.3)') ' F2 Q2= ',avq2
         call hbook1(4001,string,100,-5.,0.,0.)
        else if (ib_kd.eq.3) then
         write(string,'(a,f9.3)') ' F2 Q2= ',avq2
         call hbook1(4003,string,100,-5.,0.,0.)
        else if (ib_kd.eq.5) then
         write(string,'(a,f9.3)') ' F2 Q2= ',avq2
         call hbook1(4005,string,100,-5.,0.,0.)
        endif
*
        if (ib_kd.eq.1 .or. ib_kd.eq.2) then
         call hfill(4001,log10(avxb),1.,xf21*wtx)
        else if (ib_kd.eq.3 .or. ib_kd.eq.4) then
         call hfill(4003,log10(avxb),1.,xf21*wtx)
        else if (ib_kd.eq.5 .or. ib_kd.eq.6) then
         call hfill(4005,log10(avxb),1.,xf21*wtx)

        endif
*
C       call hfill(4010+iq_bin,log10(avxb),1.,xf21cc)
C       call hfill(4020+iq_bin,log10(avxb),1.,xf21cc/xf21)
C       call hfill(4030+iq_bin,log10(avxb),1.,xf22)
C       call hfill(4040+iq_bin,log10(avxb),1.,xf23)
C       call hfill(4050+iq_bin,log10(avxb),1.,xf24)
C       call hfill(4060+iq_bin,log10(avxb),1.,xf25)
*
        nnf2cc= nnf2cc+wtx
        call hfill(140+iq_bin,log10(avxb),1.,xf21*wtx)
        call hfill(240+iq_bin,avxb,1.,xf21cc*wtx)
        call hfill(340+iq_bin,avxb,1.,wtx*xf21cc/xf21)
*
        if (lp) then
*
         write(6,*) ' FILL xf21cc= ',xf21cc,' avxb= ',avxb
*
         write(6,*)' Bin KD ',ib_kd,avxb,avq2,avy
         write(6,*)' KD_evt 1 ',kd_evt(1,ib_kd)
     &                        ,kd_evt(1,ib_kd)/kd_evt(1,ib_kd)
C         write(6,*)' KD_evt 2 ',kd_evt(2,ib_kd)
C     &                        ,kd_evt(2,ib_kd)/kd_evt(1,ib_kd)
C         write(6,*)' KD_evt 3 ',kd_evt(3,ib_kd)
C     &                        ,kd_evt(3,ib_kd)/kd_evt(1,ib_kd)
C         write(6,*)' KD_evt 4 ',kd_evt(4,ib_kd)
C     &                        ,kd_evt(4,ib_kd)/kd_evt(1,ib_kd)
C         write(6,*)' KD_evt 5 ',kd_evt(5,ib_kd)
C     &                        ,kd_evt(5,ib_kd)/kd_evt(1,ib_kd)
C         write(6,*)' KD_evt 6 ',kd_evt(6,ib_kd)
C     &                        ,kd_evt(6,ib_kd)/kd_evt(1,ib_kd)
       endif
*
      enddo
*
* Loop over q2 and x bins
      do my_q2=1,nmybins-1
       idq2=10000+1000*my_q2
       call hbook1(idq2  ,' avQ2 ',nmybins,0.5,nmybins+0.5,0.)
       call hbook1(idq2+1,' avx  ',nmybins,0.5,nmybins+0.5,0.)
       call hbook1(idq2+2,' F2   ',nmybins,0.5,nmybins+0.5,0.)
       call hbook1(idq2+3,' F2/dx/dq2  ',nmybins,0.5,nmybins+0.5,0.)
*
       do my_xb = 1,nmybins-1
*
          avq2=av_q2(my_q2,my_xb)
          avxb=av_xb(my_q2,my_xb)
          avy =av_y (my_q2,my_xb)
*
* calculate bin width!
          del_q2 = q2low(my_q2+1) - q2low(my_q2)
          del_xb = xblow(my_xb+1) - xblow(my_xb)
*
          if (lp) then
           write(6,*) ' q2 interval '
     &      ,my_q2,' low= ',q2low(my_q2),' avq2= ',avq2,
     &      ' high= ',q2low(my_q2+1)
           write(6,*)
     &      ' xb interval ', my_xb,' low= ',xblow(my_xb),' avx= ',avxb,
     &      ' high= ',xblow(my_xb+1)
           write(6,*)' events ',xevt(my_q2,my_xb),' of ',xntot
           write(6,*)'cevents ',xevt_c(my_q2,my_xb),' of ',xntot
*
          endif
*
* If there are events in a bin, calculate F2
          if (avq2.gt.0.and.avxb.gt.0.) then
*
* Kin factor  (parl(16)= alpha_em)
            xkinfac= 2.*qpi*alphem**2/avxb/avq2**2 *(2.-2.*avy+avy**2)
*
*  F2 1:from Number of events, not correcting for Delx and DelQ2
            xf21 = xevt(my_q2,my_xb)/xntot*sigma_tot
     &      /xkinfac
*
*
*  F2 2: from density distribution (using Lepto routine)
C            call get_my_f2(avxb,avq2,xf22)
*
*  F2 3:from PDF lib (using Arkadi's routine)
C            call pdfget2(avxb,avq2,xf23,xf23cc)
*
*  write F21, F21/Delx/DelQ2   F22 and F23
C            if (lp) then
             write(6,'(A,F9.6,a,f9.1,a,f9.6,a,f9.6)')
     &       ' <xb>= ',avxb,' <Q2>= ',avq2,
     &       ' F2= ',xf21,' F2/dxdq2= ',xf21/del_xb/del_q2
C            endif
*
            call hfill(idq2  ,real(my_xb),1.,avq2*wtx)
            call hfill(idq2+1,real(my_xb),1.,avxb*wtx)
            call hfill(idq2+2,real(my_xb),1.,xf21*wtx)
            call hfill(idq2+3,real(my_xb),1.,wtx*xf21/del_xb/del_q2)
*
          else
C            write(6,*)' No F2 available '
          endif
        enddo
      enddo
*
*     normalise Pt and Xd to total integral
*
       call hrebin(1 ,ptx1d,pty1d,ptex1d,ptey1d,max_pt2,1,max_pt2)
       call hrebin(2 ,ptx2d,pty2d,ptex2d,ptey2d,max_pt2,1,max_pt2)
       call hrebin(11,  x1d,  y1d,  ex1d,  ey1d,max_xd2,1,max_xd2)
       call hrebin(12,  x2d,  y2d,  ex2d,  ey2d,max_xd2,1,max_xd2)
*
       if (lp) write(6,*) ' y1d= ',y1d,' y2d= ',y2d
*
       xpt1=0.
       xpt2=0.
       xxd1=0.
       xxd2=0.
       do i=1,max_pt2
        xpt1=xpt1+pty1d(i)
        xpt2=xpt2+pty2d(i)
       enddo
       Do i=1,max_xd2
        xxd1=xxd1+y1d(i)
        xxd2=xxd2+y2d(i)
       enddo
*
       Do i=1,max_pt2
        if (xpt1.ne.0.) then
         pty1d(i)=pty1d(i)/xpt1/ptex1d(i)/2.
         ptey1d(i)=ptey1d(i)/xpt1/ptex1d(i)/2.
        else
         pty1d(i)=-999.
         ptey1d(i)=0.
        endif
        if (xpt2.ne.0.) then
         pty2d(i)=pty2d(i)/xpt2/ptex2d(i)/2.
         ptey2d(i)=ptey2d(i)/xpt2/ptex2d(i)/2.
        else
         pty2d(i)=-999.
         ptey2d(i)=0.
        endif
       enddo
*
       Do i=1,max_xd2
        if (xxd1.ne.0.) then
         y1d(i)=y1d(i)/xxd1/ex1d(i)/2.
         ey1d(i)=ey1d(i)/xxd1/ex1d(i)/2.
        else
         y1d(i)=-999.
         ey1d(i)=0.
        endif
        if (xxd2.ne.0.) then
         y2d(i)=y2d(i)/xxd2/ex2d(i)/2.
         ey2d(i)=ey2d(i)/xxd2/ex2d(i)/2.
        else
         y2d(i)=-999.
         ey2d(i)=0.
        endif
       enddo
*
       if (lp) then
        write(6,*) nd0,' pty1d= ',pty1d
        write(6,*) ndplus,' pty2d= ',pty2d
        write(6,*) ndplus,'  y2d = ', y2d
        write(6,*) nd0,'  y1d = ', y1d
       endif
*
       call hpak ( 1,pty1d)
       call hpake( 1,ptey1d)
       call hpak ( 2,pty2d)
       call hpake( 2,ptey1d)
*
       call hpak (11,y1d)
       call hpake(11,ey1d)
       call hpak (12,y2d)
       call hpake(12,ey1d)
*
       call hzhinfo(11,real(nev))
       call hzhinfo( 1,real(nev))
       call hzhinfo(12,real(nev))
       call hzhinfo( 2,real(nev))
*
       call hzhinrm(101,0,nd0,1)
       call hzhinrm(111,0,nd0,1)
       call hzhinrm(102,0,ndplus,1)
       call hzhinrm(112,0,ndplus,1)
*
       call hzchisq(-1,1)
       call hzchisq(-2,2)
       call hzchisq(-11,11)
       call hzchisq(-12,12)
C       call hzchisq(-1,101)
C       call hzchisq(-2,102)
C       call hzchisq(-11,111)
C       call hzchisq(-12,112)
*
       call hzchisq(-241,241)
       call hzchisq(-242,242)
       call hzchisq(-243,243)
       call hzchisq(-341,341)
       call hzchisq(-342,342)
       call hzchisq(-343,343)
*
       call hzhinfo(241,nnf2cc)
       call hzhinfo(242,nnf2cc)
       call hzhinfo(243,nnf2cc)
       call hzhinfo(341,nnf2cc)
       call hzhinfo(342,nnf2cc)
       call hzhinfo(343,nnf2cc)
*
      endif
      RETURN
      END
************************************************************************
* Subroutine to determine KD's interval!
************************************************************************
      subroutine get_kd_bin(x,qsq,ibin)
      real x,qsq
      integer ibin

      ibin = -1

      IF    (10.00 .LT. qsq .AND. qsq .LT. 13.34 .AND.
     &   0.000251 .LT. x .AND. x .LT. 0.001)then
          ibin=1
      ELSEIF(13.34 .LT. qsq .AND. qsq .LT. 17.78 .AND.
     &   0.000398 .LT. x .AND. x .LT. 0.00158)then
          ibin=2
          ibin=1
      ELSEIF(10.00 .LT. qsq .AND. qsq .LT. 13.34 .AND.
     &   0.001    .LT. x .AND. x .LT. 0.01)then
          ibin=3
          ibin=2
      ELSEIF(13.34 .LT. qsq .AND. qsq .LT. 17.78 .AND.
     &   0.00158  .LT. x .AND. x .LT. 0.01)then
          ibin=4
          ibin=2
      ELSEIF(17.78 .LT. qsq .AND. qsq .LT. 23.71 .AND.
     &   0.000631 .LT. x .AND. x .LT. 0.00158)then
          ibin=5
          ibin=3
      ELSEIF(23.71 .LT. qsq .AND. qsq .LT. 31.62 .AND.
     &   0.000631 .LT. x .AND. x .LT. 0.00158)then
          ibin=6
          ibin=3
      ELSEIF(17.78 .LT. qsq .AND. qsq .LT. 31.62 .AND.
     &   0.00158  .LT. x .AND. x .LT. 0.01   )then
          ibin=7
          ibin=4
      ELSEIF(31.62 .LT. qsq .AND. qsq .LT. 56.23 .AND.
     &   0.001    .LT. x .AND. x .LT. 0.0039 )then
          ibin=8
          ibin=5
      ELSEIF(56.23 .LT. qsq .AND. qsq .LT. 100   .AND.
     &   0.00158  .LT. x .AND. x .LT. 0.00398)then
          ibin=9
          ibin=5
      ELSEIF(31.62 .LT. qsq .AND. qsq .LT. 100   .AND.
     &   0.0039   .LT. x .AND. x .LT. 0.0158 )then
          ibin=10
          ibin=6
      endif

      return
      end
*
*
       subroutine get_my_var(pcm,p,pt,et,th,rap,err_flag)
***********************************************************
*
*
*
***********************************************************
       double precision   pcm(4)
       real   p,pt,et,th,rap
       integer err_flag
       real qpi,qqradP,rd
*
       Qpi = 4.*atan(1.)
       qqradp = 180./qpi
       rd = qqradp
           err_flag = 0
           p      = real(sqrt(pcm(1)**2+pcm(2)**2+pcm(3)**2 ))
           pt     = real(sqrt( pcm(1)**2+pcm(2)**2 ))
           if (p.eq.0.) then
            write(6,*) xxxx,' p = ',p
            err_flag = -1
           else
            et     = real(pcm(4)) * pt / p
            th     = (acos(real(pcm(3))/p))
            if (abs(     th*rd).lt.1.e-4 .or.
     &          abs(180.-th*rd).lt.1.e-4 ) then
C             write(6,*) xxxx,' th = ',th
             err_flag = -2

            else
             rap    = -log(tan( th/2. ))
*                                            check on rap=nan (e.g. pt=0)
              if (rap.ne.rap) then
               write(6,*) xxxx,'Warning:  rap = ',rap,' th= ',th*rd,
     &         ' particle skipped ! '

               err_flag = -3
              endif
            endif
           endif
        return
        end
*
*CMZ :  2.00/06 02/05/2002  14.58.03  by  Tancredi Carli
*CMZ :  1.02/01 23/10/98  10.07.44  by  Tancredi Carli
*CMZ :  1.01/15 22/06/98  14.56.32  by  Tancredi Carli
*CMZ :  1.01/11 29/12/97  11.35.47  by  Tancredi Carli
*CMZ :  1.01/07 15/10/97  19.51.34  by  Tancredi Carli
*CMZ :  1.01/05 27/06/97  18.57.10  by  Tancredi Carli
*-- Author :    Tancredi Carli   04/09/96
      Subroutine hz96160(iflag)
      implicit none
      integer iflag
******************************************************************************
*  Subroutine hz96160                                                        *
*  ==================                                                        *
*                                                                            *
* Author: Birger Koblitz (koblitz@dice2.desy.de)                             *
*                                                                            *
* This routine plots distributions of charged multiplicities in the          *
* hadronic centre of mass system within 4 different eta ranges               *
* 1<eta<2, 1<eta<3, 1<eta<4 and 1<eta<5. The distributions are ploted for 4  *
* regions of W:  80<W<115, 115<W<150, 150<W<185, 185<W<200.                  *
* The routine also plots the mean charged multiplicity in these bins.        *
*                                                                            *
*                                                                            *
* Beams: 27.6 GeV positrons, 820 GeV protons   [1994 HERA running]           *
*                                                                            *
* Event selection:                                                           *
* 80 GeV < W < 220 GeV                                                       *
* 10 GeV < Q2                                                                *
* Energie of scattered positron > 12 GeV                                     *
* Energie deposited in polar angular range 4.4deg < theta < 15deg > 0.5 GeV  *
*                                                                            *
* Reference:                                                                 *
* Modified:                                                                  *
******************************************************************************
*
*        HERA tuning defined commons:
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEND.
*
* Local variables
*
      Real                ee,eb
      Parameter           (ee=27.6)
      Character           xxxx*5
      Double Precision    w2,q2,eta,theta,pt
      Double precision    pbeam(4), pgam(4),pgam4(4)
      Double Precision    plab(4),pcms(4)
      Integer             IErr
      Integer             ebid,pbid,lepid,ip
      Integer             HId,NTotal,I,J,N
      Real                Nacc
*
      Integer             nx,nx2
      Parameter (nx=24,nx2=54)
      logical lp
      data lp/.false./
*
      Real                efwd,rd,pi,y(4),y2(nx),xy2(nx2)
      Real                NormC,S
      Real                EvInB(5),EnergB(4)
      Real                xmin,xmax,xmin2,xmax2
      Parameter           (pi=3.1415927,rd=180./pi)
* CUTS:
      Real    q2cut(2), w2cut(2)
*
* Data points from plots:
*

      Real eta2(4),eta3(4),eta4(4),eta5(4)
      Real eta2st(4),eta3st(4),eta4st(4),eta5st(4)
      Real eta2sy(4),eta3sy(4),eta4sy(4),eta5sy(4)
      Real d_eta(4),d_eta2(24)

      Real d1152(24),d1152t(24),d1152y(24)
      Real d1153(24),d1153t(24),d1153y(24)
      Real d1154(24),d1154t(24),d1154y(24)
      Real d1155(24),d1155t(24),d1155y(24)

      Real d1502(24),d1502t(24),d1502y(24)
      Real d1503(24),d1503t(24),d1503y(24)
      Real d1504(24),d1504t(24),d1504y(24)
      Real d1505(24),d1505t(24),d1505y(24)

      Real d1852(24),d1852t(24),d1852y(24)
      Real d1853(24),d1853t(24),d1853y(24)
      Real d1854(24),d1854t(24),d1854y(24)
      Real d1855(24),d1855t(24),d1855y(24)

      Real d2202(24),d2202t(24),d2202y(24)
      Real d2203(24),d2203t(24),d2203y(24)
      Real d2204(24),d2204t(24),d2204y(24)
      Real d2205(24),d2205t(24),d2205y(24)
*
      Data xxxx/'96160'/

      data eta2/2.46,2.50,2.63,2.66/
      data eta2st/0.03,0.03,0.04,0.04/
      data eta2sy/0.10,0.12,0.18,0.18/

      data eta3/4.90,5.06,5.32,5.35/
      data eta3st/0.04,0.05,0.07,0.06/
      data eta3sy/0.18,0.27,0.34,0.35/

      data eta4/6.45,7.00,7.51,7.66/
      data eta4st/0.06,0.05,0.06,0.07/
      data eta4sy/0.33,0.35,0.51,0.47/

      data eta5/6.90,7.72,8.45,8.81/
      data eta5st/0.05,0.05,0.06,0.08/
      data eta5sy/0.34,0.42,0.58,0.54/

      data d1152/15.79,22.55,20.62,15.96,10.21,6.07,3.85,2.24,
     &     1.15,0.68,0.49,0.19,0.07,0.05,0.,0.,0.,0.,0.,0.,0.,
     &     0.,0.,0./
      data d1152t/0.52,0.50,0.46,0.43,0.37,0.30,0.26,0.16,0.12,
     &     0.10,0.12,0.10,0.12,0.06,0.04,0.03,0.,0.,0.,0.,
     &     0.,0.,0.,0.00/
      data d1152y/2.18,1.92,1.24,2.29,1.06,1.54,0.48,0.62,0.42,0.31,
     &     0.24,0.26,0.13,0.06,0.,0.,0.,0.,0.,0.,0.,
     &     0.,0.,0./
      data d1153/3.26,8.01,12.84,14.03,13.38,11.73,9.84,7.94,5.91,
     &     4.00,3.21,2.22,1.49,0.90,0.54,0.36,0.14,
     &     0.08,0.,0.,0.,0.,0.,0./
      data d1153t/0.22,0.27,0.35,0.35,0.32,0.35,0.34,0.33,0.32,
     &     0.21,0.19,0.18,0.14,0.15,0.11,0.08,0.07,
     &     0.05,0.,0.,0.,0.,0.,0./
      data d1153y/1.58,1.29,1.30,0.21,2.22,0.46,0.71,0.52,1.20,
     &     0.82,0.56,1.06,0.66,0.53,0.53,0.57,0.19,
     &     0.10,0.,0.,0.,0.,0.,0./
      data d1154/0.78,2.73,5.73,9.55,11.11,12.76,12.19,11.17,9.22,
     &     7.72,5.69,3.95,2.76,1.79,1.22,0.67,0.40,
     &     0.24,0.13,0.,0.,0.,0.,0./
      data d1154t/0.09,0.18,0.28,0.29,0.32,0.35,0.32,0.37,0.31,
     &     0.33,0.24,0.22,0.23,0.18,0.15,0.12,0.11,
     &     0.11,0.08,0.,0.,0.,0.,0./
      data d1154y/1.66,0.94,1.45,1.46,1.21,2.22,1.28,0.96,0.48,
     &     1.37,1.31,1.00,0.96,0.80,0.62,0.68,0.43,
     &     0.33,0.19,0.,0.,0.,0.,0./
      data d1155/0.40,1.64,3.82,7.59,10.08,12.30,12.91,12.27,10.65,
     &     8.69,6.38,4.79,3.20,2.05,1.38,0.86,0.40,
     &     0.27,0.10,0.00,0.00,0.00,0.00,0.00/
      data d1155t/0.08,0.16,0.22,0.28,0.34,0.34,0.35,0.35,0.33,
     &     0.30,0.26,0.25,0.24,0.19,0.16,0.14,0.08,
     &     0.13,0.05,0.00,0.00,0.00,0.00,0.00/
      data d1155y/0.00,0.39,1.27,1.06,1.18,0.89,1.29,1.86,0.86,
     &     1.08,0.99,1.23,0.97,0.69,0.74,0.66,0.24,
     &     0.37,0.11,0.,0.,0.,0.,0./
      data d1502/16.80,21.55,19.69,15.19,10.54,6.76,4.15,2.55,1.29,
     &     0.64,0.31,0.20,0.12,0.07,0.03,0.00,0.00,
     &     0.00,0.00,0.00,0.00,0.00,0.00,0.00/
      data d1502t/0.62,0.54,0.50,0.48,0.36,0.34,0.27,0.20,0.14,
     &     0.10,0.07,0.04,0.03,0.03,0.02,0.00,0.00,
     &     0.00,0.00,0.00,0.00,0.00,0.00,0.00/
      data d1502y/0.55,1.05,0.53,0.77,0.31,0.75,0.50,0.76,0.48,
     &     0.62,0.14,0.07,0.15,0.07,0.04,0.00,0.00,
     &     0.00,0.00,0.00,0.00,0.00,0.00,0.00/
      data d1503/4.52,8.00,12.15,12.96,12.74,11.09,9.35,7.31,6.01,
     &     4.53,3.76,2.57,1.90,1.05,0.77,0.56,0.31,
     &     0.18,0.12,0.00,0.00,0.00,0.00,0.00/
      data d1503t/0.35,0.35,0.36,0.36,0.38,0.32,0.31,0.27,0.29,
     &     0.24,0.25,0.23,0.18,0.16,0.12,0.10,0.08,
     &     0.06,0.06,0.00,0.00,0.00,0.00,0.00/
      data d1503y/1.19,1.21,0.70,0.91,0.74,1.63,0.70,2.06,0.93,
     &     1.38,0.53,0.86,0.77,0.29,0.54,0.48,0.24,
     &     0.28,0.12,0.00,0.00,0.00,0.00,0.00/
      data d1504/1.09,2.57,4.72,8.09,9.96,11.23,11.27,10.32,9.21,
     &     8.03,6.51,5.32,3.84,2.96,1.81,1.25,0.76,
     &     0.46,0.25,0.14,0.08,0.00,0.00,0.00/
      data d1504t/0.18,0.19,0.24,0.29,0.33,0.36,0.33,0.31,0.34,
     &     0.30,0.29,0.26,0.23,0.23,0.18,0.16,0.12,
     &     0.10,0.09,0.06,0.05,0.00,0.00,0.00/
      data d1504y/0.77,1.12,0.70,0.74,0.95,0.95,1.37,0.25,0.52,
     &     0.29,0.87,0.88,0.88,0.53,0.65,0.33,0.62,
     &     0.29,0.20,0.23,0.11,0.00,0.00,0.00/
      data d1505/0.35,1.17,2.58,5.63,7.97,10.36,11.44,11.96,10.41,
     &     9.65,7.88,6.15,4.96,3.51,2.15,1.47,0.93,
     &     0.72,0.25,0.17,0.12,0.03,0.00,0.00/
      data d1505t/0.08,0.13,0.14,0.23,0.24,0.31,0.37,0.35,0.32,
     &     0.36,0.28,0.23,0.27,0.25,0.21,0.17,0.14,
     &     0.17,0.08,0.07,0.08,0.02,0.00,0.00/
      data d1505y/0.00,0.62,1.26,0.69,1.03,0.82,0.56,1.18,0.66,
     &     0.74,0.49,0.80,1.35,0.50,0.45,0.43,0.92,
     &     0.62,0.34,0.24,0.13,0.03,0.00,0.00/
      data d1852/16.01,19.56,19.73,16.01,11.19,7.21,4.11,2.80,1.40,
     &     0.91,0.33,0.31,0.10,0.13,0.08,0.00,0.00,
     &     0.00,0.00,0.00,0.00,0.00,0.00,0.00/
      data d1852t/0.58,0.63,0.54,0.60,0.50,0.34,0.30,0.25,0.17,
     &     0.15,0.08,0.07,0.04,0.07,0.06,0.00,0.00,
     &     0.00,0.00,0.00,0.00,0.00,0.00,0.00/
      data d1852y/5.43,1.10,1.58,1.37,1.20,0.70,0.81,0.93,0.81,
     &     0.48,0.23,0.18,0.10,0.18,0.14,0.00,0.00,
     &     0.00,0.00,0.00,0.00,0.00,0.00,0.00/
      data d1853/4.24,8.32,10.99,11.75,11.71,11.37,9.39,7.98,6.27,
     &     5.36,3.64,2.87,1.82,1.24,1.08,0.78,0.43,
     &     0.20,0.18,0.13,0.06,0.00,0.00,0.00/
      data d1853t/0.36,0.41,0.40,0.37,0.41,0.41,0.39,0.35,0.38,
     &     0.35,0.25,0.22,0.20,0.15,0.16,0.15,0.09,
     &     0.06,0.07,0.07,0.05,0.00,0.00,0.00/
      data d1853y/3.19,1.39,0.67,1.30,1.27,1.49,1.08,0.57,0.52,
     &     1.07,1.03,0.28,0.73,0.54,0.89,0.61,0.40,
     &     0.13,0.13,0.24,0.10,0.00,0.00,0.00/
      data d1854/1.13,2.56,4.69,6.81,8.77,9.87,10.47,9.68,9.10,
     &     8.10,6.90,5.76,4.92,3.59,2.71,1.59,1.11,
     &     0.86,0.49,0.31,0.09,0.17,0.13,0.00/
      data d1854t/0.15,0.20,0.24,0.30,0.35,0.38,0.34,0.33,0.34,
     &     0.34,0.31,0.30,0.28,0.25,0.24,0.16,0.12,
     &     0.13,0.13,0.11,0.05,0.09,0.09,0.00/
      data d1854y/1.51,1.55,2.38,1.00,1.02,1.56,0.32,0.94,0.57,
     &     1.05,0.81,0.72,1.71,1.32,0.97,0.72,0.93,
     &     0.46,0.32,0.63,0.14,0.30,0.26,0.00/
      data d1855/0.28,1.09,2.21,4.18,6.61,8.24,9.77,11.04,10.87,
     &     9.89,8.18,7.07,5.76,4.88,3.42,2.43,1.31,
     &     1.07,0.55,0.43,0.12,0.18,0.16,0.00/
      data d1855t/0.08,0.13,0.14,0.20,0.23,0.31,0.34,0.33,0.34,
     &     0.35,0.35,0.31,0.34,0.31,0.26,0.25,0.17,
     &     0.19,0.14,0.13,0.05,0.08,0.11,0.00/
      data d1855y/0.00,1.03,0.71,1.28,2.08,1.36,1.20,0.89,0.66,
     &     1.13,0.44,0.56,1.15,1.50,0.89,1.00,0.78,
     &     0.64,0.51,0.50,0.51,0.32,0.31,0.00/
      data d2202/15.76,19.66,19.56,15.76,11.08,6.95,4.63,3.20,1.36,
     &     0.95,0.47,0.33,0.11,0.05,0.03,0.00,0.00,
     &     0.00,0.00,0.00,0.00,0.00,0.00,0.00/
      data d2202t/0.68,0.76,0.62,0.61,0.58,0.45,0.38,0.32,0.16,
     &     0.15,0.12,0.10,0.04,0.04,0.02,0.00,0.00,
     &     0.00,0.00,0.00,0.00,0.00,0.00,0.00/
      data d2202y/3.11,0.78,1.75,2.03,1.85,0.86,0.97,1.14,0.74,
     &     0.79,0.31,0.50,0.09,0.10,0.05,0.00,0.00,
     &     0.00,0.00,0.00,0.00,0.00,0.00,0.00/
      data d2203/4.24,8.00,10.74,11.51,11.76,11.65,9.74,7.96,6.83,
     &     5.12,3.70,2.52,1.79,1.39,1.11,0.66,0.44,
     &     0.29,0.14,0.10,0.06,0.05,0.00,0.00/
      data d2203t/0.42,0.45,0.57,0.47,0.48,0.53,0.47,0.43,0.44,
     &     0.34,0.30,0.24,0.19,0.17,0.16,0.13,0.10,
     &     0.10,0.06,0.05,0.04,0.04,0.00,0.00/
      data d2203y/3.18,0.48,1.52,0.69,2.08,1.27,1.62,0.91,1.06,
     &     1.16,1.24,0.88,0.76,0.92,1.23,0.33,0.27,
     &     0.19,0.19,0.14,0.29,0.10,0.00,0.00/
      data d2204/1.07,2.81,5.22,6.70,7.98,9.18,9.07,10.18,9.10,
     &     7.95,7.50,6.10,4.98,3.46,2.60,2.03,1.29,
     &     1.00,0.71,0.39,0.21,0.17,0.11,0.00/
      data d2204t/0.24,0.30,0.32,0.33,0.37,0.34,0.40,0.50,0.41,
     &     0.34,0.34,0.38,0.33,0.26,0.22,0.21,0.16,
     &     0.16,0.15,0.09,0.07,0.10,0.04,0.00/
      data d2204y/2.96,1.27,0.73,0.50,0.87,0.58,0.87,0.63,0.68,
     &     1.57,1.83,0.78,1.30,0.77,0.75,0.58,0.80,
     &     0.65,0.22,0.35,0.18,0.26,0.13,0.00/
      data d2205/0.27,0.96,2.37,3.73,5.47,7.50,8.49,10.08,10.54,
     &     10.40,9.20,8.03,6.48,4.78,3.81,2.32,2.13,
     &     1.14,0.83,0.64,0.30,0.13,0.19,0.03/
      data d2205t/0.09,0.13,0.23,0.24,0.27,0.30,0.35,0.39,0.46,
     &     0.43,0.44,0.40,0.30,0.29,0.27,0.21,0.22,
     &     0.14,0.12,0.14,0.07,0.07,0.08,0.02/
      data d2205y/0.00,1.96,0.68,1.12,0.99,0.83,1.24,1.61,1.18,
     &     1.71,1.00,1.12,0.99,0.95,1.22,0.78,1.08,
     &     0.67,0.44,0.29,0.39,0.18,0.26,0.05/


*
* INITIALISATION
*
      if (iflag.eq.1) then
*
        NAcc = 0.
        do I=1,4
          EnergB(I)=0.
        end do
*
	call hcdir('//PAWC',' ')
        call hmdir(xxxx,'S')
        Call hcdir('//HISTO',' ')
        call hmdir(xxxx,'S')
*
* Book histos:
*
        call Hbook1(112, 'W-dep of MCM - 1 eta 2', 4, 80.,220., 0.)
        call Hbook1(113, 'W-dep of MCM - 1 eta 3', 4, 80.,220., 0.)
        call Hbook1(114, 'W-dep of MCM - 1 eta 4', 4, 80.,220., 0.)
        call Hbook1(115, 'W-dep of MCM - 1 eta 5', 4, 80.,220., 0.)
*
        xmin=-0.5
        xmax=23.5
*
        xmin2=-0.5
        xmax2=53.5
*
        call Hbook1(212,
     &  'MC distribution 80GeV W 115 , 1<eta<2',nx,xmin,xmax,0.)
        call Hbook1(213,
     &  'MC distribution 80GeV W 115 , 1<eta<3',nx,xmin,xmax,0.)
        call Hbook1(214,
     &  'MC distribution 80GeV W 115 , 1<eta<4',nx,xmin,xmax,0.)
        call Hbook1(215,
     &  'MC distribution 80GeV W 115 , 1<eta<5',nx,xmin,xmax,0.)
*
        call Hbook1(1212,
     &  'MC distribution 80GeV W 115 , 1<eta<2',nx2,xmin2,xmax2,0.)
        call Hbook1(1213,
     &  'MC distribution 80GeV W 115 , 1<eta<3',nx2,xmin2,xmax2,0.)
        call Hbook1(1214,
     &  'MC distribution 80GeV W 115 , 1<eta<4',nx2,xmin2,xmax2,0.)
        call Hbook1(1215,
     &  'MC distribution 80GeV W 115 , 1<eta<5',nx2,xmin2,xmax2,0.)
*
        call Hbook1(222,
     &  'MC distribution 115GeV W 150 , 1<eta<2',nx,xmin,xmax,0.)
        call Hbook1(223,
     &  'MC distribution 115GeV W 150 , 1<eta<3',nx,xmin,xmax,0.)
        call Hbook1(224,
     &  'MC distribution 115GeV W 150 , 1<eta<4',nx,xmin,xmax,0.)
        call Hbook1(225,
     &  'MC distribution 115GeV W 150 , 1<eta<5',nx,xmin,xmax,0.)
*
        call Hbook1(1222,
     &  'MC distribution 115GeV W 150 , 1<eta<2',nx2,xmin2,xmax2,0.)
        call Hbook1(1223,
     &  'MC distribution 115GeV W 150 , 1<eta<3',nx2,xmin2,xmax2,0.)
        call Hbook1(1224,
     &  'MC distribution 115GeV W 150 , 1<eta<4',nx2,xmin2,xmax2,0.)
        call Hbook1(1225,
     &  'MC distribution 115GeV W 150 , 1<eta<5',nx2,xmin2,xmax2,0.)
*
        call Hbook1(232,
     &  'MC distribution 150GeV W 185 , 1<eta<2',nx,xmin,xmax,0.)
        call Hbook1(233,
     &  'MC distribution 150GeV W 185 , 1<eta<3',nx,xmin,xmax,0.)
        call Hbook1(234,
     &  'MC distribution 150GeV W 185 , 1<eta<4',nx,xmin,xmax,0.)
        call Hbook1(235,
     &  'MC distribution 150GeV W 185 , 1<eta<5',nx,xmin,xmax,0.)
*
        call Hbook1(1232,
     &  'MC distribution 150GeV W 185 , 1<eta<2',nx2,xmin2,xmax2,0.)
        call Hbook1(1233,
     &  'MC distribution 150GeV W 185 , 1<eta<3',nx2,xmin2,xmax2,0.)
        call Hbook1(1234,
     &  'MC distribution 150GeV W 185 , 1<eta<4',nx2,xmin2,xmax2,0.)
        call Hbook1(1235,
     &  'MC distribution 150GeV W 185 , 1<eta<5',nx2,xmin2,xmax2,0.)
*
        call Hbook1(242,
     &  'MC distribution 185GeV W 220 , 1<eta<2',nx,xmin,xmax,0.)
        call Hbook1(243,
     &  'MC distribution 185GeV W 220 , 1<eta<3',nx,xmin,xmax,0.)
        call Hbook1(244,
     &  'MC distribution 185GeV W 220 , 1<eta<4',nx,xmin,xmax,0.)
        call Hbook1(245,
     &  'MC distribution 185GeV W 220 , 1<eta<5',nx,xmin,xmax,0.)
*
        call Hbook1(1242,
     &  'MC distribution 185GeV W 220 , 1<eta<2',nx2,xmin2,xmax2,0.)
        call Hbook1(1243,
     &  'MC distribution 185GeV W 220 , 1<eta<3',nx2,xmin2,xmax2,0.)
        call Hbook1(1244,
     &  'MC distribution 185GeV W 220 , 1<eta<4',nx2,xmin2,xmax2,0.)
        call Hbook1(1245,
     &  'MC distribution 185GeV W 220 , 1<eta<5',nx2,xmin2,xmax2,0.)
*
* set cuts:
*
        w2cut(1) = 40.*40
        w2cut(2) = 220.*220.
*
* ANALYSIS:
*
      end if
      if(iflag.eq.2) then
*
        call hcdir('//PAWC',' ')
        call hcdir(xxxx,' ')
        do I=1,5
          EvInB(I)=0.
        end do
*
        if (lp) then
         write(6,*) 'START wtx= ',wtx,' EvInB(I)= ',EvInB
        endif
*
*  Check electron beam energy
*
       NTotal=NTotal+1
       ierr=HZIBEAM(pbid,ebid)
       if (.not.(ierr.eq.1)) then
        write(6,*) 'HZ'//xxxx,' Beams not found ! '
        return
       endif
       eb=real(PHEP(4,ebid))
       if (abs(abs(eb)-ee).ge.0.2) then
        if (NTotal.lt.10) then
         write(6,*) 'HZ'//xxxx,' Electron not at ',ee,' ! ',eb
C         call lulist(1)
        elseif (NTotal.eq.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &   ' ...last message ! '
        endif
C        return
       endif

*
* Event Selection:
*
         q2=hzdiskin(1)
         w2=hzdiskin(4)
         if (lp) then
          write(6,*)
     &    ' Q2= ',real(q2),' W2= ',real(w2),' w2xut= ',w2cut
         endif
*
         if (real(w2).gt.w2cut(1).and.real(w2).lt.w2cut(2)
     &   .and.real(q2).gt.10.) then
*
* INITIALISE BOOST:
*
           if (Hzipgam(pgam).lt.0) then
             write (6,*) 'Photon momentum not found'
             return
           endif
           lepid=hzidelec(0)
           if (lepid.lt.0) then
             write (6,*) 'Id of electron not found'
             return
           endif
           do J=1,4
             pbeam(J) = PHEP(J,pbid)
             pgam4(J) = pgam(J)
           end do
*
           call HZHCMINI(pbeam,pgam4,IErr)
           if(IErr.eq.1) then
             write (6,*) xxxx,' HZHCMINIT failed'
             return
           endif
*
          if (lp) write(6,*) ' ..start on Wfwd '
*
* Fill histos:
*
*
*      Cut on forward energy
*
           efwd=0.
           do I=1,NHEP
             if (isthep(I).eq.1.and.I.ne.lepid) then
               theta=real(HZPHMANG(PHEP(3,I),
     &              sqrt(PHEP(1,I)**2+PHEP(2,I)**2)))*rd
               if(theta.gt.4.4.and.theta.lt.15.) then
                 efwd=real(PHEP(4,I))+efwd
               endif
             endif
           enddo
*
           if (lp) then
            write(6,*) ' Enel= ',PHEP(4,lepid),' efwd= ',efwd
            write(6,*) ' nhep =',nhep
           endif
*
           if (PHEP(4,lepid).gt.12.0.and.efwd.ge.0.5) then
             Nacc = Nacc + wtx
             do I = 1,Nhep
*
               if (lp) then
                write(6,*) i,idhep(i),' isthep(I)= ',isthep(I),
     &          ' IHCHRG(I)= ',IHCHRG(I)
               endif
*
               if(isthep(I).eq.1.and.I.ne.lepid
     &           .and.IHCHRG(I).ne.0) then
                 do J=1,4
                   plab(J) = phep(J,I)
                 end do
                 if (lp) then
                  write(6,*) ' plab= ',plab
                  write(6,*) ' pcms= ',pcms
                 endif
                 call HZHCM(plab, pcms, Ierr)
                 if(Ierr.eq.1)  then
                   write (6,*) ' HZHCM BOOST failed'
                   return
                 endif
                 pt=sqrt(pcms(1)**2+pcms(2)**2)
                 theta= hzphmang(pcms(3),pt)
                 eta= -1.*log(tan(theta/2.))
                 HId=int(eta+1.0)
*
                 if (hid.ge.1) then
                  if (lp) then
                   write(6,*) theta*rd,' eta= ',eta,' hid= ',hid
                   write(6,*) hid,'  EvInB(HId)= ', EvInB(HId)
                  endif
*
                  EvInB(HId)=EvInB(HId)+1.
                 endif
*
                 if(HId.ge.2.and.HId.le.5) then
                   call HF1(HId+110,sngl(sqrt(w2)),wtx)
                 endif
*
               endif
             end do
*
             if (lp) then
              write(6,*) ' wtx= ',wtx,' EvInB(I)= ',EvInB
             endif
*
             do I=2,4
               EvInB(I+1)=EvInB(I)+EvInB(I+1)
             end do
             J=int((sqrt(w2)-45.)/35.)
             EnergB(J)=EnergB(J)+wtx
             do I=2,5
              call HF1(I+J*10+200,EvInB(I),wtx)
              call HF1(1000+I+J*10+200,EvInB(I),wtx)
             end do
             if (lp) then
              write(6,*) i,j,' wtx= ',wtx,' EvInB(I)= ',EvInB
             endif
           endif
*
         endif
       endif
*
*
* TERMINATION:
*
      if(iflag.eq.3) then
*
        call hcdir('//PAWC',' ')
        call hcdir(xxxx,' ')
*
        write (6,*) 'Hz',xxxx,': # events accepted = ',Nacc
*
* Deal with data plots
*
*
        call Hbook1(-112,
     &       'W-dep of MCM - 1<eta<2', 4, 80.,220., 0.)
        call Hbook1(-113,
     &       'W-dep of MCM - 1<eta<3', 4, 80.,220., 0.)
        call Hbook1(-114,
     &       'W-dep of MCM - 1<eta<4', 4, 80.,220., 0.)
        call Hbook1(-115,
     &       'W-dep of MCM - 1<eta<5', 4, 80.,220., 0.)
*
        call Hbook1(-122,
     &       '1<[c]<2 - statistical error', 4, 80.,220., 0.)
        call Hbook1(-123,
     &       '1<[c]<3 - statistical error', 4, 80.,220., 0.)
        call Hbook1(-124,
     &       '1<[c]<4 - statistical error', 4, 80.,220., 0.)
        call Hbook1(-125,
     &       '1<[c]<5 - statistical error', 4, 80.,220., 0.)
*
        call Hbook1(-132,
     &       '1<[c]<2 - systematic error', 4, 80.,220., 0.)
        call Hbook1(-133,
     &       '1<[c]<3 - systematic error', 4, 80.,220., 0.)
        call Hbook1(-134,
     &       '1<[c]<4 - systematic error', 4, 80.,220., 0.)
        call Hbook1(-135,
     &       '1<[c]<5 - systematic error', 4, 80.,220., 0.)
*
        call hpak(-112,eta2)
        do I=1,4
          d_eta(I)=sqrt(eta2st(I)**2+eta2sy(I)**2)
        end do
        call hpake(-112,d_eta)
        call hpak(-113,eta3)
        do I=1,4
          d_eta(I)=sqrt(eta3st(I)**2+eta3sy(I)**2)
        end do
        call hpake(-113,d_eta)
        call hpak(-114,eta4)
        do I=1,4
          d_eta(I)=sqrt(eta4st(I)**2+eta4sy(I)**2)
        end do
        call hpake(-114,d_eta)
        call hpak(-115,eta5)
        do I=1,4
          d_eta(I)=sqrt(eta5st(I)**2+eta5sy(I)**2)
        end do
        call hpake(-115,d_eta)
*
        call hpak(-122,eta2)
        call hpake(-122,eta2st)
        call hpak(-123,eta3)
        call hpake(-123,eta3st)
        call hpak(-124,eta4)
        call hpake(-124,eta4st)
        call hpak(-125,eta5)
        call hpake(-125,eta5st)
*
        call hpak(-132,eta2)
        call hpake(-132,eta2sy)
        call hpak(-133,eta3)
        call hpake(-133,eta3sy)
        call hpak(-134,eta4)
        call hpake(-134,eta4sy)
        call hpak(-135,eta5)
        call hpake(-135,eta5sy)
*
        call Hbook1(-212,
     &       'CM distribution - 1<eta<2, 80<W<115',24, -.5,23.5, 0.)
        call Hbook1(-213,
     &       'CM distribution - 1<eta<3, 80<W<115',24, -.5,23.5, 0.)
        call Hbook1(-214,
     &       'CM distribution - 1<eta<4, 80<W<115',24, -.5,23.5, 0.)
        call Hbook1(-215,
     &       'CM distribution - 1<eta<5, 80<W<115',24, -.5,23.5, 0.)
*
        call Hbook1(-222,
     &       'CM distribution - 1<eta<2, 115<W<150',24, -.5,23.5, 0.)
        call Hbook1(-223,
     &       'CM distribution - 1<eta<3, 115<W<150',24, -.5,23.5, 0.)
        call Hbook1(-224,
     &       'CM distribution - 1<eta<4, 115<W<150',24, -.5,23.5, 0.)
        call Hbook1(-225,
     &       'CM distribution - 1<eta<5, 115<W<150',24, -.5,23.5, 0.)
*
        call Hbook1(-232,
     &       'CM distribution - 1<eta<2, 150<W<185',24, -.5,23.5, 0.)
        call Hbook1(-233,
     &       'CM distribution - 1<eta<3, 150<W<185',24, -.5,23.5, 0.)
        call Hbook1(-234,
     &       'CM distribution - 1<eta<4, 150<W<185',24, -.5,23.5, 0.)
        call Hbook1(-235,
     &       'CM distribution - 1<eta<5, 150<W<185',24, -.5,23.5, 0.)
*
        call Hbook1(-242,
     &       'CM distribution - 1<eta<2, 185<W<220',24, -.5,23.5, 0.)
        call Hbook1(-243,
     &       'CM distribution - 1<eta<3, 185<W<220',24, -.5,23.5, 0.)
        call Hbook1(-244,
     &       'CM distribution - 1<eta<4, 185<W<220',24, -.5,23.5, 0.)
        call Hbook1(-245,
     &       'CM distribution - 1<eta<5, 185<W<220',24, -.5,23.5, 0.)
*
        call Hbook1(-312,
     &       'CM stat. err. - 1<eta<2, 80<W<115',24, -.5,23.5, 0.)
        call Hbook1(-313,
     &       'CM stat. err. - 1<eta<3, 80<W<115',24, -.5,23.5, 0.)
        call Hbook1(-314,
     &       'CM stat. err. - 1<eta<4, 80<W<115',24, -.5,23.5, 0.)
        call Hbook1(-315,
     &       'CM stat. err. - 1<eta<5, 80<W<115',24, -.5,23.5, 0.)
*
        call Hbook1(-322,
     &       'CM stat. err. - 1<eta<2, 115<W<150',24, -.5,23.5, 0.)
        call Hbook1(-323,
     &       'CM stat. err. - 1<eta<3, 115<W<150',24, -.5,23.5, 0.)
        call Hbook1(-324,
     &       'CM stat. err. - 1<eta<4, 115<W<150',24, -.5,23.5, 0.)
        call Hbook1(-325,
     &       'CM stat. err. - 1<eta<5, 115<W<150',24, -.5,23.5, 0.)
*
        call Hbook1(-332,
     &       'CM stat. err. - 1<eta<2, 150<W<185',24, -.5,23.5, 0.)
        call Hbook1(-333,
     &       'CM stat. err. - 1<eta<3, 150<W<185',24, -.5,23.5, 0.)
        call Hbook1(-334,
     &       'CM stat. err. - 1<eta<4, 150<W<185',24, -.5,23.5, 0.)
        call Hbook1(-335,
     &       'CM stat. err. - 1<eta<5, 150<W<185',24, -.5,23.5, 0.)
*
        call Hbook1(-342,
     &       'CM stat. err. - 1<eta<2, 185<W<220',24, -.5,23.5, 0.)
        call Hbook1(-343,
     &       'CM stat. err. - 1<eta<3, 185<W<220',24, -.5,23.5, 0.)
        call Hbook1(-344,
     &       'CM stat. err. - 1<eta<4, 185<W<220',24, -.5,23.5, 0.)
        call Hbook1(-345,
     &       'CM stat. err. - 1<eta<5, 185<W<220',24, -.5,23.5, 0.)
*
        call Hbook1(-412,
     &       'CM syst. err. - 1<eta<2, 80<W<115',24, -.5,23.5, 0.)
        call Hbook1(-413,
     &       'CM syst. err. - 1<eta<3, 80<W<115',24, -.5,23.5, 0.)
        call Hbook1(-414,
     &       'CM syst. err. - 1<eta<4, 80<W<115',24, -.5,23.5, 0.)
        call Hbook1(-415,
     &       'CM syst. err. - 1<eta<5, 80<W<115',24, -.5,23.5, 0.)
*
        call Hbook1(-422,
     &       'CM syst. err. - 1<eta<2, 115<W<150',24, -.5,23.5, 0.)
        call Hbook1(-423,
     &       'CM syst. err. - 1<eta<3, 115<W<150',24, -.5,23.5, 0.)
        call Hbook1(-424,
     &       'CM syst. err. - 1<eta<4, 115<W<150',24, -.5,23.5, 0.)
        call Hbook1(-425,
     &       'CM syst. err. - 1<eta<5, 115<W<150',24, -.5,23.5, 0.)
*
        call Hbook1(-432,
     &       'CM syst. err. - 1<eta<2, 150<W<185',24, -.5,23.5, 0.)
        call Hbook1(-433,
     &       'CM syst. err. - 1<eta<3, 150<W<185',24, -.5,23.5, 0.)
        call Hbook1(-434,
     &       'CM syst. err. - 1<eta<4, 150<W<185',24, -.5,23.5, 0.)
        call Hbook1(-435,
     &       'CM syst. err. - 1<eta<5, 150<W<185',24, -.5,23.5, 0.)
*
        call Hbook1(-442,
     &       'CM syst. err. - 1<eta<2, 185<W<220',24, -.5,23.5, 0.)
        call Hbook1(-443,
     &       'CM syst. err. - 1<eta<3, 185<W<220',24, -.5,23.5, 0.)
        call Hbook1(-444,
     &       'CM syst. err. - 1<eta<4, 185<W<220',24, -.5,23.5, 0.)
        call Hbook1(-445,
     &       'CM syst. err. - 1<eta<5, 185<W<220',24, -.5,23.5, 0.)
*
        call hpak(-212,d1152)
        do I=1,24
          d_eta2(I)=sqrt(d1152t(I)**2+d1152y(I)**2)
        end do
        call hpake(-212,d_eta2)
        call hpak(-213,d1153)
        do I=1,24
          d_eta2(I)=sqrt(d1153t(I)**2+d1153y(I)**2)
        end do
        call hpake(-213,d_eta2)
        call hpak(-214,d1154)
        do I=1,24
          d_eta2(I)=sqrt(d1154t(I)**2+d1154y(I)**2)
        end do
        call hpake(-214,d_eta2)
        call hpak(-215,d1155)
        do I=1,24
          d_eta2(I)=sqrt(d1155t(I)**2+d1155y(I)**2)
        end do
        call hpake(-215,d_eta2)
*
        call hpak(-222,d1502)
        do I=1,24
          d_eta2(I)=sqrt(d1502t(I)**2+d1502y(I)**2)
        end do
        call hpake(-222,d_eta2)
        call hpak(-223,d1503)
        do I=1,24
          d_eta2(I)=sqrt(d1503t(I)**2+d1503y(I)**2)
        end do
        call hpake(-223,d_eta2)
        call hpak(-224,d1504)
        do I=1,24
          d_eta2(I)=sqrt(d1504t(I)**2+d1504y(I)**2)
        end do
        call hpake(-224,d_eta2)
        call hpak(-225,d1505)
        do I=1,24
          d_eta2(I)=sqrt(d1505t(I)**2+d1505y(I)**2)
        end do
        call hpake(-225,d_eta2)
*
        call hpak(-232,d1852)
        do I=1,24
          d_eta2(I)=sqrt(d1852t(I)**2+d1852y(I)**2)
        end do
        call hpake(-232,d_eta2)
        call hpak(-233,d1853)
        do I=1,24
          d_eta2(I)=sqrt(d1853t(I)**2+d1853y(I)**2)
        end do
        call hpake(-233,d_eta2)
        call hpak(-234,d1854)
        do I=1,24
          d_eta2(I)=sqrt(d1854t(I)**2+d1854y(I)**2)
        end do
        call hpake(-234,d_eta2)
        call hpak(-235,d1855)
        do I=1,24
          d_eta2(I)=sqrt(d1855t(I)**2+d1855y(I)**2)
        end do
        call hpake(-235,d_eta2)
*
        call hpak(-242,d2202)
        do I=1,24
          d_eta2(I)=sqrt(d2202t(I)**2+d2202y(I)**2)
        end do
        call hpake(-242,d_eta2)
        call hpak(-243,d2203)
        do I=1,24
          d_eta2(I)=sqrt(d2203t(I)**2+d2203y(I)**2)
        end do
        call hpake(-243,d_eta2)
        call hpak(-244,d2204)
        do I=1,24
          d_eta2(I)=sqrt(d2204t(I)**2+d2204y(I)**2)
        end do
        call hpake(-244,d_eta2)
        call hpak(-245,d2205)
        do I=1,24
          d_eta2(I)=sqrt(d2205t(I)**2+d2205y(I)**2)
        end do
        call hpake(-245,d_eta2)
*
        call hpak(-312,d1152)
        call hpake(-312,d1152t)
        call hpak(-313,d1153)
        call hpake(-313,d1153t)
        call hpak(-314,d1154)
        call hpake(-314,d1154t)
        call hpak(-315,d1155)
        call hpake(-315,d1155t)
*
        call hpak(-412,d1152)
        call hpake(-412,d1152y)
        call hpak(-413,d1153)
        call hpake(-413,d1153y)
        call hpak(-414,d1154)
        call hpake(-414,d1154y)
        call hpak(-415,d1155)
        call hpake(-415,d1155y)
*
        call hpak(-322,d1502)
        call hpake(-322,d1502t)
        call hpak(-323,d1503)
        call hpake(-323,d1503t)
        call hpak(-324,d1504)
        call hpake(-324,d1504t)
        call hpak(-325,d1505)
        call hpake(-325,d1505t)
*
        call hpak(-422,d1502)
        call hpake(-422,d1502y)
        call hpak(-423,d1503)
        call hpake(-423,d1503y)
        call hpak(-424,d1504)
        call hpake(-424,d1504y)
        call hpak(-425,d1505)
        call hpake(-425,d1505y)
*
        call hpak(-332,d1852)
        call hpake(-332,d1852t)
        call hpak(-333,d1853)
        call hpake(-333,d1853t)
        call hpak(-334,d1854)
        call hpake(-334,d1854t)
        call hpak(-335,d1855)
        call hpake(-335,d1855t)
*
        call hpak(-432,d1852)
        call hpake(-432,d1852y)
        call hpak(-433,d1853)
        call hpake(-433,d1853y)
        call hpak(-434,d1854)
        call hpake(-434,d1854y)
        call hpak(-435,d1855)
        call hpake(-435,d1855y)
*
        call hpak(-342,d2202)
        call hpake(-342,d2202t)
        call hpak(-343,d2203)
        call hpake(-343,d2203t)
        call hpak(-344,d2204)
        call hpake(-344,d2204t)
        call hpak(-345,d2205)
        call hpake(-345,d2205t)
*
        call hpak(-442,d2202)
        call hpake(-442,d2202y)
        call hpak(-443,d2203)
        call hpake(-443,d2203y)
        call hpak(-444,d2204)
        call hpake(-444,d2204y)
        call hpak(-445,d2205)
        call hpake(-445,d2205y)
*
* Add the MCM Diagrams with different eta
        do I=2,4
          call HOpera(110+I,'+E',111+I,111+I,1.0,1.0)
        end do
*
* Normalize the MCM diagrams using number of events in the 4 energie bins
        do J=1,4
          if(EnergB(J).eq.0.) then
            write(6,*)'Error: Number of accepted events is 0.'
            write(6,*)'Energie bin:',J
            NormC=1.0
          else
            NormC=1.0/EnergB(J)
          end if
          if (lp) then
           write(6,*) '  EnergB(J) = ',EnergB(J),' y= ',y
          endif
          do I=2,5
            call HUNPAK(110+I,y,' ',0)
            y(J)=y(J)*NormC
            call HPAK(110+I,y)
            call HUNPKE(110+I,y,' ',0)
            y(J)=y(J)*NormC
            call HPAKE(110+I,y)
*
            call hzhinfo(110+I,NormC)
            call hzchisq(-1*(110+I),110+I)
          end do
        end do

* Normalize the CM-distribution diagrams
        do J=1,4
          do I=2,5
            call HUNPAK(200+10*J+I,y2,' ',0)
            S=0.0
            do N=1,nx
              S=y2(N)+S
            end do
            if (lp) then
             write(6,*) ' s- ',s
            endif
            call HOpera(200+10*J+I,'+E',200+10*J+I,
     &           200+10*J+I,100.0/S,0.0)
            call hzhinfo(200+10*J+I,s)
            call hzchisq(-1*(200+10*J+I),200+10*J+I)
          end do
        end do
*
        do J=1,4
          do I=2,5
            call HUNPAK(1000+200+10*J+I,xy2,' ',0)
            S=0.0
            do N=1,nx2
              S=xy2(N)+S
            end do
            call HOpera(1000+200+10*J+I,'+E',1000+200+10*J+I,
     &           1000+200+10*J+I,100.0/S,0.0)
            call hzhinfo(1000+200+10*J+I,s)
          end do
        end do
*
*
*
      Endif
*
      Return
      End
*CMZ :  1.01/15 22/06/98  15.32.51  by  Tancredi Carli
*CMZ :  1.01/11 01/01/98  16.54.05  by  Tancredi Carli
*CMZ :  1.01/07 15/10/97  17.37.24  by  Tancredi Carli
*CMZ :  1.01/05 15/07/97  10.39.53  by  Tancredi Carli
*CMZ :  1.01/03 15/05/96  19.46.03  by  Tancredi Carli
*-- Author :  Frank Botterweck 25-05-96
      subroutine HZ96215(IFLAG)
***************************************************************************
*
* Last update:  clean up
*               add data from UK analysis (someone owes me big!)
*               remove data not in published paper
*
* 5-jun-97 Michael Kuhlen
*
****************************************************************************
*       update: Included ptmax 0.5 - 1.5 with Et (0.-2.) > 6
*               Included eta 3-4
*
*
*  data 7/6/96
*
*
****************************************************************************
****************************************************************************
*  Last update: data statistical errors are included in histogram + 10
*               there are multiplicty histograms for the 9+1 bins
*               these are convenient when adding moca hbook files
*               to gain statistics.
*  data 7/6/96
*
*
****************************************************************************
****************************************************************************
*  Last update: data are included
*               Moca histograms are now normalized to bin-width
*
*  To be done ... parameters for data datastatements
*
****************************************************************************
* Purpose: produce histograms for:
*           o) CMS tracks
*           o) dn/deta, dn/deta pt>1, dn/dpt, and dn/dptmax, Et>6
*           o) pt spectra in eta bin 0.5-1.5 and 1.5-2.5
*           o) Et measured from 0.5-2.5 in etacms
*
* Event selection:
* Eel>12 GeV, 173.0>Thel>157.0, w2>4400 GeV**2 and cut on forward energy
*
*  Histograms:  in all cases: iq= kin bin (0-9)
*                             iofeta = 30 , ieta eta interval for pt.
*
* -Intermediate , reset for each event
*       20 000 + 100                    , eta
*       20 000 + 200                    , eta pt>1
*       20 000 + 300 + iofeta*(ieta-1)  , pt , for eta interval ieta
*
* -Event summed, filled after each event.
*
*       10 000 + 100 + iofeta*(ieta-1) + iq  , eta ,          d n
*       10 000 + 110 + iofeta*(ieta-1) + iq  , eta ,          d n**2
*
*       10 000 + 200 + iofeta*(ieta-1) + iq  , eta , pt>1 ,   d n
*       10 000 + 210 + iofeta*(ieta-1) + iq  , eta , pt>1 ,   d n**2
*
*       10 000 + 300 + iofeta*(ieta-1) + iq  , pt ,   d n
*       10 000 + 310 + iofeta*(ieta-1) + iq  , pt ,   d n**2
*       10 000 + 350 + iofeta*(ieta-1) + iq  , pt ,   <pT> per pt bin
*
*       10 000 + 400 + iofeta*(ieta-1) + iq  , ptmax , dNa
*       10 000 + 450 + iofeta*(ieta-1) + iq  , ptmax , <ptmax>
*
* -Final normalized histograms
*
*       10 000 + 100 + iofeta*(ieta-1) + iq  , eta ,          1/N dn/deta
*
*       10 000 + 200 + iofeta*(ieta-1) + iq  , eta , pt>1 ,   1/N dn/deta
*
*       10 000 + 300 + iofeta*(ieta-1) + iq  , pt ,  1/N dn/dpt
*       10 000 + 350 + iofeta*(ieta-1) + iq  , pt ,   <pT> per pt bin
*
*       10 000 + 400 + iofeta*(ieta-1) + iq  , ptmax , dNa   1/Na dNa/dptmax
*       10 000 + 450 + iofeta*(ieta-1) + iq  , ptmax , <ptmax>
*
*  For data the final  histograms get negative id.
*  Statistical errors are stored in -id - 10
*
*
* Running: Ee=27.6, Ep=820, no polarization, HERA running 1994
* Reference:
* Arguments: iflag=1 initialisation
*            iflag=1 filling
*            iflag=3 termination
*
* written by: Botti
****************************************************************************
      IMPLICIT NONE
      integer ibin
      integer neta,iofeta,ieta,jjbin,jbin
      parameter (neta=5,iofeta=30)
      real etsummed,etsummed1, ptmax(neta)
      real etalow(neta),etahig(neta)
      data etalow/ 0.5 , 1.5 , 3.0 , 3.0 , 3.5 /
      data etahig/ 1.5 , 2.5 , 4.0 , 3.5 , 4.0 /

*      parameter (nxbxf=7)
*      real xbxf(nxbxf+1)
*      data xbxf/
*     1   0. ,0.05 , 0.1, 0.2, 0.4, 0.6, 0.8, 1.0/
      integer nbptm
      parameter (nbptm=12)
      real xbptm(nbptm+1)
      data xbptm/
     &   0., 0.25, 0.50 , 0.75, 1.0
     &     , 1.25, 1.50 , 1.75, 2.0
     &     , 2.5 , 3.
     &     , 4., 5/
      integer nbpt
      parameter (nbpt=17)
      real xbpt1(nbpt+1)
      data xbpt1/
     1   0. , 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8
     1 , 2.1, 2.5, 3.0, 4.0, 5.0, 6.0, 8.0,10.0 /

*     multiplicity counter
      real xmult

*data sequence statements
      real deta0x0 ( 18 )
      data deta0x0 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.250000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta0y0 ( 18 )
      data deta0y0 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 2.322577 , 2.457598,
     + 2.528338 , 2.402715 , 2.141174 , 1.649924 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta0ey0 ( 18 )
      data deta0ey0 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.014777 , 0.013939,
     + 0.013827 , 0.013048 , 0.012309 , 0.012023 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta0sy0 ( 18 )
      data deta0sy0 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.226442 , 0.180556,
     + 0.171047 , 0.150818 , 0.142905 , 0.134664 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta0x1 ( 18 )
      data deta0x1 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.250000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta0y1 ( 18 )
      data deta0y1 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 2.177350 , 2.394072 , 2.455025,
     + 2.486309 , 2.512200 , 2.339928 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta0ey1 ( 18 )
      data deta0ey1 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.046460 , 0.048209 , 0.049273,
     + 0.048474 , 0.048320 , 0.046787 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta0sy1 ( 18 )
      data deta0sy1 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.317663 , 0.155949 , 0.280194,
     + 0.173537 , 0.179672 , 0.179167 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta0x2 ( 18 )
      data deta0x2 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.250000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta0y2 ( 18 )
      data deta0y2 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 2.324203 , 2.269060 , 2.510778,
     + 2.549480 , 2.567664 , 2.341193 , 1.916110 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta0ey2 ( 18 )
      data deta0ey2 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.049817 , 0.041039 , 0.044576,
     + 0.043917 , 0.043299 , 0.039829 , 0.042626 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta0sy2 ( 18 )
      data deta0sy2 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.270717 , 0.156498 , 0.172475,
     + 0.191245 , 0.200157 , 0.208638 , 0.159855 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta0x3 ( 18 )
      data deta0x3 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.250000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta0y3 ( 18 )
      data deta0y3 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 2.237587 , 2.480351 , 2.493410,
     + 2.643841 , 2.474443 , 2.313419 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta0ey3 ( 18 )
      data deta0ey3 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.035239 , 0.034720 , 0.033804,
     + 0.035613 , 0.033563 , 0.032587 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta0sy3 ( 18 )
      data deta0sy3 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.253824 , 0.153772 , 0.165751,
     + 0.195725 , 0.153256 , 0.169059 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta0x4 ( 18 )
      data deta0x4 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.250000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta0y4 ( 18 )
      data deta0y4 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 2.369294 , 2.468037,
     + 2.472720 , 2.486072 , 2.248240 , 1.782471 , 1.116604,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta0ey4 ( 18 )
      data deta0ey4 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.039748 , 0.039094,
     + 0.038228 , 0.037583 , 0.035924 , 0.035087 , 0.030254,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta0sy4 ( 18 )
      data deta0sy4 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.202745 , 0.156611,
     + 0.229117 , 0.154936 , 0.145332 , 0.142499 , 0.105021,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta0x5 ( 18 )
      data deta0x5 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.250000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta0y5 ( 18 )
      data deta0y5 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 2.258555 , 2.373175,
     + 2.482646 , 2.278014 , 2.025487 , 1.486322 , 0.838491,
     + 0.404204 , 0.170590 , 0.000000
     + /
      real deta0ey5 ( 18 )
      data deta0ey5 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.041068 , 0.036721,
     + 0.037151 , 0.033583 , 0.031456 , 0.028336 , 0.021748,
     + 0.015703 , 0.010752 , 0.000000
     + /
      real deta0sy5 ( 18 )
      data deta0sy5 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.323778 , 0.219632,
     + 0.161313 , 0.185944 , 0.171144 , 0.203854 , 0.177081,
     + 0.079731 , 0.035672 , 0.000000
     + /
      real deta0x6 ( 18 )
      data deta0x6 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.000000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta0y6 ( 18 )
      data deta0y6 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 2.257    , 2.379453,
     + 2.394166 , 2.169586 , 1.867416 , 1.123464 , 0.583172,
     + 0.264400 , 0.093353 , 0.030262
     + /
      real deta0ey6 ( 18 )
      data deta0ey6 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.034    , 0.051935,
     + 0.047427 , 0.042585 , 0.040818 , 0.029435 , 0.021869,
     + 0.015206 , 0.009496 , 0.005009
     + /
      real deta0sy6 ( 18 )
      data deta0sy6 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.249    , 0.269571,
     + 0.193730 , 0.140911 , 0.281627 , 0.200342 , 0.133837,
     + 0.063604 , 0.013411 , 0.006372
     + /
      real deta0x7 ( 18 )
      data deta0x7 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.250000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta0y7 ( 18 )
      data deta0y7 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 2.307968 , 2.551594 , 2.606660,
     + 2.634754 , 2.568604 , 2.394787 , 1.785188 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta0ey7 ( 18 )
      data deta0ey7 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.040443 , 0.037237 , 0.037357,
     + 0.036852 , 0.035707 , 0.035296 , 0.033093 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta0sy7 ( 18 )
      data deta0sy7 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.262974 , 0.181178 , 0.163738,
     + 0.178094 , 0.174253 , 0.149991 , 0.095275 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta0x8 ( 18 )
      data deta0x8 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.250000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta0y8 ( 18 )
      data deta0y8 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 2.444883 , 2.520633,
     + 2.611290 , 2.392796 , 2.008049 , 1.409134 , 0.804890,
     + 0.363043 , 0.163875 , 0.000000
     + /
      real deta0ey8 ( 18 )
      data deta0ey8 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.044866 , 0.041030,
     + 0.040703 , 0.036459 , 0.034055 , 0.027928 , 0.021629,
     + 0.015129 , 0.010877 , 0.000000
     + /
      real deta0sy8 ( 18 )
      data deta0sy8 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.238625 , 0.174674,
     + 0.164083 , 0.174590 , 0.131858 , 0.185018 , 0.183791,
     + 0.058654 , 0.037631 , 0.000000
     + /
*                                  data from UK
      real deta0x9 ( 18 )
      data deta0x9 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.000000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta0y9 ( 18 )
      data deta0y9 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 2.252    , 2.508207,
     + 2.466111 , 2.164084 , 1.626398 , 1.004962 , 0.493466,
     + 0.228442 , 0.000000 , 0.043968
     + /
      real deta0ey9 ( 18 )
      data deta0ey9 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.036    , 0.058572,
     + 0.052627 , 0.047958 , 0.038027 , 0.030043 , 0.021354,
     + 0.015490 , 0.000000 , 0.007551
     + /
      real deta0sy9 ( 18 )
      data deta0sy9 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.249    , 0.329920,
     + 0.168703 , 0.252231 , 0.246354 , 0.229767 , 0.117804,
     + 0.054844 , 0.000000 , 0.012014
     + /
*
      real deta1x0 ( 18 )
      data deta1x0 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.250000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta1y0 ( 18 )
      data deta1y0 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.167320 , 0.217762 , 0.249517,
     + 0.274188 , 0.258963 , 0.208398 , 0.133392 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1ey0 ( 18 )
      data deta1ey0 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.004188 , 0.004137 , 0.004375,
     + 0.004450 , 0.004004 , 0.003556 , 0.003562 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1sy0 ( 18 )
      data deta1sy0 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.048182 , 0.021508 , 0.010188,
     + 0.009320 , 0.009273 , 0.014047 , 0.019414 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1x1 ( 18 )
      data deta1x1 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.250000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta1y1 ( 18 )
      data deta1y1 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.182693 , 0.223598 , 0.214370,
     + 0.243840 , 0.233084 , 0.242939 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1ey1 ( 18 )
      data deta1ey1 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.014068 , 0.015739 , 0.014963,
     + 0.016143 , 0.014766 , 0.014992 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1sy1 ( 18 )
      data deta1sy1 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.063582 , 0.032032 , 0.082469,
     + 0.036096 , 0.040272 , 0.027586 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1x2 ( 18 )
      data deta1x2 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.250000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta1y2 ( 18 )
      data deta1y2 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.180000 , 0.189014 , 0.248015,
     + 0.240696 , 0.271640 , 0.210813 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1ey2 ( 18 )
      data deta1ey2 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.011919 , 0.011699 , 0.015093,
     + 0.013759 , 0.013689 , 0.010995 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1sy2 ( 18 )
      data deta1sy2 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.019182 , 0.035568 , 0.042533,
     + 0.023230 , 0.021233 , 0.013846 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1x3 ( 18 )
      data deta1x3 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.250000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta1y3 ( 18 )
      data deta1y3 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.184253 , 0.237522 , 0.225009,
     + 0.287443 , 0.264407 , 0.241901 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1ey3 ( 18 )
      data deta1ey3 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.009021 , 0.010938 , 0.009944,
     + 0.012029 , 0.010290 , 0.010127 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1sy3 ( 18 )
      data deta1sy3 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.016658 , 0.014231 , 0.012424,
     + 0.028236 , 0.014305 , 0.014975 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1x4 ( 18 )
      data deta1x4 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.250000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta1y4 ( 18 )
      data deta1y4 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.195286 , 0.225654 , 0.235799,
     + 0.274498 , 0.260185 , 0.234857 , 0.128618 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1ey4 ( 18 )
      data deta1ey4 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.013163 , 0.012172 , 0.012044,
     + 0.012818 , 0.011379 , 0.011173 , 0.009728 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1sy4 ( 18 )
      data deta1sy4 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.027193 , 0.028305 , 0.015761,
     + 0.021592 , 0.015574 , 0.019037 , 0.012740 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1x5 ( 18 )
      data deta1x5 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.250000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta1y5 ( 18 )
      data deta1y5 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.202716 , 0.240428,
     + 0.252368 , 0.231746 , 0.163663 , 0.096085 , 0.013240,
     + 0.000300 , 0.000000 , 0.000000
     + /
      real deta1ey5 ( 18 )
      data deta1ey5 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.010363 , 0.011498,
     + 0.011091 , 0.009868 , 0.008012 , 0.007557 , 0.002875,
     + 0.000279 , 0.000000 , 0.000000
     + /
      real deta1sy5 ( 18 )
      data deta1sy5 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.029652 , 0.026319,
     + 0.013409 , 0.011097 , 0.014180 , 0.025914 , 0.003906,
     + 0.000486 , 0.000000 , 0.000000
     + /
      real deta1x6 ( 18 )
      data deta1x6 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.000000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta1y6 ( 18 )
      data deta1y6 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.203 , 0.196807,
     + 0.222746 , 0.199840 , 0.127013 , 0.044789 , 0.009105,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1ey6 ( 18 )
      data deta1ey6 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.010 , 0.012662,
     + 0.012756 , 0.011414 , 0.008535 , 0.004595 , 0.002640,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1sy6 ( 18 )
      data deta1sy6 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.041 , 0.018449,
     + 0.016666 , 0.016364 , 0.043517 , 0.014931 , 0.007999,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1x7 ( 18 )
      data deta1x7 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.250000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta1y7 ( 18 )
      data deta1y7 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.217939 , 0.271109 , 0.313996,
     + 0.317236 , 0.338311 , 0.316494 , 0.178238 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1ey7 ( 18 )
      data deta1ey7 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.010495 , 0.011590 , 0.013168,
     + 0.012541 , 0.012367 , 0.012576 , 0.010753 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1sy7 ( 18 )
      data deta1sy7 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.030681 , 0.016816 , 0.023475,
     + 0.028950 , 0.028362 , 0.029980 , 0.016941 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1x8 ( 18 )
      data deta1x8 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.250000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta1y8 ( 18 )
      data deta1y8 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.244546 , 0.292619,
     + 0.320038 , 0.287161 , 0.210220 , 0.091631 , 0.021711,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1ey8 ( 18 )
      data deta1ey8 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.012472 , 0.013371,
     + 0.013554 , 0.011546 , 0.010237 , 0.006857 , 0.003954,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1sy8 ( 18 )
      data deta1sy8 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.021332 , 0.023142,
     + 0.021491 , 0.022309 , 0.013733 , 0.022542 , 0.009593,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1x9 ( 18 )
      data deta1x9 /
     + -2.750000 , -2.250000 , -1.750000 , -1.250000 , -0.750000,
     + -0.250000 , 0.250000 , 0.750000 , 1.000000 , 1.750000,
     + 2.250000 , 2.750000 , 3.250000 , 3.750000 , 4.250000,
     + 4.750000 , 5.250000 , 5.750000
     + /
      real deta1y9 ( 18 )
      data deta1y9 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.253 , 0.296094,
     + 0.292781 , 0.219977 , 0.105964 , 0.029185 , 0.002498,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1ey9 ( 18 )
      data deta1ey9 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.01200 , 0.017949,
     + 0.015594 , 0.013181 , 0.007009 , 0.003488 , 0.001130,
     + 0.000000 , 0.000000 , 0.000000
     + /
      real deta1sy9 ( 18 )
      data deta1sy9 /
     + 0.000000 , 0.000000 , 0.000000 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000 , 0.000000 , 0.044 , 0.040663,
     + 0.031058 , 0.024536 , 0.031559 , 0.006095 , 0.001575,
     + 0.000000 , 0.000000 , 0.000000
     + /
*KEEP,
      real dpte1x0 ( 17 )
      data dpte1x0 /
     + 0.162360 , 0.298877 , 0.490576 , 0.689316 , 0.890855,
     + 1.090134 , 1.293101 , 1.491562 , 1.694025 , 1.938814,
     + 2.282308 , 2.725309 , 3.411661 , 4.389038 , 5.492702,
     + 6.696726 , 8.906260
     + /
      real dpte1y0 ( 17 )
      data dpte1y0 /
     + 0.000000 , 3.809271 , 2.241907 , 1.184976 , 0.641582,
     + 0.331231 , 0.210534 , 0.127926 , 0.076379 , 0.055994,
     + 0.028325 , 0.014849 , 0.007091 , 0.002364 , 0.000933,
     + 0.000502 , 0.000054
     + /
      real dpte1ey0 ( 17 )
      data dpte1ey0 /
     + 0.000000 , 0.031118 , 0.020752 , 0.014522 , 0.010738,
     + 0.007553 , 0.006344 , 0.004836 , 0.003775 , 0.002712,
     + 0.001590 , 0.001044 , 0.000542 , 0.000292 , 0.000166,
     + 0.000107 , 0.000026
     + /
      real dpte1sy0 ( 17 )
      data dpte1sy0 /
     + 0.000000 , 0.503476 , 0.195446 , 0.097384 , 0.049776,
     + 0.041316 , 0.028940 , 0.013242 , 0.019292 , 0.010790,
     + 0.006085 , 0.002733 , 0.001375 , 0.000629 , 0.000339,
     + 0.000127 , 0.000048
     + /
      real dpte1x1 ( 17 )
      data dpte1x1 /
     + 0.157880 , 0.296208 , 0.488990 , 0.688672 , 0.892311,
     + 1.090899 , 1.293972 , 1.485585 , 1.684990 , 1.949313,
     + 2.308975 , 2.740007 , 3.284047 , 4.304148 , 5.500000,
     + 6.759059 , 9.000000
     + /
      real dpte1y1 ( 17 )
      data dpte1y1 /
     + 0.000000 , 3.964725 , 2.250483 , 1.181318 , 0.615708,
     + 0.369140 , 0.215639 , 0.124290 , 0.066408 , 0.053580,
     + 0.026624 , 0.018312 , 0.006078 , 0.002407 , 0.000000,
     + 0.000627 , 0.000000
     + /
      real dpte1ey1 ( 17 )
      data dpte1ey1 /
     + 0.000000 , 0.090217 , 0.061397 , 0.045599 , 0.033487,
     + 0.027907 , 0.021770 , 0.015804 , 0.011349 , 0.009564,
     + 0.005216 , 0.004773 , 0.001693 , 0.001057 , 0.000000,
     + 0.000399 , 0.000000
     + /
      real dpte1sy1 ( 17 )
      data dpte1sy1 /
     + 0.000000 , 0.429452 , 0.136517 , 0.126414 , 0.063365,
*     + 0.062731 , 0.038956 , 0.026626 , 0.088158 , 0.011617,
*     + 0.062731 , 0.038956 , 0.026626 , 0.044158 , 0.011617,
     + 0.062731 , 0.038956 , 0.026626 , 0.024158 , 0.011617,
*     + 0.008927 , 0.012334 , 0.003247 , 0.002807 , 0.000000,
     + 0.008927 , 0.009334 , 0.003247 , 0.002807 , 0.000000,
     + 0.000714 , 0.000000
     + /
      real dpte1x2 ( 17 )
      data dpte1x2 /
     + 0.161445 , 0.296189 , 0.490345 , 0.688699 , 0.891673,
     + 1.085692 , 1.293970 , 1.497802 , 1.695254 , 1.935458,
     + 2.277624 , 2.732543 , 3.469652 , 4.405536 , 5.514422,
     + 7.009683 , 9.000000
     + /
      real dpte1y2 ( 17 )
      data dpte1y2 /
     + 0.000000 , 3.877373 , 2.400283 , 1.145470 , 0.721684,
     + 0.290112 , 0.222869 , 0.135009 , 0.062534 , 0.060400,
     + 0.022993 , 0.011480 , 0.007940 , 0.000000 , 0.000000,
     + 0.000502 , 0.000000
     + /
      real dpte1ey2 ( 17 )
      data dpte1ey2 /
     + 0.000000 , 0.083579 , 0.060179 , 0.039119 , 0.033827,
     + 0.019545 , 0.019786 , 0.015707 , 0.009412 , 0.008625,
     + 0.004157 , 0.002718 , 0.002043 , 0.000000 , 0.000000,
     + 0.000364 , 0.000000
     + /
      real dpte1sy2 ( 17 )
      data dpte1sy2 /
     + 0.000000 , 0.445966 , 0.222516 , 0.073247 , 0.069923,
*     + 0.064002 , 0.033546 , 0.022772 , 0.021368 , 0.010949,
     + 0.064002 , 0.033546 , 0.022772 , 0.011368 , 0.010949,
     + 0.008113 , 0.004042 , 0.006983 , 0.000000 , 0.000000,
     + 0.000630 , 0.000000
     + /
      real dpte1x3 ( 17 )
      data dpte1x3 /
     + 0.160267 , 0.297412 , 0.489808 , 0.687823 , 0.888031,
     + 1.089949 , 1.295086 , 1.490131 , 1.697480 , 1.933894,
     + 2.277411 , 2.724032 , 3.414287 , 4.415628 , 5.464792,
     + 6.793752 , 9.529037
     + /
      real dpte1y3 ( 17 )
      data dpte1y3 /
     + 0.000000 , 4.035040 , 2.384313 , 1.281876 , 0.701290,
     + 0.358940 , 0.232133 , 0.127767 , 0.083752 , 0.064109,
     + 0.031486 , 0.014645 , 0.006462 , 0.002890 , 0.001080,
     + 0.000370 , 0.000000
     + /
      real dpte1ey3 ( 17 )
      data dpte1ey3 /
     + 0.000000 , 0.066086 , 0.046255 , 0.033595 , 0.025511,
     + 0.018077 , 0.015662 , 0.010941 , 0.009252 , 0.006927,
     + 0.004143 , 0.002176 , 0.001123 , 0.000767 , 0.000414,
     + 0.000195 , 0.000000
     + /
      real dpte1sy3 ( 17 )
      data dpte1sy3 /
     + 0.000000 , 0.438972 , 0.170568 , 0.093933 , 0.044942,
*     + 0.022098 , 0.032619 , 0.011751 , 0.025036 , 0.007435,
     + 0.022098 , 0.032619 , 0.011751 , 0.015036 , 0.007435,
     + 0.006797 , 0.003278 , 0.001214 , 0.001683 , 0.000932,
     + 0.000255 , 0.000000
     + /
      real dpte1x4 ( 17 )
      data dpte1x4 /
     + 0.167556 , 0.300000 , 0.491152 , 0.689191 , 0.894802,
     + 1.091834 , 1.295076 , 1.491754 , 1.687291 , 1.941291,
     + 2.270712 , 2.723969 , 3.409333 , 4.346185 , 5.521909,
     + 6.997241 , 8.728801
     + /
      real dpte1y4 ( 17 )
      data dpte1y4 /
     + 0.000000 , 3.885024 , 2.348275 , 1.242578 , 0.668143,
     + 0.303928 , 0.233712 , 0.141039 , 0.090458 , 0.059983,
     + 0.050754 , 0.021726 , 0.006169 , 0.000000 , 0.000000,
     + 0.000368 , 0.000043
     + /
      real dpte1ey4 ( 17 )
      data dpte1ey4 /
     + 0.000000 , 0.083776 , 0.059075 , 0.041913 , 0.031373,
     + 0.019496 , 0.019571 , 0.014651 , 0.012648 , 0.008208,
     + 0.007988 , 0.004470 , 0.001337 , 0.000000 , 0.000000,
     + 0.000236 , 0.000048
     + /
      real dpte1sy4 ( 17 )
      data dpte1sy4 /
     + 0.000000 , 0.526392 , 0.183135 , 0.104440 , 0.067856,
     + 0.047845 , 0.025207 , 0.034590 , 0.019041 , 0.011542,
     + 0.021529 , 0.011768 , 0.003204 , 0.000000 , 0.000000,
     + 0.000366 , 0.000086
     + /
      real dpte1x5 ( 17 )
      data dpte1x5 /
     + 0.175773 , 0.303910 , 0.493302 , 0.687073 , 0.890848,
     + 1.089773 , 1.290292 , 1.495525 , 1.708378 , 1.951255,
     + 2.253758 , 2.763419 , 3.447014 , 4.441384 , 5.490909,
     + 6.556049 , 9.000000
     + /
      real dpte1y5 ( 17 )
      data dpte1y5 /
     + 0.000000 , 0.000000 , 2.104012 , 1.171201 , 0.580983,
     + 0.336386 , 0.205590 , 0.141338 , 0.083767 , 0.054240,
     + 0.022451 , 0.012142 , 0.007565 , 0.000000 , 0.000000,
     + 0.000000 , 0.000000
     + /
*     + 0.022451 , 0.012142 , 0.007565 , 0.000971 , 0.001163,
      real dpte1ey5 ( 17 )
      data dpte1ey5 /
     + 0.000000 , 0.000000 , 0.062175 , 0.045082 , 0.032210,
     + 0.023304 , 0.019158 , 0.017185 , 0.012397 , 0.008173,
     + 0.003854 , 0.002599 , 0.001807 , 0.000349 , 0.000769,
     + 0.000000 , 0.000000
     + /
      real dpte1sy5 ( 17 )
      data dpte1sy5 /
     + 0.000000 , 0.000000 , 0.256033 , 0.159328 , 0.057842,
     + 0.070388 , 0.027805 , 0.038085 , 0.028985 , 0.014528,
     + 0.007980 , 0.004956 , 0.005243 , 0.001363 , 0.001020,
     + 0.000000 , 0.000000
     + /
*                               this data are from UK analysis
      real dpte1x6 ( 17 )
      data dpte1x6 /
     + 0.100000 , 0.300000 , 0.500000 , 0.700000 , 0.900000,
     + 1.100000 , 1.300000 , 1.500000 , 1.700000 , 1.950000,
     + 2.300000 , 2.750000 , 3.500000 , 4.500000 , 5.500000,
     + 7.000000 , 9.000000
     + /
      real dpte1y6 ( 17 )
      data dpte1y6 /
     + 2.570000 , 3.660000 , 2.250000 , 1.150000 , 0.620000,
     + 0.340000 , 0.210000 , 0.130000 , 0.093000 , 0.045400,
     + 0.039300 , 0.014800 , 0.007400 , 0.000000 , 0.0,
     + 0.000000 , 0.000000
     + /
      real dpte1ey6 ( 17 )
      data dpte1ey6 /
     + 0.101000 , 0.088000 , 0.700000 , 0.050000 , 0.037000,
     + 0.028000 , 0.023000 , 0.018000 , 0.015000 , 0.008200,
     + 0.007700 , 0.003800 , 0.002100 , 0.0      , 0.0,
     + 0.000    , 0.000000
     + /
      real dpte1sy6 ( 17 )
      data dpte1sy6 /
     + 0.32     , 0.28     , 0.11     , 0.10     , 0.041   ,
     + 0.046    , 0.043    , 0.017    , 0.023    , 0.0077  ,
     + 0.019    , 0.0098   , 0.0049   , 0.0      , 0.0     ,
     + 0.000    , 0.0000
     + /
      real dpte1x7 ( 17 )
      data dpte1x7 /
     + 0.162133 , 0.297150 , 0.489087 , 0.692878 , 0.889799,
     + 1.089919 , 1.292735 , 1.491898 , 1.692592 , 1.940659,
     + 2.281777 , 2.721463 , 3.382576 , 4.346806 , 5.536829,
     + 6.618409 , 8.963818
     + /
      real dpte1y7 ( 17 )
      data dpte1y7 /
     + 0.000000 , 4.113233 , 2.453447 , 1.333447 , 0.704757,
     + 0.416686 , 0.222304 , 0.173507 , 0.096993 , 0.068347,
     + 0.037876 , 0.019830 , 0.009541 , 0.003660 , 0.001623,
     + 0.000562 , 0.000000
     + /
      real dpte1ey7 ( 17 )
      data dpte1ey7 /
     + 0.000000 , 0.072634 , 0.050488 , 0.036494 , 0.025940,
     + 0.020593 , 0.014832 , 0.013475 , 0.010240 , 0.006818,
     + 0.004258 , 0.002825 , 0.001466 , 0.000877 , 0.000533,
     + 0.000266 , 0.000000
     + /
      real dpte1sy7 ( 17 )
      data dpte1sy7 /
     + 0.000000 , 0.463639 , 0.237014 , 0.116357 , 0.043690,
     + 0.045129 , 0.037385 , 0.017226 , 0.022884 , 0.018814,
     + 0.005120 , 0.003526 , 0.001889 , 0.002560 , 0.001138,
     + 0.000428 , 0.000000
     + /
      real dpte1x8 ( 17 )
      data dpte1x8 /
     + 0.171338 , 0.302290 , 0.492383 , 0.688816 , 0.891178,
     + 1.090408 , 1.286769 , 1.483307 , 1.693555 , 1.920627,
     + 2.294145 , 2.680084 , 3.452182 , 4.456293 , 5.388338,
     + 6.544116 , 8.738633
     + /
      real dpte1y8 ( 17 )
      data dpte1y8 /
     + 0.000000 , 0.000000 , 2.318220 , 1.244961 , 0.699909,
     + 0.386925 , 0.242838 , 0.135416 , 0.114591 , 0.059713,
     + 0.035617 , 0.016327 , 0.010424 , 0.003232 , 0.001346,
     + 0.001333 , 0.000000
     + /
      real dpte1ey8 ( 17 )
      data dpte1ey8 /
     + 0.000000 , 0.000000 , 0.068041 , 0.047018 , 0.034438,
     + 0.025872 , 0.020533 , 0.014654 , 0.015446 , 0.008157,
     + 0.005243 , 0.003399 , 0.002173 , 0.001046 , 0.000649,
     + 0.000706 , 0.000000
     + /
      real dpte1sy8 ( 17 )
      data dpte1sy8 /
     + 0.000000 , 0.000000 , 0.194213 , 0.085400 , 0.110409,
     + 0.033184 , 0.030204 , 0.031122 , 0.023996 , 0.009410,
     + 0.008817 , 0.005804 , 0.003938 , 0.001611 , 0.001403,
     + 0.001150 , 0.000000
     + /
*                              data from UK analysis
      real dpte1x9 ( 17 )
      data dpte1x9 /
     + 0.100000 , 0.300000 , 0.500000 , 0.700000 , 0.900000,
     + 1.100000 , 1.300000 , 1.500000 , 1.700000 , 1.950000,
     + 2.300000 , 2.750000 , 3.500000 , 4.500000 , 5.500000,
     + 7.000000 , 9.000000
     + /
      real dpte1y9 ( 17 )
      data dpte1y9 /
     + 2.41     , 3.59     , 2.17     , 1.12     , 0.68    ,
     + 0.36     , 0.26     , 0.165    , 0.126    , 0.082    ,
     + 0.040    , 0.0184   , 0.0106   , 0.0027   , 0.0008   ,
     + 0.0008   , 0.0004
     + /
      real dpte1ey9 ( 17 )
      data dpte1ey9 /
     + 0.101,     0.092,     0.071,     0.051,     0.041,
     + 0.029,     0.027,     0.021,     0.019,     0.013,
     + 0.0081,    0.0043,    0.0026,    0.0011,    0.00048,
     + 0.0005,    0.0006
     + /
      real dpte1sy9 ( 17 )
      data dpte1sy9 /
     + 0.23,      0.20,      0.14,      0.055,     0.069,
     + 0.037,     0.032,     0.031,     0.042,     0.015,
     + 0.014,     0.0084,    0.0037,    0.0020,    0.0020,
     + 0.00082 ,  0.000764
     + /
*KEEP,
      real dptc1x0 ( 17 )
      data dptc1x0 /
     + 0.147694 , 0.293846 , 0.490388 , 0.689648 , 0.891181,
     + 1.094106 , 1.291681 , 1.493362 , 1.689540 , 1.938333,
     + 2.277400 , 2.723569 , 3.409679 , 4.409751 , 5.409957,
     + 6.688886 , 8.575716
     + /
      real dptc1y0 ( 17 )
      data dptc1y0 /
     + 2.716896 , 4.025324 , 2.412090 , 1.303974 , 0.714159,
     + 0.411238 , 0.268062 , 0.164476 , 0.117168 , 0.078514,
     + 0.043880 , 0.024724 , 0.009706 , 0.003406 , 0.001390,
     + 0.000445 , 0.000120
     + /
      real dptc1ey0 ( 17 )
      data dptc1ey0 /
     + 0.022981 , 0.025334 , 0.018684 , 0.013582 , 0.010148,
     + 0.007755 , 0.006413 , 0.004905 , 0.004235 , 0.002892,
     + 0.001837 , 0.001267 , 0.000540 , 0.000315 , 0.000205,
     + 0.000080 , 0.000044
     + /
      real dptc1sy0 ( 17 )
      data dptc1sy0 /
     + 0.674440 , 0.266596 , 0.087826 , 0.040211 , 0.022999,
     + 0.016705 , 0.012547 , 0.009536 , 0.009050 , 0.005292,
     + 0.005121 , 0.002559 , 0.000720 , 0.000364 , 0.000367,
     + 0.000086 , 0.000095
     + /
      real dptc1x1 ( 17 )
      data dptc1x1 /
     + 0.142511 , 0.293595 , 0.492429 , 0.688975 , 0.891263,
     + 1.090830 , 1.291974 , 1.493928 , 1.682002 , 1.941305,
     + 2.263516 , 2.700239 , 3.397242 , 4.356895 , 5.416314,
     + 6.557664 , 8.570911
     + /
      real dptc1y1 ( 17 )
      data dptc1y1 /
     + 2.720804 , 4.083863 , 2.496331 , 1.273163 , 0.699145,
     + 0.412444 , 0.224467 , 0.113231 , 0.106218 , 0.074062,
     + 0.024571 , 0.019320 , 0.008643 , 0.002625 , 0.001826,
     + 0.000219 , 0.000249
     + /
      real dptc1ey1 ( 17 )
      data dptc1ey1 /
     + 0.076272 , 0.090533 , 0.068490 , 0.048173 , 0.036676,
     + 0.030753 , 0.021816 , 0.013863 , 0.015449 , 0.010920,
     + 0.004437 , 0.004089 , 0.002152 , 0.001121 , 0.000855,
     + 0.000161 , 0.000253
     + /
      real dptc1sy1 ( 17 )
      data dptc1sy1 /
     + 0.653494 , 0.292545 , 0.173902 , 0.073565 , 0.077007,
     + 0.124268 , 0.034480 , 0.034968 , 0.035378 , 0.020404,
*     + 0.020445 , 0.031317 , 0.003238 , 0.001298 , 0.002187,
*     + 0.020445 , 0.011317 , 0.003238 , 0.001298 , 0.002187,
     + 0.007445 , 0.006317 , 0.003238 , 0.001298 , 0.002187,
     + 0.000282 , 0.000398
     + /
      real dptc1x2 ( 17 )
      data dptc1x2 /
     + 0.145037 , 0.293841 , 0.492014 , 0.689552 , 0.890136,
     + 1.090716 , 1.288026 , 1.490909 , 1.680064 , 1.938085,
     + 2.268266 , 2.725070 , 3.450559 , 4.422081 , 5.562262,
     + 6.508696 , 8.325836
     + /
      real dptc1y2 ( 17 )
      data dptc1y2 /
     + 3.009003 , 4.060803 , 2.409950 , 1.295427 , 0.688230,
     + 0.358538 , 0.283491 , 0.152851 , 0.109202 , 0.071605,
     + 0.045236 , 0.017227 , 0.010488 , 0.001799 , 0.000447,
     + 0.000000 , 0.000000
     + /
      real dptc1ey2 ( 17 )
      data dptc1ey2 /
     + 0.073530 , 0.079836 , 0.058430 , 0.042968 , 0.031562,
     + 0.023344 , 0.023317 , 0.015650 , 0.013936 , 0.009507,
     + 0.006527 , 0.003302 , 0.001926 , 0.000637 , 0.000274,
     + 0.000000 , 0.000000
     + /
      real dptc1sy2 ( 17 )
      data dptc1sy2 /
     + 0.722265 , 0.211490 , 0.092714 , 0.064788 , 0.045429,
     + 0.060081 , 0.043523 , 0.025701 , 0.028262 , 0.011149,
     + 0.009932 , 0.003803 , 0.002574 , 0.000788 , 0.000607,
     + 0.000000 , 0.000000
     + /
      real dptc1x3 ( 17 )
      data dptc1x3 /
     + 0.144455 , 0.293716 , 0.490440 , 0.691144 , 0.889625,
     + 1.093596 , 1.289810 , 1.489009 , 1.694837 , 1.928929,
     + 2.261349 , 2.721453 , 3.429991 , 4.417402 , 5.503767,
     + 6.755540 , 9.000000
     + /
      real dptc1y3 ( 17 )
      data dptc1y3 /
     + 2.787075 , 4.250382 , 2.493271 , 1.352758 , 0.712999,
     + 0.389431 , 0.250610 , 0.167815 , 0.126229 , 0.073481,
     + 0.044784 , 0.026861 , 0.008675 , 0.002924 , 0.001291,
     + 0.000696 , 0.000000
     + /
      real dptc1ey3 ( 17 )
      data dptc1ey3 /
     + 0.054401 , 0.065158 , 0.047625 , 0.034854 , 0.025325,
     + 0.018405 , 0.015224 , 0.012717 , 0.011457 , 0.007153,
     + 0.005102 , 0.003385 , 0.001282 , 0.000686 , 0.000470,
     + 0.000286 , 0.000000
     + /
      real dptc1sy3 ( 17 )
      data dptc1sy3 /
     + 0.716546 , 0.248871 , 0.097121 , 0.064630 , 0.056193,
     + 0.032588 , 0.024290 , 0.021928 , 0.028998 , 0.014745,
     + 0.009205 , 0.004416 , 0.002052 , 0.000985 , 0.000869,
     + 0.000353 , 0.000053
     + /
      real dptc1x4 ( 17 )
      data dptc1x4 /
     + 0.146742 , 0.292988 , 0.487485 , 0.686987 , 0.893271,
     + 1.091360 , 1.294880 , 1.489839 , 1.686705 , 1.942431,
     + 2.267371 , 2.698091 , 3.383207 , 4.408684 , 5.587488,
     + 6.883616 , 9.210982
     + /
      real dptc1y4 ( 17 )
      data dptc1y4 /
     + 2.760948 , 4.037536 , 2.367485 , 1.255681 , 0.675033,
     + 0.434153 , 0.279069 , 0.145832 , 0.109532 , 0.070732,
     + 0.052800 , 0.015866 , 0.006439 , 0.002961 , 0.000837,
     + 0.000178 , 0.000000
     + /
      real dptc1ey4 ( 17 )
      data dptc1ey4 /
     + 0.064502 , 0.072324 , 0.051995 , 0.037350 , 0.027732,
     + 0.023808 , 0.019147 , 0.012863 , 0.011305 , 0.007496,
     + 0.006092 , 0.002745 , 0.001129 , 0.000773 , 0.000405,
     + 0.000121 , 0.000000
     + /
      real dptc1sy4 ( 17 )
      data dptc1sy4 /
     + 0.658177 , 0.312193 , 0.126168 , 0.068847 , 0.048266,
     + 0.030436 , 0.025059 , 0.025663 , 0.024075 , 0.009968,
     + 0.011006 , 0.004055 , 0.002327 , 0.001174 , 0.000611,
     + 0.000147 , 0.000000
     + /
      real dptc1x5 ( 17 )
      data dptc1x5 /
     + 0.152168 , 0.293684 , 0.490073 , 0.689051 , 0.892168,
     + 1.094797 , 1.294933 , 1.493060 , 1.684506 , 1.940361,
     + 2.287311 , 2.723493 , 3.371955 , 4.427608 , 5.390126,
     + 6.452320 , 8.346775
     + /
      real dptc1y5 ( 17 )
      data dptc1y5 /
     + 2.636499 , 3.922620 , 2.381756 , 1.286635 , 0.694123,
     + 0.385937 , 0.278184 , 0.157847 , 0.103332 , 0.068130,
     + 0.038561 , 0.020760 , 0.008837 , 0.002248 , 0.000874,
     + 0.000000 , 0.000000
     + /
      real dptc1ey5 ( 17 )
      data dptc1ey5 /
     + 0.062848 , 0.067031 , 0.050156 , 0.036455 , 0.027078,
     + 0.020217 , 0.018115 , 0.012973 , 0.010493 , 0.006988,
     + 0.004470 , 0.003031 , 0.001392 , 0.000648 , 0.000359,
     + 0.000000 , 0.000000
     + /
      real dptc1sy5 ( 17 )
      data dptc1sy5 /
     + 0.653414 , 0.344080 , 0.111256 , 0.061583 , 0.047735,
     + 0.029457 , 0.042323 , 0.021658 , 0.012918 , 0.007479,
     + 0.006905 , 0.005201 , 0.001568 , 0.000937 , 0.000556,
     + 0.000000 , 0.000000
     + /
      real dptc1x6 ( 17 )
      data dptc1x6 /
     + 0.157954 , 0.295517 , 0.489658 , 0.688904 , 0.890000,
     + 1.096887 , 1.297076 , 1.493314 , 1.697042 , 1.941818,
     + 2.281169 , 2.719217 , 3.419540 , 4.454938 , 5.406593,
     + 7.612245 , 8.712883
     + /
      real dptc1y6 ( 17 )
      data dptc1y6 /
     + 0.000000 , 3.857549 , 2.338637 , 1.267592 , 0.737240,
     + 0.368518 , 0.192383 , 0.146525 , 0.099048 , 0.061205,
     + 0.031139 , 0.018795 , 0.005526 , 0.001720 , 0.000463,
     + 0.000000 , 0.000000
     + /
      real dptc1ey6 ( 17 )
      data dptc1ey6 /
     + 0.000000 , 0.090714 , 0.066276 , 0.048257 , 0.038115,
     + 0.025283 , 0.016598 , 0.015687 , 0.013203 , 0.008737,
     + 0.005095 , 0.003476 , 0.001176 , 0.000631 , 0.000356,
     + 0.000000 , 0.000000
     + /
      real dptc1sy6 ( 17 )
      data dptc1sy6 /
     + 0.000000 , 0.445905 , 0.160504 , 0.127881 , 0.067323,
     + 0.029726 , 0.034040 , 0.023816 , 0.025680 , 0.012204,
     + 0.009643 , 0.005011 , 0.002181 , 0.000977 , 0.000472,
     + 0.000000 , 0.000000
     + /
      real dptc1x7 ( 17 )
      data dptc1x7 /
     + 0.145859 , 0.293751 , 0.490604 , 0.689643 , 0.890579,
     + 1.096949 , 1.292231 , 1.496885 , 1.694827 , 1.936240,
     + 2.287501 , 2.731355 , 3.406848 , 4.386663 , 5.386798,
     + 6.700425 , 8.544601
     + /
      real dptc1y7 ( 17 )
      data dptc1y7 /
     + 2.823874 , 4.133102 , 2.424724 , 1.382891 , 0.770065,
     + 0.491208 , 0.279378 , 0.189531 , 0.136135 , 0.101082,
     + 0.057862 , 0.034629 , 0.012369 , 0.006992 , 0.003135,
     + 0.000933 , 0.000308
     + /
      real dptc1ey7 ( 17 )
      data dptc1ey7 /
     + 0.058516 , 0.066088 , 0.048597 , 0.036252 , 0.027782,
     + 0.022113 , 0.016282 , 0.013617 , 0.011652 , 0.008505,
     + 0.005448 , 0.003899 , 0.001515 , 0.001308 , 0.000984,
     + 0.000346 , 0.000192
     + /
      real dptc1sy7 ( 17 )
      data dptc1sy7 /
     + 0.698489 , 0.236435 , 0.100596 , 0.051506 , 0.037120,
     + 0.043625 , 0.036412 , 0.021104 , 0.019520 , 0.013036,
     + 0.015160 , 0.011431 , 0.002317 , 0.001792 , 0.001483,
     + 0.000431 , 0.000474
     + /
      real dptc1x8 ( 17 )
      data dptc1x8 /
     + 0.151309 , 0.293659 , 0.489961 , 0.691081 , 0.890838,
     + 1.094539 , 1.289616 , 1.495800 , 1.691975 , 1.947166,
     + 2.285092 , 2.721915 , 3.386699 , 4.420917 , 5.375386,
     + 6.687088 , 8.527062
     + /
      real dptc1y8 ( 17 )
      data dptc1y8 /
     + 2.815146 , 3.989308 , 2.481748 , 1.253898 , 0.740500,
     + 0.437656 , 0.326755 , 0.208199 , 0.131678 , 0.083892,
     + 0.050112 , 0.027720 , 0.012471 , 0.000000 , 0.003019,
     + 0.000439 , 0.000134
     + /
      real dptc1ey8 ( 17 )
      data dptc1ey8 /
     + 0.069764 , 0.072636 , 0.054718 , 0.037935 , 0.029099,
     + 0.022025 , 0.020789 , 0.016036 , 0.012338 , 0.007976,
     + 0.005324 , 0.003817 , 0.001590 , 0.000000 , 0.001123,
     + 0.000205 , 0.000111
     + /
      real dptc1sy8 ( 17 )
      data dptc1sy8 /
     + 0.711585 , 0.285220 , 0.099777 , 0.058840 , 0.043242,
     + 0.042007 , 0.047663 , 0.022600 , 0.019342 , 0.015086,
     + 0.007371 , 0.004693 , 0.003836 , 0.000000 , 0.001625,
     + 0.000274 , 0.000136
     + /
      real dptc1x9 ( 17 )
      data dptc1x9 /
     + 0.159087 , 0.295322 , 0.492507 , 0.691324 , 0.893927,
     + 1.095948 , 1.286757 , 1.498794 , 1.685962 , 1.928382,
     + 2.290783 , 2.750410 , 3.480629 , 4.420528 , 5.072345,
     + 6.597868 , 9.000000
     + /
      real dptc1y9 ( 17 )
      data dptc1y9 /
     + 0.000000 , 3.832153 , 2.335656 , 1.385647 , 0.747305,
     + 0.446340 , 0.315724 , 0.188934 , 0.114273 , 0.102270,
     + 0.047921 , 0.031811 , 0.009681 , 0.002054 , 0.000874,
     + 0.000239 , 0.000000
     + /
      real dptc1ey9 ( 17 )
      data dptc1ey9 /
     + 0.000000 , 0.100071 , 0.072664 , 0.055077 , 0.039241,
     + 0.029086 , 0.027928 , 0.018905 , 0.014002 , 0.011979,
     + 0.006789 , 0.004841 , 0.001881 , 0.000726 , 0.000450,
     + 0.000169 , 0.000000
     + /
      real dptc1sy9 ( 17 )
      data dptc1sy9 /
     + 0.000000 , 0.526701 , 0.219943 , 0.105940 , 0.079783,
     + 0.059182 , 0.053690 , 0.024898 , 0.032368 , 0.024351,
     + 0.017462 , 0.013053 , 0.003569 , 0.001840 , 0.000736,
     + 0.000237 , 0.000000
     + /
*KEEP,
      real dptmc1x0 ( 12 )
      data dptmc1x0 /
     + 0.184909 , 0.383239 , 0.625135 , 0.870177 , 1.123248,
     + 1.366931 , 1.618030 , 1.872407 , 2.223640 , 2.726116,
     + 3.422122 , 4.408915
     + /
      real dptmc1y0 ( 12 )
C      data dptmc1y0 /
C     + 0.000000 , 0.378703 , 0.662712 , 0.617272 , 0.545168,
C     + 0.416210 , 0.300387 , 0.229335 , 0.155616 , 0.088815,
C     + 0.040083 , 0.014621
C     + /
      real dptmc1ey0 ( 12 )
      data dptmc1ey0 /
     + 0.000000 , 0.011082 , 0.017044 , 0.017496 , 0.017870,
     + 0.015604 , 0.013217 , 0.012017 , 0.006912 , 0.005196,
     + 0.002373 , 0.001407
     + /
      real dptmc1sy0 ( 12 )
      data dptmc1sy0 /
     + 0.000000 , 0.076599 , 0.065954 , 0.024231 , 0.029671,
     + 0.045498 , 0.031002 , 0.036342 , 0.033727 , 0.019826,
     + 0.006893 , 0.003985
     + /
      real dptmc1x1 ( 12 )
      data dptmc1x1 /
     + 0.190846 , 0.380396 , 0.621361 , 0.861916 , 1.127293,
     + 1.355656 , 1.621185 , 1.890611 , 2.205649 , 2.718820,
     + 3.400975 , 4.382236
     + /
      real dptmc1y1 ( 12 )
C      data dptmc1y1 /
C     + 0.142169 , 0.437253 , 0.725419 , 0.609752 , 0.601025,
C     + 0.348934 , 0.240537 , 0.239799 , 0.104868 , 0.074800,
C     + 0.031405 , 0.010037
C     + /
      real dptmc1ey1 ( 12 )
      data dptmc1ey1 /
     + 0.029371 , 0.051959 , 0.072994 , 0.069196 , 0.082287,
     + 0.054925 , 0.048711 , 0.054164 , 0.019990 , 0.020936,
     + 0.008157 , 0.004529
     + /
      real dptmc1sy1 ( 12 )
      data dptmc1sy1 /
     + 0.111852 , 0.140224 , 0.170602 , 0.089970 , 0.220207,
*     + 0.067577 , 0.113366 , 0.148308 , 0.077740 , 0.205908,
     + 0.067577 , 0.113366 , 0.148308 , 0.077740 , 0.055908,
     + 0.014900 , 0.005471
     + /
      real dptmc1x2 ( 12 )
      data dptmc1x2 /
     + 0.173446 , 0.380954 , 0.625297 , 0.880973 , 1.121135,
     + 1.365871 , 1.613911 , 1.870800 , 2.240837 , 2.713929,
     + 3.483297 , 4.454574
     + /
      real dptmc1y2 ( 12 )
C      data dptmc1y2 /
C     + 0.000000 , 0.301573 , 0.820497 , 0.658454 , 0.437798,
C     + 0.423712 , 0.309899 , 0.277312 , 0.159087 , 0.059154,
C     + 0.042440 , 0.009975
C     + /
      real dptmc1ey2 ( 12 )
      data dptmc1ey2 /
     + 0.000000 , 0.030722 , 0.069862 , 0.062159 , 0.051943,
     + 0.055969 , 0.046861 , 0.055611 , 0.025681 , 0.013933,
     + 0.008281 , 0.003708
     + /
      real dptmc1sy2 ( 12 )
      data dptmc1sy2 /
     + 0.000000 , 0.131102 , 0.119301 , 0.091600 , 0.088506,
     + 0.123725 , 0.101779 , 0.088202 , 0.053453 , 0.018133,
     + 0.014177 , 0.004573
     + /
      real dptmc1x3 ( 12 )
      data dptmc1x3 /
     + 0.180028 , 0.381590 , 0.629139 , 0.863371 , 1.119423,
     + 1.368836 , 1.615343 , 1.871934 , 2.232031 , 2.731070,
     + 3.436053 , 4.404230
     + /
      real dptmc1y3 ( 12 )
C      data dptmc1y3 /
C     + 0.000000 , 0.442598 , 0.707436 , 0.686856 , 0.455719,
C     + 0.343175 , 0.330933 , 0.193491 , 0.147872 , 0.090559,
C     + 0.036331 , 0.012230
C     + /
      real dptmc1ey3 ( 12 )
      data dptmc1ey3 /
     + 0.000000 , 0.034238 , 0.047598 , 0.050030 , 0.039567,
     + 0.034439 , 0.038396 , 0.028244 , 0.018548 , 0.013226,
     + 0.005896 , 0.003085
     + /
      real dptmc1sy3 ( 12 )
      data dptmc1sy3 /
     + 0.000000 , 0.118195 , 0.111540 , 0.103826 , 0.099728,
     + 0.056644 , 0.072793 , 0.044463 , 0.055527 , 0.023860,
     + 0.012071 , 0.006488
     + /
      real dptmc1x4 ( 12 )
      data dptmc1x4 /
     + 0.187797 , 0.386666 , 0.617034 , 0.885750 , 1.123402,
     + 1.364294 , 1.620372 , 1.866134 , 2.218742 , 2.706939,
     + 3.381609 , 4.378360
     + /
      real dptmc1y4 ( 12 )
C      data dptmc1y4 /
C     + 0.000000 , 0.408592 , 0.700393 , 0.569680 , 0.529493,
C     + 0.495197 , 0.249173 , 0.189880 , 0.184152 , 0.067487,
C     + 0.028653 , 0.012856
C     + /
      real dptmc1ey4 ( 12 )
      data dptmc1ey4 /
     + 0.000000 , 0.034243 , 0.052987 , 0.049159 , 0.053111,
     + 0.055188 , 0.032688 , 0.030169 , 0.023265 , 0.013199,
     + 0.005398 , 0.003478
     + /
      real dptmc1sy4 ( 12 )
      data dptmc1sy4 /
     + 0.000000 , 0.106887 , 0.076530 , 0.055801 , 0.080163,
     + 0.118662 , 0.048121 , 0.071336 , 0.057352 , 0.031075,
     + 0.006385 , 0.003883
     + /
      real dptmc1x5 ( 12 )
      data dptmc1x5 /
     + 0.188176 , 0.379771 , 0.624705 , 0.874184 , 1.121995,
     + 1.363787 , 1.624489 , 1.873053 , 2.220750 , 2.733312,
     + 3.381868 , 4.418096
     + /
      real dptmc1y5 ( 12 )
C      data dptmc1y5 /
C     + 0.097193 , 0.326301 , 0.748267 , 0.524361 , 0.574877,
C     + 0.544302 , 0.249174 , 0.166812 , 0.160329 , 0.081082,
C     + 0.042639 , 0.010993
C     + /
      real dptmc1ey5 ( 12 )
      data dptmc1ey5 /
     + 0.014934 , 0.024857 , 0.050682 , 0.039920 , 0.050235,
     + 0.053505 , 0.031388 , 0.024893 , 0.019081 , 0.013329,
     + 0.006957 , 0.003268
     + /
      real dptmc1sy5 ( 12 )
      data dptmc1sy5 /
     + 0.017889 , 0.121473 , 0.087695 , 0.146778 , 0.079286,
     + 0.151967 , 0.053383 , 0.049819 , 0.047239 , 0.033000,
     + 0.008974 , 0.006052
     + /
      real dptmc1x6 ( 12 )
      data dptmc1x6 /
     + 0.192167 , 0.386634 , 0.619908 , 0.866413 , 1.123692,
     + 1.367314 , 1.613110 , 1.866703 , 2.212215 , 2.718747,
     + 3.444129 , 4.458813
     + /
      real dptmc1y6 ( 12 )
C      data dptmc1y6 /
C     + 0.000000 , 0.384647 , 0.660024 , 0.598051 , 0.559137,
C     + 0.414873 , 0.367254 , 0.241776 , 0.152158 , 0.097696,
C     + 0.030112 , 0.008695
C     + /
      real dptmc1ey6 ( 12 )
      data dptmc1ey6 /
     + 0.000000 , 0.036691 , 0.057040 , 0.059170 , 0.063259,
     + 0.052215 , 0.055323 , 0.042393 , 0.024758 , 0.019683,
     + 0.006654 , 0.003139
     + /
      real dptmc1sy6 ( 12 )
      data dptmc1sy6 /
     + 0.000000 , 0.074195 , 0.099635 , 0.136125 , 0.089251,
     + 0.083469 , 0.091789 , 0.114501 , 0.070302 , 0.041458,
     + 0.015197 , 0.003896
     + /
      real dptmc1x7 ( 12 )
      data dptmc1x7 /
     + 0.182725 , 0.380908 , 0.626331 , 0.864909 , 1.127794,
     + 1.372597 , 1.618486 , 1.874856 , 2.229988 , 2.721170,
     + 3.415178 , 4.379633
     + /
      real dptmc1y7 ( 12 )
C      data dptmc1y7 /
C     + 0.000000 , 0.398140 , 0.607941 , 0.560910 , 0.633291,
C     + 0.353821 , 0.255633 , 0.281323 , 0.159120 , 0.093911,
C     + 0.042007 , 0.022187
C     + /
      real dptmc1ey7 ( 12 )
      data dptmc1ey7 /
     + 0.000000 , 0.029478 , 0.040971 , 0.041041 , 0.049498,
     + 0.033222 , 0.027853 , 0.033645 , 0.016735 , 0.012384,
     + 0.005557 , 0.004338
     + /
      real dptmc1sy7 ( 12 )
      data dptmc1sy7 /
     + 0.000000 , 0.085948 , 0.071773 , 0.061139 , 0.113478,
     + 0.068793 , 0.045759 , 0.074319 , 0.053392 , 0.024862,
     + 0.012757 , 0.007993
     + /
      real dptmc1x8 ( 12 )
      data dptmc1x8 /
     + 0.180208 , 0.387003 , 0.625232 , 0.867311 , 1.120728,
     + 1.372668 , 1.615781 , 1.873952 , 2.216092 , 2.722356,
     + 3.411063 , 4.422736
     + /
      real dptmc1y8 ( 12 )
C      data dptmc1y8 /
C     + 0.102897 , 0.354326 , 0.506606 , 0.690158 , 0.532990,
C     + 0.388945 , 0.342147 , 0.215148 , 0.172179 , 0.077980,
C     + 0.044665 , 0.000000
C     + /
      real dptmc1ey8 ( 12 )
      data dptmc1ey8 /
     + 0.014561 , 0.028793 , 0.036756 , 0.051760 , 0.045872,
     + 0.038234 , 0.036448 , 0.029044 , 0.019112 , 0.012030,
     + 0.006159 , 0.000000
     + /
      real dptmc1sy8 ( 12 )
      data dptmc1sy8 /
     + 0.025460 , 0.081474 , 0.077730 , 0.077400 , 0.065525,
     + 0.047710 , 0.058151 , 0.066686 , 0.028896 , 0.020013,
     + 0.012091 , 0.000000
     + /
      real dptmc1x9 ( 12 )
      data dptmc1x9 /
     + 0.200135 , 0.386295 , 0.637114 , 0.868089 , 1.124776,
     + 1.365027 , 1.621594 , 1.867857 , 2.230358 , 2.751206,
     + 3.482464 , 4.456751
     + /
      real dptmc1y9 ( 12 )
C      data dptmc1y9 /
C     + 0.072431 , 0.297398 , 0.519616 , 0.620743 , 0.660033,
C     + 0.489241 , 0.361023 , 0.291375 , 0.163068 , 0.116057,
C     + 0.046936 , 0.009534
C     + /
      real dptmc1ey9 ( 12 )
      data dptmc1ey9 /
     + 0.013741 , 0.030090 , 0.045420 , 0.057738 , 0.068828,
     + 0.060920 , 0.050485 , 0.045191 , 0.023678 , 0.019667,
     + 0.009359 , 0.003466
     + /
      real dptmc1sy9 ( 12 )
      data dptmc1sy9 /
     + 0.030971 , 0.119158 , 0.106133 , 0.119760 , 0.195143,
     + 0.104564 , 0.068266 , 0.118351 , 0.059613 , 0.023684,
     + 0.019451 , 0.006063
     + /
*                         kill data not in paper
      data dptmc1y0 /12*0./
      data dptmc1y1 /12*0./
      data dptmc1y2 /12*0./
      data dptmc1y3 /12*0./
      data dptmc1y4 /12*0./
      data dptmc1y5 /12*0./
      data dptmc1y6 /12*0./
      data dptmc1y7 /12*0./
      data dptmc1y8 /12*0./
      data dptmc1y9 /12*0./

*
* +seq,ptmen1.  wrong Et cut (was as ptmcn1)
*
      real dptme1x0 ( 12 )
      data dptme1x0 /
     + 0.202771 , 0.384896 , 0.618564 , 0.869944 , 1.114610,
     + 1.368176 , 1.614111 , 1.869093 , 2.224838 , 2.726034,
     + 3.416946 , 4.392986
     + /
      real dptme1y0 ( 12 )
      data dptme1y0 /
     + 0.147301 , 0.501329 , 0.765317 , 0.717118 , 0.523429,
     + 0.362050 , 0.244992 , 0.176594 , 0.106701 , 0.054390,
     + 0.028574 , 0.010089
     + /
      real dptme1ey0 ( 12 )
      data dptme1ey0 /
     + 0.009536 , 0.013565 , 0.019152 , 0.020641 , 0.018455,
     + 0.016130 , 0.013646 , 0.011732 , 0.006029 , 0.004407,
     + 0.002320 , 0.001306
     + /
      real dptme1sy0 ( 12 )
      data dptme1sy0 /
     + 0.057210 , 0.019192 , 0.072138 , 0.067982 , 0.040768,
     + 0.022480 , 0.017653 , 0.027660 , 0.012318 , 0.005982,
     + 0.003151 , 0.002096
     + /
      real dptme1x1 ( 12 )
      data dptme1x1 /
     + 0.195249 , 0.394963 , 0.619273 , 0.861081 , 1.128444,
     + 1.362864 , 1.611207 , 1.885785 , 2.245554 , 2.712126,
     + 3.266731 , 4.304149
     + /
      real dptme1y1 ( 12 )
      data dptme1y1 /
     + 0.091218 , 0.593429 , 0.727013 , 0.860689 , 0.571530,
     + 0.369275 , 0.169753 , 0.091503 , 0.080418 , 0.055826,
*     + 0.021832 , 0.011455
     + 0.021832 , 0.0
     + /
      real dptme1ey1 ( 12 )
      data dptme1ey1 /
     + 0.022045 , 0.060234 , 0.064289 , 0.087667 , 0.071651,
     + 0.060598 , 0.037175 , 0.024885 , 0.016545 , 0.016283,
     + 0.006109 , 0.005193
     + /
      real dptme1sy1 ( 12 )
      data dptme1sy1 /
     + 0.034227 , 0.135684 , 0.215162 , 0.207692 , 0.186556,
     + 0.129082 , 0.039624 , 0.029063 , 0.018332 , 0.029501,
     + 0.012946 , 0.012742
     + /
      real dptme1x2 ( 12 )
      data dptme1x2 /
     + 0.200945 , 0.382654 , 0.617252 , 0.867994 , 1.098701,
     + 1.366235 , 1.607693 , 1.872941 , 2.207174 , 2.711809,
     + 3.525543 , 4.406010
     + /
      real dptme1y2 ( 12 )
      data dptme1y2 /
     + 0.130296 , 0.489342 , 0.860071 , 0.818120 , 0.432392,
     + 0.398336 , 0.307884 , 0.132695 , 0.081799 , 0.045313,
     + 0.030736 , 0.000000
     + /
      real dptme1ey2 ( 12 )
      data dptme1ey2 /
     + 0.025995 , 0.041569 , 0.064554 , 0.070249 , 0.047104,
     + 0.053819 , 0.054364 , 0.024489 , 0.015116 , 0.013095,
     + 0.008724 , 0.000000
     + /
      real dptme1sy2 ( 12 )
      data dptme1sy2 /
     + 0.055735 , 0.117317 , 0.108463 , 0.084220 , 0.089345,
     + 0.124918 , 0.082824 , 0.038991 , 0.023164 , 0.016124,
*     + 0.031076 , 0.000000
     + 0.021076 , 0.000000
     + /
      real dptme1x3 ( 12 )
      data dptme1x3 /
     + 0.194332 , 0.382770 , 0.619234 , 0.874765 , 1.117384,
     + 1.374182 , 1.621574 , 1.868590 , 2.215757 , 2.726856,
     + 3.437006 , 4.449282
     + /
      real dptme1y3 ( 12 )
      data dptme1y3 /
     + 0.104089 , 0.565965 , 0.748645 , 0.760373 , 0.617378,
     + 0.344042 , 0.218119 , 0.154691 , 0.113766 , 0.044212,
     + 0.022475 , 0.010141
     + /
      real dptme1ey3 ( 12 )
      data dptme1ey3 /
     + 0.017002 , 0.037063 , 0.045324 , 0.050300 , 0.050338,
     + 0.034910 , 0.027396 , 0.024613 , 0.014828 , 0.007824,
     + 0.004100 , 0.002975
     + /
      real dptme1sy3 ( 12 )
      data dptme1sy3 /
     + 0.047094 , 0.055827 , 0.130618 , 0.064758 , 0.097302,
     + 0.040759 , 0.042923 , 0.041723 , 0.039867 , 0.013064,
     + 0.005316 , 0.004208
     + /
      real dptme1x4 ( 12 )
      data dptme1x4 /
     + 0.207279 , 0.384509 , 0.616529 , 0.867680 , 1.113051,
     + 1.365193 , 1.619674 , 1.878651 , 2.239346 , 2.733763,
     + 3.413449 , 4.277315
     + /
      real dptme1y4 ( 12 )
      data dptme1y4 /
     + 0.285807 , 0.435088 , 0.733734 , 0.595748 , 0.469296,
     + 0.364720 , 0.221340 , 0.211514 , 0.152605 , 0.079803,
     + 0.026088 , 0.000000
     + /
      real dptme1ey4 ( 12 )
      data dptme1ey4 /
     + 0.046350 , 0.033715 , 0.051358 , 0.049834 , 0.046043,
     + 0.045708 , 0.037577 , 0.037774 , 0.024422 , 0.019688,
     + 0.005926 , 0.000000
     + /
      real dptme1sy4 ( 12 )
      data dptme1sy4 /
     + 0.221412 , 0.053220 , 0.131420 , 0.229904 , 0.110190,
     + 0.049792 , 0.044699 , 0.067968 , 0.049138 , 0.045485,
     + 0.014664 , 0.000000
     + /
      real dptme1x5 ( 12 )
      data dptme1x5 /
     + 0.207511 , 0.382912 , 0.615533 , 0.872355 , 1.108377,
     + 1.362881 , 1.603137 , 1.844838 , 2.187179 , 2.767986,
     + 3.443208 , 4.441383
     + /
      real dptme1y5 ( 12 )
      data dptme1y5 /
*     + 0.266575 , 0.000000 , 0.685095 , 0.747259 , 0.460551,
     + 0.000000 , 0.000000 , 0.685095 , 0.747259 , 0.460551,
     + 0.346064 , 0.333248 , 0.168219 , 0.096491 , 0.062497,
*     + 0.000000 , 0.005688
     + 0.000000 , 0.00
     + /
      real dptme1ey5 ( 12 )
      data dptme1ey5 /
*     + 0.043613 , 0.000000 , 0.047425 , 0.065268 , 0.048393,
     + 0.000000 , 0.000000 , 0.047425 , 0.065268 , 0.048393,
     + 0.048948 , 0.055807 , 0.035843 , 0.016730 , 0.014805,
     + 0.000000 , 0.002025
     + /
      real dptme1sy5 ( 12 )
      data dptme1sy5 /
*     + 0.213136 , 0.000000 , 0.230165 , 0.160512 , 0.127354,
     + 0.000000 , 0.000000 , 0.230165 , 0.160512 , 0.127354,
     + 0.061714 , 0.154306 , 0.072489 , 0.039388 , 0.023713,
     + 0.000000 , 0.006689
     + /
      real dptme1x6 ( 12 )
      data dptme1x6 /
     + 0.210425 , 0.385929 , 0.616868 , 0.871532 , 1.112073,
     + 1.359845 , 1.599579 , 1.859565 , 2.287180 , 2.684467,
     + 3.526707 , 4.390825
     + /
      real dptme1y6 ( 12 )
C      data dptme1y6 /
C     + 0.063878 , 0.456321 , 0.955356 , 0.551346 , 0.848234,
C     + 0.419676 , 0.245302 , 0.141550 , 0.069251 , 0.033301,
C     + 0.016942 , 0.000000
C     + /
      real dptme1ey6 ( 12 )
      data dptme1ey6 /
     + 0.032819 , 0.055094 , 0.112145 , 0.081720 , 0.156660,
     + 0.094893 , 0.072446 , 0.048365 , 0.022048 , 0.015283,
     + 0.007937 , 0.000000
     + /
*                                   kill data that are not in paper
      data  dptme1y6 /12*0./
      real dptme1sy6 ( 12 )
      data dptme1sy6 /
     + 0.079927 , 0.107912 , 0.262210 , 0.266736 , 0.253641,
     + 0.194181 , 0.148307 , 0.056435 , 0.036521 , 0.019609,
     + 0.027449 , 0.000000
     + /
      real dptme1x7 ( 12 )
      data dptme1x7 /
     + 0.199226 , 0.389268 , 0.624265 , 0.868908 , 1.111049,
     + 1.370932 , 1.610264 , 1.873397 , 2.218633 , 2.728201,
     + 3.384680 , 4.340054
     + /
      real dptme1y7 ( 12 )
      data dptme1y7 /
     + 0.103731 , 0.493301 , 0.718031 , 0.748891 , 0.489432,
     + 0.326798 , 0.282407 , 0.212070 , 0.113748 , 0.062378,
     + 0.034230 , 0.013446
     + /
      real dptme1ey7 ( 12 )
      data dptme1ey7 /
     + 0.015585 , 0.032225 , 0.043475 , 0.048022 , 0.038199,
     + 0.031747 , 0.031186 , 0.031109 , 0.013006 , 0.010132,
     + 0.005617 , 0.003396
     + /
      real dptme1sy7 ( 12 )
      data dptme1sy7 /
     + 0.016671 , 0.065598 , 0.059168 , 0.064120 , 0.085843,
     + 0.038942 , 0.044795 , 0.088422 , 0.017622 , 0.020821,
     + 0.006168 , 0.006613
     + /
      real dptme1x8 ( 12 )
      data dptme1x8 /
     + 0.209039 , 0.380773 , 0.619529 , 0.872382 , 1.122359,
     + 1.372894 , 1.632871 , 1.856848 , 2.246414 , 2.686891,
     + 3.433805 , 4.462350
     + /
      real dptme1y8 ( 12 )
      data dptme1y8 /
     + 0.138039 , 0.484125 , 0.725545 , 0.572551 , 0.554438,
     + 0.426958 , 0.235656 , 0.218845 , 0.115849 , 0.046104,
     + 0.032936 , 0.012077
     + /
      real dptme1ey8 ( 12 )
      data dptme1ey8 /
     + 0.024487 , 0.035544 , 0.050695 , 0.048609 , 0.054016,
     + 0.051163 , 0.036354 , 0.036799 , 0.017381 , 0.010906,
     + 0.007583 , 0.004096
     + /
      real dptme1sy8 ( 12 )
      data dptme1sy8 /
     + 0.082345 , 0.058688 , 0.195956 , 0.155044 , 0.079829,
     + 0.097494 , 0.073143 , 0.054772 , 0.027915 , 0.020265,
     + 0.015152 , 0.006235
     + /
      real dptme1x9 ( 12 )
      data dptme1x9 /
     + 0.226678 , 0.379907 , 0.611574 , 0.870734 , 1.136144,
     + 1.361115 , 1.601790 , 1.880337 , 2.243956 , 2.757005,
     + 3.379965 , 4.301902
     + /
      real dptme1y9 ( 12 )
C      data dptme1y9 /
C     + 0.045820 , 0.380666 , 0.870468 , 0.712883 , 0.569571,
C     + 0.466016 , 0.191937 , 0.129547 , 0.129254 , 0.059675,
C     + 0.000000 , 0.007566
C     + /
*                         kill data not in paper
      data dptme1y9 /12*0./
      real dptme1ey9 ( 12 )
      data dptme1ey9 /
     + 0.022493 , 0.050039 , 0.102571 , 0.094273 , 0.104763,
     + 0.097506 , 0.051132 , 0.044968 , 0.034888 , 0.022207,
     + 0.000000 , 0.005998
     + /
      real dptme1sy9 ( 12 )
      data dptme1sy9 /
     + 0.086797 , 0.144056 , 0.143977 , 0.209282 , 0.171974,
     + 0.224550 , 0.108185 , 0.068172 , 0.047666 , 0.036321,
     + 0.000000 , 0.011041
     + /
* hbook parameters
      integer nbeta,ib
      parameter (nbeta=18)
      real eta0,eta1,pt0,pt1,ptbsiz,etabsiz
*      data eta0,eta1/-10.,10./
      data eta0,eta1/ -3., 6./
      data pt0,pt1/0.,5./
      real an11(nbeta),an21(nbeta),an12(nbeta),an22(nbeta)
      real ean11(nbeta),pnn(nbeta)
      real ap11(nbpt),ap12(nbpt),eap11(nbpt),ppp(nbpt)
      real apm1(nbptm),apm2(nbptm),eapm1(nbptm),ppm(nbptm)
*
*
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
*
*
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      Integer iflag,ihep,i,j,k,l
*     DESY Preprint number
      Character*5 xxxx
      Data xxxx/'96215'/
      character*30 string
*
      Real pi,dpi,rd,ee,eb,dphi
      Logical evcut,lp
      Integer jcut,ncut,iel,idum,id
      Parameter (ncut=4,pi=3.1415927,dpi=2.*pi,rd=180./pi,ee=27.6)
      Integer nentry,nevnt(2)
      Real  nev(0:9),nev1(0:9),nev2(0:9)
      real xnnev
      Data nev/10*0./,nev1/10*0./,lp/.false./,nentry/0/
      Data nev2/10*0./
      real xmean(0:9),q2mean(0:9)
      data xmean,q2mean/10*0.,10*0./
      Real x,y,q2,w2,enel,ptel,thel,efwd,th,rap,pt,et,p,costh
      Real xmi,xma,ymi,yma
      Integer nx,ny,nwt,loc
      Character chtitl*80
*
      Integer ierr,ibeam,igam
      Double precision pbeam(4),pgam(4),pcm(4),ph(5),phc(4)
*
*
*********************************************************************
*
*                      Initialization
*
*********************************************************************
      NENTRY=NENTRY+1
*
      IF (iflag.eq.1) then
*
*
*      Initialisation: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (i) make subdirectory in o/p file
*
       Call hcdir('//PAWC',' ')
       call hmdir(xxxx,'S')
       Call hcdir('//HISTO',' ')
       call hmdir(xxxx,'S')

* Book kinematics and so on
       call hbook2(1,' logx vs logq2 ',100,0.5,2.,100,-5.,-1.0,0.)
       call hbook1(2,' logq2  ',100,0.5,2.,0.)
       call hbook1(3,' logx ',100,-5.,-1.,0.)
       call hbook1(4,' Eforward ',100,0.,50.,0.)

* Book multiplicity histograms
       do i = 0, 9
        id = 100 + i
        call hbook1(id,' Ch. Part. Multi All '
     &   ,100,-0.5,99.5,0.)
        id = 200 + i
        call hbook1(id,' Ch. Part. Multi Summed ET (0.5-2.5) gt 6 '
     &   ,100,-0.5,99.5,0.)
        id = 300 + i
        call hbook1(id,' Ch. Part. Multi Summed ET (0.0-2.0) gt 6 '
     &   ,100,-0.5,99.5,0.)
       enddo



* Book intermediate and final histograms.

* Intermediate dn/deta
       id = 21 000
       call hbook1(id,' dn/deta '
     &  ,nbeta,eta0,eta1,0.)
* Intermediate dn/deta pt> 1
       id = 22 000
       call hbook1(id,' dn/deta '
     &  ,nbeta,eta0,eta1,0.)

       do ieta=1,neta
* Intermediate dn/dpt, interval ieta
         id = 23 000 +  iofeta*(ieta-1)
          call hbookb(id,' dn/dpt intermediate '
     &    ,nbpt,xbpt1,0.)
       enddo

*
      do i=0,9

* Final dn**2/deta
       id = 11 000 + i +  10
       call hbook1( id,' dn**2/deta '
     &  ,nbeta,eta0,eta1,0.)

* Final dn/deta
       id = 11 000 + i
       call hbook1( id,' dn/deta '
     &  ,nbeta,eta0,eta1,0.)
       call hbook1(-id,' DATA dn/deta '
     &  ,nbeta,eta0,eta1,0.)
       call hbook1(-id-10,' DATA dn/deta EStat '
     &  ,nbeta,eta0,eta1,0.)
*
* to be done
*       if ( i .eq. 0  .and. meta0y0.eq.nbeta) then
*
       if ( i .eq. 0 ) then
         call hpak ( -id,deta0y0)
         call hpake( -id,deta0sy0)
         call hpak ( -id-10,deta0y0)
         call hpake( -id-10,deta0ey0)
       elseif ( i .eq. 1 ) then
         call hpak ( -id,deta0y1)
         call hpake( -id,deta0sy1)
         call hpak ( -id-10,deta0y1)
         call hpake( -id-10,deta0ey1)
       elseif ( i .eq. 2 ) then
         call hpak ( -id,deta0y2)
         call hpake( -id,deta0sy2)
         call hpak ( -id-10,deta0y2)
         call hpake( -id-10,deta0ey2)
       elseif ( i .eq. 3 ) then
         call hpak ( -id,deta0y3)
         call hpake( -id,deta0sy3)
         call hpak ( -id-10,deta0y3)
         call hpake( -id-10,deta0ey3)
       elseif ( i .eq. 4 ) then
         call hpak ( -id,deta0y4)
         call hpake( -id,deta0sy4)
         call hpak ( -id-10,deta0y4)
         call hpake( -id-10,deta0ey4)
       elseif ( i .eq. 5 ) then
         call hpak ( -id,deta0y5)
         call hpake( -id,deta0sy5)
         call hpak ( -id-10,deta0y5)
         call hpake( -id-10,deta0ey5)
       elseif ( i .eq. 6 ) then
         call hpak ( -id,deta0y6)
         call hpake( -id,deta0sy6)
         call hpak ( -id-10,deta0y6)
         call hpake( -id-10,deta0ey6)
       elseif ( i .eq. 7 ) then
         call hpak ( -id,deta0y7)
         call hpake( -id,deta0sy7)
         call hpak ( -id-10,deta0y7)
         call hpake( -id-10,deta0ey7)
       elseif ( i .eq. 8 ) then
         call hpak ( -id,deta0y8)
         call hpake( -id,deta0sy8)
         call hpak ( -id-10,deta0y8)
         call hpake( -id-10,deta0ey8)
       elseif ( i .eq. 9 ) then
         call hpak ( -id,deta0y9)
         call hpake( -id,deta0sy9)
         call hpak ( -id-10,deta0y9)
         call hpake( -id-10,deta0ey9)
       endif


* Final dn**2/deta pt>1
       id = 12 000 + i +  10
       call hbook1( id,' dn**2/deta '
     &  ,nbeta,eta0,eta1,0.)

* Final dn/deta pt>1
       id = 12 000 + i
       call hbook1( id,' dn/deta '
     &  ,nbeta,eta0,eta1,0.)
       call hbook1(-id,' DATA dn/deta '
     &  ,nbeta,eta0,eta1,0.)
       call hbook1(-id-10,' DATA dn/deta Estat'
     &  ,nbeta,eta0,eta1,0.)
       if ( i .eq. 0 ) then
         call hpak ( -id,deta1y0)
         call hpake( -id,deta1sy0)
         call hpak ( -id-10,deta1y0)
         call hpake( -id-10,deta1ey0)
       elseif ( i .eq. 1 ) then
         call hpak ( -id,deta1y1)
         call hpake( -id,deta1sy1)
         call hpak ( -id-10,deta1y1)
         call hpake( -id-10,deta1ey1)
       elseif ( i .eq. 2 ) then
         call hpak ( -id,deta1y2)
         call hpake( -id,deta1sy2)
         call hpak ( -id-10,deta1y2)
         call hpake( -id-10,deta1ey2)
       elseif ( i .eq. 3 ) then
         call hpak ( -id,deta1y3)
         call hpake( -id,deta1sy3)
         call hpak ( -id-10,deta1y3)
         call hpake( -id-10,deta1ey3)
       elseif ( i .eq. 4 ) then
         call hpak ( -id,deta1y4)
         call hpake( -id,deta1sy4)
         call hpak ( -id-10,deta1y4)
         call hpake( -id-10,deta1ey4)
       elseif ( i .eq. 5 ) then
         call hpak ( -id,deta1y5)
         call hpake( -id,deta1sy5)
         call hpak ( -id-10,deta1y5)
         call hpake( -id-10,deta1ey5)
       elseif ( i .eq. 6 ) then
         call hpak ( -id,deta1y6)
         call hpake( -id,deta1sy6)
         call hpak ( -id-10,deta1y6)
         call hpake( -id-10,deta1ey6)
       elseif ( i .eq. 7 ) then
         call hpak ( -id,deta1y7)
         call hpake( -id,deta1sy7)
         call hpak ( -id-10,deta1y7)
         call hpake( -id-10,deta1ey7)
       elseif ( i .eq. 8 ) then
         call hpak ( -id,deta1y8)
         call hpake( -id,deta1sy8)
         call hpak ( -id-10,deta1y8)
         call hpake( -id-10,deta1ey8)
       elseif ( i .eq. 9 ) then
         call hpak ( -id,deta1y9)
         call hpake( -id,deta1sy9)
         call hpak ( -id-10,deta1y9)
         call hpake( -id-10,deta1ey9)
       endif



       do ieta=1,neta
* Average  <pt> in pt interval
         id = 13 000 + i +  20 + iofeta*(ieta-1)
         if ( ieta.eq.1) then
           call hbookb(id,' dn/dpt 0.5-1.5 '
     &      ,nbpt,xbpt1,0.)
           call hbookb(-id,' DATA dn/dpt 0.5-1.5 '
     &      ,nbpt,xbpt1,0.)
*           call hbookb(-id-10,' DATA dn/dpt 0.5-1.5 Estat '
*     &      ,nbpt,xbpt1,0.)
           if ( i .eq. 0 ) then
             call hpak ( -id,dpte1x0)
           elseif ( i .eq. 1 ) then
             call hpak ( -id,dpte1x1)
           elseif ( i .eq. 2 ) then
             call hpak ( -id,dpte1x2)
           elseif ( i .eq. 3 ) then
             call hpak ( -id,dpte1x3)
           elseif ( i .eq. 4 ) then
             call hpak ( -id,dpte1x4)
           elseif ( i .eq. 5 ) then
             call hpak ( -id,dpte1x5)
           elseif ( i .eq. 6 ) then
             call hpak ( -id,dpte1x6)
           elseif ( i .eq. 7 ) then
             call hpak ( -id,dpte1x7)
           elseif ( i .eq. 8 ) then
             call hpak ( -id,dpte1x8)
           elseif ( i .eq. 9 ) then
             call hpak ( -id,dpte1x9)
           endif
         endif
         if ( ieta.eq.5) then
           call hbookb(id,' dn/dpt 3.5-4.0 '
     &      ,nbpt,xbpt1,0.)
         endif
         if ( ieta.eq.4) then
           call hbookb(id,' dn/dpt 3.0-3.5 '
     &      ,nbpt,xbpt1,0.)
         endif
         if ( ieta.eq.3) then
           call hbookb(id,' dn/dpt 3.0-4.0 '
     &      ,nbpt,xbpt1,0.)
         endif
         if ( ieta.eq.2) then
           call hbookb(id,' dn/dpt 1.5-2.5 '
     &      ,nbpt,xbpt1,0.)
           call hbookb(-id,' DATA dn/dpt 1.5-2.5 '
     &      ,nbpt,xbpt1,0.)
*           call hbookb(-id-10,' DATA dn/dpt 1.5-2.5 Estat'
*     &      ,nbpt,xbpt1,0.)
           if ( i .eq. 0 ) then
             call hpak ( -id,dptc1x0)
           elseif ( i .eq. 1 ) then
             call hpak ( -id,dptc1x1)
           elseif ( i .eq. 2 ) then
             call hpak ( -id,dptc1x2)
           elseif ( i .eq. 3 ) then
             call hpak ( -id,dptc1x3)
           elseif ( i .eq. 4 ) then
             call hpak ( -id,dptc1x4)
           elseif ( i .eq. 5 ) then
             call hpak ( -id,dptc1x5)
           elseif ( i .eq. 6 ) then
             call hpak ( -id,dptc1x6)
           elseif ( i .eq. 7 ) then
             call hpak ( -id,dptc1x7)
           elseif ( i .eq. 8 ) then
             call hpak ( -id,dptc1x8)
           elseif ( i .eq. 9 ) then
             call hpak ( -id,dptc1x9)
           endif
         endif

* Final  dn**2/dpt, interval ieta
         id = 13 000 + i +  10 + iofeta*(ieta-1)
         if ( ieta.eq.5)
     &     call hbookb(id,' dn**2/dpt 3.5-4.0 '
     &      ,nbpt,xbpt1,0.)
         if ( ieta.eq.4)
     &     call hbookb(id,' dn**2/dpt 3.0-3.5 '
     &      ,nbpt,xbpt1,0.)
         if ( ieta.eq.3)
     &     call hbookb(id,' dn**2/dpt 3.0-4.0 '
     &      ,nbpt,xbpt1,0.)
         if ( ieta.eq.1)
     &     call hbookb(id,' dn**2/dpt 0.5-1.5 '
     &      ,nbpt,xbpt1,0.)
         if ( ieta.eq.2)
     &     call hbookb(id,' dn**2/dpt 1.5-2.5 '
     &      ,nbpt,xbpt1,0.)

* Final  dn/dpt, interval ieta
         id = 13 000 + i +  iofeta*(ieta-1)
         if ( ieta.eq.1)then
           call hbookb( id,' dn/dpt 0.5-1.5 '
     &      ,nbpt,xbpt1,0.)
           call hbookb(-id,' DATA dn/dpt 0.5-1.5 '
     &      ,nbpt,xbpt1,0.)
           call hbookb(-id-10,' DATA dn/dpt 0.5-1.5 Estat '
     &      ,nbpt,xbpt1,0.)
           if ( i .eq. 0 ) then
             call hpak ( -id,dpte1y0)
             call hpake( -id,dpte1sy0)
             call hpak ( -id-10,dpte1y0)
             call hpake( -id-10,dpte1ey0)
           elseif ( i .eq. 1 ) then
             call hpak ( -id,dpte1y1)
             call hpake( -id,dpte1sy1)
             call hpak ( -id-10,dpte1y1)
             call hpake( -id-10,dpte1ey1)
           elseif ( i .eq. 2 ) then
             call hpak ( -id,dpte1y2)
             call hpake( -id,dpte1sy2)
             call hpak ( -id-10,dpte1y2)
             call hpake( -id-10,dpte1ey2)
           elseif ( i .eq. 3 ) then
             call hpak ( -id,dpte1y3)
             call hpake( -id,dpte1sy3)
             call hpak ( -id-10,dpte1y3)
             call hpake( -id-10,dpte1ey3)
           elseif ( i .eq. 4 ) then
             call hpak ( -id,dpte1y4)
             call hpake( -id,dpte1sy4)
             call hpak ( -id-10,dpte1y4)
             call hpake( -id-10,dpte1ey4)
           elseif ( i .eq. 5 ) then
             call hpak ( -id,dpte1y5)
             call hpake( -id,dpte1sy5)
             call hpak ( -id-10,dpte1y5)
             call hpake( -id-10,dpte1ey5)
           elseif ( i .eq. 6 ) then
             call hpak ( -id,dpte1y6)
             call hpake( -id,dpte1sy6)
             call hpak ( -id-10,dpte1y6)
             call hpake( -id-10,dpte1ey6)
           elseif ( i .eq. 7 ) then
             call hpak ( -id,dpte1y7)
             call hpake( -id,dpte1sy7)
             call hpak ( -id-10,dpte1y7)
             call hpake( -id-10,dpte1ey7)
           elseif ( i .eq. 8 ) then
             call hpak ( -id,dpte1y8)
             call hpake( -id,dpte1sy8)
             call hpak ( -id-10,dpte1y8)
             call hpake( -id-10,dpte1ey8)
           elseif ( i .eq. 9 ) then
             call hpak ( -id,dpte1y9)
             call hpake( -id,dpte1sy9)
             call hpak ( -id-10,dpte1y9)
             call hpake( -id-10,dpte1ey9)
           endif
         endif
         if ( ieta.eq.5)then
           call hbookb( id,' dn/dpt 3.5-4.0 '
     &      ,nbpt,xbpt1,0.)
         endif
         if ( ieta.eq.4)then
           call hbookb( id,' dn/dpt 3.0-3.5 '
     &      ,nbpt,xbpt1,0.)
         endif
         if ( ieta.eq.3)then
           call hbookb( id,' dn/dpt 3.0-4.0 '
     &      ,nbpt,xbpt1,0.)
         endif
         if ( ieta.eq.2)then
           call hbookb( id,' dn/dpt 1.5-2.5 '
     &      ,nbpt,xbpt1,0.)
           call hbookb(-id,' DATA dn/dpt 1.5-2.5 '
     &      ,nbpt,xbpt1,0.)
           call hbookb(-id-10,' DATA dn/dpt 1.5-2.5 Estat '
     &      ,nbpt,xbpt1,0.)
           if ( i .eq. 0 ) then
             call hpak ( -id,dptc1y0)
             call hpake( -id,dptc1sy0)
             call hpak ( -id-10,dptc1y0)
             call hpake( -id-10,dptc1ey0)
           elseif ( i .eq. 1 ) then
             call hpak ( -id,dptc1y1)
             call hpake( -id,dptc1sy1)
             call hpak ( -id-10,dptc1y1)
             call hpake( -id-10,dptc1ey1)
           elseif ( i .eq. 2 ) then
             call hpak ( -id,dptc1y2)
             call hpake( -id,dptc1sy2)
             call hpak ( -id-10,dptc1y2)
             call hpake( -id-10,dptc1ey2)
           elseif ( i .eq. 3 ) then
             call hpak ( -id,dptc1y3)
             call hpake( -id,dptc1sy3)
             call hpak ( -id-10,dptc1y3)
             call hpake( -id-10,dptc1ey3)
           elseif ( i .eq. 4 ) then
             call hpak ( -id,dptc1y4)
             call hpake( -id,dptc1sy4)
             call hpak ( -id-10,dptc1y4)
             call hpake( -id-10,dptc1ey4)
           elseif ( i .eq. 5 ) then
             call hpak ( -id,dptc1y5)
             call hpake( -id,dptc1sy5)
             call hpak ( -id-10,dptc1y5)
             call hpake( -id-10,dptc1ey5)
           elseif ( i .eq. 6 ) then
             call hpak ( -id,dptc1y6)
             call hpake( -id,dptc1sy6)
             call hpak ( -id-10,dptc1y6)
             call hpake( -id-10,dptc1ey6)
           elseif ( i .eq. 7 ) then
             call hpak ( -id,dptc1y7)
             call hpake( -id,dptc1sy7)
             call hpak ( -id-10,dptc1y7)
             call hpake( -id-10,dptc1ey7)
           elseif ( i .eq. 8 ) then
             call hpak ( -id,dptc1y8)
             call hpake( -id,dptc1sy8)
             call hpak ( -id-10,dptc1y8)
             call hpake( -id-10,dptc1ey8)
           elseif ( i .eq. 9 ) then
             call hpak ( -id,dptc1y9)
             call hpake( -id,dptc1sy9)
             call hpak ( -id-10,dptc1y9)
             call hpake( -id-10,dptc1ey9)
           endif
         endif

* Average  <ptmax> in ptmax interval
         id = 14 000 + i +  20 + iofeta*(ieta-1)
         if ( ieta.eq.5)then
           call hbookb( id,' dn/dptmax 3.5-4.0 '
     &      ,nbptm,xbptm,0.)
         endif
         if ( ieta.eq.4)then
           call hbookb( id,' dn/dptmax 3.0-3.5 '
     &      ,nbptm,xbptm,0.)
         endif
         if ( ieta.eq.3)then
           call hbookb( id,' dn/dptmax 3.0-4.0 '
     &      ,nbptm,xbptm,0.)
         endif
         if ( ieta.eq.1)then
           call hbookb( id,' dn/dptmax 0.5-1.5 '
     &      ,nbptm,xbptm,0.)
           call hbookb(-id,' DATA dn/dptmax 0.5-1.5 '
     &      ,nbptm,xbptm,0.)
           if ( i .eq. 0 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptme1x0
             call hpak ( -id,dptme1x0)
           elseif ( i .eq. 1 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptme1x1
             call hpak ( -id,dptme1x1)
           elseif ( i .eq. 2 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptme1x2
             call hpak ( -id,dptme1x2)
           elseif ( i .eq. 3 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptme1x3
             call hpak ( -id,dptme1x3)
           elseif ( i .eq. 4 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptme1x4
             call hpak ( -id,dptme1x4)
           elseif ( i .eq. 5 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptme1x5
             call hpak ( -id,dptme1x5)
           elseif ( i .eq. 6 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptme1x6
             call hpak ( -id,dptme1x6)
           elseif ( i .eq. 7 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptme1x7
             call hpak ( -id,dptme1x7)
           elseif ( i .eq. 8 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptme1x8
             call hpak ( -id,dptme1x8)
           elseif ( i .eq. 9 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptme1x9
             call hpak ( -id,dptme1x9)
           endif
         endif
         if ( ieta.eq.2)then
           call hbookb( id,' dn/dptmax 1.5-2.5 '
     &      ,nbptm,xbptm,0.)
           call hbookb(-id,' DATA dn/dptmax 1.5-2.5 '
     &      ,nbptm,xbptm,0.)
           if ( i .eq. 0 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptmc1x0
             call hpak ( -id,dptmc1x0)
           elseif ( i .eq. 1 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptmc1x1
             call hpak ( -id,dptmc1x1)
           elseif ( i .eq. 2 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptmc1x2
             call hpak ( -id,dptmc1x2)
           elseif ( i .eq. 3 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptmc1x3
             call hpak ( -id,dptmc1x3)
           elseif ( i .eq. 4 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptmc1x4
             call hpak ( -id,dptmc1x4)
           elseif ( i .eq. 5 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptmc1x5
             call hpak ( -id,dptmc1x5)
           elseif ( i .eq. 6 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptmc1x6
             call hpak ( -id,dptmc1x6)
           elseif ( i .eq. 7 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptmc1x7
             call hpak ( -id,dptmc1x7)
           elseif ( i .eq. 8 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptmc1x8
             call hpak ( -id,dptmc1x8)
           elseif ( i .eq. 9 ) then
*             write(6,*)' HZ961 hpak data ',-id,dptmc1x9
             call hpak ( -id,dptmc1x9)
           endif
         endif

* Final  dn/dptmax , interval ieta
         id = 14 000 + i +  iofeta*(ieta-1)
         if ( ieta.eq.5)then
           call hbookb( id,' dn/dptmax 3.5-4.0 '
     &      ,nbptm,xbptm,0.)
         endif
         if ( ieta.eq.4)then
           call hbookb( id,' dn/dptmax 3.0-3.5 '
     &      ,nbptm,xbptm,0.)
         endif
         if ( ieta.eq.3)then
           call hbookb( id,' dn/dptmax 3.0-4.0 '
     &      ,nbptm,xbptm,0.)
         endif
         if ( ieta.eq.1)then
           call hbookb( id,' dn/dptmax 0.5-1.5 '
     &      ,nbptm,xbptm,0.)
           call hbookb(-id,' DATA dn/dptmax 0.5-1.5 '
     &      ,nbptm,xbptm,0.)
           call hbookb(-id-10,' DATA dn/dptmax 0.5-1.5 Estat'
     &      ,nbptm,xbptm,0.)
           if ( i .eq. 0 ) then
             call hpak ( -id,dptme1y0)
             call hpake( -id,dptme1sy0)
             call hpak ( -id-10,dptme1y0)
             call hpake( -id-10,dptme1ey0)
           elseif ( i .eq. 1 ) then
             call hpak ( -id,dptme1y1)
             call hpake( -id,dptme1sy1)
             call hpak ( -id-10,dptme1y1)
             call hpake( -id-10,dptme1ey1)
           elseif ( i .eq. 2 ) then
             call hpak ( -id,dptme1y2)
             call hpake( -id,dptme1sy2)
             call hpak ( -id-10,dptme1y2)
             call hpake( -id-10,dptme1ey2)
           elseif ( i .eq. 3 ) then
             call hpak ( -id,dptme1y3)
             call hpake( -id,dptme1sy3)
             call hpak ( -id-10,dptme1y3)
             call hpake( -id-10,dptme1ey3)
           elseif ( i .eq. 4 ) then
             call hpak ( -id,dptme1y4)
             call hpake( -id,dptme1sy4)
             call hpak ( -id-10,dptme1y4)
             call hpake( -id-10,dptme1ey4)
           elseif ( i .eq. 5 ) then
             call hpak ( -id,dptme1y5)
             call hpake( -id,dptme1sy5)
             call hpak ( -id-10,dptme1y5)
             call hpake( -id-10,dptme1ey5)
           elseif ( i .eq. 6 ) then
             call hpak ( -id,dptme1y6)
             call hpake( -id,dptme1sy6)
             call hpak ( -id-10,dptme1y6)
             call hpake( -id-10,dptme1ey6)
           elseif ( i .eq. 7 ) then
             call hpak ( -id,dptme1y7)
             call hpake( -id,dptme1sy7)
             call hpak ( -id-10,dptme1y7)
             call hpake( -id-10,dptme1ey7)
           elseif ( i .eq. 8 ) then
             call hpak ( -id,dptme1y8)
             call hpake( -id,dptme1sy8)
             call hpak ( -id-10,dptme1y8)
             call hpake( -id-10,dptme1ey8)
           elseif ( i .eq. 9 ) then
             call hpak ( -id,dptme1y9)
             call hpake( -id,dptme1sy9)
             call hpak ( -id-10,dptme1y9)
             call hpake( -id-10,dptme1ey9)
           endif
         endif
         if ( ieta.eq.2)then
           call hbookb( id,' dn/dptmax 1.5-2.5 '
     &      ,nbptm,xbptm,0.)
           call hbookb(-id,' DATA dn/dptmax 1.5-2.5 '
     &      ,nbptm,xbptm,0.)
           call hbookb(-id-10,' DATA dn/dptmax 1.5-2.5 Estat'
     &      ,nbptm,xbptm,0.)
           if ( i .eq. 0 ) then
             call hpak ( -id,dptmc1y0)
             call hpake( -id,dptmc1sy0)
             call hpak ( -id-10,dptmc1y0)
             call hpake( -id-10,dptmc1ey0)
           elseif ( i .eq. 1 ) then
             call hpak ( -id,dptmc1y1)
             call hpake( -id,dptmc1sy1)
             call hpak ( -id-10,dptmc1y1)
             call hpake( -id-10,dptmc1ey1)
           elseif ( i .eq. 2 ) then
             call hpak ( -id,dptmc1y2)
             call hpake( -id,dptmc1sy2)
             call hpak ( -id-10,dptmc1y2)
             call hpake( -id-10,dptmc1ey2)
           elseif ( i .eq. 3 ) then
             call hpak ( -id,dptmc1y3)
             call hpake( -id,dptmc1sy3)
             call hpak ( -id-10,dptmc1y3)
             call hpake( -id-10,dptmc1ey3)
           elseif ( i .eq. 4 ) then
             call hpak ( -id,dptmc1y4)
             call hpake( -id,dptmc1sy4)
             call hpak ( -id-10,dptmc1y4)
             call hpake( -id-10,dptmc1ey4)
           elseif ( i .eq. 5 ) then
             call hpak ( -id,dptmc1y5)
             call hpake( -id,dptmc1sy5)
             call hpak ( -id-10,dptmc1y5)
             call hpake( -id-10,dptmc1ey5)
           elseif ( i .eq. 6 ) then
             call hpak ( -id,dptmc1y6)
             call hpake( -id,dptmc1sy6)
             call hpak ( -id-10,dptmc1y6)
             call hpake( -id-10,dptmc1ey6)
           elseif ( i .eq. 7 ) then
             call hpak ( -id,dptmc1y7)
             call hpake( -id,dptmc1sy7)
             call hpak ( -id-10,dptmc1y7)
             call hpake( -id-10,dptmc1ey7)
           elseif ( i .eq. 8 ) then
             call hpak ( -id,dptmc1y8)
             call hpake( -id,dptmc1sy8)
             call hpak ( -id-10,dptmc1y8)
             call hpake( -id-10,dptmc1ey8)
           elseif ( i .eq. 9 ) then
             call hpak ( -id,dptmc1y9)
             call hpake( -id,dptmc1sy9)
             call hpak ( -id-10,dptmc1y9)
             call hpake( -id-10,dptmc1ey9)
           endif
         endif

       enddo

      enddo


*********************************************************************
*                      Event Processing
*
*********************************************************************

      Else if(iflag.eq.2) then

*      Filling: The following MUST always be done
*      (i) move to the correct sub-directory in PAWC
*
       call hcdir('//PAWC/'//xxxx,' ')
*
*                                             Event selection
*



       q2=real(HZDISKIN(1))
       x =real(HZDISKIN(2))
*
C       call getkinbin(x,q2,ibin)
       ibin = 0
       if(    q2.gt. 5..and.q2.le.10.) then
         if(x.gt.0.0001.and.x.le.0.0002) ibin=1
         if(x.gt.0.0002.and.x.le.0.0005.and.q2.gt.6.) ibin=2
       elseif(q2.gt.10..and.q2.le.20.) then
         if(x.gt.0.0002.and.x.le.0.0005) ibin=3
         if(x.gt.0.0005.and.x.le.0.0008) ibin=4
         if(x.gt.0.0008.and.x.le.0.0015) ibin=5
         if(x.gt.0.0015.and.x.le.0.0040) ibin=6
       elseif(q2.gt.20..and.q2.le.50.) then
         if(x.gt.0.0005.and.x.le.0.0014) ibin=7
         if(x.gt.0.0014.and.x.le.0.0030) ibin=8
         if(x.gt.0.0030.and.x.le.0.0100) ibin=9
       endif
*
       if ( ibin.lt.1.or.ibin.gt.9) goto 9990

       y =real(HZDISKIN(3))
       w2=real(HZDISKIN(4))
*
       if (lp) write(6,*) 'Hz'//xxxx,
     & ' x= ',x,' q2 ',q2,' y= ',y,' w2= ',w2
*
*                                             get electron variables
*
       iel=HZIDELEC(idum)
       if (iel.eq.-1) then
        write(6,*) 'Hz'//xxxx,' electron not found '
        goto 9990
       endif
       enel=real(PHEP(4,iel))
       thel=real(HZPHMANG(PHEP(3,iel),
     &               sqrt(PHEP(1,iel)**2+PHEP(2,iel)**2)))*rd
       if (lp) write(6,*) 'Hz'//xxxx,
     & ' enel= ',enel,' thel= ',thel
*
*                                             kinematic selection
*                                             E-pz always ok!
       evcut= enel.gt.12.
       evcut= thel.gt.157. .and. thel.lt.173.0 .and. evcut
       evcut= w2.ge.4400..and. evcut
       evcut = y.gt.0.05 .and. evcut
*       evcut = (y.gt.0.05 .and. y.lt.0.6) .and. evcut
       if (evcut .and. .NOT.(y.gt.0.05 .and. y.lt.0.6)) then
         write(6,*)' Should not happen too often (never!) '
       endif
       if(.not.evcut) goto 9990

       call hfill(1,log10(q2),log10(x),wtx)
       call hfill(2,log10(q2),1.,wtx)
       call hfill(3,log10(x),1.,wtx)
*
*                                             cut on forward energy
*
       efwd=0.
       Do ihep=1,nhep
        if (isthep(ihep).eq.1.and.ihep.ne.iel) then
         th=real(HZPHMANG(PHEP(3,ihep),
     &              sqrt(PHEP(1,ihep)**2+PHEP(2,ihep)**2)))*rd
         if(th.gt.4.4.and.th.lt.15.) then
          efwd=real(PHEP(4,ihep))+efwd
         endif
        endif
       enddo
       if (lp) write(6,*) 'Hz'//xxxx,
     & ' efwd= ',efwd,' evcut= ',evcut
*
       call hfill(4,efwd,1.,wtx)
*
       if(efwd.lt.0.5) goto 9990
*
*                                             find the kinematic bin number
*
*                                             events in 9 bins only
*       if( ibin.eq.0) goto 9990
*                                             set up CMS boost needed later
*
       ierr=HZIBEAM(ibeam,idum)
       if (.not.(ierr.eq.1)) then
        write(6,*) 'HZ'//xxxx,' beams not found ! '
        goto 9990
       else
        Do i=1,4
         pbeam(i)=PHEP(i,IBEAM)
        enddo
       endif
*
       eb=real(PHEP(4,idum))
       if (abs(abs(eb)-ee).gt.0.2) then
        if (nentry.lt.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,'  ! '
        elseif (nentry.eq.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &   ' ...last message ! '
        endif
C        goto 9990
       endif
*
       ierr=HZIPGAM(ph)
       if (ierr.eq.-1) then
        write(6,*) 'HZ'//xxxx,' boson vector not found ! '
C        call VZERO(ph,5)
        Do i=1,5
         ph(i)=0.
        enddo
       else
        Do i=1,4
         pgam(i)=ph(i)
        enddo
       endif
*
       call HZHCMINI(pbeam,pgam,ierr)
       if (ierr.eq.1) then
        write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
        goto 9990
       endif

* Reset intermediate histograms
       id = 20 000 + 1000
       call hreset(id,' ')
       id = 20 000 + 2000
       call hreset(id,' ')
       do ieta=1,neta
         id = 20 000 + 3000 + iofeta*(ieta-1)
         call hreset(id,' ')
       enddo
*
* reset multiplicity counter
       xmult=0.
* Reset event quantities
       etsummed=0.
       etsummed1=0.
       do ieta=1,neta
       ptmax(ieta)=-999.
       enddo
*
*                                             loop over objects
*
*
*                                             et in central rapidity bin
       do 2000 ihep=1,nhep
*                                             skip unstable particles and el.
       if (isthep(ihep).ne.1.or.ihep.eq.iel) goto 2000
*
*                                             transform in CMS
*
           Do i=1,4
            Phc(i)=PHEP(i,ihep)
           enddo
* pcm in had cms
           call HZHCM(phc,pcm,ierr)
           if (ierr.eq.1) then
            write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
            goto 9990
           endif

*                                             get particle momenta

           p      = real(sqrt(pcm(1)**2+pcm(2)**2+pcm(3)**2 ))
           pt     = real(sqrt( pcm(1)**2+pcm(2)**2 ))
           if (p.eq.0.) then
            write(6,*) xxxx,' p = ',p,pcm
            goto 2000
           else
            et     = real(pcm(4)) * pt / p
            th     = (acos(real(pcm(3))/p))
            if (abs(     th*rd).lt.1.e-4 .or.
     &          abs(180.-th*rd).lt.1.e-4 ) then
C             write(6,*) xxxx,' th = ',th
             goto 2000
            else
             rap    = -log(tan( th/2. ))
*                                            check on rap=nan (e.g. pt=0)
              if (rap.ne.rap) then
               write(6,*) xxxx,'Warning:  rap = ',rap,' th= ',th*rd,
     &         ' particle skipped ! '
               goto 2000
              endif
            endif
           endif
*

* Summed Et between 0.5 and 2.5 in eta cms
           if ( rap.gt.0.5.and.rap.lt.2.5) etsummed=etsummed+et
           if ( rap.gt.0.0.and.rap.lt.2.0) etsummed1=etsummed1+et
c           write(6,*) ' .... rap,et ',rap,et
* Charged particle
           if ( ihchrg(ihep).ne. 0 )then

           xmult=xmult+1.

* Fill intermediate histograms
            id = 21 000
            call hfill(id,rap,1.,wtx)
            if ( pt.gt.1.)then
              id = 22 000
              call hfill(id,rap,1.,wtx)
            endif

            do ieta=1,neta
             if ( rap.gt.etalow(ieta) .and. rap.lt.etahig(ieta))then
              id = 23 000 + (ieta-1)*iofeta
              call hfill(id,pt,1.,wtx)
              do jjbin=0,1
                jbin=ibin*jjbin
                id = 13 000 + 20 + (ieta-1)*iofeta + jbin
                call hfill(id,pt,1.,pt*wtx)
              enddo
              if ( pt.gt.ptmax(ieta))ptmax(ieta)=pt
             endif
             enddo
* Find pt max
           endif

*                                             end loop over objects
 2000  continue



       id=20 000 + 1000
       call hunpak(id,an11,'HIST',0)
       id=20 000 + 2000
       call hunpak(id,an21,'HIST',0)
       do ib=1,nbeta
         an12(ib)=an11(ib)**2
         an22(ib)=an21(ib)**2
       enddo

       do jjbin=0,1
         jbin=jjbin*ibin
         id = 12 000 + jbin
         call hpakad(id,an21)
         id = 12 000 + jbin + 10
         call hpakad(id,an22)
         id = 11 000 + jbin
         call hpakad(id,an11)
         id = 11 000 + jbin + 10
         call hpakad(id,an12)
* Multi histograms
         call hfill(100+jbin,xmult,1.,wtx)
         if (  etsummed.gt.6.)then
         call hfill(200+jbin,xmult,1.,wtx)
         endif
         if (  etsummed1.gt.6.)then
         call hfill(300+jbin,xmult,1.,wtx)
         endif

       enddo


       do ieta=1,neta
         id=23 000 + (ieta-1)*iofeta
         call hunpak(id,ap11,'HIST',0)
         do ib=1,nbpt
           ap12(ib)=ap11(ib)**2
         enddo
         do jjbin=0,1
           jbin=jjbin*ibin
           id = 13 000 + jbin + (ieta-1)*iofeta
           call hpakad(id,ap11)
           id = 13 000 + jbin + 10 + (ieta-1)*iofeta
           call hpakad(id,ap12)
         enddo
       enddo

* for each kin-bin (including all!), update ptmax, and event params
       do jjbin=0,1
         jbin=ibin*jjbin
         do ieta=1,neta
           if ( ieta.eq.1.and. etsummed1.gt.6.)then
             nev2(jbin)=nev2(jbin)+wtx
             id = 14 000 +  jbin + (ieta-1)*iofeta
             call hfill(id,ptmax(ieta),1.,wtx)
             call hfill(id+20,ptmax(ieta),1.,wtx*ptmax(ieta))
           endif
           if ( ieta.ge.2.and. etsummed.gt.6.)then
             if ( ieta.eq.2)nev1(jbin)=nev1(jbin)+wtx
             id = 14 000 +  jbin + (ieta-1)*iofeta
             call hfill(id,ptmax(ieta),1.,wtx)
             call hfill(id+20,ptmax(ieta),1.,wtx*ptmax(ieta))
           endif
         enddo

         nev(jbin)   = nev(jbin)+wtx
         xmean(jbin) = xmean(jbin) + x
         q2mean(jbin)= q2mean(jbin) + q2

       enddo

 9990  continue


*********************************************************************
*
*                      Termination
*
*********************************************************************

      Else if(iflag.eq.3) then

*      Termination: The following MUST always be done
*      (i) Move to the correct PAW subdirectory
*
       call hcdir('//PAWC/'//xxxx,' ')
*
       do ibin=0,9

* ptmax spectrum
         do ieta=1,neta
         if (ieta.eq.1) xnnev=nev2(ibin)
         if (ieta.gt.1) xnnev=nev1(ibin)
         id = 14 000 +  ibin + iofeta*(ieta-1)
*         write(6,*)' hz961 Term , unpak id ',id,xnnev
         call hunpak(id,apm1,'HIST',0)
         id = 14 000 + 20 + ibin + iofeta*(ieta-1)
*         write(6,*)' hz961 Term , unpak id ',id,xnnev
         call hunpak(id,ppm,'HIST',0)
         do ib=1,nbptm
           if ( apm1(ib) .gt. 0.)then
            ppm(ib)=ppm(ib)/apm1(ib)
*           write(6,*)' ptmax ib ',ib,ppp(ib)
           else
            ppm(ib)=(xbptm(ib+1)+xbptm(ib))/2.
           endif
           if ( xnnev.gt.0)then
             eapm1(ib) = sqrt(apm1(ib))/xnnev
             apm1(ib)=apm1(ib)/xnnev
             eapm1(ib) = eapm1(ib)/(xbptm(ib+1)-xbptm(ib))
             apm1(ib)=apm1(ib)/(xbptm(ib+1)-xbptm(ib))
           else
             eapm1(ib) = 0.
             apm1(ib)= 0.
           endif
*           write(6,*)' ptmax ib ',ib,ppm(ib),apm1(ib),eapm1(ib)
         enddo
         id = 14 000 +  ibin + iofeta*(ieta-1)
         call hreset(id,' ')
         call hpak(id,apm1)
         call hpake(id,eapm1)
         call hzhinfo(id,xnnev)
         call HZchisq(-id,id)
*
         id = 14 000 + 20 + ibin + iofeta*(ieta-1)
         call hreset(id,' ')
         call hpak(id,ppm)
         enddo
* pt spectrum
         do ieta=1,neta
           id = 13 000 + 0 + ibin + iofeta*(ieta-1)
C           write(6,*)' hz961 Term , unpak id ',id,nev(ibin)
           call hunpak(id,ap11,'HIST',0)
           id = 13 000 + 10 + ibin + iofeta*(ieta-1)
C           write(6,*)' hz961 Term , unpak id ',id,nev(ibin)
           call hunpak(id,ap12,'HIST',0)
           id = 13 000 + 20 + ibin + iofeta*(ieta-1)
C           write(6,*) xxxx,' Term , unpak id ',id,nev(ibin)
           call hunpak(id,ppp,'HIST',0)
           do ib=1,nbpt
             if ( ap11(ib) .gt. 0.)then
               ppp(ib)=ppp(ib)/ap11(ib)
             else
              ppp(ib)=(xbpt1(ib+1)+xbpt1(ib))/2.
             endif
             if ( nev(ibin).gt.1)then
               ap11(ib)=ap11(ib)/nev(ibin)
               ap12(ib)=ap12(ib)/nev(ibin)
               eap11(ib) = sqrt((ap12(ib)-ap11(ib)**2)/(nev(ibin)-1.))
               ap11(ib) = ap11(ib)/(xbpt1(ib+1)-xbpt1(ib))
               eap11(ib) = eap11(ib)/(xbpt1(ib+1)-xbpt1(ib))
             else
               ap11(ib)=0.
               ap12(ib)=0.
               eap11(ib) =0.
             endif
C             write(6,*)' pt ',ib,ppp(ib),ap11(ib),eap11(ib),ap12(ib)
           enddo
           id = 13 000 + 0 + ibin + iofeta*(ieta-1)
           call hreset(id,' ')
           call hpak(id,ap11)
           call hpake(id,eap11)
           call hzhinfo(id,nev(ibin))
           call HZchisq(-id,id)
           id = 13 000 + 20 + ibin + iofeta*(ieta-1)
           call hreset(id,' ')
           call hpak(id,ppp)
           call hpake(id,eap11)
           call hzhinfo(id,nev(ibin))
           call HZchisq(-id,id)
         enddo
* eta spectra
         do j=1,2
           id = 10 000 + 1000*j + ibin
           call hunpak(id,an11,'HIST',0)
           id = 10 000 + 1000*j + 10 + ibin
           call hunpak(id,an12,'HIST',0)
           etabsiz=(eta1-eta0)/float(nbeta)
           do ib=1,nbeta
             pnn(ib)=eta0+ (ib-1)*etabsiz + etabsiz/2.
             if ( nev(ibin).gt.1)then
               an11(ib)=an11(ib)/nev(ibin)
               an12(ib)=an12(ib)/nev(ibin)
               ean11(ib) = sqrt((an12(ib)-an11(ib)**2)/(nev(ibin)-1.))
               an11(ib)=an11(ib)/etabsiz
               ean11(ib)=ean11(ib)/etabsiz
             else
               an11(ib)=0.
               an12(ib)=0.
               ean11(ib) =0.
             endif
*             write(6,*)' eta ib',ib,pnn(ib),an11(ib),ean11(ib),an12(ib)
           enddo
           id = 10 000 + 1000*j + ibin
           call hreset(id,' ')
           call hpak(id,an11)
           call hpake(id,ean11)
           call hzhinfo(id,nev(ibin))
           call HZchisq(-id,id)
         enddo
       enddo
*                                              normalize mean Et,x,q2
*                                              fill histos with that info
*                                              set errors of norm. histo 0
       do ibin=0,9
        if (nev(ibin).ne.0.) then
         xmean(ibin) =xmean(ibin)/nev(ibin)
         q2mean(ibin)=q2mean(ibin)/nev(ibin)
        else
          xmean(ibin) =-999.
         q2mean(ibin) =-999.
        endif
       enddo
*
       write(6,'(a,a)')    xxxx,' bin statistics: '
       write(6,'(a,10f9.2)') ' nev  = ',nev
       write(6,'(a,10f9.2)') ' nev1 = ',nev1
       write(6,'(a,10f7.5)') ' <x>  = ',xmean
       write(6,'(a,10f7.3)') ' <q2> = ',q2mean

      endif
*
      RETURN
      END
*CMZ :  2.00/04 31/07/2000  19.44.18  by  Tancredi Carli
*CMZ :  1.02/00 07/10/98  19.54.14  by  Tancredi Carli
*-- Author : Tancredi Carli
      subroutine hz97098 (iflag)
**********************************************************************
* Running: Ee=27.5, Ep=820, no polarization
*
* purpose: produce histograms for:
*
*          event shape variables: thrust, jet broadening, jet mass
*          ----------------------
*
*          Q-bins: low Q sample:
*                  1) 7 < Q < 8 GeV
*                  2) 8 < Q < 10 GeV
*                  hi Q sample:
*                  3) 14 < Q < 16 GeV
*                  4) 16 < Q < 20 GeV
*                  5) 20 < Q < 30 GeV
*                  6) 30 < Q < 50 GeV
*                  7) 50 < Q < 100 GeV
*
*          event selection:
*          i)   energy of scattered lepton > 10 GeV
*          ii)  polar angle of scattered lepton
*               within (157,173) for low Q sample or
*               within (30,150) for hi Q sample
*          iii) hadronic energy in forward region (polar angle
*               within (4,15)) > 0.5 GeV
*          iv)  total hadronic energy in Breit current
*               hemisphere > 0.1 GeV
*          v)   0.05 < y < 0.80
*          vi)  number of particles in Breit current hemisphere >= 2
*          vii) abs(value of evt.sh.var.-upper limit of evt.sh.var.)>nl
*               abs(value of evt.sh.var.-lower limit of evt.sh.var.)>nl
*               with nl > 5*10**-5
*               (separate for each variable)
*
*
* produced histos:
*
*            distributions: (QbinNo = 1..7 s.a.)
*            ID = 10 + QbinNo:     1/N dn/d(1-Tc)
*            ID = 20 + QbinNo:     1/N dn/d(1-Tz)
*            ID = 30 + QbinNo:     1/N dn/dBc
*            ID = 40 + QbinNo:     1/N dn/d(rho c)
*            mean values:
*            ID = 10:     <1-Tc>
*            ID = 20:     <1-Tz>/2
*            ID = 30:     <Bc>
*            ID = 40:     <rho c>
*
*            H1 data histograms have corresponding negative numbers.
*            Data histos with only statistic or only systematic errors
*            are stored with offset -100 and -200.
*
*
* Arguments: iflag=1 initialisation
*            iflag=2 filling
*            iflag=3 termination
*
* called subroutines and functions:
*            from hbook lib:  hcdir,hmdir,hbookb,hbook1,
*                             hpak,hpake,hbarx,hfill
*            from HzTool lib: devshp
*                             HzDiskin,HzIdelec,HzIpgam,HzIbeam,
*                             HzBrtini,HzBrt,HzHinrm,HzHinfo,HzChisq
*            and some subroutines contained in this file
*
* written by: Andreas von Manteuffel
*
* Reference:  DESY-97-098
*
**********************************************************************

      Implicit None

**********************************************************************
*
*                      declarations
*
**********************************************************************

*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
* subroutine-specific settings
*-----------------------------

* constants:

      Real pi,rd
      Parameter (PI=3.1415927,RD=180./PI)
      Logical highQ, lowQ
      Parameter (highQ = .true., lowQ = .false.)

* general variables:

*     DESY Preprint number
      Character*6 xxxx
      Data xxxx/'97098'/

      Logical lp
      Data lp /.true./
      save lp

* histo variables:

      Character*80 chtitl

* kinematic variables:

      Logical Qtype
      Real Q, x, y
      Real costheta, thetae, thetah, temp
      Double Precision Q2
      Double Precision Ehadfwd, EhadBrt
      Double Precision Plab (4)
      Double Precision Pbrt (4)
      Double Precision Phad (4, NMXHEP)
      Double Precision pbeam(4), pgam(4), p5(5)

* event shape variables:

      Real Qbinning(9)
      Data Qbinning / 7.0, 8.0, 10.0, 14.0, 16.0,
     .                20.0, 30.0, 50.0, 100.0 /

*     for H1 data

*      Real mQ(7)
      Real TcM(8), TcMae(8), TcMye(8)
      Real TzMh(8), TzMhae(8), TzMhye(8)
      Real BcM(8), BcMae(8), BcMye(8)
      Real rcM(8), rcMae(8), rcMye(8)

      Real Tc1n(10), Tc1ce(10), Tc1ae(10), Tc1ye(10)
      Real Tc2n(10), Tc2ce(10), Tc2ae(10), Tc2ye(10)
      Real Tc3n(10), Tc3ce(10), Tc3ae(10), Tc3ye(10)
      Real Tc4n(10), Tc4ce(10), Tc4ae(10), Tc4ye(10)
      Real Tc5n(10), Tc5ce(10), Tc5ae(10), Tc5ye(10)
      Real Tc6n(10), Tc6ce(10), Tc6ae(10), Tc6ye(10)
      Real Tc7n(10), Tc7ce(10), Tc7ae(10), Tc7ye(10)

      Real Bc1n(10), Bc1ce(10), Bc1ae(10), Bc1ye(10)
      Real Bc2n(10), Bc2ce(10), Bc2ae(10), Bc2ye(10)
      Real Bc3n(10), Bc3ce(10), Bc3ae(10), Bc3ye(10)
      Real Bc4n(10), Bc4ce(10), Bc4ae(10), Bc4ye(10)
      Real Bc5n(10), Bc5ce(10), Bc5ae(10), Bc5ye(10)
      Real Bc6n(10), Bc6ce(10), Bc6ae(10), Bc6ye(10)
      Real Bc7n(10), Bc7ce(10), Bc7ae(10), Bc7ye(10)

      Real rQ1n(10), rQ1ce(10), rQ1ae(10), rQ1ye(10)
      Real rQ2n(10), rQ2ce(10), rQ2ae(10), rQ2ye(10)
      Real rQ3n(10), rQ3ce(10), rQ3ae(10), rQ3ye(10)
      Real rQ4n(10), rQ4ce(10), rQ4ae(10), rQ4ye(10)
      Real rQ5n(10), rQ5ce(10), rQ5ae(10), rQ5ye(10)
      Real rQ6n(10), rQ6ce(10), rQ6ae(10), rQ6ye(10)
      Real rQ7n(10), rQ7ce(10), rQ7ae(10), rQ7ye(10)

      Real Tz1n(10), Tz1ce(10), Tz1ae(10), Tz1ye(10)
      Real Tz2n(10), Tz2ce(10), Tz2ae(10), Tz2ye(10)
      Real Tz3n(10), Tz3ce(10), Tz3ae(10), Tz3ye(10)
      Real Tz4n(10), Tz4ce(10), Tz4ae(10), Tz4ye(10)
      Real Tz5n(10), Tz5ce(10), Tz5ae(10), Tz5ye(10)
      Real Tz6n(10), Tz6ce(10), Tz6ae(10), Tz6ye(10)
      Real Tz7n(10), Tz7ce(10), Tz7ae(10), Tz7ye(10)

*     for MC calculation

      Real esMean(4,7)
      Real esMeanE(4,7)
      Real esMtmp(8)
      Real esMEtmp(8)

      Double Precision nl
      Parameter (nl=5.D-5)

      Double Precision lolimit (4)
      Double Precision hilimit (4)
      Double Precision evshpMC (4)
      Double Precision evshpSR (13)
      Double Precision esSum (4, 7)
      Double Precision esSqSum (4, 7)
      save esSum
      save esSqSum


* counting, index and errorcode variables:

      Integer ihep, iel, ibeam, igam
      Integer idum, ierr, iflag, id
      Integer ichn, iQbin, curQbin, iesType
      Integer ihad, icomp
      Integer inBrtCrr
      Real Nevt(4,7)
      Real locut(4,7)
      Real hicut(4,7)
      Double Precision ddum
      save Nevt

*********************************************************************
*
*                     data points from H1
*
*********************************************************************


* H1 event shape means:

*      Data mQ / 7.46, 8.74, 14.97, 17.75, 23.62, 36.72, 63.44 /

      Data TcM    / 0.1678, 0.1631, 0.0000, 0.1251, 0.1193,
     .              0.1072, 0.0880, 0.0746 /
      Data TcMae  / 0.0019, 0.0021, 0.0000, 0.0016, 0.0012,
     .              0.0012, 0.0018, 0.0037 /
      Data TcMye  / 0.0023, 0.0019, 0.0000, 0.0021, 0.0022,
     .              0.0025, 0.0021, 0.0023 /

      Data TzMh   / 0.2182, 0.2009, 0.0000, 0.1555, 0.1351,
     .              0.1125, 0.0912, 0.0635 /
      Data TzMhae / 0.0019, 0.0022, 0.0000, 0.0018, 0.0014,
     .              0.0013, 0.0019, 0.0035 /
      Data TzMhye / 0.0024, 0.0023, 0.0000, 0.0023, 0.0025,
     .              0.0024, 0.0023, 0.0049 /

      Data BcM    / 0.3566, 0.3414, 0.0000, 0.2978, 0.2704,
     .              0.2394, 0.2039, 0.1654 /
      Data BcMae  / 0.0019, 0.0023, 0.0000, 0.0018, 0.0013,
     .              0.0014, 0.0023, 0.0046 /
      Data BcMye  / 0.0071, 0.0076, 0.0000, 0.0069, 0.0067,
     .              0.0070, 0.0093, 0.0107 /

      Data rcM    / 0.1055, 0.1009, 0.0000, 0.0871, 0.0816,
     .              0.0780, 0.0637, 0.0512 /
      Data rcMae  / 0.0015, 0.0015, 0.0000, 0.0010, 0.0008,
     .              0.0008, 0.0013, 0.0024 /
      Data rcMye  / 0.0023, 0.0024, 0.0000, 0.0031, 0.0020,
     .              0.0030, 0.0030, 0.0021 /

* H1 event shape distributions:

      Data   Tc1n  / 2.0877, 3.0518, 3.9578, 3.8372, 3.1103,
     .               2.3335, 1.3402, 0.2815, 0.0000, 0.0000 /
      Data   Tc1ce / 0.5323, 0.4970, 0.4708, 0.5005, 0.4913,
     .               0.3423, 0.2596, 0.0671, 0.0000, 0.0000 /
      Data   Tc1ae / 0.0966, 0.1168, 0.1330, 0.1310, 0.1179,
     .               0.1021, 0.0774, 0.0355, 0.0000, 0.0000 /
      Data   Tc1ye / 0.5235, 0.4830, 0.4516, 0.4830, 0.4769,
     .               0.3267, 0.2478, 0.0569, 0.0000, 0.0000 /

      Data   Tc2n  / 2.0072, 3.2660, 4.1687, 3.7592, 3.0034,
     .               2.3871, 1.1947, 0.2138, 0.0000, 0.0000 /
      Data   Tc2ce / 0.4431, 0.4062, 0.3139, 0.3568, 0.3525,
     .               0.3007, 0.3037, 0.0822, 0.0000, 0.0000 /
      Data   Tc2ae / 0.1052, 0.1342, 0.1517, 0.1440, 0.1287,
     .               0.1148, 0.0812, 0.0343, 0.0000, 0.0000 /
      Data   Tc2ye / 0.4305, 0.3833, 0.2749, 0.3264, 0.3282,
     .               0.2779, 0.2927, 0.0747, 0.0000, 0.0000 /

      Data   Tc3n  / 3.1568, 5.2517, 4.5898, 3.2778, 1.8134,
     .               1.1952, 0.5285, 0.1692, 0.0176, 0.0000 /
      Data   Tc3ce / 0.4201, 0.3345, 0.3114, 0.2590, 0.1978,
     .               0.1698, 0.1153, 0.0626, 0.0230, 0.0000 /
      Data   Tc3ae / 0.1247, 0.1609, 0.1504, 0.1271, 0.0945,
     .               0.0767, 0.0510, 0.0289, 0.0093, 0.0000 /
      Data   Tc3ye / 0.4011, 0.2933, 0.2727, 0.2257, 0.1738,
     .               0.1515, 0.1034, 0.0556, 0.0210, 0.0000 /

      Data   Tc4n  / 2.8891, 5.8336, 4.9827, 2.9736, 1.6689,
     .               0.9901, 0.5237, 0.1305, 0.0078, 0.0000 /
      Data   Tc4ce / 0.3910, 0.4581, 0.4625, 0.3573, 0.1551,
     .               0.1097, 0.0757, 0.0401, 0.0064, 0.0000 /
      Data   Tc4ae / 0.0967, 0.1374, 0.1270, 0.0981, 0.0735,
     .               0.0566, 0.0412, 0.0206, 0.0050, 0.0000 /
      Data   Tc4ye / 0.3788, 0.4370, 0.4447, 0.3436, 0.1366,
     .               0.0940, 0.0635, 0.0344, 0.0039, 0.0000 /

      Data   Tc5n  / 3.9188, 6.7630, 4.2459, 2.3695, 1.3226,
     .               0.8789, 0.3943, 0.1006, 0.0063, 0.0000 /
      Data   Tc5ce / 0.6255, 0.5140, 0.3791, 0.2762, 0.1830,
     .               0.1138, 0.0661, 0.0233, 0.0083, 0.0000 /
      Data   Tc5ae / 0.1173, 0.1542, 0.1221, 0.0912, 0.0682,
     .               0.0556, 0.0372, 0.0188, 0.0047, 0.0000 /
      Data   Tc5ye / 0.6144, 0.4903, 0.3589, 0.2607, 0.1698,
     .               0.0992, 0.0547, 0.0137, 0.0068, 0.0000 /

      Data   Tc6n  / 6.4097, 6.6005, 2.9957, 1.7533, 1.2299,
     .               0.7981, 0.1782, 0.0347, 0.0000, 0.0000 /
      Data   Tc6ce / 0.4972, 0.4151, 0.2244, 0.1925, 0.1420,
     .               0.1039, 0.0553, 0.0306, 0.0000, 0.0000 /
      Data   Tc6ae / 0.2481, 0.2518, 0.1696, 0.1298, 0.1087,
     .               0.0876, 0.0414, 0.0182, 0.0000, 0.0000 /
      Data   Tc6ye / 0.4309, 0.3300, 0.1469, 0.1422, 0.0914,
     .               0.0560, 0.0367, 0.0246, 0.0000, 0.0000 /

      Data   Tc7n  / 9.8287, 4.7100, 2.5708, 1.3032, 0.9634,
     .               0.4957, 0.0808, 0.0000, 0.0000, 0.0000 /
      Data   Tc7ce / 0.7650, 0.5787, 0.4209, 0.2774, 0.2544,
     .               0.1661, 0.0738, 0.0000, 0.0000, 0.0000 /
      Data   Tc7ae / 0.6833, 0.4730, 0.3495, 0.2488, 0.2139,
     .               0.1535, 0.0619, 0.0000, 0.0000, 0.0000 /
      Data   Tc7ye / 0.3440, 0.3333, 0.2346, 0.1227, 0.1377,
     .               0.0635, 0.0403, 0.0000, 0.0000, 0.0000 /


      Data   Bc1n  / 0.0000, 0.0485, 0.2351, 0.8510, 1.6524,
     .               2.7155, 3.4655, 3.5857, 3.7861, 3.6558 /
      Data   Bc1ce / 0.0000, 0.0538, 0.1069, 0.2621, 0.2574,
     .               0.4552, 0.3371, 0.8237, 0.3572, 0.3846 /
      Data   Bc1ae / 0.0000, 0.0147, 0.0324, 0.0617, 0.0859,
     .               0.1102, 0.1245, 0.1266, 0.1301, 0.1278 /
      Data   Bc1ye / 0.0000, 0.0517, 0.1019, 0.2548, 0.2426,
     .               0.4417, 0.3133, 0.8139, 0.3327, 0.3627 /

      Data   Bc2n  / 0.0116, 0.1025, 0.4408, 1.2082, 2.2011,
     .               2.9718, 3.2057, 3.3449, 3.5951, 2.9183 /
      Data   Bc2ce / 0.0129, 0.0613, 0.1912, 0.3510, 0.6052,
     .               0.2860, 0.6425, 0.3384, 0.3923, 0.2642 /
      Data   Bc2ae / 0.0080, 0.0238, 0.0493, 0.0816, 0.1102,
     .               0.1280, 0.1330, 0.1358, 0.1408, 0.1269 /
      Data   Bc2ye / 0.0101, 0.0565, 0.1848, 0.3414, 0.5951,
     .               0.2558, 0.6286, 0.3099, 0.3662, 0.2317 /

      Data   Bc3n  / 0.0092, 0.2407, 1.1766, 2.1920, 3.2427,
     .               2.7891, 2.7533, 2.5151, 2.2751, 2.1063 /
      Data   Bc3ce / 0.0115, 0.0756, 0.2135, 0.1674, 0.2969,
     .               0.2869, 0.2177, 0.1909, 0.1473, 0.1921 /
      Data   Bc3ae / 0.0067, 0.0344, 0.0761, 0.1039, 0.1264,
     .               0.1172, 0.1165, 0.1178, 0.1104, 0.1066 /
      Data   Bc3ye / 0.0094, 0.0673, 0.1994, 0.1312, 0.2687,
     .               0.2618, 0.1839, 0.1502, 0.0976, 0.1598 /

      Data   Bc4n  / 0.0189, 0.4277, 1.9846, 3.7219, 3.4220,
     .               2.8145, 2.2936, 2.1189, 1.8803, 1.2980 /
      Data   Bc4ce / 0.0639, 0.1326, 0.1521, 0.2687, 0.1755,
     .               0.2112, 0.2077, 0.1637, 0.1667, 0.1754 /
      Data   Bc4ae / 0.0078, 0.0372, 0.0802, 0.1098, 0.1053,
     .               0.0955, 0.0862, 0.0828, 0.0780, 0.0648 /
      Data   Bc4ye / 0.0634, 0.1273, 0.1293, 0.2452, 0.1403,
     .               0.1884, 0.1889, 0.1412, 0.1473, 0.1630 /

      Data   Bc5n  / 0.0381, 1.0561, 3.5305, 4.2269, 3.2213,
     .               2.4026, 1.8228, 1.4735, 1.2234, 1.0049 /
      Data   Bc5ce / 0.1019, 0.2156, 0.2112, 0.2372, 0.1847,
     .               0.1623, 0.2044, 0.1681, 0.1342, 0.1574 /
      Data   Bc5ae / 0.0116, 0.0609, 0.1114, 0.1219, 0.1064,
     .               0.0919, 0.0800, 0.0720, 0.0656, 0.0594 /
      Data   Bc5ye / 0.1013, 0.2068, 0.1794, 0.2035, 0.1510,
     .               0.1338, 0.1881, 0.1519, 0.1170, 0.1457 /

      Data   Bc6n  / 0.2039, 3.2918, 4.7431, 3.7597, 2.5149,
     .               1.7113, 1.4350, 0.9139, 0.7761, 0.6503 /
      Data   Bc6ce / 0.0549, 0.2307, 0.2652, 0.3063, 0.2733,
     .               0.2366, 0.1921, 0.1794, 0.1594, 0.1580 /
      Data   Bc6ae / 0.0443, 0.1778, 0.2135, 0.1900, 0.1554,
     .               0.1282, 0.1174, 0.0937, 0.0863, 0.0790 /
      Data   Bc6ye / 0.0323, 0.1470, 0.1574, 0.2402, 0.2248,
     .               0.1988, 0.1521, 0.1530, 0.1340, 0.1368 /

      Data   Bc7n  / 0.8798, 6.3943, 4.1233, 3.0085, 2.1221,
     .               0.9383, 1.1414, 0.6296, 0.4602, 0.3023 /
      Data   Bc7ce / 0.2969, 0.6440, 0.5603, 0.4946, 0.3825,
     .               0.3122, 0.2898, 0.2179, 0.2005, 0.1960 /
      Data   Bc7ae / 0.2044, 0.5512, 0.4426, 0.3781, 0.3175,
     .               0.2111, 0.2329, 0.1729, 0.1479, 0.1198 /
      Data   Bc7ye / 0.2153, 0.3331, 0.3436, 0.3189, 0.2132,
     .               0.2300, 0.1724, 0.1326, 0.1354, 0.1551 /


      Data   rQ1n  / 4.8012, 6.3386, 4.5072, 2.3381, 1.1538,
     .               0.5376, 0.2707, 0.0349, 0.0134, 0.0000 /
      Data   rQ1ce / 2.1514, 1.0142, 1.1607, 0.7741, 0.5244,
     .               0.3359, 0.4088, 0.0372, 0.0412, 0.0000 /
      Data   rQ1ae / 0.1466, 0.1684, 0.1420, 0.1023, 0.0719,
     .               0.0490, 0.0348, 0.0125, 0.0077, 0.0000 /
      Data   rQ1ye / 2.1464, 1.0002, 1.1520, 0.7673, 0.5195,
     .               0.3323, 0.4073, 0.0350, 0.0404, 0.0000 /

      Data   rQ2n  / 4.7909, 6.5121, 4.7740, 2.2681, 1.1284,
     .               0.3522, 0.1111, 0.0288, 0.0046, 0.0077 /
      Data   rQ2ce / 1.9725, 1.2987, 1.6879, 0.5421, 0.7114,
     .               0.2422, 0.1813, 0.0330, 0.0091, 0.0180 /
      Data   rQ2ae / 0.1626, 0.1895, 0.1623, 0.1119, 0.0789,
     .               0.0441, 0.0248, 0.0126, 0.0051, 0.0065 /
      Data   rQ2ye / 1.9658, 1.2848, 1.6801, 0.5305, 0.7070,
     .               0.2381, 0.1796, 0.0305, 0.0075, 0.0168 /

      Data   rQ3n  / 5.6025, 7.5452, 3.8745, 1.7123, 0.6989,
     .               0.3300, 0.1171, 0.0286, 0.0169, 0.0100 /
      Data   rQ3ce / 0.6977, 0.5385, 0.3632, 0.2932, 0.2224,
     .               0.1669, 0.1038, 0.0538, 0.0259, 0.0124 /
      Data   rQ3ae / 0.1662, 0.1929, 0.1382, 0.0919, 0.0587,
     .               0.0403, 0.0240, 0.0119, 0.0091, 0.0070 /
      Data   rQ3ye / 0.6776, 0.5028, 0.3359, 0.2784, 0.2145,
     .               0.1619, 0.1010, 0.0524, 0.0242, 0.0103 /

      Data   rQ4n  / 5.8796, 8.0333, 3.4587, 1.3468, 0.6857,
     .               0.3460, 0.1535, 0.0609, 0.0219, 0.0136 /
      Data   rQ4ce / 0.8759, 0.6765, 0.5210, 0.2107, 0.1642,
     .               0.0917, 0.0532, 0.0241, 0.0148, 0.0089 /
      Data   rQ4ae / 0.1380, 0.1613, 0.1059, 0.0661, 0.0471,
     .               0.0335, 0.0223, 0.0141, 0.0084, 0.0066 /
      Data   rQ4ye / 0.8650, 0.6570, 0.5101, 0.2001, 0.1573,
     .               0.0853, 0.0483, 0.0196, 0.0121, 0.0060 /

      Data   rQ5n  / 7.1262, 7.5957, 2.8019, 1.2664, 0.5955,
     .               0.3118, 0.1798, 0.0648, 0.0322, 0.0116 /
      Data   rQ5ce / 0.3919, 0.3084, 0.1587, 0.0953, 0.0833,
     .               0.0610, 0.0368, 0.0218, 0.0126, 0.0077 /
      Data   rQ5ae / 0.1583, 0.1635, 0.0993, 0.0667, 0.0458,
     .               0.0331, 0.0251, 0.0151, 0.0106, 0.0064 /
      Data   rQ5ye / 0.3585, 0.2615, 0.1238, 0.0680, 0.0696,
     .               0.0513, 0.0269, 0.0157, 0.0068, 0.0043 /

      Data   rQ6n  / 10.1500, 5.7132, 2.1353, 0.9746, 0.5177,
     .               0.2396, 0.1181, 0.0511, 0.0619, 0.0000 /
      Data   rQ6ce / 0.5295, 0.3389, 0.2012, 0.1366, 0.0867,
     .               0.0549, 0.0433, 0.0234, 0.0267, 0.0000 /
      Data   rQ6ae / 0.3124, 0.2344, 0.1433, 0.0968, 0.0706,
     .               0.0480, 0.0337, 0.0222, 0.0244, 0.0000 /
      Data   rQ6ye / 0.4275, 0.2448, 0.1413, 0.0963, 0.0503,
     .               0.0267, 0.0272, 0.0075, 0.0108, 0.0000 /

      Data   rQ7n  / 12.1888, 4.1333, 1.3569, 1.2022, 0.1850,
     .               0.1583, 0.0776, 0.0776, 0.0000, 0.0000 /
      Data   rQ7ce / 0.8506, 0.5336, 0.3832, 0.3521, 0.2244,
     .               0.1892, 0.1118, 0.0764, 0.0000, 0.0000 /
      Data   rQ7ae / 0.7628, 0.4442, 0.2545, 0.2395, 0.0940,
     .               0.0869, 0.0608, 0.0608, 0.0000, 0.0000 /
      Data   rQ7ye / 0.3763, 0.2957, 0.2865, 0.2581, 0.2037,
     .               0.1680, 0.0938, 0.0463, 0.0000, 0.0000 /


      Data   Tz1n  / 0.3194, 1.2483, 1.6760, 1.8007, 1.5085,
     .               1.2338, 0.9597, 0.7942, 0.3717, 0.0876 /
      Data   Tz1ce / 0.0919, 0.1087, 0.2119, 0.1224, 0.0806,
     .               0.0986, 0.2136, 0.1005, 0.0731, 0.0611 /
      Data   Tz1ae / 0.0267, 0.0528, 0.0612, 0.0634, 0.0581,
     .               0.0525, 0.0463, 0.0421, 0.0288, 0.0140 /
      Data   Tz1ye / 0.0880, 0.0950, 0.2029, 0.1047, 0.0559,
     .               0.0835, 0.2085, 0.0913, 0.0672, 0.0595 /

      Data   Tz2n  / 0.5315, 1.5205, 1.8928, 1.7275, 1.3058,
     .               1.1317, 0.9133, 0.6219, 0.2721, 0.0829 /
      Data   Tz2ce / 0.1725, 0.2173, 0.2157, 0.2438, 0.3373,
     .               0.1442, 0.0816, 0.1366, 0.1145, 0.0475 /
      Data   Tz2ae / 0.0383, 0.0648, 0.0723, 0.0690, 0.0600,
     .               0.0559, 0.0502, 0.0414, 0.0274, 0.0151 /
      Data   Tz2ye / 0.1682, 0.2074, 0.2032, 0.2339, 0.3319,
     .               0.1329, 0.0643, 0.1302, 0.1111, 0.0450 /

      Data   Tz3n  / 1.1746, 2.4551, 1.8801, 1.3135, 1.0126,
     .               0.7693, 0.6577, 0.4146, 0.2738, 0.0486 /
      Data   Tz3ce / 0.0893, 0.1452, 0.1324, 0.1081, 0.0900,
     .               0.0843, 0.0723, 0.0535, 0.0457, 0.0215 /
      Data   Tz3ae / 0.0538, 0.0778, 0.0681, 0.0569, 0.0499,
     .               0.0435, 0.0403, 0.0320, 0.0260, 0.0109 /
      Data   Tz3ye / 0.0713, 0.1225, 0.1135, 0.0919, 0.0749,
     .               0.0722, 0.0600, 0.0428, 0.0376, 0.0185 /

      Data   Tz4n  / 1.8672, 3.1374, 1.7572, 1.0802, 0.7486,
     .               0.5941, 0.3737, 0.2730, 0.1441, 0.0245 /
      Data   Tz4ce / 0.1554, 0.1534, 0.1053, 0.0985, 0.0554,
     .               0.0501, 0.0401, 0.0370, 0.0301, 0.0215 /
      Data   Tz4ae / 0.0550, 0.0713, 0.0533, 0.0418, 0.0348,
     .               0.0310, 0.0246, 0.0210, 0.0153, 0.0063 /
      Data   Tz4ye / 0.1454, 0.1358, 0.0908, 0.0891, 0.0431,
     .               0.0393, 0.0316, 0.0305, 0.0259, 0.0206 /

      Data   Tz5n  / 3.1173, 3.1771, 1.3783, 0.8068, 0.5588,
     .               0.3631, 0.2630, 0.2119, 0.0996, 0.0242 /
      Data   Tz5ce / 0.1321, 0.1430, 0.0826, 0.0688, 0.0674,
     .               0.0470, 0.0513, 0.0480, 0.0356, 0.0325 /
      Data   Tz5ae / 0.0740, 0.0747, 0.0492, 0.0376, 0.0313,
     .               0.0253, 0.0215, 0.0193, 0.0132, 0.0065 /
      Data   Tz5ye / 0.1094, 0.1219, 0.0664, 0.0576, 0.0597,
     .               0.0396, 0.0466, 0.0439, 0.0331, 0.0319 /

      Data   Tz6n  / 4.9564, 2.4416, 1.0788, 0.5708, 0.3575,
     .               0.1930, 0.1551, 0.1425, 0.0858, 0.0185 /
      Data   Tz6ce / 0.1655, 0.1172, 0.0745, 0.0580, 0.0481,
     .               0.0377, 0.0330, 0.0304, 0.0243, 0.0140 /
      Data   Tz6ae / 0.1543, 0.1083, 0.0720, 0.0524, 0.0414,
     .               0.0304, 0.0273, 0.0262, 0.0203, 0.0094 /
      Data   Tz6ye / 0.0599, 0.0447, 0.0192, 0.0248, 0.0244,
     .               0.0223, 0.0185, 0.0154, 0.0133, 0.0104 /

      Data   Tz7n  / 6.3357, 1.9493, 0.7622, 0.4186, 0.1981,
     .               0.2249, 0.0389, 0.0308, 0.0178, 0.0000 /
      Data   Tz7ce / 0.3903, 0.2224, 0.1481, 0.1133, 0.0812,
     .               0.0824, 0.0439, 0.0390, 0.0337, 0.0000 /
      Data   Tz7ae / 0.3879, 0.2152, 0.1346, 0.0997, 0.0686,
     .               0.0731, 0.0304, 0.0270, 0.0206, 0.0000 /
      Data   Tz7ye / 0.0436, 0.0560, 0.0617, 0.0539, 0.0435,
     .               0.0381, 0.0316, 0.0282, 0.0267, 0.0000 /


*********************************************************************
*
*                      Initialization
*
*********************************************************************


*

      if (iflag.eq.1) then
*
*
*      Initialisation: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (ii) make subdirectory in o/p file
*

         call hcdir('//PAWC',' ')
         call hmdir(xxxx,'S')
         call hcdir('//HISTO',' ')
         call hmdir(xxxx,'S')

* hello world !

	 WRITE(6,*)'***************************************************'
	 WRITE(6,*)'HZ'//xxxx//' called'
     	 WRITE(6,*)'***************************************************'

*
* remind:
*     HistoIDs:  ID < 0  for H1 data
*                ID > 0  for corresponding generator histos
*               |ID| = i        for combined errors
*               |ID| = 100 + i  for statist. errors only
*               |ID| = 200 + i  for system. errors only
*
*


* DISTRIBUTION - HISTOS:
* build up H1-histos and prepare MC-histos

         write(chtitl,*) '1/N dn/d(1-Tc) in Breit frame'
         call H1distr(11,chtitl,10,0.,.5,Tc1n,Tc1ce,Tc1ae,Tc1ye)
         call H1distr(12,chtitl,10,0.,.5,Tc2n,Tc2ce,Tc2ae,Tc2ye)
         call H1distr(13,chtitl,10,0.,.5,Tc3n,Tc3ce,Tc3ae,Tc3ye)
         call H1distr(14,chtitl,10,0.,.5,Tc4n,Tc4ce,Tc4ae,Tc4ye)
         call H1distr(15,chtitl,10,0.,.5,Tc5n,Tc5ce,Tc5ae,Tc5ye)
         call H1distr(16,chtitl,10,0.,.5,Tc6n,Tc6ce,Tc6ae,Tc6ye)
         call H1distr(17,chtitl,10,0.,.5,Tc7n,Tc7ce,Tc7ae,Tc7ye)
         call MCdistr(10,chtitl,10,0.,.5, 7)

         write(chtitl,*) '1/N dn/d(1-Tz) in Breit frame'
         call H1distr(21,chtitl,10,0.,1.,Tz1n,Tz1ce,Tz1ae,Tz1ye)
         call H1distr(22,chtitl,10,0.,1.,Tz2n,Tz2ce,Tz2ae,Tz2ye)
         call H1distr(23,chtitl,10,0.,1.,Tz3n,Tz3ce,Tz3ae,Tz3ye)
         call H1distr(24,chtitl,10,0.,1.,Tz4n,Tz4ce,Tz4ae,Tz4ye)
         call H1distr(25,chtitl,10,0.,1.,Tz5n,Tz5ce,Tz5ae,Tz5ye)
         call H1distr(26,chtitl,10,0.,1.,Tz6n,Tz6ce,Tz6ae,Tz6ye)
         call H1distr(27,chtitl,10,0.,1.,Tz7n,Tz7ce,Tz7ae,Tz7ye)
         call MCdistr(20,chtitl,10,0.,1., 7)

         write(chtitl,*) '1/N dn/d(Bc) in Breit frame'
         call H1distr(31,chtitl,10,0.,.5,Bc1n,Bc1ce,Bc1ae,Bc1ye)
         call H1distr(32,chtitl,10,0.,.5,Bc2n,Bc2ce,Bc2ae,Bc2ye)
         call H1distr(33,chtitl,10,0.,.5,Bc3n,Bc3ce,Bc3ae,Bc3ye)
         call H1distr(34,chtitl,10,0.,.5,Bc4n,Bc4ce,Bc4ae,Bc4ye)
         call H1distr(35,chtitl,10,0.,.5,Bc5n,Bc5ce,Bc5ae,Bc5ye)
         call H1distr(36,chtitl,10,0.,.5,Bc6n,Bc6ce,Bc6ae,Bc6ye)
         call H1distr(37,chtitl,10,0.,.5,Bc7n,Bc7ce,Bc7ae,Bc7ye)
         call MCdistr(30,chtitl,10,0.,.5, 7)

         write(chtitl,*) '1/N dn/d(rho Q) in Breit frame'
         call H1distr(41,chtitl,10,0.,.5,rQ1n,rQ1ce,rQ1ae,rQ1ye)
         call H1distr(42,chtitl,10,0.,.5,rQ2n,rQ2ce,rQ2ae,rQ2ye)
         call H1distr(43,chtitl,10,0.,.5,rQ3n,rQ3ce,rQ3ae,rQ3ye)
         call H1distr(44,chtitl,10,0.,.5,rQ4n,rQ4ce,rQ4ae,rQ4ye)
         call H1distr(45,chtitl,10,0.,.5,rQ5n,rQ5ce,rQ5ae,rQ5ye)
         call H1distr(46,chtitl,10,0.,.5,rQ6n,rQ6ce,rQ6ae,rQ6ye)
         call H1distr(47,chtitl,10,0.,.5,rQ7n,rQ7ce,rQ7ae,rQ7ye)
         call MCdistr(40,chtitl,10,0.,.5, 7)


* MEAN VALUE - HISTOS:
* build up H1-histos and prepare MC-histos

         write(chtitl,*) 'mean(1-Tc) in Breit frame'
         call H1means(10,chtitl,8,Qbinning,TcM,TcMae,TcMye)
         call MCmeans(10,chtitl,8,Qbinning)
         write(chtitl,*) 'mean((1-Tz)/2) in Breit frame'
         call H1means(20,chtitl,8,Qbinning,TzMh,TzMhae,TzMhye)
         call MCmeans(20,chtitl,8,Qbinning)
         write(chtitl,*) 'mean(1-Bc) in Breit frame'
         call H1means(30,chtitl,8,Qbinning,BcM,BcMae,BcMye)
         call MCmeans(30,chtitl,8,Qbinning)
         write(chtitl,*) 'mean(rho Q) in Breit frame'
         call H1means(40,chtitl,8,Qbinning,rcM,rcMae,rcMye)
         call MCmeans(40,chtitl,8,Qbinning)


* prepare control histo

         write(chtitl,*) 'dn/dQ in lab. frame - control plot'
         call hbook1(1, chtitl, 100, 0., 100., 0.)
         call hbarx(1)


* initialize counter variables

         do iesType = 1, 4
            do iQbin = 1, 7
               esSum(iesType, iQbin) = 0.D0
               esSqSum(iesType, iQbin) = 0.D0
               Nevt(iesType, iQbin) = 0.
               locut(iesType, iQbin) = 0.
               hicut(iesType, iQbin) = 0.
            enddo
         enddo

* initialize exclusive limits for event shapes in MC calculation

      lolimit(1) = nl
      lolimit(2) = nl
      lolimit(3) = nl
      lolimit(4) = nl
      hilimit(1) = 5.D-1 - nl
      hilimit(2) = 1.D0 - nl
      hilimit(3) = 5.D-1 - nl
      hilimit(4) = 5.D-1 - nl


*********************************************************************
*
*                      Event Processing
*
*********************************************************************

      else if (iflag.eq.2) then


*      Filling: The following MUST always be done
*      (i) move to the correct sub-directory in PAWC
*
         call hcdir('//PAWC/'//xxxx,' ')

*----------------
* Event selection
*----------------

* get Q2
         Q2 = HzDiskin(1)

* get Q and fill control histo
         if (Q2.le.0.D0) then
            write(6,*) 'Hz'//xxxx, ' ERROR: Q2 less or equal zero !!!'
            goto 9990
         else
            Q = real(sqrt(Q2))
            call hfill(1,Q,0.,wtx)
         endif


* Q-binning:  Q has to be within [7 GeV, 10 GeV] (low Q) or
*-----------              within [14 GeV, 100 GeV] (high Q)

         if ((Q.ge.7.).and.(Q.le.10.)) then
            Qtype = lowQ
            if (Q.lt.8.)  then
               curQbin = 1
            else
               curQbin = 2
            endif
         elseif ((Q.ge.14.).and.(Q.le.100.)) then
            Qtype = highQ
            if (Q.lt.16.) then
               curQbin = 3
            elseif (Q.lt.20.) then
               curQbin = 4
            elseif (Q.lt.30.) then
               curQbin = 5
            elseif (Q.lt.50.) then
               curQbin = 6
            else
               curQbin = 7
            endif
         else
            goto 9990
         endif


* detect lepton
         iel = HzIdelec(idum)
         if ( (iel.eq.-1).or.
     .        (iel.lt.1).or.(iel.gt.NMXHEP) ) then
            write(6,*) 'Hz'//xxxx,' ERROR: lepton not found !!!'
            goto 9990
         endif

* CUT (i): energy of scattered lepton > 10 GeV
*---------
         if (real(PHEP(4,iel)).le.10.) goto 9990


* get polar angle of scattered lepton
         costheta =  real(PHEP(3,iel)) /
     .        sqrt( real(PHEP(1,iel))**2 + real(PHEP(2,iel))**2
     .        + real(PHEP(3,iel))**2 )
         if (abs(costheta).gt.1.) then
            write(6,*) 'Hz'//xxxx, ' ERROR: abs(cos(thetae)) > 1 !!!'
            goto 9990
         endif
         thetae = RD * acos(costheta)


* CUT (ii): polar angle of scattered lepton within [157, 173] (low Q)
*----------                              or within [30, 150] (high Q)

         if (Qtype.eqv.lowQ) then
            if ((thetae.le.157.).or.(thetae.ge.173.)) then
               goto 9990
            endif
         elseif (Qtype.eqv.highQ) then
            if ((thetae.le.30.).or.(thetae.ge.150.)) then
               goto 9990
            endif
         endif

* get y
         y = Real(HzDiskin(3))

* CUT (v): y within [.05,0.8]
*---------
         if ((y.lt.0.05).or.(y.gt.0.80)) goto 9990


* init boost to Breit frame
         ierr = HzIbeam(ibeam,idum)
         if ( (ierr.ne.1).or.
     .        (ibeam.lt.1).or.(ibeam.gt.NMXHEP).or.
     .        (idum.lt.1).or.(idum.gt.NMXHEP)       ) then
            write(6,*) 'HZ'//xxxx,' ERROR: beams not found !!!'
            goto 9990
         else
            Do icomp = 1, 4
               pbeam(icomp)=PHEP(icomp,IBEAM)
            enddo
         endif

         ierr = HzIpgam(p5)
         if (ierr.eq.-1) then
            write(6,*) 'HZ'//xxxx,' ERROR: boson vector not found !!!'
            goto 9990
         else
            Do icomp = 1, 4
               pgam(icomp) = p5(icomp)
            enddo
         endif

         call HzBrtini (pbeam, pgam, ierr)
         if (ierr.eq.-1) then
            write(6,*)
     .          'HZ'//xxxx,' problem with boost to Breit frame !'
            goto 9990
         endif

* loop over HEP common
         ihad = 0
         Ehadfwd = 0.D0
         inBrtCrr = 0
         EhadBrt = 0.D0
         do 5000 ihep = 1, nhep
*     skip lepton and unstable particles
            if ((isthep(ihep).ne.1).or.(ihep.eq.iel))  goto 5000

*     get polar angle of hadron
            temp =  sqrt( real(PHEP(1,ihep))**2 + real(PHEP(2,ihep))**2
     .           + real(PHEP(3,ihep))**2 )
            if (temp.ne.0.) then
               costheta =  real(PHEP(3,ihep)) / temp
               if (abs(costheta).gt.1.) then
                  write(6,*) 'Hz'//xxxx, 'ERROR: abs(cos(thetah))>1 !!!'
                  goto 9990
               endif
               thetah = RD * acos(costheta)
            else
               thetah = 0.
            endif

*     sum up hadronic energy in forward direction
            if ((thetah.gt.4.).and.(thetah.lt.15.))  then
               Ehadfwd = Ehadfwd + PHEP(4, ihep)
            endif

*     perform boost to Breit frame
            do icomp = 1, 4
               Plab(icomp) = PHEP(icomp, IHEP)
            enddo
            call HzBrt(plab, pbrt, ierr)
            if (ierr.eq.-1) then
               write(6,*) 'HZ'//xxxx,
     .              ' problem with boost to Breit frame !'
               goto 9990
            endif

*     copy to array suitable for subroutine devshp
            ihad = ihad + 1
            Phad(1, ihad) = pbrt(4)
            Phad(2, ihad) = pbrt(1)
            Phad(3, ihad) = pbrt(2)
            Phad(4, ihad) = pbrt(3)

*     particle in Breit current hemisphere ?
            if (pbrt(3).LT.0.D0) then
*     sum up number of particles in Breit current hemisphere
               inBrtCrr = inBrtCrr + 1
*     sum up hadronic energy in Breit current hemisphere
               EhadBrt = EhadBrt + Pbrt(4)
            endif

 5000    continue


* CUT (iii): hadronic energy in forward direction >= 0.5 GeV
*-----------
         if (real(Ehadfwd).lt.0.5) goto 9990

* CUT (vi): number of particles in Breit current hemisphere >= 2
*----------
         if (inBrtCrr.lt.2) goto 9990

* CUT (iv): total hadronic energy in Breit current hemisphere  >= 0.1 Q
*----------
         if (real(EhadBrt).lt.(0.1*Q)) goto 9990



*-------------------------------------
* Calculation of event shape variables
*-------------------------------------

* get event shape variables
         call devshp (Phad, ihad, Q2, evshpSR, idum, ddum)

* copy into internal array
         evshpMC(1) = evshpSR(1)
         evshpMC(2) = evshpSR(3)
         evshpMC(3) = evshpSR(5)
         evshpMC(4) = evshpSR(6)

* calculate sums for mean values and their standard deviations
         do iesType = 1, 4
            esSum(iesType, curQbin) = esSum(iesType, curQbin)
     .                              + dble(wtx)*evshpMC(iesType)
            esSqSum(iesType, curQbin) = esSqSum(iesType, curQbin)
     .                              + dble(wtx)*(evshpMC(iesType)**2.)
         enddo


*--------------
* Histo filling
*--------------


* fill histos and increase counters for number of accepted events
         do iesType = 1, 4

* CUT (vii): values of evt.shp.var. in allowed regions (s.a.)
*-----------
           if ((evshpMC(iesType).gt.lolimit(iesType)).and.
     .         (evshpMC(iesType).lt.hilimit(iesType))) then
              call hfill(iesType*10+curQbin,
     .                   Real(evshpMC(iesType)),0.,wtx)
              Nevt(iesType,curQbin) = Nevt(iesType,curQbin) + wtx
           elseif (evshpMC(iesType).le.lolimit(iesType)) then
              locut(iesType,curQbin) = locut(iesType,curQbin) + wtx
           elseif (evshpMC(iesType).ge.hilimit(iesType)) then
              hicut(iesType,curQbin) = hicut(iesType,curQbin) + wtx
           endif
         enddo


 9990    continue



*********************************************************************
*
*                      Termination
*
*********************************************************************

      else if(iflag.eq.3) then

*      Termination: The following MUST always be done
*      (i) Move to the correct PAW subdirectory
*
         call hcdir('//PAWC/'//xxxx,' ')

* write out number of accepted events to histos
         do iesType = 1, 4
            do iQbin = 1, 7
               if (Nevt(iesType,iQbin).gt.0.) then
                  call HzHinrm(iesType*10+iQbin,0,Nevt(iesType,iQbin),1)
               endif
               call HzHinfo(iesType*10+iQbin, Nevt(iesType,iQbin))
            enddo
         enddo

* get mean values and errors of event shape variables
         do iesType = 1, 4
            do iQbin = 1, 7
               if (Nevt(iesType,iQbin).le.0.) then
                  esMean(iesType,iQbin) = 0.
                  esMeanE(iesType,iQbin) = 0.
               else
                  esMean(iesType,iQbin) = Real(esSum(iesType,iQbin))
     .                 / Nevt(iesType,iQbin)
                  if (Nevt(iesType,iQbin).ge.2.) then
                     esMeanE(iesType,iQbin) =
     .                sqrt(  ( Real(esSqSum(iesType,iQbin)) -
     .                         Real(esSum(iesType,iQbin)**2)
     .                         / Nevt(iesType,iQbin) )
     .                  /((Nevt(iesType,iQbin)-1)*Nevt(iesType,iQbin)))
                  else
                     esMeanE(iesType,iQbin) = 0.
                     write(6,*)
     .                 'Hz'//xxxx,' only one event in Q-bin No.:',iQbin
                  endif
               endif
            enddo
         enddo

* histo for mean thrust Tz should contain <Tz/2>
         do iQbin = 1, 7
            esMean(2,iQbin) = esMean(2,iQbin)/2.
            esMeanE(2,iQbin) = esMeanE(2,iQbin)/2.
         enddo

* fill mean histos
* (3rd channel contains zeros)
         do iesType = 1, 4
            do ichn = 1, 2
               esMtmp(ichn) = esMean(iesType, ichn)
               esMEtmp(ichn) = esMeanE(iesType, ichn)
            enddo
            esMtmp(3) = 0.
            esMEtmp(3) = 0.
            do ichn = 4, 8
               esMtmp(ichn) = esMean(iesType, ichn-1)
               esMEtmp(ichn) = esMeanE(iesType, ichn-1)
            enddo
            call hpak(iesType*10, esMtmp)
            call hpake(iesType*10, esMEtmp)
         enddo

* get chi-squares and write them to n-tuple
         do iesType = 1, 4
            call HzChisq(-(iesType*10),iesType*10)
         enddo

         do iesType = 1, 4
            do iQbin = 1, 7
               call HzChisq(-(iesType*10+iQbin),iesType*10+iQbin)
            enddo
         enddo

* write out statistics
         if (lp) then
           write(6,*) 'Hz'//xxxx, 'statistics:'
           do iesType = 1, 4
             write(6,*) '----- for event shape variable', iesType
             do iQbin = 1, 7
                if (Nevt(iesType,iQbin).ne.0.) then
                   temp = (hicut(iesType,iQbin)+locut(iesType,iQbin))/
     .                     Nevt(iesType,iQbin)
                else
                   temp = 0.
                endif
                write(6,*) 'Qbin:',iQbin,'N accepted:',
     .                     Nevt(iesType,iQbin),
     .                     'N hicut:', hicut(iesType,iQbin),
     .                     'N locut:', locut(iesType,iQbin),
     .                     '(N hicut + N locut) / N total :', temp
             enddo
           enddo
         endif
      endif


      return

      end
*****************************************************************************







********************************************
* SUBROUTINES used by subroutine Hz97098 : *
********************************************


      subroutine H1means (id, chtitl, ncx, xbins, n, ae, ye)
*****************************************************************************
*     Subroutine H1means builds up 3 histos with H1 data:
*       Histo-ID = - id        for combined errors (ce)
*                = - (100+id)  for statist. errors (ae) only
*                = - (200+id)  for syst. errros (ye) only
*

      Implicit None

      Integer      id, ncx, i
      Real         n, ae, ye, xbins
      Real         ce(20)
      Character*80 chtitl
      Dimension xbins(ncx+1)
      Dimension n(ncx)
      Dimension ae(ncx)
      Dimension ye(ncx)

      do i = 1, ncx
         ce(i) = sqrt( ae(i)**2. + ye(i)**2. )
      enddo

      call hbookb(-id, chtitl, ncx, xbins, 0.)
      call hpak(-id, n)
      call hpake(-id, ce)

      call hbookb(-100-id, chtitl, ncx, xbins, 0.)
      call hpak(-100-id, n)
      call hpake(-100-id, ae)

      call hbookb(-200-id, chtitl, ncx, xbins, 0.)
      call hpak(-200-id, n)
      call hpake(-200-id, ye)

      end


      subroutine H1distr (id, chtitl, ncx, xlo, xhi, n, ce, ae, ye)
*****************************************************************************
*     Subroutine H1distr builds up 3 histos with H1 data:
*       Histo-ID = - id        for combined errors (ce)
*                = - (100+id)  for statist. errors (ae) only
*                = - (200+id)  for syst. errros (ye) only
*

      Implicit None

      Integer      id, ncx
      Real         xlo, xhi, n, ce, ae, ye
      Character*80 chtitl
      Dimension n(ncx)
      Dimension ce(ncx)
      Dimension ae(ncx)
      Dimension ye(ncx)

      call hbook1(-id, chtitl, ncx, xlo, xhi, 0.)
      call hpak(-id, n)
      call hpake(-id, ce)

      call hbook1(-100-id, chtitl, ncx, xlo, xhi, 0.)
      call hpak(-100-id, n)
      call hpake(-100-id, ae)

      call hbook1(-200-id, chtitl, ncx, xlo, xhi, 0.)
      call hpak(-200-id, n)
      call hpake(-200-id, ye)

      end


      subroutine MCdistr (id, chtitl, ncx, xlo, xhi, nQbin)
*****************************************************************************
*     Subroutine MCdistr prepares histos for Monte Carlo events:
*       # of booked histos = nQbin
*       Histo-ID = id + n , with n=1,...,nQbin
*

      Implicit None

      Integer      id, ncx, nQbin, iQbin
      Real         xlo, xhi
      Character*80 chtitl

      do iQbin = 1, nQbin
         call hbook1(id+iQbin, chtitl, ncx, xlo, xhi, 0.)
         call hbarx(id+iQbin)
      enddo

      end


      subroutine MCmeans (id, chtitl, ncx, xbins)
*****************************************************************************
*     Subroutine MCmeans prepares histo for generator events:
*

      Implicit None

      Integer      id, ncx
      Real         xbins
      Character*80 chtitl

      Dimension xbins(ncx+1)

      call hbookb(id, chtitl, ncx, xbins, 0.)
      call hbarx(id)

      end

* eof











*CMZ :  2.00/06 02/05/2002  14.23.52  by  Tancredi Carli
*-- Author :
* eof











*CMZ :  1.02/00 04/10/98  22.30.18  by  Tancredi Carli
*CMZ :  1.01/15 14/04/98  21.07.48  by  Tancredi Carli
*CMZ :  1.01/13 23/03/98  18.10.19  by  Tancredi Carli
*CMZ :  1.01/11 09/12/97  16.44.12  by  Tancredi Carli
*CMZ :  1.01/07 15/10/97  16.34.09  by  Tancredi Carli
*CMZ :  1.00/02 12/03/96  19.18.00  by  Tancredi Carli
*CMZ :  0.00/09 16/02/96  17.15.47  by  Tancredi Carli
*CMZ :  0.00/08 15/02/96  12.30.10  by  Tancredi Carli
*CMZ :  0.00/06 02/02/96  19.54.21  by  Tancredi Carli
*-- Author :  Dave Kant   01/07/97
      subroutine HZ97108(IFLAG)
****************************************************************************
* Purpose: produced histograms for:
*          the charged particle multiplicity versus Q
*          the mean and the width of the ln(1/xp) distribution vs Q
*
* Event selection:
* Eel>14, W2>4400, 0.05<y<0.6, rapidity gap events EXCLUDED
*
* Running:  HERA running 1994
* Reference:
* Arguments: iflag=1 initialisation
*            iflag=1 filling
*            iflag=3 termination
*
* written by: Dave Kant (d.kant@qmw.ac.uk) and based on HZ95072 written by
*             Tancredi Carli and Renate Mohr (carli@mail.desy.de
*                                             mohr@mail.desy.de  )
* Modified: April 98 angles were in radiant
*                    introduced *rd (???) Did it ever work ???
****************************************************************************
      IMPLICIT NONE
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      Integer iquest
      COMMON/QUEST/IQUEST(100)
*
      Integer iflag,ihep,i,j,k,l
*     DESY Preprint number
      Character*5 xxxx
*
      Real VMIN,VMAX
      integer nxpbin
      parameter (nxpbin=11)
      Integer ierr,ibeam,igam
      Double precision pbeam(4),pgam(4),pbrt(4),plab(4),ph(5)
      Integer limup,limlo
      Real xp,xpmean,xi
      Real par(3), step(3), pmin(3),pmax(3),sigpar(3),chi2
*
      Real pi,rd,ee,eb
      Logical evcut,lp
      Integer jcut,iel,idum,id,ibin,ivec
      Parameter (pi=3.1415927,rd=180./pi,ee=27.6)
      Integer nentry
      Real nev(nxpbin)
      Data lp/.false./,nentry/0/
      Real x,y,q2,w2,enel,efwd,th
      Real xmi,xma,ymi,yma
      Integer nx,ny,nwt,loc
      Character chtitl*80
*
      real sqrtq(nxpbin+1),q2aux(nxpbin+1)
      real peak(nxpbin),width(nxpbin),epeak(nxpbin),ewidth(nxpbin)
      real mult(nxpbin),emult(nxpbin)
      real q(nxpbin),qdata(nxpbin)
*
      real xp1(15),xp2(15),dxp1(15),dxp2(15)
      real xi1(40),xi2(40),dxi1(40),dxi2(40)
      real pn1(12),pn2(12),pn3(12),pn4(12),pn5(12),pn6(12)
      real dpn1(12),dpn2(12),dpn3(12),dpn4(12),dpn5(12),dpn6(12)
      real c1,c2,cos_thel,thel,coth,thq
      real pbreit(4),costheta_bf
      integer nlow,nhig,ntrk,id1,id2
      Real  nnum(6),n2num(3)
*
******************************************************************************
      Data xxxx/'97108'/
*.... data points from plots

       data q2aux/12.,15.,20.,40.,60.,80.,100.,175.,250.,
     +            450.,1000.,8000./
       data qdata/3.63,4.12,5.23,6.90,8.20,9.32,12.5,14.6,
     +            17.9,25.0,41.2/

       do i=1,nxpbin+1
        sqrtq(i)=sqrt(q2aux(i))
       enddo
*.... initialise event counters for normalisation in step 3
       data nev   /0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0./
       data nnum  /0.,0.,0.,0.,0.,0./
       data n2num /0.,0.,0./

*.... TOTAL CURRENT HEMISPHERE
       data peak  /1.52,1.53,1.72,1.84,1.97,2.04,2.26,2.43,
     +             2.51,2.77,3.02/
       data width /0.80,0.74,0.75,0.78,0.90,0.87,1.09,1.05,
     +             0.97,1.08,1.26/
       data mult  /1.18,1.38,1.62,2.19,2.59,3.16,3.65,4.13,
     +             4.05,5.23,7.32/
       data epeak /0.05,0.04,0.03,0.04,0.08,0.10,0.11,0.08,
     +             0.06,0.08,0.14/
       data ewidth/0.06,0.05,0.03,0.04,0.10,0.12,0.18,0.13,
     +             0.09,0.14,0.23/
       data emult /0.07,0.08,0.08,0.12,0.16,0.25,0.32,0.34,
     +             0.34,0.43,0.65/

*.... Figure 1(a) - 1/N dn/dxp
*.... distributions for 12<Q2<100 (xp1 and error dxp1) and
*     100<Q2<8000 (xp2 and dxp2) GeV2

       data xp1 /3.322,6.232,5.082,3.429,2.227,1.637,1.026,
     +           0.647,0.427,0.328,0.190,0.108,0.097,0.067,
     +           0.020/
       data xp2 /29.05,17.88,8.709,4.309,2.766,1.579,1.056,
     +           0.736,0.466,0.258,0.132,0.147,0.057,0.024,
     +           0.010/
       data dxp1/0.125,0.164,0.147,0.120,0.095,0.085,0.066,
     +           0.053,0.044,0.041,0.033,0.027,0.027,0.026,
     +           0.021/
       data dxp2/0.704,0.539,0.382,0.262,0.220,0.161,0.138,
     +           0.114,0.091,0.065,0.047,0.053,0.037,0.025,
     +           0.021/

*.... Figure 1(b) - 1/N dn/dln(1/xp)
*.... distributions for 12<Q2<100 (xi1 and error dxi1) and
*     100<Q2<8000 (xi2 and dxi2) GeV2

       data xi1 /0.000,0.000,0.000,0.003,0.021,0.050,0.104,
     +           0.222,0.339,0.482,0.632,0.730,0.800,0.864,
     +           0.819,0.738,0.654,0.489,0.425,0.280,0.209,
     +           0.145,0.119,0.093,0.050,0.026,0.000,0.000,
     +           0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     +           0.000,0.000,0.000,0.000,0.000/
       data dxi1/0.000,0.000,0.000,0.020,0.020,0.021,0.021,
     +           0.023,0.026,0.029,0.032,0.035,0.037,0.038,
     +           0.040,0.039,0.038,0.037,0.033,0.032,0.028,
     +           0.026,0.025,0.026,0.028,0.024,0.000,0.000,
     +           0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     +           0.000,0.000,0.000,0.000,0.000/
       data xi2 /0.000,0.000,0.000,0.001,0.005,0.020,0.102,
     +           0.215,0.367,0.448,0.719,0.918,0.988,1.369,
     +           1.505,1.635,1.590,1.893,1.697,1.696,1.357,
     +           1.509,1.252,0.787,0.765,0.425,0.335,0.306,
     +           0.168,0.122,0.061,0.055,0.014,0.013,0.000,
     +           0.000,0.000,0.000,0.000,0.000/
       data dxi2/0.000,0.000,0.000,0.020,0.020,0.020,0.022,
     +           0.030,0.040,0.050,0.054,0.066,0.075,0.074,
     +           0.091,0.093,0.097,0.094,0.104,0.097,0.099,
     +           0.089,0.096,0.086,0.069,0.067,0.052,0.047,
     +           0.050,0.039,0.037,0.030,0.030,0.025,0.000,
     +           0.000,0.000,0.000,0.000,0.000/


*.... Figure 8 - 1/N dN/dn
*     Pn spectra in the following Q2 and x bins
*     12<Q2<30 GeV2 and 6.E-4<x<2.E-3
       data pn1 /0.312,0.309,0.219,0.116,0.031,0.005,0.0012,
     +           0.000,0.000,0.000,0.000,0.000/
       data dpn1/0.025,0.016,0.027,0.009,0.005,0.001,0.0006,
     +           0.000,0.000,0.000,0.000,0.000/
*     12<Q2<30 GeV2 and 2.E-03<x<1.E-2
       data pn2 /0.246,0.281,0.233,0.133,0.055,0.030,0.0012,
     +           0.000,0.000,0.000,0.000,0.000/
       data dpn2/0.070,0.025,0.042,0.031,0.011,0.012,0.0020,
     +           0.000,0.000,0.000,0.000,0.000/
*     30<Q2<80 GeV2 and 6.E-4<x<2.E-3
       data pn3 /0.194,0.250,0.205,0.182,0.079,0.036,0.031,
     +           0.000,0.000,0.000,0.000,0.000/
       data dpn3/0.023,0.026,0.025,0.023,0.017,0.011,0.018,
     +           0.000,0.000,0.000,0.000,0.000/
*     30<Q2<80 GeV2 and 2.E-03<x<1.E-2
       data pn4 /0.150,0.195,0.229,0.199,0.116,0.049,0.023,
     +           0.007,0.003,0.000,0.000,0.000/
       data dpn4/0.031,0.013,0.025,0.020,0.026,0.012,0.006,
     +           0.004,0.003,0.000,0.000,0.000/
*     100<Q2<500 GeV2 and 2.E-3<x<1.E-2
       data pn5 /0.041,0.083,0.119,0.236,0.169,0.124,0.106,
     +           0.035,0.030,0.017,0.000,0.000/
       data dpn5/0.009,0.019,0.024,0.049,0.024,0.024,0.027,
     +           0.017,0.017,0.011,0.000,0.000/
*     100<Q2<500 GeV2 and 1.E-2<x<2.E-1
       data pn6 /0.020,0.052,0.093,0.171,0.184,0.151,0.135,
     +           0.075,0.048,0.021,0.018,0.007/
       data dpn6/0.011,0.014,0.018,0.031,0.026,0.032,0.029,
     +           0.026,0.022,0.010,0.013,0.005/

******************************************************************************
      NENTRY=NENTRY+1
*
      IF (iflag.eq.1) then
*
*      Initialisation: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (i) make subdirectory in o/p file
*
       Call hcdir('//PAWC',' ')
       call hmdir(xxxx,'S')
       Call hcdir('//HISTO',' ')
       call hmdir(xxxx,'S')
*
       Do i=1,nxpbin
        nev(i)=0.
       enddo
*
*      book your histograms  (data: ID<0)
*                                     (VZERO, VMIN, VMAX see CERNLIB F121)
*      non-equidistant binning
       call hbookb(-10,'Q vs ln(1/xp)peak ',nxpbin,sqrtq,0.)
       call hbookb(-20,'Q vs ln(1/xp)width',nxpbin,sqrtq,0.)
       call hbookb(-30,'Q vs nch          ',nxpbin,sqrtq,0.)
       call hbook1(-101,'x-ax peak/width',nxpbin,0.,real(nxpbin+1.),0.)
*
       call hbook1(-200,'1/N dn/dxp vs xp               Q2(12,100)  ',
     + 15,0.,1.,0.)
       call hbook1(-201,'1/N dn/dxp vs xp               Q2(100,8000)',
     + 15,0.,1.,0.)
       call hbook1(-300,'1/N dn/dln(1/xp) vs ln(1/xp)   Q2(12,100)  ',
     + 40,-1.,7.,0.)
       call hbook1(-301,'1/N dn/dln(1/xp) vs ln(1/xp)   Q2(100,8000)',
     + 40,-1.,7.,0.)

       call hbook1(-400,
     + '1/N dN/dn vs n     Q2(12,30) and xbj(6E-4,2E-3)',
     + 12,-0.5,11.5,0.)
       call hbook1(-401,
     + '1/N dN/dn vs n     Q2(12,30) and xbj(2E-3,1E-2)',
     + 12,-0.5,11.5,0.)
       call hbook1(-402,
     + '1/N dN/dn vs n     Q2(30,80) and xbj(6E-4,2E-3)',
     + 12,-0.5,11.5,0.)
       call hbook1(-403,
     + '1/N dN/dn vs n     Q2(30,80) and xbj(2E-3,1E-2)',
     + 12,-0.5,11.5,0.)
       call hbook1(-404,
     + '1/N dN/dn vs n   Q2(100,500) and xbj(2E-3,1E-2)',
     + 12,-0.5,11.5,0.)
       call hbook1(-405,
     + '1/N dN/dn vs n   Q2(100,500) and xbj(1E-2,2E-1)',
     + 12,-0.5,11.5,0.)

*
*      MC Histos
*
       call hbookb(10,'MC  Q vs ln(1/xp)peak ',nxpbin,sqrtq,0.)
       call hbookb(20,'MC  Q vs ln(1/xp)width',nxpbin,sqrtq,0.)
       call hbookb(30,'MC  Q vs nch          ',nxpbin,sqrtq,0.)
       call hbookb(31,'MC  Q vs nch aux      ',nxpbin,sqrtq,0.)

*      MC auxiliary histograms
       do ibin=1,nxpbin
        call hbook1(110+ibin,'MC  dn/dln(1/xp)',50,0.,7.,0.)
       enddo
*
       call hbook1(200,'MC 1/N dn/dxp vs xp               Q2(12,100)  ',
     + 15,0.,1.,0.)
       call hbook1(201,'MC 1/N dn/dxp vs xp               Q2(100,8000)',
     + 15,0.,1.,0.)
       call hbook1(300,'MC 1/N dn/dln(1/xp) vs ln(1/xp)   Q2(12,100)  ',
     + 40,-1.,7.,0.)
       call hbook1(301,'MC 1/N dn/dln(1/xp) vs ln(1/xp)   Q2(100,8000)',
     + 40,-1.,7.,0.)
*
       call hbook1(400,
     + 'MC 1/N dN/dn vs n     Q2(12,30) and xbj(6E-4,2E-3)',
     + 12,-0.5,11.5,0.)
       call hbook1(401,
     + 'MC 1/N dN/dn vs n     Q2(12,30) and xbj(2E-3,1E-2)',
     + 12,-0.5,11.5,0.)
       call hbook1(402,
     + 'MC 1/N dN/dn vs n     Q2(30,80) and xbj(6E-4,2E-3)',
     + 12,-0.5,11.5,0.)
       call hbook1(403,
     + 'MC 1/N dN/dn vs n     Q2(30,80) and xbj(2E-3,1E-2)',
     + 12,-0.5,11.5,0.)
       call hbook1(404,
     + 'MC 1/N dN/dn vs n   Q2(100,500) and xbj(2E-3,1E-2)',
     + 12,-0.5,11.5,0.)
       call hbook1(405,
     + 'MC 1/N dN/dn vs n   Q2(100,500) and xbj(1E-2,2E-1)',
     + 12,-0.5,11.5,0.)
*
       call hbook1(600,
     + 'MC 1/N dN/dn vs n   Q2(12,30) and xbj(6E-4,1E-2)',
     + 12,-0.5,11.5,0.)
       call hbook1(601,
     + 'MC 1/N dN/dn vs n   Q2(30,80) and xbj(6E-4,1E-2)',
     + 12,-0.5,11.5,0.)
       call hbook1(602,
     + 'MC 1/N dN/dn vs n   Q2(100,500) and xbj(1E-2,2E-1)',
     + 12,-0.5,11.5,0.)
*
       call hbook2(800,
     + 'E/Q vs COS Theta BF   Q2(12,100)',
     + 25,-1.1,0.1,25,-0.25,1.605,0.0)
       call hbook2(801,
     + 'E/Q vs COS Theta BF   Q2(100,8000)',
     + 25,-1.1,0.1,25,-0.25,1.605,0.0)
*********************************************************************
*
      Else if(iflag.eq.2) then
*      Filling: The following MUST always be done
*      (i) move to the correct sub-directory in PAWC
*
       call hcdir('//PAWC/'//xxxx,' ')
*
*      Event selection
*
       q2=real(HZDISKIN(1))
       x =real(HZDISKIN(2))
       y =real(HZDISKIN(3))
       w2=real(HZDISKIN(4))
*
       if (lp) write(6,*) 'Hz'//xxxx,
     & ' x= ',x,' q2 ',q2,' y= ',y,' w2= ',w2
*
*      get position of scattered electron, energy,Pt and polar angle
*
       iel=HZIDELEC(idum)
       if (iel.eq.-1) then
        write(6,*) 'Hz'//xxxx,' electron not found '
        return
       endif

*.... attributes of scattered electron
       enel     = real(PHEP(4,iel))
       cos_thel = real( PHEP(3,iel)/
     +            sqrt(PHEP(1,iel)**2+PHEP(2,iel)**2+PHEP(3,iel)**2))
            If (cos_thel.lt.-1.OR.cos_thel.gt.1.) then
             write (6,*) 'no electron angle could be calculated'
             return
            Endif
       thel     = acos(cos_thel)*rd  ! theta in degrees

*.... get beam properties
       ierr=HZIBEAM(ibeam,idum)
       if (.not.(ierr.eq.1)) then
        write(6,*) 'HZ'//xxxx,' beams not found ! '
        return
       else
        Do i=1,4
         pbeam(i)=PHEP(i,IBEAM)
        enddo
       endif
*
       eb=real(PHEP(4,idum))
       if (abs(abs(eb)-ee).gt.0.2) then
        if (nentry.lt.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,'  ! '
        elseif (nentry.eq.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &   ' ...last message ! '
        endif
C        return
       endif
*
*.... scattered quark angle
           coth= real( 1.-2.*y*eb/ (y*eb + Q2*(1.-y)/(4.*eb*y)) )
            If (coth.lt.-1.OR.coth.gt.1.) then
             write (6,*) 'no quark angle could be calculated'
             return
            Endif
           thq = acos(coth)*rd

*.... cut on forward energy
       efwd=0.
       Do 5 ihep=1,nhep
        if (isthep(ihep).ne.1.or.ihep.eq.iel) goto 5
        th=real(HZPHMANG(PHEP(3,ihep),
     &              sqrt(PHEP(1,ihep)**2+PHEP(2,ihep)**2)))*rd
        if(th.gt.4.4.and.th.lt.15.) then
         efwd=real(PHEP(4,ihep))+efwd
        endif
 5     continue

*
*      cut on kinematics
*
       evcut= ( ((thel.gt.157.).and.(thel.lt.172.5)).or.
     +          ((thel.gt.10. ).and.(thel.lt.150. )) )
       evcut= (thq.gt.10. ) .and. evcut
       evcut= (thq.lt.150.) .and. evcut
       evcut= (enel.gt.14.) .and. evcut
       evcut= (w2.ge.4400.) .and. evcut
       evcut= (y.lt.0.6   ) .and. evcut
       evcut= (y.gt.0.05  ) .and. evcut
       evcut= (efwd.gt.0.5) .and. evcut

       If (.not.(evcut)) then
        return
       Endif

       if (lp) write(6,*) 'Hz'//xxxx,
     &                         ' efwd= ',efwd,' evcut= ',evcut
*
*      set up Breit frame boost needed later
*
       ierr=HZIPGAM(ph)
       if (ierr.eq.-1) then
        write(6,*) 'HZ'//xxxx,' boson vector not found ! '
C        call VZERO(ph,5)
        Do i=1,5
         ph(i)=0.
        enddo
       else
        Do i=1,4
         pgam(i)=ph(i)
        enddo
       endif
*
       Call hzbrtini(pbeam,pgam,ierr)
       if (ierr.eq.1) then
        write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
        return
       endif
*
*      get bin number
*
       ibin=-1
       Do i=1,nxpbin+1
        if (lp) write(6,*) i,q2aux(i),' < ',q2,' < ',q2aux(i+1)
        if (q2.ge.q2aux(i).and.q2.lt.q2aux(i+1)) ibin=i
       enddo
       if (ibin.le.0) then
        if (lp) write(6,*) 'hz',xxxx,' q2 in no bin= ',q2
        return
       endif
*
*.... calculate E/Q and cos_theta_bf for all hadrons in the
*     current region of the breit frame

*.... initialise plab, and pbreit as these shall be used later
      do ivec=1,4
       costheta_bf  = 0.05
       pbreit(ivec) = 0.0
        plab(ivec)  = 0.0
      enddo

      do 60 ihep = 1, nhep
        If(isthep(ihep).eq.1.and.ihep.ne.iel) then
         do ivec=1,4
          plab(ivec) = phep(ivec,ihep)
         enddo
         Call hzbrt(plab,pbrt,ierr)
         if(real(pbrt(3)).lt.0.) then
          do ivec=1,4  ! vector sum
           pbreit(ivec) = pbreit(ivec) + real(pbrt(ivec))
          enddo
         endif
        Endif
 60     continue

*.... events with no energy in this hemisphere have no definable
*     direction. These events are not included in histograms 800
*     and 801.

       If (pbreit(4).gt.0) then
         costheta_bf = real(pbreit(3)/
     +sqrt(pbreit(1)**2+pbreit(2)**2+pbreit(3)**2))
        if (ibin.lt.7) then
         call hfill(800,real(costheta_bf),
     +real(pbreit(4)/sqrt(q2)),wtx)
        else
         call hfill(801,real(costheta_bf),
     +real(pbreit(4)/sqrt(q2)),wtx)
        endif
       Endif

*.... initialise plab
       do ivec=1,4
        plab(ivec) = 0.0
       enddo

*.... initialise number of tracks per event
       ntrk = 0
       do 30 ihep = 1, nhep
        If(isthep(ihep).eq.1.and.ihchrg(ihep).ne.0
     +     .and.ihep.ne.iel) then
C        idpart=abs(idhep(jmohep(1,ihep)))
C        If(idpart.eq.310.or.idpart.eq.3122) goto 30
         do ivec=1,4
          plab(ivec) = phep(ivec,ihep)
         enddo
         Call hzbrt(plab,pbrt,ierr)
         if(real(pbrt(3)).lt.0.) then
          xp = 2.*real(sqrt(pbrt(1)**2+pbrt(2)**2+pbrt(3)**2))
     +        /sqrt(q2)
          xi = log(1./xp)

          call hfill(110+ibin,log(1./xp),0.,wtx)
          call hfill(30   ,sqrt(q2),0.,wtx)

          if (ibin.lt.7) then  ! low q2 data set
           call hfill(200,xp,0.,wtx)
           call hfill(300,real(xi),0.,wtx)
          else                 ! high q2 data set
           call hfill(201,xp,0.,wtx)
           call hfill(301,real(xi),0.,wtx)
          endif

*.... number of charged tracks for this event
         ntrk = ntrk + 1
         endif
        Endif
 30     continue
*
        call hfill(31   ,sqrt(q2),0.,wtx)

*.... number of events in each bin
        nev(ibin)=nev(ibin)+wtx
*
*
*.... fill pn bins (n1,n2... are counters for normailisation)
        If ((q2.ge.12).and.(q2.lt.30)) then
          if ((x.gt.6.E-4).and.(x.lt.1.E-2)) then
           n2num(1) = n2num(1) + wtx
           call hfill(600,real(ntrk),0.,wtx)
          endif
          if ((x.gt.6.E-4).and.(x.lt.2.E-3)) then
            nnum(1) = nnum(1) + wtx
            call hfill(400,real(ntrk),0.,wtx)
          elseif ((x.ge.2.E-3).and.(x.lt.1.E-2))  then
            nnum(2) = nnum(2) + wtx
            call hfill(401,real(ntrk),0.,wtx)
          endif
        Endif
*
        If ((q2.ge.30).and.(q2.lt.80)) then
          if ((x.gt.2.E-3).and.(x.lt.1.E-2)) then
           n2num(2) = n2num(2) + wtx
           call hfill(601,real(ntrk),0.,wtx)
          endif
          if ((x.gt.6.E-4).and.(x.lt.2.E-3)) then
            nnum(3) = nnum(3) + wtx
            call hfill(402,real(ntrk),0.,wtx)
          elseif ((x.ge.2.E-3).and.(x.lt.1.E-2)) then
            nnum(4) = nnum(4) + wtx
            call hfill(403,real(ntrk),0.,wtx)
          endif
        Endif
*
        If ((q2.ge.100).and.(q2.lt.500)) then
          if ((x.gt.2.E-3).and.(x.lt.2.E-1)) then
           n2num(3) = n2num(3) + wtx
           call hfill(602,real(ntrk),0.,wtx)
          endif
          if ((x.gt.2.E-3).and.(x.lt.1.E-2)) then
            nnum(5) = nnum(5) + wtx
            call hfill(404,real(ntrk),0.,wtx)
          elseif ((x.ge.1.E-2).and.(x.lt.2.E-1)) then
            nnum(6) = nnum(6) + wtx
            call hfill(405,real(ntrk),0.,wtx)
          endif
        Endif
************************************************************************
*
      Else if(iflag.eq.3) then
*      Termination: The following MUST always be done
*      (i) Move to the correct PAW subdirectory
*
       call hcdir('//PAWC/'//xxxx,' ')
*
* Deal with data plots
*
       Call hpak (-10,peak)
       Call hpak (-20,width)
       Call hpak (-30,mult)
       Call hpake(-10,epeak)
       Call hpake(-20,ewidth)
       Call hpake(-30,emult)
       call hpak (-101,qdata)
*.... L(xp) distributions
       call hpak (-200,xp1)
       call hpake(-200,dxp1)
       call hpak (-201,xp2)
       call hpake(-201,dxp2)
*....D(ln(1/xp)) distributions
       call hpak (-300,xi1)
       call hpake(-300,dxi1)
       call hpak (-301,xi2)
       call hpake(-301,dxi2)
*.... pn distributions
       call hpak (-400,pn1)
       call hpake(-400,dpn1)
       call hpak (-401,pn2)
       call hpake(-401,dpn2)
       call hpak (-402,pn3)
       call hpake(-402,dpn3)
       call hpak (-403,pn4)
       call hpake(-403,dpn4)
       call hpak (-404,pn5)
       call hpake(-404,dpn5)
       call hpak (-405,pn6)
       call hpake(-405,dpn6)

*
*      normalise and fit data histograms
*
*.... get number of events in low and high q2 sample
       nlow = 0
       nhig = 0
       do i=1,nxpbin
        if (i.lt.7) then
         nlow = nev(i) + nlow
        else
         nhig = nev(i) + nhig
        endif
       enddo

*.... get normalisation factors (account for the bin width)
       c1 = (15/(1.-0.))/nlow
       c2 = (15/(1.-0.))/nhig
       call hopera(200,'+e',200,200,c1,0.0)
       call hopera(201,'+e',201,201,c2,0.0)

       c1 = (40/(7.- (-1.)))/nlow
       c2 = (40/(7.- (-1.)))/nhig
       call hopera(300,'+e',300,300,c1,0.0)
       call hopera(301,'+e',301,301,c2,0.0)

*.... normalise pn distributions
       id1=400
       Do i=1,6
         If (nnum(i).gt.0.) then
          call hopera(id1,'+e',id1,id1,1./nnum(i),0.0)
         Endif
        id1=id1+1
       Enddo

*.... normalise pn distributions
       id1=600
       Do i=1,3
         If (n2num(i).gt.0.) then
          call hopera(id1,'+e',id1,id1,1./n2num(i),0.0)
         Endif
        id1=id1+1
       Enddo
*
*.... calculated as a ratio of #charged tracks/#events
       Call hopera(30,'/e',31,30,1.,1.)
*
       do ibin=1,nxpbin
        id=110+ibin
        xpmean = hstati(id,1,' ',1)
        Call hgive(id,chtitl,nx,xmi,xma,ny,ymi,yma,nwt,loc)
        call hxi(id,xpmean+1.2,limup)
        call hxi(id,xpmean-1.2,limlo)
        iquest(11) = limlo
        iquest(12) = limup
        par(1)= hmax(id)
        par(2)= xpmean
        par(3)= hstati(id,2,' ',1)
C       write(6,*) ' limup= ',limup,' limlo= ',limlo
C       write(6,*) ' par= ',par
        Call hfithn(id,'G','NQR',3,par,step,pmin,pmax,sigpar,chi2)
*
        write(6,'(a,a,a,i4,3(a,f9.3))') 'Hz',xxxx,
     &  ' id= ',id,' mean= ',par(2),' sig= ',par(3),' chi2= ',chi2
*
        call hfill(10,sqrtq(ibin)+0.1,0.,wtx*par(2))
        call hfill(20,sqrtq(ibin)+0.1,0.,wtx*par(3))
        call hdelet(id)
       enddo
*
       call hdelet(31)
*
       call HZchisq(-10,20)
       call HZchisq(-20,20)
       call HZchisq(-30,30)
       call HZchisq(-201,201)
       call HZchisq(-200,200)
       call HZchisq(-301,301)
       call HZchisq(-300,300)
       call HZchisq(-401,401)
       call HZchisq(-401,401)
       call HZchisq(-402,402)
       call HZchisq(-403,403)
       call HZchisq(-404,404)
       call HZchisq(-405,405)
*
      Endif
*
      RETURN
      END
*CMZ :  1.02/06 04/02/99  11.14.45  by  Tancredi Carli
*CMZ :  1.01/15 02/09/98  13.51.38  by  Tancredi Carli
*-- Author :
      subroutine HZ97158(IFLAG)
****************************************************************************
* Purpose: calculate F2D3 (H1) 1994
*
* Event selection:
*
* Running:
*
* Arguments: iflag=1 initialisation
*            iflag=1 filling
*            iflag=3 termination
*
* written by:
****************************************************************************
      IMPLICIT NONE
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
* common that gives the position of particles in X and Y system
      integer nxobj,nyobj,nxgag,nygag
      double precision pom
      common /diffhad/pom(5),nxobj(5000),nyobj(5000),nxgag,nygag

      Integer numjet
      Parameter (numjet=50)
      Double precision pj(numjet,8)
      Double precision pbeam(4),pgam(4),pcm(4),ph(5),plab(5,NMXHEP)
      Double precision ptest(4)
*
      Integer i,iflag,ihep
      Character*5 xxxx
*
      Real pi,rd,eb,ee
      Parameter (ee=27.5)
      Integer iel,idum,ibeam
      Parameter (pi=3.1415927,rd=180./pi)
      real alph_em
      Parameter (alph_em=7.29927e-3)
      Real gev2nb
      Parameter (gev2nb=0.389e6)
      Integer nentry
      Real x,y,q2,enel,thel,efwd,th,lx,lxj
*
      Integer ierr
      Integer maxhi,modjet,maxjet
      Parameter (maxhi=1000,modjet=2,maxjet=30)
      Real  selj(maxjet,4),help,empz,empzh,xg,empzl,empzhl,xgl
      Integer ipjet(maxjet),l,k
      Real nev(maxhi),lum,xw,nev2(maxhi)
      Real deta,ptj2,thj
      Real xpom, x_pom,beta,xgluon,p_mx(4),mx2,mx,xmas,ymas,t
      Integer idhe,nhst
      Double precision rcone
      Parameter (rcone=1.)
      Logical lp,f2d3
      Data lp/.false./
*********************************************************************
      Integer nx
      Real n2,nall,nall2
      Real xmin,xmax
      save xxxx,nev,nall
      Data xxxx/'97158'/,NENTRY/0/
*   q2 =    4.500
*   beta =.040
      Real f2dq1b1(16),e2dq1b1(16),se2dq1b1(16)
      data f2dq1b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.02030,0.01820,
     +          0.00000,0.00910,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq1b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00420,0.00390,
     +          0.00000,0.00300,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq1b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00170,0.00170,
     +          0.00000,0.00170,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.100
      Real f2dq1b2(16),e2dq1b2(16),se2dq1b2(16)
      data f2dq1b2/0.00000,0.00000,0.00000,0.00000,
     +          0.01120,0.00000,0.01740,0.02590,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq1b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00440,0.00000,0.00550,0.00770,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq1b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00150,0.00000,0.00250,0.00380,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.200
      Real f2dq1b3(16),e2dq1b3(16),se2dq1b3(16)
      data f2dq1b3/0.00000,0.00000,0.00000,0.02380,
     +          0.02460,0.00000,0.01850,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq1b3/0.00000,0.00000,0.00000,0.00700,
     +          0.00680,0.00000,0.00630,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq1b3/0.00000,0.00000,0.00000,0.00220,
     +          0.00210,0.00000,0.00240,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.400
      Real f2dq1b4(16),e2dq1b4(16),se2dq1b4(16)
      data f2dq1b4/0.00000,0.00000,0.04330,0.03720,
     +          0.00000,0.02180,0.03350,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq1b4/0.00000,0.00000,0.01300,0.01100,
     +          0.00000,0.01070,0.01390,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq1b4/0.00000,0.00000,0.00330,0.00150,
     +          0.00000,0.00220,0.00390,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.650
      Real f2dq1b5(16),e2dq1b5(16),se2dq1b5(16)
      data f2dq1b5/0.00000,0.05660,0.03300,0.00000,
     +          0.04510,0.04230,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq1b5/0.00000,0.01590,0.01040,0.00000,
     +          0.01540,0.01750,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq1b5/0.00000,0.01120,0.00320,0.00000,
     +          0.00550,0.00490,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.900
      Real f2dq1b6(16),e2dq1b6(16),se2dq1b6(16)
      data f2dq1b6/0.00000,0.00000,0.06600,0.06780,
     +          0.00000,0.03140,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq1b6/0.00000,0.00000,0.02000,0.02420,
     +          0.00000,0.01770,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq1b6/0.00000,0.00000,0.01050,0.01090,
     +          0.00000,0.00440,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   q2 =    7.500
*   beta =.040
      Real f2dq2b1(16),e2dq2b1(16),se2dq2b1(16)
      data f2dq2b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.02010,
     +          0.01950,0.02150,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq2b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00530,
     +          0.00430,0.00460,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq2b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00110,
     +          0.00270,0.00390,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.100
      Real f2dq2b2(16),e2dq2b2(16),se2dq2b2(16)
      data f2dq2b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.02050,0.01950,0.01240,
     +          0.00000,0.02980,0.04900,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq2b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00710,0.00600,0.00420,
     +          0.00000,0.00740,0.01560,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq2b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00210,0.00190,0.00130,
     +          0.00000,0.00560,0.01010,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.200
      Real f2dq2b3(16),e2dq2b3(16),se2dq2b3(16)
      data f2dq2b3/0.00000,0.00000,0.00000,0.00000,
     +          0.02580,0.02100,0.01740,0.01700,
     +          0.00000,0.02220,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq2b3/0.00000,0.00000,0.00000,0.00000,
     +          0.00850,0.00650,0.00540,0.00500,
     +          0.00000,0.00650,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq2b3/0.00000,0.00000,0.00000,0.00000,
     +          0.00190,0.00230,0.00160,0.00210,
     +          0.00000,0.00340,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.400
      Real f2dq2b4(16),e2dq2b4(16),se2dq2b4(16)
      data f2dq2b4/0.00000,0.00000,0.00000,0.03540,
     +          0.02770,0.02660,0.01550,0.03940,
     +          0.00000,0.02310,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq2b4/0.00000,0.00000,0.00000,0.01230,
     +          0.01020,0.00920,0.00640,0.01100,
     +          0.00000,0.00830,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq2b4/0.00000,0.00000,0.00000,0.00280,
     +          0.00140,0.00260,0.00100,0.00480,
     +          0.00000,0.00360,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.650
      Real f2dq2b5(16),e2dq2b5(16),se2dq2b5(16)
      data f2dq2b5/0.00000,0.00000,0.07640,0.02530,
     +          0.03470,0.01960,0.00000,0.01460,
     +          0.02120,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq2b5/0.00000,0.00000,0.02210,0.00910,
     +          0.01200,0.00760,0.00000,0.00740,
     +          0.00820,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq2b5/0.00000,0.00000,0.01160,0.00260,
     +          0.00290,0.00240,0.00000,0.00250,
     +          0.00340,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.900
      Real f2dq2b6(16),e2dq2b6(16),se2dq2b6(16)
      data f2dq2b6/0.00000,0.00000,0.06380,0.00000,
     +          0.04340,0.03790,0.03650,0.02570,
     +          0.00000,0.02200,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq2b6/0.00000,0.00000,0.02090,0.00000,
     +          0.01580,0.01480,0.01770,0.01210,
     +          0.00000,0.01160,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq2b6/0.00000,0.00000,0.01220,0.00000,
     +          0.00630,0.00710,0.00620,0.00770,
     +          0.00000,0.00640,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   q2 =    9.000
*   beta =.040
      Real f2dq3b1(16),e2dq3b1(16),se2dq3b1(16)
      data f2dq3b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.02790,
     +          0.02110,0.03130,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq3b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00350,
     +          0.00260,0.00400,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq3b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00270,
     +          0.00200,0.00270,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.100
      Real f2dq3b2(16),e2dq3b2(16),se2dq3b2(16)
      data f2dq3b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.02520,0.03040,0.02610,
     +          0.02480,0.03170,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq3b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00350,0.00420,0.00390,
     +          0.00410,0.00570,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq3b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00190,0.00330,0.00300,
     +          0.00290,0.00340,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.200
      Real f2dq3b3(16),e2dq3b3(16),se2dq3b3(16)
      data f2dq3b3/0.00000,0.00000,0.00000,0.00000,
     +          0.02600,0.03540,0.02000,0.02570,
     +          0.02350,0.02700,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq3b3/0.00000,0.00000,0.00000,0.00000,
     +          0.00350,0.00410,0.00260,0.00340,
     +          0.00330,0.00460,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq3b3/0.00000,0.00000,0.00000,0.00000,
     +          0.00160,0.00220,0.00180,0.00150,
     +          0.00280,0.00300,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.400
      Real f2dq3b4(16),e2dq3b4(16),se2dq3b4(16)
      data f2dq3b4/0.00000,0.00000,0.00000,0.04560,
     +          0.04460,0.03750,0.02260,0.02220,
     +          0.03510,0.02470,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq3b4/0.00000,0.00000,0.00000,0.00640,
     +          0.00600,0.00530,0.00350,0.00440,
     +          0.00660,0.00610,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq3b4/0.00000,0.00000,0.00000,0.00290,
     +          0.00280,0.00290,0.00130,0.00140,
     +          0.00250,0.00320,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.650
      Real f2dq3b5(16),e2dq3b5(16),se2dq3b5(16)
      data f2dq3b5/0.00000,0.00000,0.04690,0.05110,
     +          0.03780,0.04450,0.02380,0.02220,
     +          0.01610,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq3b5/0.00000,0.00000,0.00720,0.00650,
     +          0.00540,0.00650,0.00470,0.00440,
     +          0.00440,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq3b5/0.00000,0.00000,0.00590,0.00570,
     +          0.00280,0.00510,0.00240,0.00290,
     +          0.00300,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.900
      Real f2dq3b6(16),e2dq3b6(16),se2dq3b6(16)
      data f2dq3b6/0.00000,0.00000,0.03460,0.00000,
     +          0.02460,0.00000,0.02770,0.00000,
     +          0.01060,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq3b6/0.00000,0.00000,0.00610,0.00000,
     +          0.00550,0.00000,0.00800,0.00000,
     +          0.00410,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq3b6/0.00000,0.00000,0.00340,0.00000,
     +          0.00300,0.00000,0.00310,0.00000,
     +          0.00120,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   q2 =   12.000
*   beta =.040
      Real f2dq4b1(16),e2dq4b1(16),se2dq4b1(16)
      data f2dq4b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.02810,
     +          0.02770,0.02840,0.04520,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq4b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00540,
     +          0.00340,0.00470,0.00560,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq4b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00500,
     +          0.00230,0.00280,0.00560,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.100
      Real f2dq4b2(16),e2dq4b2(16),se2dq4b2(16)
      data f2dq4b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.03080,0.02680,0.02560,
     +          0.02850,0.02980,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq4b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00610,0.00380,0.00330,
     +          0.00450,0.00440,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq4b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00280,0.00220,0.00170,
     +          0.00300,0.00330,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.200
      Real f2dq4b3(16),e2dq4b3(16),se2dq4b3(16)
      data f2dq4b3/0.00000,0.00000,0.00000,0.00000,
     +          0.02300,0.03510,0.02480,0.02390,
     +          0.03020,0.02220,0.04030,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq4b3/0.00000,0.00000,0.00000,0.00000,
     +          0.00420,0.00450,0.00310,0.00310,
     +          0.00410,0.00330,0.00680,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq4b3/0.00000,0.00000,0.00000,0.00000,
     +          0.00150,0.00300,0.00180,0.00150,
     +          0.00220,0.00220,0.00680,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.400
      Real f2dq4b4(16),e2dq4b4(16),se2dq4b4(16)
      data f2dq4b4/0.00000,0.00000,0.00000,0.03720,
     +          0.04780,0.03510,0.03540,0.02670,
     +          0.01860,0.02660,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq4b4/0.00000,0.00000,0.00000,0.00770,
     +          0.00600,0.00500,0.00490,0.00460,
     +          0.00340,0.00470,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq4b4/0.00000,0.00000,0.00000,0.00330,
     +          0.00390,0.00260,0.00250,0.00260,
     +          0.00180,0.00470,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.650
      Real f2dq4b5(16),e2dq4b5(16),se2dq4b5(16)
      data f2dq4b5/0.00000,0.00000,0.05850,0.05230,
     +          0.04420,0.04250,0.02840,0.02640,
     +          0.02690,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq4b5/0.00000,0.00000,0.01330,0.00720,
     +          0.00570,0.00610,0.00450,0.00440,
     +          0.00540,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq4b5/0.00000,0.00000,0.01000,0.00440,
     +          0.00450,0.00430,0.00230,0.00320,
     +          0.00280,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.900
      Real f2dq4b6(16),e2dq4b6(16),se2dq4b6(16)
      data f2dq4b6/0.00000,0.00000,0.03210,0.00000,
     +          0.03590,0.00000,0.01140,0.00000,
     +          0.01760,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq4b6/0.00000,0.00000,0.00640,0.00000,
     +          0.00750,0.00000,0.00330,0.00000,
     +          0.00500,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq4b6/0.00000,0.00000,0.00420,0.00000,
     +          0.00320,0.00000,0.00110,0.00000,
     +          0.00180,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   q2 =   18.000
*   beta =.040
      Real f2dq5b1(16),e2dq5b1(16),se2dq5b1(16)
      data f2dq5b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.03500,0.04080,0.05130,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq5b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00390,0.00390,0.00540,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq5b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00310,0.00300,0.00550,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.100
      Real f2dq5b2(16),e2dq5b2(16),se2dq5b2(16)
      data f2dq5b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.02860,0.03230,
     +          0.03090,0.04110,0.04290,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq5b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00410,0.00380,
     +          0.00380,0.00470,0.00660,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq5b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00240,0.00270,
     +          0.00330,0.00430,0.00700,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.200
      Real f2dq5b3(16),e2dq5b3(16),se2dq5b3(16)
      data f2dq5b3/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.03440,0.02560,0.02610,
     +          0.02510,0.02570,0.04330,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq5b3/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00420,0.00300,0.00300,
     +          0.00280,0.00290,0.00650,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq5b3/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00210,0.00150,0.00180,
     +          0.00270,0.00220,0.00490,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.400
      Real f2dq5b4(16),e2dq5b4(16),se2dq5b4(16)
      data f2dq5b4/0.00000,0.00000,0.00000,0.00000,
     +          0.03820,0.03910,0.04050,0.02750,
     +          0.03280,0.03120,0.02580,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq5b4/0.00000,0.00000,0.00000,0.00000,
     +          0.00550,0.00510,0.00500,0.00370,
     +          0.00450,0.00420,0.00490,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq5b4/0.00000,0.00000,0.00000,0.00000,
     +          0.00200,0.00300,0.00270,0.00190,
     +          0.00280,0.00290,0.00630,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.650
      Real f2dq5b5(16),e2dq5b5(16),se2dq5b5(16)
      data f2dq5b5/0.00000,0.00000,0.00000,0.05430,
     +          0.04970,0.03600,0.04390,0.02720,
     +          0.02510,0.01960,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq5b5/0.00000,0.00000,0.00000,0.00740,
     +          0.00640,0.00460,0.00560,0.00380,
     +          0.00380,0.00440,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq5b5/0.00000,0.00000,0.00000,0.00510,
     +          0.00370,0.00280,0.00380,0.00260,
     +          0.00250,0.00320,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.900
      Real f2dq5b6(16),e2dq5b6(16),se2dq5b6(16)
      data f2dq5b6/0.00000,0.00000,0.00000,0.00000,
     +          0.03700,0.00000,0.02050,0.00000,
     +          0.01800,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq5b6/0.00000,0.00000,0.00000,0.00000,
     +          0.00650,0.00000,0.00440,0.00000,
     +          0.00620,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq5b6/0.00000,0.00000,0.00000,0.00000,
     +          0.00370,0.00000,0.00140,0.00000,
     +          0.00160,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   q2 =   28.000
*   beta =.040
      Real f2dq6b1(16),e2dq6b1(16),se2dq6b1(16)
      data f2dq6b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.04760,0.04070,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq6b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00500,0.00510,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq6b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00480,0.00560,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.100
      Real f2dq6b2(16),e2dq6b2(16),se2dq6b2(16)
      data f2dq6b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.04160,
     +          0.03880,0.04140,0.03470,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq6b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00600,
     +          0.00560,0.00580,0.00640,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq6b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00440,
     +          0.00340,0.00340,0.00720,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.200
      Real f2dq6b3(16),e2dq6b3(16),se2dq6b3(16)
      data f2dq6b3/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.03850,0.03030,
     +          0.03060,0.03540,0.04340,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq6b3/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00520,0.00390,
     +          0.00390,0.00450,0.00960,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq6b3/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00230,0.00220,
     +          0.00210,0.00300,0.00430,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.400
      Real f2dq6b4(16),e2dq6b4(16),se2dq6b4(16)
      data f2dq6b4/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.04760,0.04350,0.03370,
     +          0.04010,0.03310,0.04700,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq6b4/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00740,0.00630,0.00500,
     +          0.00570,0.00530,0.00780,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq6b4/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00370,0.00250,0.00290,
     +          0.00280,0.00420,0.00580,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.650
      Real f2dq6b5(16),e2dq6b5(16),se2dq6b5(16)
      data f2dq6b5/0.00000,0.00000,0.00000,0.00000,
     +          0.05390,0.04510,0.03350,0.02360,
     +          0.03410,0.02170,0.02230,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq6b5/0.00000,0.00000,0.00000,0.00000,
     +          0.00840,0.00660,0.00530,0.00410,
     +          0.00540,0.00420,0.00630,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq6b5/0.00000,0.00000,0.00000,0.00000,
     +          0.00430,0.00350,0.00320,0.00180,
     +          0.00260,0.00240,0.00420,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.900
      Real f2dq6b6(16),e2dq6b6(16),se2dq6b6(16)
      data f2dq6b6/0.00000,0.00000,0.00000,0.00000,
     +          0.03210,0.00000,0.02600,0.00000,
     +          0.01400,0.00000,0.01290,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq6b6/0.00000,0.00000,0.00000,0.00000,
     +          0.00720,0.00000,0.00650,0.00000,
     +          0.00500,0.00000,0.00710,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq6b6/0.00000,0.00000,0.00000,0.00000,
     +          0.00420,0.00000,0.00170,0.00000,
     +          0.00130,0.00000,0.00200,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   q2 =   45.000
*   beta =.040
      Real f2dq7b1(16),e2dq7b1(16),se2dq7b1(16)
      data f2dq7b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.05850,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq7b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00810,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq7b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00780,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.100
      Real f2dq7b2(16),e2dq7b2(16),se2dq7b2(16)
      data f2dq7b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.03840,0.03280,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq7b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00660,0.00610,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq7b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00300,0.00430,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.200
      Real f2dq7b3(16),e2dq7b3(16),se2dq7b3(16)
      data f2dq7b3/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.02680,
     +          0.04060,0.03020,0.03100,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq7b3/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00490,
     +          0.00610,0.00490,0.00570,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq7b3/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00230,
     +          0.00260,0.00260,0.00270,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.400
      Real f2dq7b4(16),e2dq7b4(16),se2dq7b4(16)
      data f2dq7b4/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.03470,0.03870,
     +          0.02150,0.02730,0.03280,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq7b4/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00720,0.00700,
     +          0.00460,0.00530,0.00670,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq7b4/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00240,0.00210,
     +          0.00160,0.00270,0.00430,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.650
      Real f2dq7b5(16),e2dq7b5(16),se2dq7b5(16)
      data f2dq7b5/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.04180,0.02620,0.02940,
     +          0.02400,0.01990,0.02200,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq7b5/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00810,0.00580,0.00610,
     +          0.00540,0.00450,0.00600,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq7b5/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00270,0.00130,0.00280,
     +          0.00260,0.00160,0.00250,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.900
      Real f2dq7b6(16),e2dq7b6(16),se2dq7b6(16)
      data f2dq7b6/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.02040,0.00000,
     +          0.02010,0.00000,0.00310,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq7b6/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00720,0.00000,
     +          0.00780,0.00000,0.00320,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq7b6/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00130,0.00000,
     +          0.00150,0.00000,0.00040,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   q2 =   75.000
*   beta =.040
      Real f2dq8b1(16),e2dq8b1(16),se2dq8b1(16)
      data f2dq8b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq8b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq8b1/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.100
      Real f2dq8b2(16),e2dq8b2(16),se2dq8b2(16)
      data f2dq8b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.04530,0.06100,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq8b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00900,0.01370,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq8b2/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00470,0.00880,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.200
      Real f2dq8b3(16),e2dq8b3(16),se2dq8b3(16)
      data f2dq8b3/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.03410,0.04070,0.03120,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq8b3/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00730,0.00710,0.00730,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq8b3/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00000,
     +          0.00370,0.00350,0.00320,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.400
      Real f2dq8b4(16),e2dq8b4(16),se2dq8b4(16)
      data f2dq8b4/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.04440,
     +          0.04050,0.02360,0.03180,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq8b4/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.01200,
     +          0.00960,0.00630,0.00800,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq8b4/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00000,0.00290,
     +          0.00370,0.00200,0.00310,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.650
      Real f2dq8b5(16),e2dq8b5(16),se2dq8b5(16)
      data f2dq8b5/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.02240,0.02430,
     +          0.03140,0.02120,0.02520,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq8b5/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00750,0.00720,
     +          0.00790,0.00560,0.00830,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq8b5/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00160,0.00180,
     +          0.00270,0.00250,0.00260,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
*   beta =.900
      Real f2dq8b6(16),e2dq8b6(16),se2dq8b6(16)
      data f2dq8b6/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.02340,0.00000,
     +          0.01450,0.00000,0.00930,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data e2dq8b6/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.01040,0.00000,
     +          0.00820,0.00000,0.00620,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/
      data se2dq8b6/0.00000,0.00000,0.00000,0.00000,
     +          0.00000,0.00000,0.00200,0.00000,
     +          0.00190,0.00000,0.00110,0.00000,
     +          0.00000,0.00000,0.00000,0.00000/


      Real xpombw(17)
      data xpombw/8.3e-5,1.5e-4,2.63e-4,4.7e-4,
     +            8.3e-4,1.5e-3,2.63e-3,4.7e-3,
     +            8.3e-3,1.5e-2,2.63e-2,4.7e-2,
     +            8.3e-2,1.5e-1,2.63e-1,4.7e-1,
     +            8.3e-1/
      Real xpo(16)
      data xpo/1.2e-4,2.07e-4,3.67e-4,6.5e-4,
     +         1.2e-3,2.07e-3,3.67e-3,6.5e-3,
     +         1.2e-2,2.07e-2,3.67e-2,6.5e-2,
     +         1.2e-1,2.07e-1,3.67e-1,6.5e-1/
      Integer npomb
      Parameter (npomb=16)
      Real conten(npomb),contene(npomb)
      Real fact
      Real q2bin(9)
      data q2bin/3.53,5.61,7.94,10.59,14.125,22.39,35.48,56.23,89.12/
      Real q2binw(8)
      Integer nq2
      Parameter (nq2=8)
      Real q2b(8)
      data q2b/4.5,7.5,9.,12.,18.,28.,45.,75./
      Real betab(7)
      data betab/0.023,0.07,0.14,0.3,0.5,0.8,1.0/
      Real betabw(6)
      Real bet(6)
      data bet/0.04,0.1,0.2,0.4,0.65,0.9/
      Integer nbet
      Parameter (nbet=6)
      Integer ibeta,iq2,ihisto,idhisto,i1,i2,I3
*
*********************************************************************
*
*                      Initialization
*
*********************************************************************
      NENTRY=NENTRY+1
*
      IF (iflag.eq.1) then
*
         nall=0.
         nall2=0.
         n2=0.
         call Vzero(nev,maxhi)
         call Vzero(nev2,maxhi)
*
*
* Initialisation: The following MUST always be done
* (i) make subdirectory in PAWC
* - use the name as the xxxxxx in HZxxxxxx subroutine
* (i) make subdirectory in o/p file
*
         Call hcdir('//PAWC',' ')
         call hmdir(xxxx,'S')
         Call hcdir('//HISTO',' ')
         call hmdir(xxxx,'S')
*
* book histos
*
         nx=6
         xmin=0.05e-2
         xmax=0.35e-02
         do i=1,nbet
            betabw(i)=betab(i+1)-betab(i)
         enddo
         do i=1,nq2
            q2binw(i)=q2bin(i+1)-q2bin(i)
         enddo
*
         call hbook1(221,'  y     ',100,0.,1.,0.)
         call hbook1(222,'  Q2     ',100,0.,100.,0.)
         call hbook1(223,'  xpom    ',100,0.,0.1,0.)
         call hbook1(224,'  beta    ',100,0.,1.,0.)
         call hbook1(225,'  M_x  0-20  ',100,0.,20.,0.)
         call hbook1(226,'  M_x  0-100  ',100,0.,100.,0.)
* histos for q2=4.5
         call hbookb(11,'  f2d3 q2=4.5 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(12,'  f2d3 q2=4.5 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(13,'  f2d3 q2=4.5 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(14,'  f2d3 q2=4.5 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(15,'  f2d3 q2=4.5 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(16,'  f2d3 q2=4.5 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=7.5
         call hbookb(21,'  f2d3 q2=7.5 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(22,'  f2d3 q2=7.5 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(23,'  f2d3 q2=7.5 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(24,'  f2d3 q2=7.5 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(25,'  f2d3 q2=7.5 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(26,'  f2d3 q2=7.5 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=9.0
         call hbookb(31,'  f2d3 q2=9 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(32,'  f2d3 q2=9 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(33,'  f2d3 q2=9 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(34,'  f2d3 q2=9 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(35,'  f2d3 q2=9 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(36,'  f2d3 q2=9 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=12.0
         call hbookb(41,'  f2d3 q2=12 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(42,'  f2d3 q2=12 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(43,'  f2d3 q2=12 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(44,'  f2d3 q2=12 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(45,'  f2d3 q2=12 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(46,'  f2d3 q2=12 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=18.0
         call hbookb(51,'  f2d3 q2=18 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(52,'  f2d3 q2=18 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(53,'  f2d3 q2=18 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(54,'  f2d3 q2=18 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(55,'  f2d3 q2=18 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(56,'  f2d3 q2=18 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=28.0
         call hbookb(61,'  f2d3 q2=28 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(62,'  f2d3 q2=28 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(63,'  f2d3 q2=28 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(64,'  f2d3 q2=28 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(65,'  f2d3 q2=28 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(66,'  f2d3 q2=28 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=45.0
         call hbookb(71,'  f2d3 q2=45 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(72,'  f2d3 q2=45 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(73,'  f2d3 q2=45 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(74,'  f2d3 q2=45 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(75,'  f2d3 q2=45 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(76,'  f2d3 q2=45 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=75.0
         call hbookb(81,'  f2d3 q2=75 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(82,'  f2d3 q2=75 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(83,'  f2d3 q2=75 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(84,'  f2d3 q2=75 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(85,'  f2d3 q2=75 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(86,'  f2d3 q2=75 beta=0.9 ',npomb, xpombw,0.)
*now the data histos with stat errors
* histos for q2=4.5
         call hbookb(-11,'  f2d3 q2=4.5 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(-12,'  f2d3 q2=4.5 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(-13,'  f2d3 q2=4.5 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(-14,'  f2d3 q2=4.5 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(-15,'  f2d3 q2=4.5 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(-16,'  f2d3 q2=4.5 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=7.5
         call hbookb(-21,'  f2d3 q2=7.5 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(-22,'  f2d3 q2=7.5 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(-23,'  f2d3 q2=7.5 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(-24,'  f2d3 q2=7.5 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(-25,'  f2d3 q2=7.5 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(-26,'  f2d3 q2=7.5 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=9.0
         call hbookb(-31,'  f2d3 q2=9 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(-32,'  f2d3 q2=9 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(-33,'  f2d3 q2=9 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(-34,'  f2d3 q2=9 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(-35,'  f2d3 q2=9 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(-36,'  f2d3 q2=9 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=12.0
         call hbookb(-41,'  f2d3 q2=12 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(-42,'  f2d3 q2=12 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(-43,'  f2d3 q2=12 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(-44,'  f2d3 q2=12 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(-45,'  f2d3 q2=12 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(-46,'  f2d3 q2=12 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=18.0
         call hbookb(-51,'  f2d3 q2=18 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(-52,'  f2d3 q2=18 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(-53,'  f2d3 q2=18 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(-54,'  f2d3 q2=18 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(-55,'  f2d3 q2=18 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(-56,'  f2d3 q2=18 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=28.0
         call hbookb(-61,'  f2d3 q2=28 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(-62,'  f2d3 q2=28 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(-63,'  f2d3 q2=28 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(-64,'  f2d3 q2=28 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(-65,'  f2d3 q2=28 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(-66,'  f2d3 q2=28 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=45.0
         call hbookb(-71,'  f2d3 q2=45 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(-72,'  f2d3 q2=45 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(-73,'  f2d3 q2=45 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(-74,'  f2d3 q2=45 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(-75,'  f2d3 q2=45 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(-76,'  f2d3 q2=45 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=75.0
         call hbookb(-81,'  f2d3 q2=75 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(-82,'  f2d3 q2=75 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(-83,'  f2d3 q2=75 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(-84,'  f2d3 q2=75 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(-85,'  f2d3 q2=75 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(-86,'  f2d3 q2=75 beta=0.9 ',npomb, xpombw,0.)
*now the data histos with syst errors
* histos for q2=4.5
         call hbookb(-111,'  f2d3 q2=4.5 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(-112,'  f2d3 q2=4.5 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(-113,'  f2d3 q2=4.5 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(-114,'  f2d3 q2=4.5 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(-115,'  f2d3 q2=4.5 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(-116,'  f2d3 q2=4.5 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=7.5
         call hbookb(-121,'  f2d3 q2=7.5 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(-122,'  f2d3 q2=7.5 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(-123,'  f2d3 q2=7.5 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(-124,'  f2d3 q2=7.5 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(-125,'  f2d3 q2=7.5 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(-126,'  f2d3 q2=7.5 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=9.0
         call hbookb(-131,'  f2d3 q2=9 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(-132,'  f2d3 q2=9 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(-133,'  f2d3 q2=9 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(-134,'  f2d3 q2=9 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(-135,'  f2d3 q2=9 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(-136,'  f2d3 q2=9 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=12.0
         call hbookb(-141,'  f2d3 q2=12 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(-142,'  f2d3 q2=12 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(-143,'  f2d3 q2=12 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(-144,'  f2d3 q2=12 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(-145,'  f2d3 q2=12 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(-146,'  f2d3 q2=12 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=18.0
         call hbookb(-151,'  f2d3 q2=18 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(-152,'  f2d3 q2=18 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(-153,'  f2d3 q2=18 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(-154,'  f2d3 q2=18 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(-155,'  f2d3 q2=18 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(-156,'  f2d3 q2=18 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=28.0
         call hbookb(-161,'  f2d3 q2=28 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(-162,'  f2d3 q2=28 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(-163,'  f2d3 q2=28 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(-164,'  f2d3 q2=28 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(-165,'  f2d3 q2=28 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(-166,'  f2d3 q2=28 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=45.0
         call hbookb(-171,'  f2d3 q2=45 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(-172,'  f2d3 q2=45 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(-173,'  f2d3 q2=45 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(-174,'  f2d3 q2=45 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(-175,'  f2d3 q2=45 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(-176,'  f2d3 q2=45 beta=0.9 ',npomb, xpombw,0.)
* histos for q2=75.0
         call hbookb(-181,'  f2d3 q2=75 beta=0.04 ',npomb, xpombw,0.)
         call hbookb(-182,'  f2d3 q2=75 beta=0.1 ',npomb, xpombw,0.)
         call hbookb(-183,'  f2d3 q2=75 beta=0.2 ',npomb, xpombw,0.)
         call hbookb(-184,'  f2d3 q2=75 beta=0.4 ',npomb, xpombw,0.)
         call hbookb(-185,'  f2d3 q2=75 beta=0.65 ',npomb, xpombw,0.)
         call hbookb(-186,'  f2d3 q2=75 beta=0.9 ',npomb, xpombw,0.)


*
* pack data into histograms (stat error)
*
         Call hpak (-11,f2dq1b1)
         Call hpake(-11,e2dq1b1)
         Call hpak (-12,f2dq1b2)
         Call hpake(-12,e2dq1b2)
         Call hpak (-13,f2dq1b3)
         Call hpake(-13,e2dq1b3)
         Call hpak (-14,f2dq1b4)
         Call hpake(-14,e2dq1b4)
         Call hpak (-15,f2dq1b5)
         Call hpake(-15,e2dq1b5)
         Call hpak (-16,f2dq1b6)
         Call hpake(-16,e2dq1b6)
*
         Call hpak (-21,f2dq2b1)
         Call hpake(-21,e2dq2b1)
         Call hpak (-22,f2dq2b2)
         Call hpake(-22,e2dq2b2)
         Call hpak (-23,f2dq2b3)
         Call hpake(-23,e2dq2b3)
         Call hpak (-24,f2dq2b4)
         Call hpake(-24,e2dq2b4)
         Call hpak (-25,f2dq2b5)
         Call hpake(-25,e2dq2b5)
         Call hpak (-26,f2dq2b6)
         Call hpake(-26,e2dq2b6)
*
         Call hpak (-31,f2dq3b1)
         Call hpake(-31,e2dq3b1)
         Call hpak (-32,f2dq3b2)
         Call hpake(-32,e2dq3b2)
         Call hpak (-33,f2dq3b3)
         Call hpake(-33,e2dq3b3)
         Call hpak (-34,f2dq3b4)
         Call hpake(-34,e2dq3b4)
         Call hpak (-35,f2dq3b5)
         Call hpake(-35,e2dq3b5)
         Call hpak (-36,f2dq3b6)
         Call hpake(-36,e2dq3b6)
*
         Call hpak (-41,f2dq4b1)
         Call hpake(-41,e2dq4b1)
         Call hpak (-42,f2dq4b2)
         Call hpake(-42,e2dq4b2)
         Call hpak (-43,f2dq4b3)
         Call hpake(-43,e2dq4b3)
         Call hpak (-44,f2dq4b4)
         Call hpake(-44,e2dq4b4)
         Call hpak (-45,f2dq4b5)
         Call hpake(-45,e2dq4b5)
         Call hpak (-46,f2dq4b6)
         Call hpake(-46,e2dq4b6)
*
         Call hpak (-51,f2dq5b1)
         Call hpake(-51,e2dq5b1)
         Call hpak (-52,f2dq5b2)
         Call hpake(-52,e2dq5b2)
         Call hpak (-53,f2dq5b3)
         Call hpake(-53,e2dq5b3)
         Call hpak (-54,f2dq5b4)
         Call hpake(-54,e2dq5b4)
         Call hpak (-55,f2dq5b5)
         Call hpake(-55,e2dq5b5)
         Call hpak (-56,f2dq5b6)
         Call hpake(-56,e2dq5b6)
*
         Call hpak (-61,f2dq6b1)
         Call hpake(-61,e2dq6b1)
         Call hpak (-62,f2dq6b2)
         Call hpake(-62,e2dq6b2)
         Call hpak (-63,f2dq6b3)
         Call hpake(-63,e2dq6b3)
         Call hpak (-64,f2dq6b4)
         Call hpake(-64,e2dq6b4)
         Call hpak (-65,f2dq6b5)
         Call hpake(-65,e2dq6b5)
         Call hpak (-66,f2dq6b6)
         Call hpake(-66,e2dq6b6)
*
         Call hpak (-71,f2dq7b1)
         Call hpake(-71,e2dq7b1)
         Call hpak (-72,f2dq7b2)
         Call hpake(-72,e2dq7b2)
         Call hpak (-73,f2dq7b3)
         Call hpake(-73,e2dq7b3)
         Call hpak (-74,f2dq7b4)
         Call hpake(-74,e2dq7b4)
         Call hpak (-75,f2dq7b5)
         Call hpake(-75,e2dq7b5)
         Call hpak (-76,f2dq7b6)
         Call hpake(-76,e2dq7b6)
*
         Call hpak (-81,f2dq8b1)
         Call hpake(-81,e2dq8b1)
         Call hpak (-82,f2dq8b2)
         Call hpake(-82,e2dq8b2)
         Call hpak (-83,f2dq8b3)
         Call hpake(-83,e2dq8b3)
         Call hpak (-84,f2dq8b4)
         Call hpake(-84,e2dq8b4)
         Call hpak (-85,f2dq8b5)
         Call hpake(-85,e2dq8b5)
         Call hpak (-86,f2dq8b6)
         Call hpake(-86,e2dq8b6)
* now syst error
         Call hpak (-111,f2dq1b1)
         Call hpake(-111,se2dq1b1)
         Call hpak (-112,f2dq1b2)
         Call hpake(-112,se2dq1b2)
         Call hpak (-113,f2dq1b3)
         Call hpake(-113,se2dq1b3)
         Call hpak (-114,f2dq1b4)
         Call hpake(-114,se2dq1b4)
         Call hpak (-115,f2dq1b5)
         Call hpake(-115,se2dq1b5)
         Call hpak (-116,f2dq1b6)
         Call hpake(-116,se2dq1b6)
*
         Call hpak (-121,f2dq2b1)
         Call hpake(-121,se2dq2b1)
         Call hpak (-122,f2dq2b2)
         Call hpake(-122,se2dq2b2)
         Call hpak (-123,f2dq2b3)
         Call hpake(-123,se2dq2b3)
         Call hpak (-124,f2dq2b4)
         Call hpake(-124,se2dq2b4)
         Call hpak (-125,f2dq2b5)
         Call hpake(-125,se2dq2b5)
         Call hpak (-126,f2dq2b6)
         Call hpake(-126,se2dq2b6)
*
         Call hpak (-131,f2dq3b1)
         Call hpake(-131,se2dq3b1)
         Call hpak (-132,f2dq3b2)
         Call hpake(-132,se2dq3b2)
         Call hpak (-133,f2dq3b3)
         Call hpake(-133,se2dq3b3)
         Call hpak (-134,f2dq3b4)
         Call hpake(-134,se2dq3b4)
         Call hpak (-135,f2dq3b5)
         Call hpake(-135,se2dq3b5)
         Call hpak (-136,f2dq3b6)
         Call hpake(-136,se2dq3b6)
*
         Call hpak (-141,f2dq4b1)
         Call hpake(-141,se2dq4b1)
         Call hpak (-142,f2dq4b2)
         Call hpake(-142,se2dq4b2)
         Call hpak (-143,f2dq4b3)
         Call hpake(-143,se2dq4b3)
         Call hpak (-144,f2dq4b4)
         Call hpake(-144,se2dq4b4)
         Call hpak (-145,f2dq4b5)
         Call hpake(-145,se2dq4b5)
         Call hpak (-146,f2dq4b6)
         Call hpake(-146,se2dq4b6)
*
         Call hpak (-151,f2dq5b1)
         Call hpake(-151,se2dq5b1)
         Call hpak (-152,f2dq5b2)
         Call hpake(-152,se2dq5b2)
         Call hpak (-153,f2dq5b3)
         Call hpake(-153,se2dq5b3)
         Call hpak (-154,f2dq5b4)
         Call hpake(-154,se2dq5b4)
         Call hpak (-155,f2dq5b5)
         Call hpake(-155,se2dq5b5)
         Call hpak (-156,f2dq5b6)
         Call hpake(-156,se2dq5b6)
*
         Call hpak (-161,f2dq6b1)
         Call hpake(-161,se2dq6b1)
         Call hpak (-162,f2dq6b2)
         Call hpake(-162,se2dq6b2)
         Call hpak (-163,f2dq6b3)
         Call hpake(-163,se2dq6b3)
         Call hpak (-164,f2dq6b4)
         Call hpake(-164,se2dq6b4)
         Call hpak (-165,f2dq6b5)
         Call hpake(-165,se2dq6b5)
         Call hpak (-166,f2dq6b6)
         Call hpake(-166,se2dq6b6)
*
         Call hpak (-171,f2dq7b1)
         Call hpake(-171,se2dq7b1)
         Call hpak (-172,f2dq7b2)
         Call hpake(-172,se2dq7b2)
         Call hpak (-173,f2dq7b3)
         Call hpake(-173,se2dq7b3)
         Call hpak (-174,f2dq7b4)
         Call hpake(-174,se2dq7b4)
         Call hpak (-175,f2dq7b5)
         Call hpake(-175,se2dq7b5)
         Call hpak (-176,f2dq7b6)
         Call hpake(-176,se2dq7b6)
*
         Call hpak (-181,f2dq8b1)
         Call hpake(-181,se2dq8b1)
         Call hpak (-182,f2dq8b2)
         Call hpake(-182,se2dq8b2)
         Call hpak (-183,f2dq8b3)
         Call hpake(-183,se2dq8b3)
         Call hpak (-184,f2dq8b4)
         Call hpake(-184,se2dq8b4)
         Call hpak (-185,f2dq8b5)
         Call hpake(-185,se2dq8b5)
         Call hpak (-186,f2dq8b6)
         Call hpake(-186,se2dq8b6)
*         write(6,*) ' in hz97158 '
*
*********************************************************************
*
*                      Event Processing
*
*********************************************************************
      Else if(iflag.eq.2) then
*
* Filling: The following MUST always be done
* (i) move to the correct sub-directory in PAWC
*
         call hcdir('//PAWC/'//xxxx,' ')
*
         xw=wtx
         nall=nall+xw
*
         ierr=HZIBEAM(ibeam,idum)
         if (.not.(ierr.eq.1)) then
            write(6,*) 'HZ'//xxxx,' beams not found ! '
            return
         else
            Do i=1,4
               pbeam(i)=PHEP(i,IBEAM)
            enddo
         endif
*
         eb=real(PHEP(4,idum))
         if (abs(abs(eb)-ee).gt.0.1) then
            if (nentry.lt.10) then
               write(6,*) 'HZ'//xxxx,' Electron not at ',ee,' ! ',eb
            elseif (nentry.eq.10) then
               write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     +         ' ...last message ! '
            endif
            return
         endif
         ierr=HZIPGAM(ph)
         if (ierr.eq.-1) then
            write(6,*) 'HZ'//xxxx,' boson vector not found ! '
C           call VZERO(ph,5)
            Do i=1,5
             ph(i)=0.
            enddo
         else
            Do i=1,4
               pgam(i)=ph(i)
            enddo
         endif
*
* Event selection
*
         q2=real(HZDISKIN(1))
         x =real(HZDISKIN(2))
         y =real(HZDISKIN(3))

*
         if (lp) then
            write(*,*) 'Hz'//xxxx,' x y q2=',x,y,q2
         endif
*
* get electron variables for kinematic selection
*
         iel=HZIDELEC(idum)
         if (iel.eq.-1) then
            write(*,*) 'Hz'//xxxx,' electron not found '
            return
         endif
         enel=real(PHEP(4,iel))
         thel=real(HZPHMANG(PHEP(3,iel), sqrt(PHEP(1,iel)**2+PHEP(2,
     +   iel)**2)))*rd
*
*
*  do diffractive selection
         x_pom=1.
         do i=1,4
            p_mx(i)=0.
         enddo
         call hzhadgap(xmas,ymas,x_pom,t)
         mx2=xmas**2
         if (lp) then
            write(6,*) 'Hz'//xxxx,' enel= ',enel,' thel= ',thel
            write(6,*) 'Hz'//xxxx,' y= ',y,' q2= ',q2
            write(6,*) 'Hz'//xxxx,' x_pom= ',x_pom,' m_x ',sqrt(mx2)

*        call hzlulist(1)
         endif
         if(x_pom.lt.x) then
            if(lp) then
               write(6,*) ' hz97158: x < x_pom = '
               write(6,*) ' hz97158: x = ',x,' x_pom = ',xpom
               write(6,*) ' hz97158: q2 = ',q2,' m_x^2 = ',mx2
            endif
            return
         endif
         beta = x/x_pom
         if (lp) then
            write(6,*) 'Hz'//xxxx,' enel= ',enel,' thel= ',thel
            write(6,*) 'Hz'//xxxx,' y= ',y,' q2= ',q2
            write(6,*) 'Hz'//xxxx,' x_pom= ',x_pom,' m_x ',sqrt(mx2)

*        call hzlulist(1)
         endif

         f2d3=.true.
         if (q2.lt.q2bin(1)) f2d3=.false.
         if (q2.gt.q2bin(nq2+1)) f2d3=.false.
         if (beta.lt.betab(1)) f2d3=.false.
         if (beta.gt.betab(nbet+1)) f2d3=.false.
         if (x_pom.lt.xpombw(1)) f2d3=.false.
         if (x_pom.gt.xpombw(npomb+1)) f2d3=.false.
         if (ymas.gt.1.6) f2d3=.false.
         if (abs(t).gt.1.0) f2d3=.false.
*
* do f2d3
         if (f2d3) then
*
*
c fill all global histos
            call hfill(221,y,0.,wtx)
            call hfill(222,q2,0.,wtx)
            call hfill(223,x_pom,0.,wtx)
            call hfill(224,beta,0.,wtx)
            call hfill(225,sqrt(mx2),0.,wtx)
            call hfill(226,sqrt(mx2),0.,wtx)
* select beta bin
            if(beta.gt.betab(1).and.beta.le.betab(2)) then
               ibeta = 1
            elseif(beta.gt.betab(2).and.beta.le.betab(3)) then
               ibeta = 2
            elseif(beta.gt.betab(3).and.beta.le.betab(4)) then
               ibeta = 3
            elseif(beta.gt.betab(4).and.beta.le.betab(5)) then
               ibeta = 4
            elseif(beta.gt.betab(5).and.beta.le.betab(6)) then
               ibeta = 5
            elseif(beta.gt.betab(6).and.beta.le.betab(7)) then
               ibeta = 6
            elseif(beta.gt.betab(7)) then
               write(6,*) 'hz97158:  beta gt 1 ',beta
            endif
* select q2 bin
            if(q2.gt.q2bin(1).and.q2.le.q2bin(2)) then
               iq2=1
            elseif(q2.gt.q2bin(2).and.q2.le.q2bin(3)) then
               iq2=2
            elseif(q2.gt.q2bin(3).and.q2.le.q2bin(4)) then
               iq2=3
            elseif(q2.gt.q2bin(4).and.q2.le.q2bin(5)) then
               iq2=4
            elseif(q2.gt.q2bin(5).and.q2.le.q2bin(6)) then
               iq2=5
            elseif(q2.gt.q2bin(6).and.q2.le.q2bin(7)) then
               iq2=6
            elseif(q2.gt.q2bin(7).and.q2.le.q2bin(8)) then
               iq2=7
            elseif(q2.gt.q2bin(8).and.q2.le.q2bin(9)) then
               iq2=8
            endif
            ihisto=iq2*10+ibeta
* weighting with photon flux
            xw = bet(ibeta)*q2b(iq2)*q2b(iq2)/(1.-y+y**2/2)
            nall2=nall2+xw
            nev(ihisto)=nev(ihisto)+wtx
            call hfill(ihisto,x_pom,0.,xw*wtx)
*
         endif
*********************************************************************
*
*                      Termination
*
*********************************************************************

      Else if(iflag.eq.3) then

* Termination: The following MUST always be done
* (i) Move to the correct PAW subdirectory
*
         call hcdir('//PAWC/'//xxxx,' ')
*
         lum=999999999.
         if (xsec.ne.0.) then
            lum=real(nall)/real(xsec)
         else
            write(6,*) 'hz',xxxx,' xsec=0 ! '
         endif
*
         write(6,*) 'hz97158: Total Cross= ', real(xsec),' nall= ',nall
*
*
*      normalize the histos
         if(nall2.gt.1) then
*
* now do the cross section normalisation
            do i1=1,6
               do i2=1,8
                  idhisto= i2*10 +i1
                  call hzhinfo(idhisto,nev(idhisto))
* now normalise histo with 1/binwidth
c                  write(6,*) ' histo check ',idhisto,nev(idhisto)
                  if(nev(idhisto).gt.0) then
                     call hzhinrm( idhisto, 0, 1., 1 )
c                  write(6,*) ' before hunpak '
                     call hunpak( idhisto,conten,' ',0 )
c                  write(6,*) ' after hunpak '
                     call hunpke( idhisto,contene,' ',0 )
c                  write(6,*) ' after hunpak '
                     fact=0.
                     do i3=1,npomb
                        fact=1./(4.*pi*alph_em**2)
                        fact=fact/1000./gev2nb*xpo(i3)/betabw(i1)/
     +                  q2binw(i2)/ lum
c                        write(6,*) conten(i3),fact
                        conten(i3)=conten(i3)*fact
                        contene(i3)=contene(i3)*fact
                     enddo
                     call hpak( idhisto,conten)
                     call hpake( idhisto,contene)
                  endif
               enddo
            enddo

         endif
*
      endif
*
      RETURN
      END
*CMZ :  1.02/06 27/03/99  16.07.57  by  Tancredi Carli
*-- Author :
        SUBROUTINE HZ97164(IFLAG)
****************************************************************************
*
* Purpose: Produces histograms for the double-differential di-jet cross
*          section in photoproduction, as a function of the momentum
*          fraction of the parton in the photon as reconstructed from the
*          two highest transverse energy final state jets, and of the
*          logarithm of the square of the mean transverse energy of these
*          jets:
*
*          d^2 sigma(ep->2 jets + X)/(dx_gamma*dlog_10(E_T(jet)^2))
*
*          Event selection cuts : Q2 < 4 GeV^2
*                                 0.2 < y <0.83
*                                 0 < 1/2*(eta1+eta2) < 2
*                                 |eta1-eta2| < 1
*                                 |ET1-ET2|/(ET1+ET2) < 0.25
*
*           with:   Q2 = photon virtuality
*                   y  = E(photon)/E(beam) = normalized photon energy
*            eta1,eta2 = pseudorapidities of the two highest transverse energy
*                        jets in HERA laboratory frame
*            ET1,ET2   = transverse energies of these two jets
*            E_T(jet)  = mean transverse energy of jets = (ET1+ET2)/2
*            x_gamma   = (ET1*exp(-eta1)+ET2*exp(-eta2))/(2*E(beam)*y)
*
*
* Reference : DESY-97-164
*             Eur. Phys. J. C 1 (1998) 97-107
*             Figure 2 and Table 1
*
* Arguments:  iflag=1 initialisation/booking of histograms
*             iflag=2 event processing/filling of MC histograms
*             iflag=3 termination/final normalisation
*                     (the variables Xsec (total cross section) and
*                      Ntot (total number of events) have to be set before
*                      calling the termination routine in order to get a
*                      correct normalisation for the MC histograms)
*
*             This photoproduction routine has to be run twice with the
*             following code additions:
* 	              +1000 for the DIRECT component run.
*	              +2000 for the RESOLVED component run.
*             for all three phases (iflag=1,2,3)
*
* written by: Hartmut Rick (Hartmut.Rick@desy.de) on 04/02/98
*     modified for split resolved and direct components by Russell Taylor
****************************************************************************
*
* Output graphs:
*---------------
* DATA
*
* histograms -1..-7 contain the measured di-jet cross section data,
* d^2 sigma/(dx_gamma dlog10(ET^2))
* errors are statistical + uncorrelated systematic
* -1        0.1 < x_gamma < 0.2
* -2        0.2 < x_gamma < 0.3
* -3        0.3 < x_gamma < 0.4
* -4        0.4 < x_gamma < 0.5
* -5        0.5 < x_gamma < 0.6
* -6        0.6 < x_gamma < 0.75
* -7        0.75 < x_gamma
*
* histograms -11..-16 contain the same data as a function of x_gamma
* -11       2.00 < log10(ET^2/GeV^2) < 2.15    ( 10.0 GeV < ET < 11.9 GeV )
* -12       2.15 < log10(ET^2/GeV^2) < 2.30    ( 11.9 GeV < ET < 14.1 GeV )
* -13       2.30 < log10(ET^2/GeV^2) < 2.50    ( 14.1 GeV < ET < 17.8 GeV )
* -14       2.50 < log10(ET^2/GeV^2) < 2.70    ( 17.8 GeV < ET < 22.4 GeV )
* -15       2.70 < log10(ET^2/GeV^2) < 3.00    ( 22.4 GeV < ET < 31.6 GeV )
* -16       3.00 < log10(ET^2/GeV^2) < 3.40    ( 31.6 GeV < ET < 50.1 GeV )
*
*
* Monte-Carlo
* d^2 sigma/(dx_gamma dlog10(ET^2))
*  1        0.1 < x_gamma < 0.2
*  2        0.2 < x_gamma < 0.3
*  3        0.3 < x_gamma < 0.4
*  4        0.4 < x_gamma < 0.5
*  5        0.5 < x_gamma < 0.6
*  6        0.6 < x_gamma < 0.75
*  7        0.75 < x_gamma
*               These graphs will be
*               meaningless unless Xsec and Ntot are set before
*               calling the termination routine.
*               (Xsec - total cross section returned by MC)
*               (Ntot - number of events passed to this routine)
*
* d^2 sigma/(dx_gamma dlog10(ET^2)) plotted as a function of x_gamma
* 11       2.00 < log10(ET^2/GeV^2) < 2.15    ( 10.0 GeV < ET < 11.9 GeV )
* 12       2.15 < log10(ET^2/GeV^2) < 2.30    ( 11.9 GeV < ET < 14.1 GeV )
* 13       2.30 < log10(ET^2/GeV^2) < 2.50    ( 14.1 GeV < ET < 17.8 GeV )
* 14       2.50 < log10(ET^2/GeV^2) < 2.70    ( 17.8 GeV < ET < 22.4 GeV )
* 15       2.70 < log10(ET^2/GeV^2) < 3.00    ( 22.4 GeV < ET < 31.6 GeV )
* 16       3.00 < log10(ET^2/GeV^2) < 3.40    ( 31.6 GeV < ET < 50.1 GeV )
*               The same remark about Xsec and Ntot applies as above
*
*****************************************************************************
        IMPLICIT NONE

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.

        INTEGER NPTBIN,NXGBIN
        PARAMETER (NPTBIN=6,NXGBIN=7)
        INTEGER NBIN(NPTBIN+10)
        REAL XBIN(NXGBIN+1),PTBIN(NPTBIN+1)
        REAL XSDI(NXGBIN*NPTBIN),XERR(NXGBIN*NPTBIN)

        INTEGER I,J,IP,IL,NJET1
        INTEGER IFLAG,IFFLAG
        REAL TMP(10),TMPE(10),AJET1(10,3)
        REAL EBEAM,Q2,Y,ETA1,ETA2,ET1,ET2,ETJET
        REAL ET2LOG,XGAMMA,WBIN,ANORM(2)

        CHARACTER *80 HISTNAME

        REAL RAPMAX,ETMIN,ETSMIN,RJET
        INTEGER NRAPB,NAZMB
        PARAMETER(RAPMAX=5.203263,NRAPB=106,NAZMB=64,ETMIN=0.1,
     +            ETSMIN=5.,RJET=0.7)

C       binning definition
        DATA NBIN /2,3,4,4,4,5,6,0,0,0,7,7,6,5,2,1/
        DATA XBIN /0.1,0.2,0.3,0.4,0.5,0.6,0.75,1.001/
        DATA PTBIN /2.,2.15,2.3,2.5,2.7,3.,3.4/

C       di-jet cross section data
        DATA XSDI /7.42,2.62,0.00,0.00,0.00,0.00,
     +             6.31,2.83,1.23,0.00,0.00,0.00,
     +             5.06,3.00,1.27,0.30,0.00,0.00,
     +             3.81,2.19,1.16,0.46,0.00,0.00,
     +             4.05,2.71,1.27,0.60,0.00,0.00,
     +             5.11,4.15,2.00,0.75,0.27,0.00,
     +             4.32,3.43,2.50,1.25,0.54,0.09/

C       di-jet cross section errors
        DATA XERR /0.87,0.32,1.00,1.00,1.00,1.00,
     +             0.74,0.35,0.16,1.00,1.00,1.00,
     +             0.60,0.37,0.16,0.04,1.00,1.00,
     +             0.46,0.26,0.15,0.07,1.00,1.00,
     +             0.48,0.33,0.16,0.09,1.00,1.00,
     +             0.64,0.49,0.24,0.10,0.05,1.00,
     +             0.62,0.40,0.30,0.16,0.07,0.02/

        INTEGER intiflag, iproc

C --- choose direct/resolved
C --- recommend 1 - DIRECT, 2 - RESOLVED
	IF (iflag.gt.1000) THEN
	  iproc=INT(iflag/1000)
	  intiflag=MOD(iflag,1000)
	ENDIF
	IF ((iproc.gt.2).or.(iproc.lt.1)) THEN
	  PRINT*,'HZ97164 : Badly called routine'
	  PRINT*,'          please set intiflag +1000 or +2000'
	ENDIF

        IF (intiflag.eq.1) THEN
C *** Initialisation run ***

        PRINT*,"**********************************************"
        PRINT*,"* HZ97164 initialisation, booking histograms *"
        PRINT*,"**********************************************"


27      FORMAT ('DATA d^2![s]/dx?[g]!/dlog?10!(E?T!^2!), ',
     +  F4.2,'"l#x?[g]!"l#',F4.2)
28      FORMAT ('DATA d^2![s]/dx?[g]!/dlog?10!(E?T!^2!), ',
     +  F4.2,'"l#log?10!(E?T!^2!)"l#',F4.2)
127     FORMAT ('MC d^2![s]/dx?[g]!/dlog?10!(E?T!^2!), ',
     +  F4.2,'"l#x?[g]!"l#',F4.2)
128     FORMAT ('MC d^2![s]/dx?[g]!/dlog?10!(E?T!^2!), ',
     +  F4.2,'"l#log?10!(E?T!^2!)"l#',F4.2)
129     FORMAT ('MC X-sec, ',
     +  F4.2,'"l#x?[g]!"l#',F4.2)
130     FORMAT ('MC X-sec, ',
     +  F4.2,'"l#log?10!(E?T!^2!)"l#',F4.2)

        IF (iproc.eq.1) THEN
          CALL HCDIR('//PAWC',' ')
          CALL HMDIR('97164','S')
          CALL HCDIR('//HISTO',' ')
          CALL HMDIR('97164','S')


          DO I=1,NXGBIN
            WRITE (HISTNAME,27) XBIN(I),XBIN(I+1)
            CALL HBOOKB(-I,HISTNAME,NBIN(I),PTBIN,0.)
            WRITE (HISTNAME,127) XBIN(I),XBIN(I+1)
            CALL HBOOKB(I,HISTNAME,NBIN(I),PTBIN,0.)
            DO J=1,NBIN(I)
              TMP(J)=XSDI((I-1)*NPTBIN+J)
              TMPE(J)=XERR((I-1)*NPTBIN+J)
            END DO
            CALL HPAK(-I,TMP)
            CALL HPAKE(-I,TMPE)
          END DO

          DO J=1,NPTBIN
            WRITE (HISTNAME,28) PTBIN(J),PTBIN(J+1)
            CALL HBOOKB(-J-10,HISTNAME,NBIN(J+10),
     +                XBIN(1+NXGBIN-NBIN(J+10)),0.)
            WRITE (HISTNAME,128) PTBIN(J),PTBIN(J+1)
            CALL HBOOKB(J+10,HISTNAME,NBIN(J+10),
     +                XBIN(1+NXGBIN-NBIN(J+10)),0.)
            DO I=1+NXGBIN-NBIN(J+10),NXGBIN
              TMP(I+NBIN(J+10)-NXGBIN)=XSDI((I-1)*NPTBIN+J)
              TMPE(I+NBIN(J+10)-NXGBIN)=XERR((I-1)*NPTBIN+J)
            END DO
            CALL HPAK(-J-10,TMP)
            CALL HPAKE(-J-10,TMPE)
          END DO
        ENDIF

        CALL HCDIR('//HISTO/97164',' ')
	CALL HCDIR('//PAWC/97164',' ')

        DO I=1,NXGBIN
          WRITE (HISTNAME,129) XBIN(I),XBIN(I+1)
          CALL HBOOKB(I+100*iproc,HISTNAME,NBIN(I),PTBIN,0.)
          CALL HBARX(I+100*iproc)
        END DO

        DO J=1,NPTBIN
          WRITE (HISTNAME,130) PTBIN(J),PTBIN(J+1)
          CALL HBOOKB(J+10+100*iproc,HISTNAME,NBIN(J+10),
     +                XBIN(1+NXGBIN-NBIN(J+10)),0.)
          CALL HBARX(J+10+100*iproc)
        END DO

*       try to find electron beam energy
        IF FLAG=HZIBEAM(IP,IL)
        IF (IFFLAG.EQ.0.OR.IFFLAG.EQ.1) THEN
          EBEAM=PHEP(4,IL)
          IF (ABS(EBEAM-27.55).GT.0.5) THEN
            PRINT *,'HZ97164 Warning: wrong electron beam energy'
          END IF
        ELSE
          EBEAM=27.55
        END IF


C==================================================================

        ELSE IF (intiflag.EQ.2) THEN
C *** Event loop, fill MC histograms ***

          CALL HCDIR('//PAWC/97164',' ')

          CALL VZERO(AJET1,30)
          NJET1=0
          CALL H1QGCONE(RAPMAX,NRAPB,NAZMB,ETMIN,ETSMIN,RJET,
     +                  NJET1,AJET1)
*
*         test kinematic range
          Q2=REAL(HZPHOKIN(1))
          Y=REAL(HZPHOKIN(3))
          IF (Q2.GT.4.) GOTO 65
          IF (Y.LT.0.2.OR.Y.GT.0.83) GOTO 65
*
*         at least two jets required
          IF (NJET1.LT.2) GOTO 65
*
*         pseudorapidity range of jets
          ETA1=AJET1(1,2)
          ETA2=AJET1(2,2)
          IF (ABS(ETA1-ETA2).GT.1.) GOTO 65
          IF (ETA1+ETA2.LT.0..OR.ETA1+ETA2.GT.4.) GOTO 65
*
*         jet transverse energies
          ET1=AJET1(1,1)
          ET2=AJET1(2,1)
          ETJET=(ET1+ET2)/2
          IF (ABS(ET1-ET2)/ETJET.GT.0.5) GOTO 65
          ET2LOG=2.*LOG10(ETJET)
          XGAMMA=(ET1*EXP(-ETA1)+ET2*EXP(-ETA2))/(2.*Y*EBEAM)
*
*         bin width
          WBIN=WTX
*
*         find ET bin
          DO J=1,NPTBIN
            IF (PTBIN(J).LE.ET2LOG.AND.ET2LOG.LT.PTBIN(J+1)) GOTO 63
          END DO
*
63        CONTINUE
          IF (J.GT.NPTBIN) GOTO 65
          WBIN=WBIN/(PTBIN(J+1)-PTBIN(J))
*
*         find x_gamma bin
          DO I=1,NXGBIN
            IF (XBIN(I).LE.XGAMMA.AND.XGAMMA.LT.XBIN(I+1)) GOTO 64
          END DO
*
64        CONTINUE
          IF (I.GT.NXGBIN) GOTO 65
          WBIN=WBIN/(XBIN(I+1)-XBIN(I))
*
*         fill histograms
          CALL HFILL (I+100*iproc,ET2LOG,0.,WBIN)
          CALL HFILL (J+10+100*iproc,XGAMMA,0.,WBIN)
*
65       CONTINUE


        ELSE IF (intiflag.eq.3) THEN
C *** Termination, fix normalisation of MC histograms ***

          CALL HCDIR('//PAWC/97164',' ')

          IF (Xsec.eq.0) THEN
	    PRINT*,'HZ97164: termination called with zero cross section'
	    PRINT*,'          cross section graph meaningless'
	    PRINT*,'	      in process :',iproc*1000
	    Xsec=1
	  ENDIF
	  IF (Ntot.eq.0) THEN
	    PRINT*,'HZ97164: termination called with no total events'
	    PRINT*,'          cross section graph meaningless'
	    PRINT*,'	      in process :',iproc*1000
	    Ntot=1
	  ENDIF

          ANORM(iproc)=0.
          ANORM(iproc)=XSEC/NTOT

C          PRINT*,ANORM(iproc)

          IF (iproc.eq.2) THEN
            DO I=1,NXGBIN
              CALL HOPERA(I+100,'+E',I+100,I+100,ANORM(1),0.)
              CALL HOPERA(I+200,'+E',I+200,I+200,ANORM(2),0.)
              CALL HOPERA(I+100,'+E',I+200,I,1.,1.)
              CALL HZCHISQ(I,-I)
            END DO
*
            DO J=1,NPTBIN
              CALL HOPERA(J+110,'+E',J+110,J+110,ANORM(1),0.)
              CALL HOPERA(J+210,'+E',J+210,J+210,ANORM(2),0.)
              CALL HOPERA(J+110,'+E',J+210,J+10,1.,1.)
              CALL HZCHISQ(J+10,-(J+10))
            END DO
          ENDIF
*
        ELSE
          WRITE(6,*) 'HZ97164: Unknown flag',iflag
        ENDIF
        RETURN
        END
*CMZ :  1.01/13 23/03/98  18.11.59  by  Tancredi Carli
*CMZ :  1.01/11 05/06/97  10.00.11  by  Tancredi Carli
*-- Author :    Tania Ebert   05/06/97
      subroutine HZ97179(IFLAG)
****************************************************************************
* Purpose: produced histograms for the inclusive jet cross-section
*          Event selection: 0.65 < q2 < 49 Gevsq
*                           0.3 < y < 0.6
*                           In Gamma*p frame using kt algorithm:
*                           Et(jet) > 4 GeV
*                           -2.5 < eta(jet) < -0.5
*
*          Reference:
* Arguments: iflag=1 initialisation
*            iflag=1 filling
*            iflag=3 termination
*
* written by: Tania Ebert on 05/06/97
****************************************************************************
      IMPLICIT NONE
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEND.
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      Integer ihep,iflag,ibin,iloop,ierr,iel,idum, njets, nsjets
      integer jloop,i,j
      integer jgam, jbeam, ilep, ipro, npart, mjet(2048)
      Real Nev
      double precision pgam(5), ppro(4),ppho(4),plab(4),pcms(4)
      double precision dpartgp(4,300), dpjet(4,20)
      Real q2, ykin, ycut(2), q2bins(9), y(2048), pjet(4,20),binwid
      real jetp, ptjet, etjet, rapjet,etbins(5),flux(8)
      real invlumi
      Data ycut/0.3,0.6/
      data etbins/4.0,5.0,7.0,10.0,20.0/
      data flux/ 6.560E-04, 8.273E-04, 4.609E-04, 8.677E-04,
     +     8.544E-04, 2.388E-04, 3.902E-04, 3.299E-04 /
      Data q2bins/0.65, 1.2, 2.6, 4.0, 9.0, 20.0, 25.0, 36.0, 49.0/
*     DESY Preprint number
      Character*5 xxxx
      Data xxxx/'97179'/
*
*
* Data points from plots
*
      real et1(4),et2(4),et3(4),et4(4),et5(4),et6(4),et7(4),et8(4)
      real eta1(5),eta2(5),eta3(5),eta4(5),eta5(5),eta6(5),eta7(5)
     +     ,eta8(5)
*
      real stet1(4),stet2(4),stet3(4),stet4(4),stet5(4),stet6(4),
     +     stet7(4),stet8(4)
      real steta1(5),steta2(5),steta3(5),steta4(5),steta5(5),steta6(5)
     +     ,steta7(5),steta8(5)
      real qsq1(8),qsq2(8),qsq3(8),qsq4(8)
      real stqsq1(8),stqsq2(8),stqsq3(8),stqsq4(8)
      logical lp
      Data lp/.false./
*
      data et1 /3.539, 1.089, 0.174, 1.596E-02/
      data stet1 /0.295, 0.105, 3.710E-02, 7.836E-03/
      data et2 /3.418, 1.171, 0.220, 1.738E-02/
      data stet2 /0.307, 0.122, 4.398E-02, 6.533E-03/
      data et3 /1.486, 0.477, 4.940E-02, 5.074E-03/
      data stet3 /0.214, 7.763E-02, 1.619E-02, 3.753E-03/
      data et4 /1.645, 0.691, 0.128, 2.434E-02/
      data stet4 /0.206, 9.406E-02, 3.331E-02, 1.052E-02/
      data et5 /1.111, 0.494, 0.143, 0.012/
      data stet5 /0.032, 0.015, 0.007, 0.001/
      data et6 /0.271, 0.110, 0.033, 0.006/
      data stet6 /0.016, 0.007, 0.003, 0.001/
      data et7 /0.338, 0.094, 0.030, 0.005/
      data stet7 /0.018, 0.005, 0.002, 0.001/
      data et8 /0.193, 0.051, 0.033, 0.005/
      data stet8 /0.014, 0.003, 0.003, 0.001/
*
      data eta1 /1.934, 1.592, 1.926, 1.175, 0.727/
      data steta1 /0.344, 0.281, 0.404, 0.245, 0.159/
      data eta2 /2.340, 1.742, 1.038, 1.324, 1.299/
      data steta2 /0.435, 0.318, 0.230, 0.287, 0.293/
      data eta3 /0.753, 0.513, 0.488, 0.623, 0.348/
      data steta3 /0.212, 0.158, 0.160, 0.222, 0.130/
      data eta4 /1.494, 1.507, 0.792, 0.639, 0.672/
      data steta4 /0.337, 0.353, 0.210, 0.188, 0.207/
      data eta5  /1.258, 0.807, 0.621, 0.710, 0.495 /
      data steta5  /0.056, 0.041, 0.033, 0.042, 0.032/
      data eta6  /0.237, 0.269, 0.221, 0.084, 0.111/
      data steta6 /0.023, 0.029, 0.024, 0.011, 0.013/
      data eta7 /0.253, 0.142, 0.167, 0.140, 0.144/
      data steta7 /0.019, 0.012, 0.015, 0.014, 0.016/
      data eta8 /0.371, 0.159, 0.074, 0.072, 0.079/
      data steta8 /0.034, 0.015, 0.008, 0.009, 0.011/
*
      data qsq1 /3.539,3.418,1.486,1.645,1.111,0.271,0.338,0.193/
      data qsq2 /1.089,1.171,0.477,0.691,0.494,0.110,0.094,0.051/
      data qsq3 /0.174,0.220,4.940E-02,0.128,0.143,0.033,0.030,0.033/
      data qsq4 /1.596E-02,1.738E-02,5.074E-03,2.434E-02,0.012,0.006,0
     +     .005,0.005/
*
      data stqsq1 /0.295,0.307,0.214,0.206,0.032,0.016,0.018,0.014/
      data stqsq2 /0.105,0.122,7.763E-02,9.406E-02,0.015,0.007,0.005,
     +     0.003/
      data stqsq3 /3.710E-02,4.398E-02,1.619E-02,3.331E-02,0.007,0.003,
     +     0.002,0.003/
      data stqsq4 /7.836E-03,6.533E-03,3.753E-03,1.052E-02,0.001,0.001,
     +     0.001,0.001/
*
      IF (iflag.eq.1) then
*
*      Initialisation: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (i) make subdirectory in o/p file
*
       Call hcdir('//PAWC',' ')
       call hmdir(xxxx,'S')
       Call hcdir('//HISTO',' ')
       call hmdir(xxxx,'S')
*
       Nev=0.
*
*      book your histograms
*
       CALL HBOOKB(11,'d(N)/d(et),0.65.lt.Q2.lt.1.2,',4,etbins,0.)
       CALL HBOOKB(12,'d(N)/d(et),1.2.lt.Q2.lt.2.6',4,etbins,0.)
       CALL HBOOKB(13,'d(N)/d(et),2.6.lt.Q2.lt.4.0',4,etbins,0.)
       CALL HBOOKB(14,'d(N)/d(et),4.0.lt.Q2.lt.9.0',4,etbins,0.)
       CALL HBOOKB(15,'d(N)/d(et),9.lt.Q2.lt.20',4,etbins,0.)
       CALL HBOOKB(16,'d(N)/d(et),20.lt.Q2.lt.25',4,etbins,0.)
       CALL HBOOKB(17,'d(N)/d(et),25.lt.Q2.lt.36',4,etbins,0.)
       CALL HBOOKB(18,'d(N)/d(et),36.lt.Q2.lt.49',4,etbins,0.)
*
       CALL HBOOK1(21,'d(N)/d(eta),0.65.lt.Q2.lt.1.2',5,-2.5,-0.5,0.)
       CALL HBOOK1(22,'d(N)/d(eta),1.2.lt.Q2.lt.2.6',5,-2.5,-0.5,0.)
       CALL HBOOK1(23,'d(N)/d(eta),2.6.lt.Q2.lt.4.0',5,-2.5,-0.5,0.)
       CALL HBOOK1(24,'d(N)/d(eta),4.0.lt.Q2.lt.9.0',5,-2.5,-0.5,0.)
       CALL HBOOK1(25,'d(N)/d(eta),9.lt.Q2.lt.20',5,-2.5,-0.5,0.)
       CALL HBOOK1(26,'d(N)/d(eta),20.lt.Q2.lt.25',5,-2.5,-0.5,0.)
       CALL HBOOK1(27,'d(N)/d(eta),25.lt.Q2.lt.36',5,-2.5,-0.5,0.)
       CALL HBOOK1(28,'d(N)/d(eta),36.lt.Q2.lt.49',5,-2.5,-0.5,0.)
*
       CALL HBOOKB(31,'N(Q2)gamma*p,4.lt.et.lt.5',8,q2bins,0.)
       CALL HBOOKB(32,'N(Q2)gamma*p,5.lt.et.lt.7',8,q2bins,0.)
       CALL HBOOKB(33,'N(Q2)gamma*p,7.lt.et.lt.10',8,q2bins,0.)
       CALL HBOOKB(34,'N(Q2)gamma*p,10.lt.et.lt.20',8,q2bins,0.)
*
       CALL HBOOKB(111,'d(sigma)/d(et),0.65.lt.Q2.lt.1.2,',4,etbins,0.)
       CALL HBOOKB(112,'d(sigma)/d(et),1.2.lt.Q2.lt.2.6',4,etbins,0.)
       CALL HBOOKB(113,'d(sigma)/d(et),2.6.lt.Q2.lt.4.0',4,etbins,0.)
       CALL HBOOKB(114,'d(sigma)/d(et),4.0.lt.Q2.lt.9.0',4,etbins,0.)
       CALL HBOOKB(115,'d(sigma)/d(et),9.lt.Q2.lt.20',4,etbins,0.)
       CALL HBOOKB(116,'d(sigma)/d(et),20.lt.Q2.lt.25',4,etbins,0.)
       CALL HBOOKB(117,'d(sigma)/d(et),25.lt.Q2.lt.36',4,etbins,0.)
       CALL HBOOKB(118,'d(sigma)/d(et),36.lt.Q2.lt.49',4,etbins,0.)
*
       CALL HBOOK1(121,'d(sigma)/d(eta),0.65.lt.Q2.lt.1.2',
     +      5,-2.5,-0.5,0.)
       CALL HBOOK1(122,'d(sigma)/d(eta),1.2.lt.Q2.lt.2.6',
     +      5,-2.5,-0.5,0.)
       CALL HBOOK1(123,'d(sigma)/d(eta),2.6.lt.Q2.lt.4.0',
     +      5,-2.5,-0.5,0.)
       CALL HBOOK1(124,'d(sigma)/d(eta),4.0.lt.Q2.lt.9.0',
     +      5,-2.5,-0.5,0.)
       CALL HBOOK1(125,'d(sigma)/d(eta),9.lt.Q2.lt.20',5,-2.5,-0.5,0.)
       CALL HBOOK1(126,'d(sigma)/d(eta),20.lt.Q2.lt.25',5,-2.5,-0.5,0.)
       CALL HBOOK1(127,'d(sigma)/d(eta),25.lt.Q2.lt.36',5,-2.5,-0.5,0.)
       CALL HBOOK1(128,'d(sigma)/d(eta),36.lt.Q2.lt.49',5,-2.5,-0.5,0.)
*
       CALL HBOOKB(131,'sigma(Q2)gamma*p,4.lt.et.lt.5',8,q2bins,0.)
       CALL HBOOKB(132,'sigma(Q2)gamma*p,5.lt.et.lt.7',8,q2bins,0.)
       CALL HBOOKB(133,'sigma(Q2)gamma*p,7.lt.et.lt.10',8,q2bins,0.)
       CALL HBOOKB(134,'sigma(Q2)gamma*p,10.lt.et.lt.20',8,q2bins,0.)
*
       CALL HBOOKB(-111,'d(sigma)/d(et),0.65.lt.Q2.lt.1.2,',
     +      4,etbins,0.)
       CALL HBOOKB(-112,'d(sigma)/d(et),1.2.lt.Q2.lt.2.6',4,etbins,0.)
       CALL HBOOKB(-113,'d(sigma)/d(et),2.6.lt.Q2.lt.4.0',4,etbins,0.)
       CALL HBOOKB(-114,'d(sigma)/d(et),4.0.lt.Q2.lt.9.0',4,etbins,0.)
       CALL HBOOKB(-115,'d(sigma)/d(et),9.lt.Q2.lt.20',4,etbins,0.)
       CALL HBOOKB(-116,'d(sigma)/d(et),20.lt.Q2.lt.25',4,etbins,0.)
       CALL HBOOKB(-117,'d(sigma)/d(et),25.lt.Q2.lt.36',4,etbins,0.)
       CALL HBOOKB(-118,'d(sigma)/d(et),36.lt.Q2.lt.49',4,etbins,0.)
*
       CALL HBOOK1(-121,'d(sigma)/d(eta),0.65.lt.Q2.lt.1.2',
     +      5,-2.5,-0.5,0.)
       CALL HBOOK1(-122,'d(sigma)/d(eta),1.2.lt.Q2.lt.2.6',
     +      5,-2.5,-0.5,0.)
       CALL HBOOK1(-123,'d(sigma)/d(eta),2.6.lt.Q2.lt.4.0',
     +      5,-2.5,-0.5,0.)
       CALL HBOOK1(-124,'d(sigma)/d(eta),4.0.lt.Q2.lt.9.0',
     +      5,-2.5,-0.5,0.)
       CALL HBOOK1(-125,'d(sigma)/d(eta),9.lt.Q2.lt.20',
     +      5,-2.5,-0.5,0.)
       CALL HBOOK1(-126,'d(sigma)/d(eta),20.lt.Q2.lt.25',
     +      5,-2.5,-0.5,0.)
       CALL HBOOK1(-127,'d(sigma)/d(eta),25.lt.Q2.lt.36',
     +      5,-2.5,-0.5,0.)
       CALL HBOOK1(-128,'d(sigma)/d(eta),36.lt.Q2.lt.49',
     +      5,-2.5,-0.5,0.)
*
       CALL HBOOKB(-131,'sigma(Q2)gamma*p,4.lt.et.lt.5',8,q2bins,0.)
       CALL HBOOKB(-132,'sigma(Q2)gamma*p,5.lt.et.lt.7',8,q2bins,0.)
       CALL HBOOKB(-133,'sigma(Q2)gamma*p,7.lt.et.lt.10',8,q2bins,0.)
       CALL HBOOKB(-134,'sigma(Q2)gamma*p,10.lt.et.lt.20',8,q2bins,0.)
*
      Else if(iflag.eq.2) then
*      Filling: The following MUST always be done
*      (i) move to the correct sub-directory in PAWC
*
       call hcdir('//PAWC/'//xxxx,' ')
*
       if (xsec.gt.0) then
        Nev=Nev+wtx
       endif
*
       q2  = real(hzdiskin(1))
       ykin= real(hzdiskin(3))
*
*--Sort out the binning first
*
       ibin = 0
       IF ((ykin.gt.ycut(1)).and.(ykin.lt.ycut(2))) then
          DO ILoop=1,8,1
             IF ((q2.ge.q2bins(ILoop)).and.
     +            (q2.lt.q2bins(ILoop+1))) then
                ibin = iloop
                goto 100
             endif
          enddo
       ENDIF
*
 100   continue
       if (ibin.eq.0) then
          goto 999
       endif
*
       if (lp) then
        write(6,*) ' y, q2= ',ykin,q2,' ibin= ',ibin
       endif
*
*--Find the proton and photon
*
       IF (gen(1:3).eq.'HRW') then
C         jgam = hzipgamn(pgam)
       else
C          jgam = hzipgam(pgam)
       endif
*
       if (jgam.ne.1) then
          write(6,*) 'hz',xxxx,' ERROR: No photon found'
          goto 999
       endif
*
       jbeam = hzibeam(ipro,ilep)
*
       if (jbeam.ne.1) then
          write(6,*) 'ERROR: Problem finding beams'
          goto 999
       endif
*
       do iloop=1,4
          ppro(iloop) = phep(iloop,ipro)
          ppho(iloop) = pgam(iloop)
       enddo
*
*--set up the boost
*
       call hzhcmini(ppro,ppho,ierr)
*
       if (ierr.eq.1) then
          write(6,*) 'Hz'//xxxx,'ERROR: Problem with boost'
          goto 999
       endif
*
*--Find the scattered electron
*
       iel=HZIDELEC(idum)
       if (iel.eq.-1) then
          write(6,*) 'Hz'//xxxx,' electron not found '
          goto 999
       endif
*
*---Sort out all the stable particles and boost them
*
       do i=1,300
        do j=1,4
         dpartgp(j,i)=0.
        enddo
       enddo
C       CALL VZERO(dpartgp,1200)
*
       npart = 0
*
       do 200 ihep=1,nhep
*     skip unstable particles and electron
          if (isthep(ihep).ne.1.or.ihep.eq.iel) goto 200
          if (npart.eq.300) then
             WRITE(6,*) 'Hz'//xxxx,'ERROR: Too many stable particles'
             GOTO 999
          endif
          npart = npart + 1
          Do iloop=1,4
             Plab(iloop)=PHEP(iloop,ihep)
          enddo
          call HZHCM(plab,pcms,ierr)
          Do iloop=1,4
             if (iloop.eq.3) then
                dpartgp(iloop,npart) = -pcms(iloop)
             else
                dpartgp(iloop,npart) = pcms(iloop)
             endif
          enddo
          if (ierr.eq.1) then
             write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
             goto 999
          endif
 200   continue
*
       call ktclus(4, dpartgp, npart, 3., y, *91)
       call ktreco(1, dpartgp, npart, 3., 1., 1., dpjet, mjet,
     &      njets, nsjets, *92)
*
       if (lp) then
        WRITE(6,*) 'This event has',njets,' jets'
       endif
*
       IF (njets.gt.20) THEN
          WRITE(6,*) 'This event has',njets,' jets'
          GOTO 999
       ENDIF
*
       DO iloop=1,njets
          Do jloop = 1,4
             pjet(jloop,iloop) = sngl(dpjet(jloop,iloop))
          enddo
          ptjet = sqrt(pjet(1,iloop)**2+pjet(2,iloop)**2)
          jetp = sqrt(ptjet**2 + pjet(3,iloop)**2)
          etjet = pjet(4,iloop)*ptjet/jetp
          IF (jetp.eq.abs(pjet(3,iloop))) THEN
             IF (pjet(3,iloop).gt.0.) THEN
                rapjet = 999.
             ELSE
                rapjet = -999.
             ENDIF
          ELSE
             rapjet=0.5*(LOG(jetp+pjet(3,iloop))-
     +            LOG(jetp-pjet(3,iloop)))
          ENDIF
*
*--Fill the histograms
*
          if (lp) then
           write(6,*) jloop,' rap, pt= ', etjet,rapjet
          endif
          IF ((rapjet.gt.-2.5).and.(rapjet.lt.-0.5)) then
             if ((etjet.gt.4.0).and.(etjet.lt.20.)) then
                if ((etjet.gt.4.0).and.(etjet.le.5.0)) then
                   call hfill(31,q2,0.,wtx/flux(ibin))
                   binwid = 1.0
                elseif ((etjet.gt.5.0).and.(etjet.le.7.0)) then
                   call hfill(32,q2,0.,wtx/flux(ibin))
                   binwid = 2.0
                elseif ((etjet.gt.7.0).and.(etjet.le.10.0)) then
                   call hfill(33,q2,0.,wtx/flux(ibin))
                   binwid = 3.0
                elseif ((etjet.gt.10.0).and.(etjet.le.20.0)) then
                   call hfill(34,q2,0.,wtx/flux(ibin))
                   binwid = 10.0
                endif
                call hfill(10+ibin,etjet,0.,wtx/binwid)
             endif
*
             if (etjet.gt.5.0) then
                call hfill(20+ibin,rapjet,0.,2.5*wtx)
             endif
          endif
       enddo
*
       goto 999
*
 91    WRITE(6,*) 'Hz'//xxxx,' ERROR: from ktclus'
 92    WRITE(6,*) 'Hz'//xxxx,' ERROR: from ktreco'
*
 999   continue
*
      Else if(iflag.eq.3) then
*      Termination: The following MUST always be done
*      (i) Move to the correct PAW subdirectory
*
       call hcdir('//PAWC/'//xxxx,' ')
*
*      Pack the data
*
       call hpak(-111,et1)
       call hpak(-112,et2)
       call hpak(-113,et3)
       call hpak(-114,et4)
       call hpak(-115,et5)
       call hpak(-116,et6)
       call hpak(-117,et7)
       call hpak(-118,et8)
*
       call hpake(-111,stet1)
       call hpake(-112,stet2)
       call hpake(-113,stet3)
       call hpake(-114,stet4)
       call hpake(-115,stet5)
       call hpake(-116,stet6)
       call hpake(-117,stet7)
       call hpake(-118,stet8)
*
       call hpak(-121,eta1)
       call hpak(-122,eta2)
       call hpak(-123,eta3)
       call hpak(-124,eta4)
       call hpak(-125,eta5)
       call hpak(-126,eta6)
       call hpak(-127,eta7)
       call hpak(-128,eta8)
*
       call hpake(-121,steta1)
       call hpake(-122,steta2)
       call hpake(-123,steta3)
       call hpake(-124,steta4)
       call hpake(-125,steta5)
       call hpake(-126,steta6)
       call hpake(-127,steta7)
       call hpake(-128,steta8)
*
*     Normalise the histograms by the luminosity
*
****       invlumi = xsec/real(ntot)
       write(6,*) 'hz'//xxxx,' Total number of events= ',nev
       if (nev.ne.0.) then
        invlumi = xsec*0.001/nev
       else
        invlumi = -999.
       endif
*
       if (invlumi.ne.0) then
        write(6,*) 'hz'//xxxx,' lumi is= ',1/invlumi
       else
         write(6,*) 'hz'//xxxx,' lumi= 0 ! '
       endif
*
       do iloop = 1, 8
          qsq1(iloop)=qsq1(iloop)/flux(iloop)
          qsq2(iloop)=2.0*qsq2(iloop)/flux(iloop)
          qsq3(iloop)=3.0*qsq3(iloop)/flux(iloop)
          qsq4(iloop)=10.0*qsq4(iloop)/flux(iloop)
          stqsq1(iloop)=stqsq1(iloop)/flux(iloop)
          stqsq2(iloop)=2.0*stqsq2(iloop)/flux(iloop)
          stqsq3(iloop)=3.0*stqsq3(iloop)/flux(iloop)
          stqsq4(iloop)=10.0*stqsq4(iloop)/flux(iloop)
          call hopera(10+iloop,'+',10+iloop,110+iloop,0.,invlumi)
          call hopera(20+iloop,'+',20+iloop,120+iloop,0.,invlumi)
          idum=110+iloop
          call hzchisq(-idum,idum)
          idum=120+iloop
          call hzchisq(-idum,idum)
       enddo
*
       do iloop =1,4
          call hopera(30+iloop,'+',30+iloop,130+iloop,0.,invlumi)
          idum=130+iloop
          call hzchisq(-idum,idum)
       enddo
*
       call hpak(-131,qsq1)
       call hpak(-132,qsq2)
       call hpak(-133,qsq3)
       call hpak(-134,qsq4)
*
       call hpake(-131,stqsq1)
       call hpake(-132,stqsq2)
       call hpake(-133,stqsq3)
       call hpake(-134,stqsq4)
*
       Write(6,*) 'hz'//xxxx,' X-section is ',xsec
      Endif
*
      RETURN
*
      END
*CMZ :  1.01/14 24/03/98  09.56.35  by  Tancredi Carli
*CMZ :  1.01/13 20/03/98  16.58.18  by  Tancredi Carli
*-- Author :
************************************************************************
      Subroutine hz97183(iflag)
************************************************************************
* Subroutine hz97183                                                   *
* ==================                                                   *
*                                                                      *
* Author: Nick Brook (n.brook@physics.gla.ac.uk)                       *
*                                                                      *
* This routine plots the xp distbns                                    *
* in the current region of the Breit frame.                            *
* The distbn are corrected for particles coming from K0s and Lambdas   *
*                                                                      *
*                                                                      *
* Reference: Phys Lett B414(1997) 428.                                 *
*            DESY 97-183                                               *
*                                                                      *
************************************************************************
*
* HERA tuning defined commons
*
      Implicit Double Precision(A-H,O-Z)
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEND.
*
      COMMON/QUEST/IQUEST(100)
*
* Set up local variables
*
      Integer idum,ierr,nentry
      Character xxxx*5
      Real eb,ee
      Parameter (ee=27.5)
      Character*80 chtitl
      Character*2 cid
      Dimension plab(4), pbrt(4), pbeam(4), pgam(4), pgam5(5)
      Dimension qbins(8), xbins(5), qmean(11)
      Real chmean(10), chsig(10), xpmean
C*TC  Integer ids(11), Nacc(11),id, ncx
      Integer ids(11),id, ncx
      Real Nacc(11)
      Character*8 Tags(9)
      Real event(9)
      Integer iqu, iql, ixu, ixl
*
      Parameter(ncx=8)
      Real datx(8,11), datxe(8,11), datxsu(8,11), datxsl(8,11)
      Real logx(8), logxe(8), logxsu(8), logxsl(8)
      Real qdat(11)
      Real xpbins(9)
*
      Integer inbins
      Parameter(inbins=8)
      COMMON /ancmn/ meanq,lowq2,hiq2,lowxbj,highxbj,xp,xpstat,
     +                xpusys,xplsys
      Real  meanq, lowq2, hiq2,lowxbj,highxbj
      Real xp(8),xpstat(8),xpusys(8),xplsys(8)
      Real errtmp(8)
*
      Data nentry/0/
      Data xxxx/'97183'/
      data ids/12,13,23,33,24,34,44,54,65,75,55/
      Data xpbins/.02,.05,.1,.2,.3,.4,.5,.7,1./
      data Nacc /11*0./
*
* Data points from plots
*
      data qdat/14.4,14.7,28.1,54.7,29.2,56.7,
     +          110.,212.,440.,855.,222./
      data datx/1.49,2.83,3.58,2.79,1.68,.959,.389,.112,
     +          1.51,3.12,3.88,2.87,1.68,1.04,.438,.117,
     1          3.22,6.02,5.83,3.37,1.94,1.00,.428,.0941,
     2          7.98,10.7,7.27,3.80,1.78,.847,.387,.0793,
     3          3.53,6.55,6.16,3.66,1.95,1.07,.449,.107,
     4          8.14,10.8,8.29,4.08,1.99,.978,.389,.0801,
     5          15.5,16.8,9.33,4.03,1.73,.895,.391,.0658,
     6          26.8,21.4,10.2,3.69,1.86,.960,.280,.0912,
     7          41.4,25.6,9.68,3.69,1.35,.777,.374,.0498,
     8          52.0,28.1,9.15,4.11,1.95,.752,.297,.0162,
     9          26.8,24.2,10.5,4.25,1.94,.942,.284,.0638/
      data datxe/.103,.0952,.0734,.0644,.0488,.0361,.0152,.00649,
     +           .109,.111,.0809,.0667,.0491,.0382,.0165,.00647,
     1           .189,.188,.129,.0940,.0723,.0507,.0227,.00812,
     2           .414,.345,.197,.146,.0964,.0640,.0311,.0111,
     3           .185,.182,.121,.0899,.0642,.0467,.0207,.00775,
     4           .299,.246,.153,.106,.0732,.0503,.0221,.00763,
     5           .560,.439,.226,.151,.0935,.0669,.0326,.0105,
     6           1.31,.873,.436,.250,.184,.136,.0461,.0267,
     7           2.12,1.28,.548,.337,.191,.142,.0813,.0209,
     8           3.49,2.11,.801,.567,.415,.224,.0988,.0181,
     9           1.14,.868,.392,.254,.172,.116,.0402,.0151/
      data datxsu/.327,.337,.236,.136,.0742,.0256,.0751,.0328,
     +            .279,.108,.204,.282,.146,.0915,.0796,.0384,
     1            .659,.337,.184,.495,.175,.191,.0700,.0376,
     2            .547,.629,.559,.265,.146,.0747,.0643,.0256,
     3            .292,.618,.596,.275,.170,.271,.0774,.0429,
     4            .336,.856,.607,.462,.139,.203,.0459,.0253,
     5            .360,1.15,.664,.122,.210,.0547,.0458,.0157,
     6            1.63,1.69,.176,.128,.155,.000,.0925,.0291,
     7            1.63,1.34,.178,.0792,.118,.242,.000496,.0502,	
     8            1.31,1.08,.195,.664,.166,.215,.136,.0223,
     9            1.68,.796,.612,.113,.113,.211,.0922,.0254/
      data datxsl/.315,.232,.294,.242,.117,.128,.00106,.00596,
     +            .321,.359,.453,.416,.187,.171,.0519,.00572,
     1            .198,.973,.621,.437,.228,.0790,.0390,.00004,
     2            .778,1.02,.794,.0646,.0005,.0698,.0113,.00002,
     3            .411,.824,.985,.460,.224,.194,.0389,.0136,
     4            .550,1.09,.738,.358,.178,.104,.0274,.0126,
     5            1.92,.572,.424,.387,.110,.0611,.0252,.00531,
     6            2.12,.881,.528,.174,.0306,.235,.0242,.0235,
     7            1.57,1.11,.972,.304,.0573,.0332,.0843,.0219,
     8            2.67,3.01,.274,.243,.554,.158,.0478,.0184,
     9            2.03,2.44,.971,.447,.444,.135,.0593,.00043/
*
      If(iflag.eq.1) then
*
* Initialisation: The following MUST always be done
* (i) make subdirectory in PAWC
*      - use the name as the xxxxxx in HZxxxxxx subroutine
* (i) make subdirectory in o/p file
*
        Call hcdir('//PAWC',' ')
        call hmdir('97183','S')
        Call hcdir('//HISTO',' ')
        call hmdir('97183','S')
*
* book your histograms
*
        Do kd = 1, 11
          write(cid,'(I2)') ids(kd)
          call hbookb(ids(kd),' xp ('//cid//')',
     +                ncx,xpbins,0.)
*         call hbookb(-ids(kd),' xp ('//cid//')',
*    +                ncx,xpbins,0.)
*         call hbookb(-1000-ids(kd),' xp ('//cid//')',
*    +                ncx,xpbins,0.)
        Enddo
        Call hbnt(1000,'Monte Carlo',' ')
        Call Hbname(1000,'MC',meanq,'meanq:r,lowq2:r,hiq2:r'
     + //',lowxbj:r,highxbj:r,xp(8):r,xpstat(8):r')
        Call hbnt(2000,'Data',' ')
        Call Hbname(2000,'DAT',meanq,'meanq:r,lowq2:r,hiq2:r,'
     + //'lowxbj:r,highxbj:r,xp(8):r,xpstat(8):r,'
     1 //'xpusys(8):r,xplsys(8):r')
*
* set your plot/paper specific cuts
*
        qbins(1) = 10.
        qbins(2) = 20.
        qbins(3) = 40.
        qbins(4) = 80.
        qbins(5) = 160.
        qbins(6) = 320.
        qbins(7) = 640.
        qbins(8) = 1280.
        xbins(1) = 6.0e-04
        xbins(2) = 1.2e-03
        xbins(3) = 2.4e-03
        xbins(4) = 1.0e-02
        xbins(5) = 5.0e-02
*
      Else if(iflag.eq.2) then
* Filling: The following MUST always be done
* (i) move to the correct sub-directory in PAWC
*
        call hcdir('//PAWC/97183',' ')
        q2  = hzdiskin(1)
        xbj = hzdiskin(2)
        If(q2.ge.qbins(1).and.q2.lt.qbins(2).and.
     +     xbj.ge.xbins(1).and.xbj.lt.xbins(2)) then
           id = 12
           Nacc(1) = Nacc(1) + wtx
           qmean(1) = qmean(1) + q2
        Else If(q2.ge.qbins(1).and.q2.lt.qbins(2).and.
     +     xbj.ge.xbins(2).and.xbj.lt.xbins(3)) then
           id = 13
           Nacc(2) = Nacc(2) + wtx
           qmean(2) = qmean(2) + q2
        Else If(q2.ge.qbins(2).and.q2.lt.qbins(3).and.
     +     xbj.ge.xbins(2).and.xbj.lt.xbins(3)) then
           id = 23
           Nacc(3) = Nacc(3) + wtx
           qmean(3) = qmean(3) + q2
        Else If(q2.ge.qbins(3).and.q2.lt.qbins(4).and.
     +     xbj.ge.xbins(2).and.xbj.lt.xbins(3)) then
           id = 33
           Nacc(4) = Nacc(4) + wtx
           qmean(4) = qmean(4) + q2
        Else If(q2.ge.qbins(2).and.q2.lt.qbins(3).and.
     +     xbj.ge.xbins(3).and.xbj.lt.xbins(4)) then
           id = 24
           Nacc(5) = Nacc(5) + wtx
           qmean(5) = qmean(5) + q2
        Else If(q2.ge.qbins(3).and.q2.lt.qbins(4).and.
     +     xbj.ge.xbins(3).and.xbj.lt.xbins(4)) then
           id = 34
           Nacc(6) = Nacc(6) + wtx
           qmean(6) = qmean(6) + q2
        Else If(q2.ge.qbins(4).and.q2.lt.qbins(5).and.
     +     xbj.ge.xbins(3).and.xbj.lt.xbins(4)) then
           id = 44
           Nacc(7) = Nacc(7) + wtx
           qmean(7) = qmean(7) + q2
        Else If(q2.ge.qbins(5).and.q2.lt.qbins(6).and.
     +     xbj.ge.xbins(3).and.xbj.lt.xbins(4)) then
           id = 54
           Nacc(8) = Nacc(8) + wtx
           qmean(8) = qmean(8) + q2
        Else If(q2.ge.qbins(6).and.q2.lt.qbins(7).and.
     +     xbj.ge.xbins(4).and.xbj.lt.xbins(5)) then
           id = 65
           Nacc(9) = Nacc(9) + wtx
           qmean(9) = qmean(9) + q2
        Else If(q2.ge.qbins(7).and.q2.lt.qbins(8).and.
     +     xbj.ge.xbins(4).and.xbj.lt.xbins(5)) then
           id = 75
           Nacc(10) = Nacc(10) + wtx
           qmean(10) = qmean(10) + q2
        Else If(q2.ge.qbins(5).and.q2.lt.qbins(6).and.
     +     xbj.ge.xbins(4).and.xbj.lt.xbins(5)) then
           id = 55
           Nacc(11) = Nacc(11) + wtx
           qmean(11) = qmean(11) + q2
        Else
           Return
        Endif
*
* Fill your histograms
*
          jel = hzidelec(idum)
          if(jel.lt.0) Return
          if(hzipgam(pgam5).lt.0) Return
          if(hzibeam(ip,il).ne.1) Return
* check on electron beam energy
          nentry=nentry+1
          ierr=HZIBEAM(ibeam,idum)
          if (.not.(ierr.eq.1)) then
           write(6,*) 'HZ'//xxxx,' beams not found ! '
           return
          endif
*
          eb=real(PHEP(4,idum))
          if (abs(abs(eb)-ee).gt.0.3) then
           if (nentry.lt.10) then
            write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,'  ! '
           elseif (nentry.eq.10) then
            write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &      ' ...last message ! '
           endif
           return
          endif

          do ivec = 1, 4
            pbeam(ivec) = phep(ivec,ip)
            pgam(ivec) = pgam5(ivec)
          enddo
          Call hzbrtini(pbeam,pgam,ierr)
          do 30 ihep = 1, nhep
            If(isthep(ihep).eq.1.and.ihchrg(ihep).ne.0
     +         .and.ihep.ne.jel) then
             idpart=abs(idhep(jmohep(1,ihep)))
             If(idpart.eq.310.or.idpart.eq.3122) goto 30
             do ivec=1,4
               plab(ivec) = phep(ivec,ihep)
             enddo
             Call hzbrt(plab,pbrt,ierr)
             if(pbrt(3).lt.0.) then
               xpp = 2.*sqrt(pbrt(1)**2+pbrt(2)**2+pbrt(3)**2)
     +               /sqrt(q2)
               call hfill(id,real(xpp),0.,wtx)
             endif
            Endif
 30       continue
*
      Else if(iflag.eq.3) then
* Termination: The following MUST always be done
* (i) Move to the correct PAW subdirectory
*
        call hcdir('//PAWC/97183',' ')
*
* Histo manipulation
* Deal with data plots
*
        Do kd = 1, 11
*
          if(kd.eq.1) then
            iql = 1
            iqu = 2
            ixl = 1
            ixu = 2
          else if(kd.eq.2) then
            iql = 1
            iqu = 2
            ixl = 2
            ixu = 3
          else if(kd.eq.3) then
            iql = 2
            iqu = 3
            ixl = 2
            ixu = 3
          else if(kd.eq.4) then
            iql = 3
            iqu = 4
            ixl = 2
            ixu = 3
          else if(kd.eq.5) then
            iql = 2
            iqu = 3
            ixl = 3
            ixu = 4
          else if(kd.eq.6) then
            iql = 3
            iqu = 4
            ixl = 3
            ixu = 4
          else if(kd.eq.7) then
            iql = 4
            iqu = 5
            ixl = 3
            ixu = 4
          else if(kd.eq.8) then
            iql = 5
            iqu = 6
            ixl = 3
            ixu = 4
          else if(kd.eq.9) then
            iql = 6
            iqu = 7
            ixl = 4
            ixu = 5
          else if(kd.eq.10) then
            iql = 7
            iqu = 8
            ixl = 4
            ixu = 5
          else if(kd.eq.11) then
            iql = 5
            iqu = 6
            ixl = 4
            ixu = 5
          Endif
          lowq2 = sngl(qbins(iql))
          hiq2 = sngl(qbins(iqu))
          lowxbj = sngl(xbins(ixl))
          highxbj = sngl(xbins(ixu))
          nacc(kd) = max(1.,nacc(kd))
          qmean(kd) = qmean(kd)/dble(nacc(kd))
          meanq = sngl(qmean(kd))
          Call hzhinrm(ids(kd),0,nacc(kd),1)
          call hzhinfo(ids(kd),nacc(kd))
          Call hunpak(ids(kd),xp,' ',0)
          Call hunpke(ids(kd),xpstat,' ',0)
          Call hfnt(1000)
          id=-1000-ids(kd)
          call hbookb(id,' xp ',ncx,xpbins,0.)
          Call ucopy(datx(1,kd),logx,8)
          Call ucopy(datxe(1,kd),logxe,8)
          Call hpak(id,logx)
          Call hpake(id,logxe)
          meanq = qdat(kd)
          call ucopy(logx,xp,8)
          call ucopy(logxe,xpstat,8)
          Call ucopy(datxsu(1,kd),xpusys,8)
          Call ucopy(datxsl(1,kd),xplsys,8)
          do kerr = 1, 8
            errtmp(kerr) = sqrt(xpstat(kerr)**2+xpusys(kerr)**2)
          enddo
          id=-ids(kd)
          call hbookb(id,' xp ',ncx,xpbins,0.)
          call hpak(id,xp)
          Call hpake(id,errtmp)
          do kerr = 1, 8
            errtmp(kerr) = sqrt(xpstat(kerr)**2+xplsys(kerr)**2)
          enddo
          id1=-2000-ids(kd)
          call hbookb(id1,' xp ',ncx,xpbins,0.)
          call hpak(id1,xp)
          Call hpake(id1,errtmp)
*         Write(6,*) 'logx,xp: ',logx,xp
          Call hfnt(2000)
*
          call HZCHISQ(-1000-ids(kd),ids(kd))
          Call hzchisqa(id,id1,ids(kd))
          Call hdelet(id)
          Call hdelet(id1)
        Enddo

      Endif
*
      Return
 1001 Format(/,1X,' bin # ',I2,' Mean Q = ',F4.1)
 1002 Format(A,F4.2,A,F4.2)
 1003 Format(A,F4.2,A,F4.2,A,F4.2)
      End
*CMZ :  2.00/05 31/07/2000  21.21.26  by  Tancredi Carli
*CMZ :  2.00/04 31/07/2000  17.46.09  by  Tancredi Carli
*CMZ :  1.02/01 23/10/98  17.54.38  by  Tancredi Carli
*CMZ :  1.02/00 02/10/98  17.54.18  by  Tancredi Carli
*-- Author :
        Subroutine HZ97191(iflag)
*****************************************************************************
* This photoproduction routine has to be run twice with the following
* code additions:
*       +1000 for the DIRECT component run.
*       +2000 for the RESOLVED component run.
* for all three phases (iflag=1,2,3)
*
* iflag = 1,2 or 3 depending on wether it is the initialization,
*               processing or termination phase (respectively)
*
* The default jetfinder is PXCONE
* To change jetfinder use these values to call the initialisation phase.
* 1 + 10 * (jetfinder number)
*
* This routine produces sixteen Monte Carlo graphs.
*        for inclusive jet production: (jet profiles)
*           10  |  14 < ET <= 17
*           11  |  17 < ET <= 21
*           12  |  21 < ET <= 25
*           13  |  25 < ET <= 29
*           20  |  -1 < rap < 0
*           21  |   0 < rap < 1
*           22  |   1 < rap < 1.5
*           23  | 1.5 < rap < 2
*           15  |  r=0.5 ET
*           25  |  r=0.5 rap
*        for dijet events: (jet profiles)
*           30  |  -1 < rap < 0
*           31  |   0 < rap < 1
*           32  |   1 < rap < 1.5
*           33  | 1.5 < rap < 2
*           40  | xg > 0.75 and -1 < rap < 0
*           41  | xg < 0.75 and  0 < rap < 1
*
* Cuts :        Q2 < 4 GeV^2
*               0.2 < y_jb < 0.85
*               Et > 14 GeV
*               -1 <eta1,eta2 <2
*
* Recommended value for Ptmin is 8 GeV (to be set in MC set up)
*
* Author : Mark Hayes (mhayes@zow.desy.de)
*
* Reference : DESY-97-191 accepted by ZfP. hep-ex/9710002
*
*
*****************************************************************************
*
* HERA Tuning defined commons

        IMPLICIT NONE

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.

c *** INCLUSIVE jet results
c *** a is -1<eta<0, b is 0<eta<1, c is 1<eta<1.5, d is 1.5<eta<2
c *** in bins of eta
        REAL cs1a(9),sta1a(9)
        DATA cs1a/0.573,0.710,0.794,0.855,0.899,0.934,0.960,0.981,1.0/
        DATA sta1a/0.008,0.006,0.005,0.004,0.003,0.002,0.001,0.001,0.0/
        REAL cs1b(9),sta1b(9)
        DATA cs1b/0.528,0.672,0.763,0.829,0.879,0.918,0.951,0.977,1.0/
        DATA sta1b/0.005,0.004,0.003,0.003,0.002,0.001,0.001,0.001,0.0/
        REAL cs1c(9),sta1c(9)
        DATA cs1c/0.446,0.597,0.709,0.788,0.847,0.896,0.937,0.971,1.0/
        DATA sta1c/0.007,0.007,0.006,0.005,0.004,0.003,0.002,0.001,0.0/
        REAL cs1d(9),sta1d(9)
        DATA cs1d/0.381,0.533,0.647,0.734,0.807,0.865,0.914,0.960,1.0/
        DATA sta1d/0.006,0.006,0.005,0.004,0.003,0.003,0.002,0.001,0.0/
c *** a 14<et<17, b is 17<et<21, c is 21<et<25, d is 25<et<29
c *** in bins of et
        REAL cs2a(9),sta2a(9)
        DATA cs2a/0.446,0.599,0.707,0.786,0.846,0.895,0.935,0.971,1.0/
        DATA sta2a/0.004,0.004,0.003,0.002,0.002,0.001,0.001,0.001,0.0/
        REAL cs2b(9),sta2b(9)
        DATA cs2b/0.521,0.665,0.752,0.820,0.872,0.914,0.946,0.975,1.0/
        DATA sta2b/0.006,0.006,0.005,0.004,0.003,0.002,0.001,0.001,0.0/
        REAL cs2c(9),sta2c(9)
        DATA cs2c/0.584,0.722,0.806,0.859,0.902,0.934,0.960,0.981,1.0/
        DATA sta2c/0.011,0.010,0.008,0.006,0.005,0.003,0.002,0.001,0.0/
        REAL cs2d(9),sta2d(9)
        DATA cs2d/0.611,0.736,0.822,0.875,0.917,0.947,0.968,0.985,1.0/
        DATA sta2d/0.018,0.015,0.012,0.009,0.006,0.004,0.003,0.002,0.0/
c *** in eta r=0.5
        REAL cs3(4),sta3(4),xbins3(5)
        DATA xbins3/-1.0,0.0,1.0,1.5,2.0/
        DATA cs3/0.855,0.829,0.788,0.734/
        DATA sta3/0.004,0.003,0.005,0.004/
c *** in et r=0.5
        REAL cs4(4),sta4(4),xbins4(5)
        DATA xbins4/14.0,17.0,21.0,25.0,29.0/
        DATA cs4/0.786,0.820,0.859,0.875/
        DATA sta4/0.002,0.004,0.006,0.009/
c *** DIJET results
c *** a is -1<eta<0, b is 0<eta<1, c is 1<eta<1.5, d is 1.5<eta<2
c *** in bins of eta
        REAL cs5a(9),sta5a(9)
        DATA cs5a/0.611,0.747,0.822,0.877,0.914,0.946,0.967,0.985,1.0/
        DATA sta5a/0.013,0.010,0.009,0.007,0.005,0.003,0.002,0.001,0.0/
        REAL cs5b(9),sta5b(9)
        DATA cs5b/0.568,0.713,0.799,0.859,0.904,0.937,0.963,0.984,1.0/
        DATA sta5b/0.007,0.006,0.005,0.004,0.003,0.002,0.001,0.001,0.0/
        REAL cs5c(9),sta5c(9)
        DATA cs5c/0.521,0.666,0.767,0.835,0.888,0.929,0.957,0.980,1.0/
        DATA sta5c/0.012,0.010,0.008,0.007,0.005,0.003,0.002,0.001,0.0/
        REAL cs5d(9),sta5d(9)
        DATA cs5d/0.487,0.628,0.733,0.803,0.862,0.908,0.942,0.975,1.0/
        DATA sta5d/0.010,0.009,0.008,0.006,0.004,0.003,0.002,0.001,0.0/
c *** a is xg<0.75 b is xg>0.75
c *** in bin -1<eta<2, ET>14
        REAL cs6a(9),sta6a(9)
        DATA cs6a/0.494,0.634,0.736,0.807,0.865,0.911,0.947,0.976,1.0/
        DATA sta6a/0.008,0.007,0.006,0.005,0.004,0.003,0.002,0.001,0.0/
        REAL cs6b(9),sta6b(9)
        DATA cs6b/0.591,0.726,0.809,0.865,0.909,0.942,0.965,0.984,1.0/
        DATA sta6b/0.006,0.005,0.004,0.003,0.002,0.002,0.001,0.001,0.0/
        Integer chjet
        SAVE chjet
C --- choose same jet finder as in the paper --- PXCONE
        DATA chjet/2/
        CHARACTER*6 jetf

C --- information returned by jet finder
        INTEGER NJET
        DOUBLE PRECISION Jets(50,8)
        DOUBLE PRECISION CONER

C --- cuts arrays
        DOUBLE PRECISION ybjcut(2),q2cut(2)
        DOUBLE PRECISION rapcut(2),Etcut(4)
C --- photoproduction cuts
        DATA ybjcut/0.2,0.85/
        DATA q2cut/0.0,4/
        DATA Etcut/14.0,14.0,14.0,14.0/
        DATA rapcut/-1.0,2.0/

C --- private copies of Xsec and Ntot from HERACMN
        DOUBLE PRECISION mhxsec(2)
        INTEGER mhntot(2)

c ---
        INTEGER nbins
        PARAMETER(nbins=9)
        DOUBLE PRECISION myr(nbins)
        DATA myr/0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0/
        DOUBLE PRECISION elecE
        INTEGER myil,myip,loop,i,j,gr,gr2
        DOUBLE PRECISION xgam,distr2
        DOUBLE PRECISION px,py,pz,ptsq,ppsq,pet,pphi,prap
        DOUBLE PRECISION phi(2),rap(2),Et(2)
        DOUBLE PRECISION ybj,q2
        REAL cont(4),tot
        INTEGER intiflag, iproc, iflag
        INTEGER hzflag

        REAL pttemp(12)
        INTEGER ivec,jvec
        REAL HI

C --- choose direct/resolved
C --- recommend 1 - DIRECT, 2 - RESOLVED
        IF (iflag.gt.1000) THEN
          iproc=INT(iflag/1000)
          intiflag=MOD(iflag,1000)
        ENDIF
        IF ((iproc.gt.2).or.(iproc.lt.1)) THEN
          PRINT*,'HZ97191 : Badly called routine'
          PRINT*,'          please set intiflag +1000 or +2000'
        ENDIF

C --- choose jet finder
        IF ((intiflag.gt.10).and.(MOD(intiflag,10).eq.1)) THEN
          chjet=INT(intiflag/10)
          intiflag=MOD(intiflag,10)
        ENDIF

        IF (intiflag.eq.1) THEN
C *** Initialisation run ***
C *** Create directories ***
          IF (iproc.eq.1) THEN
            CALL HCDIR('//HISTO',' ')
            CALL HMDIR('97191','S')
            CALL HCDIR('//PAWC',' ')
            CALL HMDIR('97191','S')

            CALL HBOOK1(10,'MC r 14.lt.ET.le.17'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(11,'MC r 17.lt.ET.le.21'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(12,'MC r 21.lt.ET.le.25'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(13,'MC r 25.lt.ET.le.29'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(20,'MC r -1.lt.rap.lt.0'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(21,'MC r 0.lt.rap.lt.1'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(22,'MC r 1.lt.rap.lt.1.5'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(23,'MC r 1.5.lt.rap.lt.2'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOKB(15,'MC r=0.5 ET'
     +           ,4, xbins4, 0.)
            CALL HBOOKB(25,'MC r=0.5 [c]'
     +           ,4, xbins3, 0.)
            CALL HBOOK1(30,'MC DIJET r -1.lt.rap.lt.0'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(31,'MC DIJET r 0.lt.rap.lt.1'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(32,'MC DIJET r 1.lt.rap.lt.1.5'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(33,'MC DIJET r 1.5.lt.rap.lt.2'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(40,'MC DIJET DIR r -1.lt.rap.lt.0'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(41,'MC DIJET RES r 0.lt.rap.lt.1'
     +           ,nbins, 0.15, 1.05, 0.)
          ENDIF
          CALL HCDIR('//HISTO/97191',' ')
          CALL HCDIR('//PAWC/97191',' ')
          CALL HBOOK1(iproc*100+10,'MC r 14.lt.ET.le.17'
     +           ,nbins, 0.15, 1.05, 0.)
          CALL HBOOK1(iproc*100+11,'MC r 17.lt.ET.le.21'
     +           ,nbins, 0.15, 1.05, 0.)
          CALL HBOOK1(iproc*100+12,'MC r 21.lt.ET.le.25'
     +           ,nbins, 0.15, 1.05, 0.)
          CALL HBOOK1(iproc*100+13,'MC r 25.lt.ET.le.29'
     +           ,nbins, 0.15, 1.05, 0.)
          CALL HBOOK1(iproc*100+20,'MC r -1.lt.rap.lt.0'
     +           ,nbins, 0.15, 1.05, 0.)
          CALL HBOOK1(iproc*100+21,'MC r 0.lt.rap.lt.1'
     +           ,nbins, 0.15, 1.05, 0.)
          CALL HBOOK1(iproc*100+22,'MC r 1.lt.rap.lt.1.5'
     +           ,nbins, 0.15, 1.05, 0.)
          CALL HBOOK1(iproc*100+23,'MC r 1.5.lt.rap.lt.2'
     +           ,nbins, 0.15, 1.05, 0.)
          CALL HBOOK1(iproc*100+30,'MC DIJET r -1.lt.rap.lt.0'
     +           ,nbins, 0.15, 1.05, 0.)
          CALL HBOOK1(iproc*100+31,'MC DIJET r 0.lt.rap.lt.1'
     +           ,nbins, 0.15, 1.05, 0.)
          CALL HBOOK1(iproc*100+32,'MC DIJET r 1.lt.rap.lt.1.5'
     +           ,nbins, 0.15, 1.05, 0.)
          CALL HBOOK1(iproc*100+33,'MC DIJET r 1.5.lt.rap.lt.2'
     +           ,nbins, 0.15, 1.05, 0.)
          CALL HBOOK1(iproc*100+40,'MC DIJET DIR r -1.lt.rap.lt.0'
     +           ,nbins, 0.15, 1.05, 0.)
          CALL HBOOK1(iproc*100+41,'MC DIJET RES r 0.lt.rap.lt.1'
     +           ,nbins, 0.15, 1.05, 0.)
c --- number of events counted with jets in
          mhntot(iproc)=0


C --- standard cone radius is 1.0
          CALL HZJETRAD(2,CONER)
          IF (CONER.lt.0.0) THEN
             CONER=1.0
          ENDIF
          CALL HZJTNAME(chjet,jetf)

          WRITE(6,*)'**********************************************'
          WRITE(6,*)'* HZ97191 called, histograms will be output. *'
          WRITE(6,*)'*     Jet finder selected : ',jetf,'           *'
          WRITE(6,1001)'*        with cone radius : ',CONER,'   *'
          WRITE(6,*)'**********************************************'

 1001     FORMAT(A29,F5.2,A13)

        ELSE IF (intiflag.eq.2) THEN
C *** Filling runs ***

C *** Change directory to our graphs ***
          CALL HCDIR('//PAWC/97191',' ')

          q2=hzphokin(1)
          IF (q2.eq.-1) THEN
            PRINT*,'HZ97191: HZPHOKIN returns error for Q2'
          ELSEIF (q2.lt.0) THEN
            q2=abs(q2)
          ENDIF
          ybj=hzphokin(3)
          IF (ybj.eq.-1) THEN
            PRINT*,'HZ97191: HZPHOKIN returns error for ybj'
          ENDIF

C *** Fill our histogram ***

          IF ((ybj.ge.ybjcut(1)).and.(ybj.le.ybjcut(2))
     &          .and.(q2.lt.q2cut(2))) Then

          elecE=27.5
          hzflag=HZIBEAM(myip,myil)
          IF (hzflag.ge.0) Then
            elecE=abs(PHEP(4,myil))
          ELSE
            PRINT*,'HZ97191: Electron not found. E=0.001'
            PRINT*,'         event will be rejected'
            elecE=0.001
          ENDIF

            CALL hzjtfind(chjet,CONER,NJET,Jets)

            IF (NJET.ge.1) THEN
              DO loop=1,NJET
                Et(1)=Jets(loop,3)
                phi(1)=Jets(loop,2)
                rap(1)=Jets(loop,1)
                IF (rap(1).ge.rapcut(1).and.rap(1).le.rapcut(2)
     +             .and.Et(1).gt.etcut(1)) THEN
                   IF (loop.eq.2) THEN
                      xgam=(Et(1)*exp(-1*rap(1))+Et(2)*exp(-1*rap(2)))
     +                       /(2*ybj*elecE)
                   ENDIF
               DO i=1,NHEP
                 IF (ISTHEP(i).eq.1) THEN
                    px=PHEP(1,i)
                    py=PHEP(2,i)
                    pz=PHEP(3,i)
                    ptsq=px**2+py**2
                    ppsq=(SQRT(ptsq+pz**2)+ABS(pz))**2
                    IF (ptsq.le.4.25E-18*ppsq) THEN
                      prap=20
                    ELSE
                      prap=0.5*LOG(ppsq/ptsq)
                    ENDIF
                    prap=SIGN(prap,pz)
                    IF (ptsq.EQ.0) THEN
                       pphi=0
                    ELSE
                       pphi=ATAN2(py,px)
                    ENDIF
                    distr2=(prap-rap(1))**2+(pphi-phi(1))**2
                    pet=PHEP(4,i)*SQRT(ptsq/(ptsq+pz**2))
                    gr=iproc*100+10
                    IF (ET(1).gt.17.and.Et(1).lt.21) gr=gr+1
                    IF (ET(1).gt.21.and.Et(1).lt.25) gr=gr+2
                    IF (ET(1).gt.25.and.Et(1).lt.29) gr=gr+3
                    gr2=iproc*100+20
                    IF (rap(1).gt.0.0.and.rap(1).lt.1.0) gr2=gr2+1
                    IF (rap(1).gt.1.0.and.rap(1).lt.1.5) gr2=gr2+2
                    IF (rap(1).gt.1.5.and.rap(1).lt.2.0) gr2=gr2+3
                    DO j=1,nbins
                      IF (distr2.lt.myr(j)**2) THEN
                         CALL HF1(gr,REAL(j*0.1+0.10),REAL(pet))
                         CALL HF1(gr2,REAL(j*0.1+0.10),REAL(pet))
                         IF (loop.eq.2) THEN
                         CALL HF1(gr2+10,REAL(j*0.1+0.10),REAL(pet))
                         IF (xgam.gt.0.75) THEN
                      CALL HF1(iproc*100+40,REAL(j*0.1+0.10),REAL(pet))
                         ELSE
                      CALL HF1(iproc*100+41,REAL(j*0.1+0.10),REAL(pet))
                         ENDIF ! which xgamma bin
                         ENDIF ! loop=2 i.e. DIJET event
                      ENDIF ! inside a certain radius
                    ENDDO ! over all radii
                  ENDIF ! final state particle
                ENDDO   ! scan of HEPEVT
              ENDIF ! rapcut and etcut
              ENDDO ! loop over jets
            ENDIF ! NJET.ge.1
          ENDIF         ! Q2 & y cuts

        ELSE IF (intiflag.eq.3) THEN
C *** Termination run ***
C *** Change directory ***
          CALL HCDIR('//PAWC/97191',' ')
C *** Finish off histograms ***
          IF (Ntot.eq.0) THEN
            PRINT*,'HZ97191: termination called with no total events'
            PRINT*,'          in process :',iproc*1000
            Ntot=1
          ENDIF


          IF (iproc.eq.2) THEN
C --- only finally
C --- create proper cross-section data
            CALL HBOOK1(-10,'r (14"l#E?t!"l#17)'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(-11,'r (17"l#E?t!"l#21)'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(-12,'r (21"l#E?t!"l#25)'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(-13,'r (25"l#E?t!"l#29)'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(-20,'r (-1"l#[c]"l#0)'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(-21,'r (0"l#[c]"l#1)'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(-22,'r (1"l#[c]"l#1.5)'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(-23,'r (1.5"l#[c]"l#2)'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOKB(-15,'(r=0.5) E?t!'
     +           ,4, xbins4, 0.)
            CALL HBOOKB(-25,'(r=0.5) [c]'
     +           ,4, xbins3, 0.)
            CALL HBOOK1(-30,'DIJET r (-1"l#[c]"l#0)'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(-31,'DIJET r (0"l#[c]"l#1)'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(-32,'DIJET r (1"l#[c]"l#1.5)'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(-33,'DIJET r (1.5"l#[c]"l#2)'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(-40,'DIJET DIR r'
     +           ,nbins, 0.15, 1.05, 0.)
            CALL HBOOK1(-41,'DIJET RES r'
     +           ,nbins, 0.15, 1.05, 0.)

            CALL HPAK(-10,cs2a)
            CALL HPAKE(-10,sta2a)
            CALL HPAK(-11,cs2b)
            CALL HPAKE(-11,sta2b)
            CALL HPAK(-12,cs2c)
            CALL HPAKE(-12,sta2c)
            CALL HPAK(-13,cs2d)
            CALL HPAKE(-13,sta2d)
            CALL HPAK(-20,cs1a)
            CALL HPAKE(-20,sta1a)
            CALL HPAK(-21,cs1b)
            CALL HPAKE(-21,sta1b)
            CALL HPAK(-22,cs1c)
            CALL HPAKE(-22,sta1c)
            CALL HPAK(-23,cs1d)
            CALL HPAKE(-23,sta1d)
            CALL HPAK(-15,cs4)
            CALL HPAKE(-15,sta4)
            CALL HPAK(-25,cs3)
            CALL HPAKE(-25,sta3)
            CALL HPAK(-30,cs5a)
            CALL HPAKE(-30,sta5a)
            CALL HPAK(-31,cs5b)
            CALL HPAKE(-31,sta5b)
            CALL HPAK(-32,cs5c)
            CALL HPAKE(-32,sta5c)
            CALL HPAK(-33,cs5d)
            CALL HPAKE(-33,sta5d)
            CALL HPAK(-40,cs6b)
            CALL HPAKE(-40,sta6b)
            CALL HPAK(-41,cs6a)
            CALL HPAKE(-41,sta6a)

C --- now calculate cross-section graphs 10,20
            DO i=1,4
            DO loop=0,3
            IF (i.ne.4.or.loop.lt.2) THEN
            cont(1)=HI(100+i*10+loop,nbins)
            cont(2)=HI(200+i*10+loop,nbins)
            tot=cont(1)+cont(2)
            IF (cont(1).eq.0.0) cont(1)=1.0
            IF (cont(2).eq.0.0) cont(2)=1.0
            IF (tot.eq.0.0) tot=1.0

            CALL HOPERA(100+i*10+loop,'+e',200+i*10+loop,i*10+loop,
     &           REAL(1.0/tot), REAL(1.0/tot))
            CALL HOPERA(100+i*10+loop,'+e',100+i*10+loop,100+i*10+loop,
     &           REAL(1.0/cont(1)), 0.)
            CALL HOPERA(200+i*10+loop,'+e',200+i*10+loop,200+i*10+loop,
     &           REAL(1.0/cont(2)), 0.)
            CALL HZCHISQ(-(i*10)-loop,(i*10)+loop)
            ENDIF !only graphs 40,41 (no 42,43)
            ENDDO !loop
            ENDDO !i
            DO j=1,4
              cont(j)=HI(10+(j-1),4)
            ENDDO ! j
            CALL HPAK(15,cont)
            DO j=1,4
              cont(j)=HI(20+(j-1),4)
            ENDDO ! j
            CALL HPAK(25,cont)
          ENDIF

        ELSE
C *** End ***
          PRINT*,'HZ97191:Please run routine with iflag set to 1,2 or 3'
          PRINT*,'        with +1000 or +2000 for DIR or RES events.'
        ENDIF

        RETURN
        END
*CMZ :  1.02/01 23/10/98  17.56.17  by  Tancredi Carli
*CMZ :  1.02/00 02/10/98  17.55.57  by  Tancredi Carli
*-- Author :
        Subroutine HZ97196(iflag)
*****************************************************************************
* This photoproduction routine has to be run twice with the following
* code additions:
*       +1000 for the DIRECT component run.
*       +2000 for the RESOLVED component run.
* for all three phases (iflag=1,2,3)
*
* iflag = 1,2 or 3 depending on wether it is the initialization,
*               processing or termination phase (respectively)
*
* The default jetfinder is KTCLUS
* To change jetfinder use these values to call the initialisation phase.
* 1 + 10 * (jetfinder number)
*
* This routine produces eight Monte Carlo graphs:
*               graphs 10,11,12,13 are for xg<0.75 for ET>6,8,11,15 resp.
*               graphs 20,21,22,23 are for xg<0.75 for ET>6,8,11,15 resp.
* It also outputs the corresponding data points (stat+sys errors)
*               graphs -10,-11,-12,-13,-20,-21,-22,-23
*
* Cuts :        Q2 < 4 GeV^2
*               0.2 < y_bj < 0.8
*               Et > 6,8,11,15 GeV
*               |delta_eta| < 0.5
*
* Recommended value for Ptmin is 2.5 GeV (to be set in MC set up)
*
* Author : Mark Hayes (mhayes@zow.desy.de)
*
* Reference : DESY-97-196
*             Eur. Phys. J. C 1 (1998) 1/2, 109-122 hep-ex/9710018
*
*****************************************************************************
*
* HERA Tuning defined commons

        IMPLICIT NONE

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.

c *** a is >6, b>8, c>11, d>15
c *** Data for DIRECT xg>0.75
        REAL cs1a(9),sta1a(9)
        DATA cs1a/0.22,0.66,1.12,1.32,1.48,1.46,1.05,0.49,0.22/
        DATA sta1a/0.03,0.05,0.07,0.07,0.07,0.07,0.06,0.04,0.03/
        REAL sys1a(9)
        DATA sys1a/0.12,0.10,0.22,0.15,0.22,0.13,0.11,0.09,0.05/
        REAL cs1b(8),sta1b(8)
        DATA cs1b/0.06,0.36,0.55,0.56,0.60,0.60,0.42,0.22/
        DATA sta1b/0.01,0.04,0.05,0.04,0.04,0.04,0.04,0.03/
        REAL sys1b(8)
        DATA sys1b/0.06,0.03,0.09,0.08,0.05,0.05,0.08,0.04/
        REAL cs1c(4),sta1c(4)
        DATA cs1c/0.19,0.22,0.20,0.04/
        DATA sta1c/0.02,0.02,0.02,0.01/
        REAL sys1c(4)
        DATA sys1c/0.04,0.03,0.03,0.01/
        REAL cs1d(4),sta1d(4)
        DATA cs1d/0.033,0.082,0.078,0.035/
        DATA sta1d/0.008,0.012,0.011,0.007/
        REAL sys1d(4)
        DATA sys1d/0.006,0.014,0.014,0.009/
c *** Data for RESOLVED 0.3<xg<0.75
        REAL cs2a(8),sta2a(8)
        DATA cs2a/0.56,0.89,1.35,1.47,1.49,1.16,0.57,0.26/
        DATA sta2a/0.05,0.06,0.07,0.07,0.08,0.07,0.05,0.03/
        REAL sys2a(8)
        DATA sys2a/0.20,0.24,0.33,0.19,0.36,0.15,0.14,0.07/
        REAL cs2b(8),sta2b(8)
        DATA cs2b/0.09,0.25,0.37,0.45,0.59,0.55,0.31,0.23/
        DATA sta2b/0.02,0.03,0.03,0.04,0.05,0.05,0.03,0.03/
        REAL sys2b(8)
        DATA sys2b/0.08,0.04,0.06,0.09,0.25,0.07,0.09,0.05/
        REAL cs2c(3),sta2c(3)
        DATA cs2c/0.08,0.16,0.11/
        DATA sta2c/0.01,0.02,0.01/
        REAL sys2c(3)
        DATA sys2c/0.03,0.06,0.03/
        REAL cs2d(3),sta2d(3)
        DATA cs2d/0.013,0.046,0.033/
        DATA sta2d/0.004,0.008,0.006/
        REAL sys2d(3)
        DATA sys2d/0.009,0.026,0.006/
c *** bin widths
        REAL bw(4)
        DATA bw/0.25,0.25,0.5,0.5/
        Integer chjet
        SAVE chjet
C --- choose same jet finder as in the paper --- KTCLUS
        DATA chjet/3/
        CHARACTER*6 jetf

C --- information returned by jet finder
        INTEGER NJET
        DOUBLE PRECISION Jets(50,8)
        DOUBLE PRECISION CONER

C --- cuts arrays
        DOUBLE PRECISION ybjcut(2),q2cut(2)
        DOUBLE PRECISION rapcut(2),Etcut(4)
C --- photoproduction cuts
        DATA ybjcut/0.2,0.8/
        DATA q2cut/0.0,4/
        DATA Etcut/6.0,8.0,11.0,15.0/
        DATA rapcut/-1.375,1.875/

C --- private copies of Xsec and Ntot from HERACMN
        DOUBLE PRECISION mhxsec(2),mhntot(2)

c ---
        DOUBLE PRECISION elecE
        INTEGER myil,myip,loop,graph
        DOUBLE PRECISION deltaeta,etabar,xgam
        DOUBLE PRECISION rap(2),Et(2),phi(2)
        DOUBLE PRECISION ybj,q2
        INTEGER intiflag, iproc, iflag
        INTEGER hzflag

        REAL pttemp(12)
        INTEGER ivec,jvec
        REAL sqrt

C --- choose direct/resolved
C --- recommend 1 - DIRECT, 2 - RESOLVED
        IF (iflag.gt.1000) THEN
          iproc=INT(iflag/1000)
          intiflag=MOD(iflag,1000)
        ENDIF
        IF ((iproc.gt.2).or.(iproc.lt.1)) THEN
          PRINT*,'HZ97196 : Badly called routine'
          PRINT*,'          please set intiflag +1000 or +2000'
        ENDIF

C --- choose jet finder
        IF ((intiflag.gt.10).and.(MOD(intiflag,10).eq.1)) THEN
          chjet=INT(intiflag/10)
          intiflag=MOD(intiflag,10)
        ENDIF

        IF (intiflag.eq.1) THEN
C *** Initialisation run ***
C *** Create directories ***
          IF (iproc.eq.1) THEN
            CALL HCDIR('//HISTO',' ')
            CALL HMDIR('97196','S')
            CALL HCDIR('//PAWC',' ')
            CALL HMDIR('97196','S')

            CALL HBOOK1(10,'MC etabar DIR ET.gt.6'
     &          ,9, -1.125, 1.125, 0.)
            CALL HBOOK1(11,'MC etabar DIR ET.gt.8'
     &          ,8, -0.825, 1.125, 0.)
            CALL HBOOK1(12,'MC etabar DIR ET.gt.11'
     &          ,4, -0.375, 1.625, 0.)
            CALL HBOOK1(13,'MC etabar DIR ET.gt.15'
     &          ,4, -0.375, 1.625, 0.)
            CALL HBOOK1(20,'MC etabar RES ET.gt.6'
     &          ,8, -0.325, 1.625, 0.)
            CALL HBOOK1(21,'MC etabar RES ET.gt.8'
     &          ,8, -0.325, 1.625, 0.)
            CALL HBOOK1(22,'MC etabar RES ET.gt.11'
     &          ,3, 0.125, 1.625, 0.)
            CALL HBOOK1(23,'MC etabar RES ET.gt.15'
     &          ,3, 0.125, 1.625, 0.)
          ENDIF
            CALL HCDIR('//HISTO/97196',' ')
            CALL HCDIR('//PAWC/97196',' ')
            CALL HBOOK1(iproc*100+10,'MC etabar DIR ET.gt.6'
     &          ,9, -1.125, 1.125, 0.)
            CALL HBOOK1(iproc*100+11,'MC etabar DIR ET.gt.8'
     &          ,8, -0.825, 1.125, 0.)
            CALL HBOOK1(iproc*100+12,'MC etabar DIR ET.gt.11'
     &          ,4, -0.375, 1.625, 0.)
            CALL HBOOK1(iproc*100+13,'MC etabar DIR ET.gt.15'
     &          ,4, -0.375, 1.625, 0.)
            CALL HBOOK1(iproc*100+20,'MC etabar RES ET.gt.6'
     &          ,8, -0.325, 1.625, 0.)
            CALL HBOOK1(iproc*100+21,'MC etabar RES ET.gt.8'
     &          ,8, -0.325, 1.625, 0.)
            CALL HBOOK1(iproc*100+22,'MC etabar RES ET.gt.11'
     &          ,3, 0.125, 1.625, 0.)
            CALL HBOOK1(iproc*100+23,'MC etabar RES ET.gt.15'
     &          ,3, 0.125, 1.625, 0.)

C --- standard cone radius is 1.0
          CALL HZJETRAD(2,CONER)
          IF (CONER.lt.0.0) THEN
            CONER=1.0
          ENDIF
          CALL HZJTNAME(chjet,jetf)

          WRITE(6,*)'**********************************************'
          WRITE(6,*)'* HZ97196 called, histograms will be output. *'
          WRITE(6,*)'*     Jet finder selected : ',jetf,'           *'
          WRITE(6,1001)'*        with cone radius : ',CONER,'   *'
          WRITE(6,*)'**********************************************'

 1001     FORMAT(A29,F5.2,A13)

        ELSE IF (intiflag.eq.2) THEN
C *** Filling runs ***

C *** Change directory to our graphs ***
          CALL HCDIR('//PAWC/97196',' ')

          q2=hzphokin(1)
          IF (q2.eq.-1.0d0) THEN
C            PRINT*,'HZ97196: HZPHOKIN returns error for Q2'
          ENDIF
          q2=abs(q2)
          ybj=hzphokin(3)
          IF (ybj.eq.-1.d0) THEN
C            PRINT*,'HZ97196: HZPHOKIN returns error for ybj'
          ENDIF

C *** Fill our histogram ***

          IF ((ybj.ge.ybjcut(1)).and.(ybj.le.ybjcut(2))
     &          .and.(q2.lt.q2cut(2))) Then

          elecE=27.5d0
          hzflag=HZIBEAM(myip,myil)
          IF (hzflag.ge.0) Then
            elecE=abs(PHEP(4,myil))
          ELSE
            PRINT*,'HZ97196: Electron not found. E=0.001'
            PRINT*,'         event will be rejected'
            elecE=0.001d0
          ENDIF

            CALL hzjtfind(chjet,CONER,NJET,Jets)

            IF (NJET.ge.2) THEN
              DO loop=1,2
                Et(loop)=Jets(loop,3)
                phi(loop)=Jets(loop,2)
                rap(loop)=Jets(loop,1)
              ENDDO
              IF (rap(1).ge.rapcut(1).and.rap(2).ge.rapcut(1)
     +            .and.rap(1).le.rapcut(2).and.rap(2).le.rapcut(2))
     +            THEN
              deltaeta=abs(rap(1)-rap(2))
              etabar=(rap(1)+rap(2))/2
              xgam=(Et(1)*exp(-1*rap(1))+Et(2)*exp(-1*rap(2)))
     +           /(2*ybj*elecE)

              IF (abs(deltaeta).lt.0.5.and.xgam.gt.0.3) THEN
               IF (xgam.gt.0.75) graph=9
               IF (xgam.le.0.75) graph=19
               DO loop=1,4
               IF (Et(2).gt.Etcut(loop))
     +           CALL HF1(iproc*100+graph+loop,REAL(etabar),wtx)
               ENDDO
              ENDIF ! deltaeta.lt.0.5
              ENDIF ! rapcut
            ENDIF ! NJET.ge.2

          ENDIF         ! Q2 & y cuts

        ELSE IF (intiflag.eq.3) THEN
C *** Termination run ***
C *** Change directory ***
          CALL HCDIR('//PAWC/97196',' ')
C *** Finish off histograms ***

          IF (Xsec.eq.0) THEN
            PRINT*,'HZ97196: termination called with zero cross section'
            PRINT*,'          cross section graph meaningless'
            PRINT*,'          in process :',iproc*1000
            Xsec=1
          ENDIF
          IF (Ntot.eq.0) THEN
            PRINT*,'HZ97196: termination called with no total events'
            PRINT*,'          cross section graph meaningless'
            PRINT*,'          in process :',iproc*1000
            Ntot=1
          ENDIF

C --- store Xsec and Ntot for both direct and resolved events.
          mhXsec(iproc)=Xsec
          mhntot(iproc)=Ntot

          IF (iproc.eq.2) THEN
C --- only finally
C --- create proper cross-section data
            CALL HBOOK1(-10,'DATA etabar DIR ET.gt.6'
     &          ,9, -1.125, 1.125, 0.)
            CALL HBOOK1(-11,'DATA etabar DIR ET.gt.8'
     &          ,8, -0.825, 1.125, 0.)
            CALL HBOOK1(-12,'DATA etabar DIR ET.gt.11'
     &          ,4, -0.375, 1.625, 0.)
            CALL HBOOK1(-13,'DATA etabar DIR ET.gt.15'
     &          ,4, -0.375, 1.625, 0.)
            CALL HBOOK1(-20,'DATA etabar RES ET.gt.6'
     &          ,8, -0.325, 1.625, 0.)
            CALL HBOOK1(-21,'DATA etabar RES ET.gt.8'
     &          ,8, -0.325, 1.625, 0.)
            CALL HBOOK1(-22,'DATA etabar RES ET.gt.11'
     &          ,3, 0.125, 1.625, 0.)
            CALL HBOOK1(-23,'DATA etabar RES ET.gt.15'
     &          ,3, 0.125, 1.625, 0.)

            CALL HPAK(-10,cs1a)
            DO ivec=1,9
              pttemp(ivec)=sqrt(sta1a(ivec)**2+sys1a(ivec)**2)
            ENDDO
            CALL HPAKE(-10,pttemp)
            CALL HPAK(-11,cs1b)
            DO ivec=1,8
              pttemp(ivec)=sqrt(sta1b(ivec)**2+sys1b(ivec)**2)
            ENDDO
            CALL HPAKE(-11,pttemp)
            CALL HPAK(-12,cs1c)
            DO ivec=1,4
              pttemp(ivec)=sqrt(sta1c(ivec)**2+sys1c(ivec)**2)
            ENDDO
            CALL HPAKE(-12,pttemp)
            CALL HPAK(-13,cs1d)
            DO ivec=1,4
              pttemp(ivec)=sqrt(sta1d(ivec)**2+sys1d(ivec)**2)
            ENDDO
            CALL HPAKE(-13,pttemp)
            CALL HPAK(-20,cs2a)
            DO ivec=1,8
              pttemp(ivec)=sqrt(sta2a(ivec)**2+sys2a(ivec)**2)
            ENDDO
            CALL HPAKE(-20,pttemp)
            CALL HPAK(-21,cs2b)
            DO ivec=1,8
              pttemp(ivec)=sqrt(sta2b(ivec)**2+sys2b(ivec)**2)
            ENDDO
            CALL HPAKE(-21,pttemp)
            CALL HPAK(-22,cs2c)
            DO ivec=1,3
              pttemp(ivec)=sqrt(sta2c(ivec)**2+sys2c(ivec)**2)
            ENDDO
            CALL HPAKE(-22,pttemp)
            CALL HPAK(-23,cs2d)
            DO ivec=1,3
              pttemp(ivec)=sqrt(sta2d(ivec)**2+sys2d(ivec)**2)
            ENDDO
            CALL HPAKE(-23,pttemp)

C --- now calculate cross-section graphs 10,20
C --- Modified to also normalise resolved/direct component histograms
C --- on 20/8/98 by Russell Taylor
            DO loop=0,3
            CALL HOPERA(110+loop,'+e',110+loop,110+loop,
     &           REAL(mhXsec(1)/mhNtot(1)/bw(loop+1)),0.)
            CALL HOPERA(120+loop,'+e',120+loop,120+loop,
     &           REAL(mhXsec(1)/mhNtot(1)/bw(loop+1)),0.)
            CALL HOPERA(210+loop,'+e',210+loop,210+loop,
     &           REAL(mhXsec(2)/mhNtot(2)/bw(loop+1)),0.)
            CALL HOPERA(220+loop,'+e',220+loop,220+loop,
     &           REAL(mhXsec(2)/mhNtot(2)/bw(loop+1)),0.)
            CALL HOPERA(110+loop,'+e',210+loop,10+loop,1.,1.)
            CALL HOPERA(120+loop,'+e',220+loop,20+loop,1.,1.)
            CALL HZCHISQ(-10-loop,10+loop)
            CALL HZCHISQ(-20-loop,20+loop)
            ENDDO
          ENDIF

        ELSE
C *** End ***
          PRINT*,'HZ97196:Please run routine with iflag set to 1,2 or 3'
          PRINT*,'        with +1000 or +2000 for DIR or RES events.'
        ENDIF

        RETURN
        END
*CMZ :  2.00/05 31/07/2000  21.21.54  by  Tancredi Carli
*CMZ :  2.00/04 31/07/2000  21.08.05  by  Tancredi Carli
*CMZ :  1.02/09 03/08/99  15.53.54  by  Tancredi Carli
*-- Author :
*-- Author :    Alice Valkarova  1999
c-----------------------------------------------------------------------

      SUBROUTINE HZ97210(iflag)

c-----------------------------------------------------------------------
c---- Description

c Purpose: Study topological structure of the hadronic final state in
c          diffractive deep inelastic scattering
c
c Event selection: 10. < Q2 < 100 GeV2
c                  y < 0.5
c                  xpom < 0.05
c                  4 < Mx < 36 GeV
c                  |t| < 1 GeV2
c                  My < 1.6 GeV
c
c Reference: DESY 97-210
c            Eur. Phys. J. C (1998)
c
c Arguments: iflag=1 initialisation
c            iflag=1 filling
c            iflag=3 termination
c
c Written by: Alice Valkarova and Gerhard Knies

c-----------------------------------------------------------------------
c---- Declarations

      IMPLICIT NONE

c.... HzTool stuff

*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
c.... input variable
      INTEGER iflag

c.... local variables
      LOGICAL          iacc(NMXHEP)
      INTEGER          nacc, ihep, i, j, ierr, ibp, ibl, isl,
     &                 id,
     &                 index(NMXHEP),id1,id2,ii
      REAL             p, pz, gap, tmp, w2, mp,
     &                 xvec(4), yvec(4), rap(NMXHEP)


      REAL             evpt2(7),thrmc,mxmc,pt2,rndm,ptsqr(8)
      PARAMETER        (mp = 0.938)
      DOUBLE PRECISION pbeam(4), gamma(4), p_lab(4), p_hcms(4)
      CHARACTER*4      low, high
      Character*6 xxxx
      Data xxxx/'97210'/

C****************** QUANTITIES FOR THRUST ANALYSIS *********************
      DOUBLE PRECISION
     & p_xcms(4), prot_xcms(4), zerovec(4), onevec(4),p_xcms5
     &, decoj(5,15),pj2, pjprot, pprot2,  cosi2, psum, pv2
      LOGICAL evacc	
      integer nt,ik,ij
C****************** QUANTITIES FOR THRUST ANALYSIS *********************

c.... Mx bin limits
      REAL mxbins(8), ptbins(9),mxbins1(7)
      DATA mxbins / 4., 6., 8., 11., 15., 19., 24., 36./
      DATA mxbins1 / 6., 8., 11., 15., 19., 24., 36./
      DATA ptbins / 0., 1., 3., 6., 12., 25., 43., 79., 151./

c.... kinematical selection criteria
      REAL q2, q2_low, q2_high
      DATA q2_low  / 10.  /, q2_high / 100. /
      REAL y,  y_low,  y_high
      DATA y_low   / 0.0 /, y_high  / 0.5  /
      REAL xp, xp_high
      DATA xp_high / 0.05 /
      REAL mx_low, mx_high
      DATA mx_low  / 4.   /, mx_high / 36.  /
      REAL t,  t_high
      DATA t_high  / 1.   /
      REAL my, my_high
      DATA my_high / 1.6  /

c-----------------------------------------------------------------------
c---- Corrected data from H1
C Thrust data
      REAL mxx(7),thr(7),ethr1(7),ethr2(7)
      REAL mx_lt1(7),mx_gt1(7),thr_lt1(7),thr_gt1(7)
      REAL ethr1_lt1(7),ethr2_lt1(7),ethr1_gt1(7),ethr2_gt1(7)

C Pt data
*      REAL pt2_int(48),mx_int(48),dsig(48),dsig_est(48),dsig_esy(48)
      REAL pt2_int(8,6),mx_int(8,6),dsig(8,6),dsig_est(8,6),
     &  dsig_esy(8,6)

C fraction data
      REAL frac_1(6),mxf_1(6),efr1_1(6),efr2_1(6)
      REAL frac_3(6),mxf_3(6),efr1_3(6),efr2_3(6)
c--------------------------
C Thrust MOCA
      REAL mx_mc(7),thr_mc(7),ethr1_mc(7)
      REAL mx_lt1_mc(7),mx_gt1_mc(7),thr_lt1_mc(7),thr_gt1_mc(7)
      REAL ethr1_lt1_mc(7),ethr1_gt1_mc(7)
      REAL nev_mc(7),nev_lt1_mc(7),nev_gt1_mc(7)

C Pt MOCA
      REAL pt2_int_mc(8,6),dsig_mc(8,6),dsig_esy_mc(8,6)
C auxilliary

      REAL pn_tmp(8),pne_tmp(8),pns_tmp(8)

      DATA mxx    /
*   exp. mean mass of X
     &              4.97,  6.98,  9.40, 12.81, 16.82, 21.20, 28.64/


      DATA thr   /
*   exp. mean thrust
     &              0.777, 0.781, 0.802, 0.822, 0.847, 0.865, 0.875/

      DATA ethr1    / 0.004, 0.004, 0.004, 0.004, 0.005, 0.005, 0.006/

      DATA ethr2    / 0.008, 0.005, 0.006, 0.005, 0.006, 0.008, 0.009/

      DATA thr_lt1/ 0.787, 0.810, 0.828, 0.850, 0.890, 0.909, 0.910/
      DATA thr_gt1/ 0.762, 0.758, 0.785, 0.806, 0.831, 0.844, 0.864/

      DATA mx_lt1 / 4.95,  6.96,  9.44, 12.75, 16.90, 21.17, 28.08/
      DATA mx_gt1 / 4.99,  6.99,  9.38, 12.85, 16.80, 21.21, 28.82/

      DATA ethr1_lt1/ 0.005, 0.005, 0.005, 0.005, 0.007, 0.007, 0.008/
      DATA ethr1_gt1/ 0.006, 0.005, 0.005, 0.005, 0.006, 0.007, 0.007/

      DATA ethr2_lt1/ 0.006, 0.002, 0.003, 0.002, 0.002, 0.002, 0.009/
      DATA ethr2_gt1/ 0.004, 0.006, 0.003, 0.002, 0.002, 0.002, 0.002/


      DATA pt2_int / 0.37, 1.88, 4.21, 0.0,
     &               0.,   0.,   0.,   0.,
     &               0.38, 1.84, 4.30, 8.38,
     &               0.,   0.,   0.,   0.,
     &               0.40, 1.83, 4.22, 8.54,
     &              15.97, 0.,  0.,   0.,
     &               0.41, 1.79, 4.32, 8.47,
     &              17.1, 30.75, 0.,  0.,
     &               0.37, 1.84, 4.22, 8.08,
     &              16.19, 33.18, 51.7, 0.,
     &               0.41, 1.83, 4.26, 8.42,
     &              17.38, 32.09, 58.28, 113.2/

       DATA mx_int / 6.96,   6.96,  7.10,  0.,
     &               0.,     0.,    0.,    0.,
     &               9.39,   9.36,  9.31,  9.54,
     &               0.,     0.,    0.,    0.,
     &              12.72, 12.74, 12.77, 12.78,
     &              13.10,  0.,    0.,    0.,
     &              16.90, 16.78, 16.70, 16.98,
     &              16.89, 16.85,  0.,    0.,
     &              21.01, 21.10, 21.40, 20.91,
     &              21.07, 20.79, 22.15,  0.,
     &              27.79, 28.05, 27.94, 28.26,
     &              28.65, 29.35, 28.18, 30.45/

       DATA dsig   / 0.527,   0.144,   0.042,    0.,
     &               0.,      0.,      0.,       0.,
     &               0.470,   0.129,   0.052,    0.016,
     &               0.,      0.,      0.,       0.,
     &               0.451,   0.117,   0.045,    0.019,
     &               0.0051,  0.,      0.,       0.,
     &               0.404,   0.133,   0.053,    0.016,
     &               0.005,   0.0007,  0.,       0.,
     &               0.444,   0.111,   0.045,    0.020,
     &               0.0038,  0.0008,  0.00039,  0.,
     &               0.361,   0.141,   0.048,    0.017,
     &               0.0049,  0.0014,  0.00054,  0.00011/

       DATA dsig_est / 0.018,   0.009,   0.004,   0.,
     &                 0.,      0.,      0.,      0.,
     &                 0.017,   0.008,   0.004,   0.002,
     &                 0.,      0.,      0.,      0.,
     &                 0.019,   0.009,   0.004,   0.002,
     &                 0.0007,  0.,      0.,      0.,
     &                 0.024,   0.012,   0.006,   0.002,
     &                 0.001,   0.0002,  0.,      0.,
     &                 0.030,   0.013,   0.006,   0.003,
     &                 0.0008,  0.0003,  0.00014, 0.,
     &                 0.032,   0.018,   0.008,   0.003,
     &                 0.0010,  0.0004,  0.00018, 0.00006/
       DATA dsig_esy / 0.038,   0.022,   0.007,   0.,
     &                 0.,      0.,      0.,      0.,
     &                 0.039,   0.022,   0.007,   0.003,
     &                 0.,      0.,      0.,      0.,
     &                 0.033,   0.013,   0.005,   0.003,
     &                 0.0013,  0.,      0.,      0.,
     &                 0.038,   0.016,   0.008,   0.004,
     &                 0.001,   0.0003,  0.,      0.,
     &                 0.044,   0.016,   0.009,   0.005,
     &                 0.001,   0.0004,  0.00022, 0.,
     &                 0.039,   0.028,   0.013,   0.004,
     &                 0.0011,  0.0006,  0.00025, 0.00011/


       DATA mxf_1  /  7.1,  9.6, 12.9, 17.,  21.2, 28.3 /
       DATA frac_1 / 47.3, 53.,  54.9, 59.6, 55.6, 63.9 /
       DATA efr1_1 /  1.7,  1.6,  1.8,  2.3,  2.9,  3.1 /
       DATA efr2_1 /  3.4,  3.6,  2.8,  3.0,  2.6,  2.3 /

       DATA mxf_3  /  7.0,  9.6, 12.9, 17.,  21.2, 28.3 /
       DATA frac_3 / 18.6, 27.2, 31.5, 33.,  33.4, 35.7 /
       DATA efr1_3 /  1.3,  1.4,  1.6,  2.,   2.4,  2.9 /
       DATA efr2_3 /  2.4,  3.4,  3.8,  3.8,  2.6,  3.2 /

C****************** commons used with DECO *****************************
C                                                                      *
      integer jptmax,jfroff
      real econf
*KEEP,QJMACS.
C------------ /QJMACS/ --- Buffer for jet and topological routines -----
         INTEGER JTBIMX,JTBOMX,JPARMX,JTBI,JTBIT,JTBO,JTBOF
         DOUBLE PRECISION QPI,QTBIR,QPO,QTBOR
         PARAMETER (JTBIMX =10000,JTBOMX = 30,JPARMX = 5)
         COMMON /QCTBUF/QPI(5,JTBIMX),QTBIR(JPARMX,JTBIMX),
     +                  QPO(5,JTBOMX),QTBOR(JPARMX,JTBOMX),
     +                  JTBI,JTBIT(JTBIMX),
     +                  JTBO,JTBOF(JPARMX,JTBIMX)
C     jtbi       number of input vectors (max : jtbimx).
C     qpi(i,j)   particle input vector j; i=1,2,3,4:px,py,pz,e; i=5 free
C     jtbit(j)   pointer to corresponding q-vector
C     qtbir(k,j) scalar input k for each input vector j
C     jtbo       number of output jets   (max : jtbomx)
C     qpo(i,j)   jet output vector (jet axis) i=1,2,3,4:px,py,pz,e
C     jtbof(k,i) number of jet for input particle i in multiplet k
C     qtbor(k,j) scalar output result k for each jet j (k_max : jparmx)
C                (will be stored as user words in Q_vector)
*
*KEEP,DECOMA.
        INTEGER IPTMAX,IPTOT,ITRTOT,ITRSRC,MEVENT
     1,JETF,IFRAME,ITROFF,INIMUL,IDPREV, NCON, NPRI, IFLAGG, JETFU
     2,IREV
     3,MAXMUL,JORD,IFUPOS,MINPA,MAXCHA,ITERIJ,NEVPRI,MODUS
      COMMON/QCOCOM/IPTMAX,IPTOT,ITRTOT,ITRSRC,MEVENT
     1,JETF(10),JETNAM(10),IFRAME(10),ITROFF(10),INIMUL(10),IDPREV(10)
     2,IREV(10)
     3,MAXMUL,JORD,IFUPOS,MINPA,MAXCHA,ITERIJ(5),ECONF,NEVPRI,MODUS
      CHARACTER*4 JETNAM
      CHARACTER*7 JETNA

      PARAMETER (JPTMAX=150)
      PARAMETER (JFROFF=JPTMAX+50)
        REAL PJET,FTOP,LPJ
      COMMON/QRECOM/ PJET(10,15,10),FTOP(5,10),LPJ(JPTMAX+2,15,10)
*
*KEND.
C								       *
C***********************************************************************

c-----------------------------------------------------------------------
c---- Initialisation

      IF (iflag .EQ. 1) THEN

c....   set number of accepted events to zero
        nacc= 0

c....   create subdirectories for use with HBOOK/PAW
        CALL HCDIR ('//PAWC', ' ')
        CALL HMDIR ('97210', 'S')
        CALL HCDIR ('//HISTO', ' ')
        CALL HMDIR ('97210', 'S')

	 WRITE(6,*)'***************************************************'
	 WRITE(6,*)'HZ'//xxxx//' called'
     	 WRITE(6,*)'***************************************************'
c....   book moca histograms

        DO i = 1, 7
          WRITE (low, '(F4.0)') mxbins(i)
          WRITE (high,'(F4.0)') mxbins(i+1)
**  thrust and mass histograms
          id = 10+i
          CALL HBOOK1 (id,
     &      'Moca TD - '//low//' .lt. Mx .lt. '//high//' GeV, total',
     &      20, 0.5, 1.0, 0.)
          id = 60+i
          CALL HBOOK1 (id,
     &      'Moca MD - '//low//' .lt. Mx .lt. '//high//' GeV, total',
     &      64, 4. , 36. , 0.)
          id = 20+i
          CALL HBOOK1 (id,
     &      'Moca TD - '//low//' .lt. Mx .lt. '//high//' GeV, ptgt1',
     &      20, 0.5, 1.0, 0.)
          id = 70+i
          CALL HBOOK1 (id,
     &      'Moca MD - '//low//' .lt. Mx .lt. '//high//' GeV, total',
     &     64, 4. , 36.  , 0.)
          id = 30+i
          CALL HBOOK1 (id,
     &      'Moca TD - '//low//' .lt. Mx .lt. '//high//' GeV, ptlt1',
     &      20, 0.5, 1.0, 0.)
          id = 80+i
          CALL HBOOK1 (id,
     &      'Moca MD - '//low//' .lt. Mx .lt. '//high//' GeV, total',
     &      64, 4. , 36. , 0.)

           ENDDO
            DO i = 1,6
          WRITE (low, '(F4.0)') mxbins1(i)
          WRITE (high,'(F4.0)') mxbins1(i+1)
** pt2 histograms
          id = 90 + i
          CALL HBOOKB (id,
     &      'Moca Pt2D - '//low//' .lt. Mx .lt. '//high//' GeV, total',
     &      8, ptbins , 0.)
          id = 300 +i
          CALL HBOOKB (id,
     &      'Moca bins Pt2D - '//low//' .lt. Mx .lt. '//high//' GeV, ',
     &      8, ptbins , 0.)
         DO j = 1,8
            id = 300 +i*10 +j
          CALL HBOOKB (id,
     &      'Moca bins Pt2D - '//low//' .lt. Mx .lt. '//high//' GeV, ',
     &      8, ptbins , 0.)
         ENDDO
        ENDDO


        CALL HBOOKB (510, 'Moca thrust vs mass',
     &               7, mxbins, 0.)

          CALL HBOOKB (560, 'Moca mass vs mass',
     &               7, mxbins, 0.)

        CALL HBOOKB (520, 'Moca thrust ptgt1 vs mass',
     &               7, mxbins, 0.)

          CALL HBOOKB (570, 'Moca mass ptgt1 vs mass',
     &               7, mxbins, 0.)

        CALL HBOOKB (530, 'Moca thrust ptlt1 vs mass',
     &               7, mxbins, 0.)

          CALL HBOOKB (580, 'Moca mass ptlt1 vs mass',
     &               7, mxbins, 0.)

********* data histograms
** pt2 histograms
        DO i=1,6
          WRITE (low, '(F4.0)') mxbins1(i)
          WRITE (high,'(F4.0)') mxbins1(i+1)

          id = -90 -i
          CALL HBOOKB (id,
     &      'Data Pt2D - '//low//' .lt. Mx .lt. '//high//' GeV, total',
     &      8, ptbins , 0.)
          id = -150 -i
          CALL HBOOKB (id,
     &      'Data Pt2D - '//low//' .lt. Mx .lt. '//high//' GeV, total',
     &      8, ptbins , 0.)
          id = -300 -i
          CALL HBOOKB (id,
     &      'Data bins Pt2D - '//low//' .lt. Mx .lt. '//high//' GeV, ',
     &      8, ptbins , 0.)

        ENDDO

********* thrust
         DO   i=1,2
             id = -410-i*100
          CALL HBOOKB (id,
     &      'Data Thrust - 4 .lt. Mx .lt. 36 GeV, total',
     &      7, mxbins , 0.)

             id = -420-i*100
          CALL HBOOKB (id,
     &      'Data Thr pt lt 1 - 4 .lt. Mx .lt. 36 GeV, total',
     &      7, mxbins , 0.)

             id = -430-i*100
          CALL HBOOKB (id,
     &      'Data Thr pt gt 1 - 4 .lt. Mx .lt. 36 GeV, total',
     &      7, mxbins , 0.)

            ENDDO

          CALL HBOOKB (-560,
     &      'Data mass all pt - 4 .lt. Mx .lt. 36 GeV, total',
     &      7, mxbins , 0.)

          CALL HBOOKB (-570,
     &      'Data mass pt lt 1 - 4 .lt. Mx .lt. 36 GeV, total',
     &      7, mxbins , 0.)

          CALL HBOOKB (-580,
     &      'Data mass pt gt 1 - 4 .lt. Mx .lt. 36 GeV, total',
     &      7, mxbins , 0.)

CC--------fraction of events with pt**2>1 and >3

             DO i=1,2
                id = -360 -i*50

          CALL HBOOKB (id,
     &      'Data fraction  pt gt 1- 4 .lt. Mx .lt. 36 GeV, total',
     &      6, mxbins1 , 0.)

          CALL HBOOKB (id-10,
     &      'Data fraction  pt gt 3- 4 .lt. Mx .lt. 36 GeV, total',
     &      6, mxbins1 , 0.)

            ENDDO

          CALL HBOOKB (-430,
     &      'Data fraction mass pt gt 1- 4 .lt. Mx .lt. 36 GeV, total',
     &      6, mxbins1 , 0.)

          CALL HBOOKB (-440,
     &      'Data fraction mass pt gt 3- 4 .lt. Mx .lt. 36 GeV, total',
     &      6, mxbins1 , 0.)


c-----------------------------------------------------------------------
c---- Event analysis

      ELSEIF (iflag .EQ. 2) THEN

c....   move to the correct subdirectory in PAWC
        CALL HCDIR ('//PAWC/97210', ' ')

c....   get vectors for boost to hCMS
        ierr = HZIBEAM (ibp, ibl)
        isl = HZIDELEC(id)
        IF (ierr .EQ. 1 .AND. isl .GT. 0) THEN
          DO i = 1, 4
            pbeam(i) = PHEP (i, ibp)
            gamma(i) = PHEP (i, ibl) - PHEP (i, isl)
          ENDDO
        ELSEIF (ierr .NE. 1 .AND. isl .GT. 0) THEN
          PRINT *, 'HZ97210-- Warning: No beam(s) found,'
          PRINT *, '        -- proton beam energy set to 820 GeV,'
          PRINT *, '        -- positron beam energy set to 27.55 GeV.'
          IF (ierr .EQ.  0) ibp = 0
          IF (ierr .EQ. -1) ibl = 0
          pbeam(1) = 0.
          pbeam(2) = 0.
          pbeam(3) = +820.
          pbeam(4) = +820.
          gamma(1) = - PHEP (1, isl)
          gamma(2) = - PHEP (2, isl)
          gamma(3) = -27.55 - PHEP (3, isl)
          gamma(4) = +27.55 - PHEP (4, isl)
        ELSEIF (isl .LE. 0) THEN
          PRINT *, 'HZ97210-- Warning: No scattered positron found,'
          PRINT *, '        -- event skipped !'
          GOTO 999
        ENDIF

c....   initialise boost to hCMS
        CALL HZHCMINI (pbeam, gamma, ierr)
	NPRI=0
         IF(NPRI.GE.2)
     1     PRINT *, 'HZ97210: boost to hadronic CMS defined'
        IF (ierr .EQ. 1) THEN
          PRINT *, 'HZ97210-- Warning: boost to hadronic CMS failed,'
          PRINT *, '        -- event skipped !'
          GOTO 999
        ENDIF
c control print out: 0=none, 1=medium, 2=detailed
            CALL HZHCM(pbeam, p_hcms, ierr)

C	NPRI=2
         IF(NPRI.GE.2)
     1    PRINT *,'HZ97210, pbeam,ierr',(pbeam(i),i=1,4),ierr
         IF(NPRI.GE.2)
     1    PRINT *,'HZ97210, prot_hcms ',(p_hcms(i),i=1,4)

c....   select final state particles and store pseudorapidity in hCMS
        DO ihep = 1, NHEP
          iacc(ihep) = .FALSE.
          rap(ihep) = 9999.
          IF (
     &        ISTHEP(ihep) .EQ. 1 .AND.
     &        ihep .NE. ibp       .AND.
     &        ihep .NE. ibl       .AND.
     &        ihep .NE. isl       .AND.
     &        .TRUE.) THEN
            iacc(ihep) = .TRUE.
            p_lab(1) = PHEP (1, ihep)
            p_lab(2) = PHEP (2, ihep)
            p_lab(3) = PHEP (3, ihep)
            p_lab(4) = PHEP (4, ihep)
            CALL HZHCM(p_lab, p_hcms, ierr)
            IF (ierr .EQ. 1) THEN
              PRINT *,
     &          'HZ97210-- Warning: boost to hadronic CMS failed,'
              PRINT *, '        -- event skipped !'
              GOTO 999
            ENDIF
c           rap is pseudorapidity !
            p = SQRT(p_hcms(1)**2+p_hcms(2)**2+p_hcms(3)**2)
            pz = p_hcms(3)
            IF (p .GT. ABS(pz)) rap(ihep) = 0.5*(LOG(p+pz)-LOG(p-pz))
          ENDIF
        ENDDO

c....   sort particles with increasing pseudorapidity
        CALL SORTZV (rap, index, NHEP, 1, 0, 0)

c....   look for largest gap
        gap =  0.
        DO ihep = 2, NHEP
          tmp = rap(index(ihep)) - rap(index(ihep-1))
          IF (tmp .GT. gap .AND. iacc(index(ihep))) THEN
            gap = tmp
            id = ihep
          ENDIF
        ENDDO
c       store boundary between X and Y in variable gap
        gap = rap(index(id-1)) + gap/2

c....   get DIS kinematics
        q2 = HZDISKIN (1)
        y  = HZDISKIN (3)
        w2 = HZDISKIN (4)

c....   get diffractive DIS kinematics and select particles of system X
        DO i = 1, 4
          xvec(i) = 0.
          yvec(i) = 0.
        ENDDO
        DO ihep = 1, NHEP
          IF (iacc(ihep)) THEN
            IF (rap(ihep) .GT. gap) THEN
              xvec(1) = xvec(1) + PHEP (1, ihep)
              xvec(2) = xvec(2) + PHEP (2, ihep)
              xvec(3) = xvec(3) + PHEP (3, ihep)
              xvec(4) = xvec(4) + PHEP (4, ihep)
            ELSE
              iacc(ihep) = .FALSE.
              yvec(1) = yvec(1) + PHEP (1, ihep)
              yvec(2) = yvec(2) + PHEP (2, ihep)
              yvec(3) = yvec(3) + PHEP (3, ihep)
              yvec(4) = yvec(4) + PHEP (4, ihep)
            ENDIF
          ENDIF
        ENDDO
        mxmc = xvec(4)**2 - xvec(1)**2 - xvec(2)**2 - xvec(3)**2
        IF (mxmc .GT. 0) THEN
          mxmc = SQRT(mxmc)
        ELSE
          mxmc = 0.
        ENDIF
        my = yvec(4)**2 - yvec(1)**2 - yvec(2)**2 - yvec(3)**2
        IF (my .GT. 0) THEN
          my = SQRT(my)
        ELSE
          my = 0.
        ENDIF
        t = (pbeam(4)-yvec(4))**2 - (pbeam(1)-yvec(1))**2
     &    - (pbeam(2)-yvec(2))**2 - (pbeam(3)-yvec(3))**2
        xp = (q2 + mxmc**2 - t)/(q2 + w2 - mp**2)

c....   select event

	evacc = .FALSE.
        IF (
     &      q2 .GT. q2_low      .AND.  q2 .LT. q2_high  .AND.
     &      y  .GT. y_low       .AND.  y  .LT. y_high   .AND.
     &      mxmc .GT. mx_low      .AND.  mxmc .LT. mx_high  .AND.
     &      my .LT. my_high     .AND.
     &      ABS(t) .LT. t_high  .AND.
     &      xp .LT. xp_high     .AND.
     &      .TRUE.) THEN
	  evacc = .TRUE.
          IF(.NOT.EVACC) GOTO 998	
          nacc = nacc + 1
C...  initialise DECO
	  CALL HEDECI(NHEP,1, IFLAGG)
c	 IF(IFLAGG.NE.0) GOTO 998
C...   event to large for DECO buffer

c....     initialise boost to X_CMS
          zerovec(1) = 0.
          zerovec(2) = 0.
          zerovec(3) = 1.
          zerovec(4) = 1.
          onevec(1)=xvec(1)-zerovec(1)
          onevec(2)=xvec(2)-zerovec(2)
          onevec(3)=xvec(3)-zerovec(3)
          onevec(4)=xvec(4)-zerovec(4)
          prot_xcms(1)=0.
          prot_xcms(2)=0.
          prot_xcms(3)=0.
          prot_xcms(4)=0.

          CALL HZHCMINI (onevec, zerovec, ierr)
         IF(NPRI.GE.2)
     1    PRINT *,'HZ97210, pbeam,ierr',(pbeam(i),i=1,4),ierr
         IF(NPRI.GE.2)
     1    PRINT *,'HZ97210, xvec,ierr',(xvec(i),i=1,4),ierr
c... proton into X_cms
               CALL HZHCM (pbeam,prot_xcms, ierr)
c control print out: 0=none, 1=medium, 2=detailed
C	NPRI=2
          IF(NPRI.GE.2)
     1print *,'NEVHEP, M_X' , nevhep, mxmc
         IF(NPRI.GE.2)
     1    PRINT *,'HZ97210, prot_xcms ',(prot_xcms(i),i=1,4)

          nt = 0
	  psum = 0.
          DO ihep = 1, NHEP
          IF(NPRI.GE.2)
     1PRINT *,'hz97210, PHEP',ihep,(PHEP(i,ihep),i=1,4)
       IF (iacc(ihep) .AND. rap(ihep) .GT. gap) THEN
c....     get number of particles in gamma-pom CMS
		nt = nt + 1
              p_lab(1) = PHEP(1, ihep)
              p_lab(2) = PHEP(2, ihep)
              p_lab(3) = PHEP(3, ihep)
              p_lab(4) = PHEP(4, ihep)
             CALL HZHCM (p_lab, p_xcms, ierr)
C... mom sum for  thrust normalisation
	      pv2 = p_xcms(1)**2 + p_xcms(2)**2 + p_xcms(3)**2
              psum = psum + sqrt(pv2)
C... fill qctbuf with input vectors for DECO
		DO ik = 1,4
		 qpi(ik,nt) = p_xcms(ik)
		ENDDO
	        p_xcms5=p_xcms(4)**2 - pv2
	        if(p_xcms5.ge.0.) p_xcms5 = sqrt(p_xcms5)
	        if(p_xcms5.lt.0.) p_xcms5 = -sqrt(-p_xcms5)
                qpi(5,nt)=p_xcms5
         IF(NPRI.GE.2)
     1    PRINT *,'HZ97210, qpi ***** ',nt,(qpi(i,nt),i=1,5)

C... remeember ihep index
		jtbit(nt) = ihep	
            ENDIF
          ENDDO

C...  initialise DECO
	  CALL HEDECI(nt,2, IFLAGG)
	 IF(IFLAGG.NE.0) GOTO 998
C...   event to large for DECO buffer



         IF(NPRI.GE.2)
     1 PRINT *,'HZ97210, qpi of X in C_cms **'
     1,(qpi(i,iptmax+1),i=1,5)

Call DECO
	JETNAM(1)='MOCA'
	JETNA ='MOCARLO'
	JETFU=1
	MAXMUL=2
	NCON=0

	CALL HGDECO(JETNA,jetfu,maxmul,ncon,npri,iflagg) 	

*Write jet vector from qctbuf to decoj(5,15)
          DO ik = 1,5
		DO ij = 1,15
		decoj(ik,ij) = qpo(ik,ij)
		ENDDO
	  ENDDO

C...     THRUST:thrmc,  thrust-jet Pt**2: pt2, from decoj(i,2)
	pj2 = (decoj(1,2)**2 + decoj(2,2)**2 + decoj(3,2)**2)
	thrmc=2.*sqrt(pj2)/psum
         pprot2=prot_xcms(1)**2+prot_xcms(2)**2+prot_xcms(3)**2
	pjprot=decoj(1,2)*prot_xcms(1)
     &         +decoj(2,2)*prot_xcms(2)
     &         +decoj(3,2)*prot_xcms(3)
	cosi2=pjprot**2/(pj2*pprot2)
	pt2=pj2*(1.-cosi2)


********************************************************
              wtx = 1.

c....     fill histograms
*          DO j=1,3
          DO i = 1,7
            id1 = 10+i
            id2 = 50+10+i
            IF (mxmc .GT. mxbins(i) .AND. mxmc .LT. mxbins(i+1)) THEN
              CALL HFILL (id1, thrmc, 0., wtx)
              CALL HFILL (id2, mxmc, 0., wtx)
            ENDIF
          ENDDO

          if(pt2.gt.1.) j=2
          if(pt2.le.1.) j=3
          DO i = 1,7
            id1 = j*10+i
            id2 = 50+j*10+i
            IF (mxmc .GT. mxbins(i) .AND. mxmc .LT. mxbins(i+1)) THEN
              CALL HFILL (id1, thrmc, 0., wtx)
              CALL HFILL (id2, mxmc, 0., wtx)
            ENDIF
          ENDDO

          DO i = 1,7
             id=90+i
            IF (mxmc .GT. mxbins(i) .AND. mxmc .LT. mxbins(i+1)) THEN
              CALL HFILL (id, pt2, 0., wtx)
          DO j = 1,8
            If (pt2. gt. ptbins(j) .AND. pt2 .lt. ptbins(j+1)) THEN
             id = 300 +i*10+j
              CALL HFILL (id, pt2, 0., wtx)
            ENDIF
          ENDDO

            ENDIF
          ENDDO

  998   CONTINUE
        ENDIF

c-----------------------------------------------------------------------
c---- Termination

      ELSEIF (iflag .EQ. 3) THEN

c....   move to the correct PAW subdirectory
        call hcdir('//PAWC/97210',' ')

c....   normalise pt2 MOCA distributions

           do i = 1,6
            id = 90 + i
            evpt2(i) = HSTATI (id,   3, ' ', 1)
            print *,'events',i, evpt2(i)
            CALL HZHINRM (id,   0, evpt2(i), 1)
        ENDDO

c....  calculates the center of bins of pt2 distr. for each mx

           do i= 1,6
             do j = 1,8
             id = 300 +i*10+j
             pt2_int_mc(i,j)= HSTATI (id,   1, ' ', 1)
             ENDDO
           ENDDO

c....   extract mean values for thrust and mass (centers of bin)
        DO i = 1, 7
          id = 10 +i
          thr_mc(i) = HSTATI (id,   1, ' ', 1)
          ethr1_mc(i) = HSTATI (id,   2, ' ', 1)
          nev_mc(i) = HSTATI (id,   3, ' ', 1)
          print *,'mean and error',i,thr_mc(i),ethr1_mc(i), nev_mc(i)
          ethr1_mc(i)= ethr1_mc(i)/sqrt(nev_mc(i))
          print *,'mean and error',i,thr_mc(i),ethr1_mc(i), nev_mc(i)
          id = 60 +i
          mx_mc(i) = HSTATI (id,   1, ' ', 1)
          id = 20 +i
          thr_lt1_mc(i) = HSTATI (id,   1, ' ', 1)
          ethr1_lt1_mc(i) = HSTATI (id,   2, ' ', 1)
          nev_lt1_mc(i) = HSTATI (id,   3, ' ', 1)
          ethr1_lt1_mc(i)= ethr1_lt1_mc(i)/sqrt(nev_lt1_mc(i))
          id = 70 +i
          mx_lt1_mc(i) = HSTATI (id,   1, ' ', 1)
          id = 30 +i
          thr_gt1_mc(i) = HSTATI (id,   1, ' ', 1)
          ethr1_gt1_mc(i) = HSTATI (id,   2, ' ', 1)
          nev_gt1_mc(i) = HSTATI (id,   3, ' ', 1)
          ethr1_gt1_mc(i)= ethr1_gt1_mc(i)/sqrt(nev_gt1_mc(i))
          id = 80 +i
          mx_gt1_mc(i) = HSTATI (id,   1, ' ', 1)


        ENDDO

       print *,'thr,ethr,mx',(thr_mc(i),ethr1_mc(i),mx_mc(i),i=1,7)

        CALL HPAK (510, thr_mc)
        CALL HPAKE(510, ethr1_mc)
        CALL HPAK (560, mx_mc)
        CALL HPAK (520, thr_gt1_mc)
        CALL HPAKE(520, ethr1_gt1_mc)
        CALl HPAK (570, mx_gt1_mc)
        CALL HPAK (530, thr_lt1_mc)
        CALL HPAKE(530, ethr1_lt1_mc)
        CALL HPAK (580, mx_lt1_mc)

          DO j = 1, 6
             DO i = 1, 8
               pn_tmp (i) = pt2_int_mc(i,j)
          ENDDO
           id= 300 + j
            CALL HPAK  (id, pn_tmp)
          ENDDO

c....   store H1 data in histograms
c....   pt2 distributions

****** data pt**2 distributions - cross section
          DO j = 1, 6
            DO i = 1, 8

              pn_tmp (i) = dsig(i,j)
              pne_tmp (i) = dsig_est(i,j)
              pns_tmp (i) = dsig_esy(i,j)
            ENDDO
              print *,'pn_tmp',(pn_tmp(i),i=1,8)
            id = -90 - j
            CALL HPAK  (id, pn_tmp)
            CALL HPAKE (id, pne_tmp)
            CALL HPAK  (id-60, pn_tmp)
            CALL HPAKE (id-60, pns_tmp)
          CALL HUNPAK (id, ptsqr, ' ', 1)
              print *,'ptsqr',(ptsqr(i),i=1,8)
          ENDDO
****** data pt**2 distributions centers of bins in pt**2
          DO j = 1, 6
             DO i = 1, 8
               pn_tmp (i) = pt2_int(i,j)
          ENDDO
           id= -300 - j
            CALL HPAK  (id, pn_tmp)
          ENDDO


        CALL HPAK (-510, thr)
        CALL HPAKE (-510, ethr1)
        CALL HPAK (-610, thr)
        CALL HPAKE (-610, ethr2)
        CALL HPAK (-560, mxx)

        CALL HPAK (-520, thr_lt1)
        CALL HPAKE (-520, ethr1_lt1)
        CALL HPAK (-620, thr_lt1)
        CALL HPAKE (-620, ethr2_lt1)
        CALl HPAK (-570, mx_lt1)

        CALL HPAK (-530, thr_gt1)
        CALL HPAKE (-530, ethr1_gt1)
        CALL HPAK (-630, thr_gt1)
        CALL HPAKE (-630, ethr2_gt1)
        CALL HPAK (-580, mx_gt1)

        CALL HPAK (-410, frac_1)
        CALL HPAKE (-410, efr1_1)
        CALL HPAK (-460, frac_1)
        CALL HPAKE (-460, efr2_1)
        CALL HPAK (-430, mxf_1)

        CALL HPAK (-420, frac_3)
        CALL HPAKE (-420, efr1_3)
        CALL HPAK (-470, frac_3)
        CALL HPAKE (-470, efr2_3)
        CALL HPAK (-440, mxf_3)

c....   print number of accepted events
        PRINT *, 'HZ97210-- Number of accepted moca events: ', nacc

      ENDIF

c----------------------------------------------------------------------
c---- Return

999   RETURN
      END
*CMZ :  1.02/08 02/08/99  15.49.41  by  Tancredi Carli
*-- Author :
      Subroutine HZ98018(iflag)
*****************************************************************************
* This routine has to be run twice with the following code additions:
*       +1000 for the DIRECT component run.
*       +2000 for the RESOLVED component run.
* for all three phases (iflag=1,2,3)
*
*      +10000 to run on parton showers instead of final state particles.
*
* iflag = 1,2 or 3 depending on whether it is the initialization,
*               processing or termination phase (respectively)
*
* The default jetfinder is PXCONE
* To change jetfinder use these values to call the initialisation phase.
* 1 + 10 * (jetfinder number)
*
* This routine produces 7 Monte Carlo graphs.
* id 10 is the cross section differential in nb for ET > 14 GeV 134<W<277GeV
* id 20 is the cross section differential in nb for ET > 17 GeV 134<W<277GeV
* id 30 is the cross section differential in nb for ET > 21 GeV 134<W<277GeV
* id 40 is the cross section differential in nb for ET > 25 GeV 134<W<277GeV
* id 50 is the cross section differential in nb for ET > 14 GeV 134<W<190GeV
* id 60 is the cross section differential in nb for ET > 14 GeV 190<W<233GeV
* id 70 is the cross section differential in nb for ET > 14 GeV 233<W<277GeV
*               These graph will be
*               meaningless unless Xsec and Ntot are set before
*               calling the termination routine.
*               (Xsec - total cross section returned by MC)
*               (Ntot - number of events passed to this routine)
*
* Cuts :        Q2 < 4 GeV2
*               0.2< y_bj < 0.85
*
*
* Author : Jon Butterworth jmb@hep.ucl.ac.uk
*
* Reference : DESY-98-018
*             The European Physical Journal C4 (1998) 591-606
*
*
*****************************************************************************
*
* HERA Tuning defined commons

      IMPLICIT NONE

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.

      CHARACTER*6 jetf

      INTEGER NJET
      DOUBLE PRECISION Jets(50,8)
      DOUBLE PRECISION CONER

      DOUBLE PRECISION elecE
      INTEGER myil,myip
      INTEGER loop,count
      DOUBLE PRECISION phi(2),px(2),py(2),pz(2),ptsq(2)
      DOUBLE PRECISION ppsq(2),energy(2),mass(2)
      DOUBLE PRECISION rap,Et
      DOUBLE PRECISION ybj,q2

C --- cuts arrays
      DOUBLE PRECISION ybjcut(4),q2cut(2)
      DOUBLE PRECISION rapcut(2),Etcut(4)

C --- private copies of Xsec and Ntot from HERACMN
      DOUBLE PRECISION mhxsec(2),mhntot(2)

C *** Data for ET > 14 GeV, full W range
      INTEGER nbin
      PARAMETER(nbin=12)
      REAL eta(nbin),etacr(nbin),cresta(nbin)
      REAL cresys(nbin),band(nbin)
      DATA eta/-0.88,-0.62,-0.38,-0.12, 0.12,0.38,0.62,0.88,1.12,1.38,
     &     1.62,1.88/
      DATA etacr/135,345,690,1040,1330,1535,1790,1785,1715,1690,1655
     &     ,1785/
      DATA cresta/15, 25, 35, 40, 45, 45, 50, 50, 50, 50, 50, 50/
      DATA cresys/10,90,50, 120,90, 170,60,80, 110,80, 110, 100/

C     *** Data for ET > 17 GeV, full W range
      INTEGER nbin2
      PARAMETER(nbin2=11)
      REAL eta2(nbin2),etacr2(nbin2),cresta2(nbin2),cresys2(nbin2)
      DATA eta2/-0.62,-0.38,-0.12, 0.12,0.38,0.62,0.88,1.12,1.38,1.62,1
     &     .88/
      DATA etacr2/80,185,355,500,625,755,750,725,690,710,665/
      DATA cresta2/10,15,25,25,30,35,35,35,30,35,30/
      DATA cresys2/10,30,30,30,50,40,20,50,40,70,30/


C     *** Data for ET > 21 GeV, full W range
      INTEGER nbin3
      PARAMETER(nbin3=5)
      REAL eta3(nbin3),etacr3(nbin3),cresta3(nbin3),cresys3(nbin3)
      DATA eta3/-0.25,0.25,0.75,1.25,1.75/
      DATA etacr3/50,205,305,280,235/
      DATA cresta3/5,10,15,15,15/
      DATA cresys3/15,15,5,20,30/

C     *** Data for ET > 25 GeV, full W range
      INTEGER nbin4
      PARAMETER(nbin4=4)
      REAL eta4(nbin4),etacr4(nbin4),cresta4(nbin4),cresys4(nbin4)
      DATA eta4/0.25,0.75,1.25,1.75/
      DATA etacr4/70,125,125,120/
      DATA cresta4/5,10,10,10/
      DATA cresys4/5,15,15,10/

C     *** Data for ET > 14 GeV, low W range
      INTEGER nbin5
      PARAMETER(nbin5=4)
      REAL eta5(nbin5),etacr5(nbin5),cresta5(nbin5),cresys5(nbin5)
      DATA eta5/0.25,0.75,1.25,1.75/
      DATA etacr5/340,720,700,725/
      DATA cresta5/15,25,25,25/
      DATA cresys5/70,60,50,50/

C     *** Data for ET > 14 GeV, middle W range
      INTEGER nbin6
      PARAMETER(nbin6=5)
      REAL eta6(nbin6),etacr6(nbin6),cresta6(nbin6),cresys6(nbin6)
      DATA eta6/-0.25,0.25,0.75,1.25,1.75/
      DATA etacr6/305,585,555,495,500/
      DATA cresta6/15,20,20,20,20/
      DATA cresys6/60,30,50,30,40/

C     *** Data for ET > 14 GeV, high W range
      INTEGER nbin7
      PARAMETER(nbin7=6)
      REAL eta7(nbin7),etacr7(nbin7),cresta7(nbin7),cresys7(nbin7)
      DATA eta7/-0.75,-0.25,0.25,0.75,1.25,1.75/
      DATA etacr7/220,535,500,495,475,475/
      DATA cresta7/15,20,20,20,20,20/
      DATA cresys7/30,30,40,30,30,20/

      INTEGER intiflag, chjet, iproc, iflag
      SAVE chjet
C     --- choose same jet finder as in the paper --- PXCONE
      DATA chjet/2/
      INTEGER hzflag

      REAL pttemp(nbin),pttemp2(nbin2),pttemp3(nbin3),pttemp4(nbin4)
     &     ,pttemp5(nbin5),pttemp6(nbin6),pttemp7(nbin7)
      INTEGER ivec,jvec
      REAL sqrt

	LOGICAL parton_showers

	parton_showers=.FALSE.
        intiflag=iflag
	IF (intiflag.gt.10000) THEN
	   parton_showers=.TRUE.
	   intiflag=MOD(intiflag,10000)
	ENDIF

C     --- choose direct/resolved
C     --- recommend 1 - DIRECT, 2 - RESOLVED
      IF (intiflag.gt.1000) THEN
         iproc=INT(intiflag/1000)
         intiflag=MOD(intiflag,1000)
      ENDIF
      IF ((iproc.gt.2).or.(iproc.lt.1)) THEN
         PRINT*,'HZ98018 : Badly called routine'
         PRINT*,'          please set intiflag +1000 or +2000'
      ENDIF

C     --- choose jet finder
      IF ((intiflag.gt.10).and.(MOD(intiflag,10).eq.1)) THEN
         chjet=INT(intiflag/10)
         intiflag=MOD(intiflag,10)
      ENDIF

      IF (parton_showers) THEN
         chjet=-1*chjet
      ENDIF

      IF (intiflag.eq.1) THEN
C     *** Initialisation run ***
C     *** Create directories ***
         IF (iproc.eq.1) THEN
             CALL HCDIR('//HISTO',' ')
	     IF (parton_showers) THEN
		CALL HMDIR('PS98018','S')
		CALL HCDIR('//PAWC',' ')
		CALL HMDIR('PS98018','S')
	     ELSE
		CALL HMDIR('98018','S')
		CALL HCDIR('//PAWC',' ')
		CALL HMDIR('98018','S')
	     ENDIF

            CALL HBOOK1(10,'MC cross section (nb) E?T!"g# 14 GeV'
     &           ,nbin ,-1.0 ,2.0 ,0.)

            CALL HBOOK1(20,'MC cross section (nb) E?T!"g# 17 GeV'
     &           ,nbin2 ,-0.75 ,2.0 ,0.)

            CALL HBOOK1(30,'MC cross section (nb) E?T!"g# 21 GeV'
     &           ,nbin3 ,-0.5 ,2.0 ,0.)

            CALL HBOOK1(40,'MC cross section (nb) E?T!"g# 25 GeV'
     &           ,nbin4 ,-0.0 ,2.0 ,0.)

            CALL HBOOK1(50,'MC cross section (nb) 134"l#W"l190 GeV'
     &           ,nbin5 ,0.0 ,2.0 ,0.)

            CALL HBOOK1(60,'MC cross section (nb) 190"l#W"233 GeV'
     &           ,nbin6 ,-0.5 ,2.0 ,0.)

            CALL HBOOK1(70,'MC cross section (nb) 233"l#W"l277 GeV'
     &           ,nbin7 ,-1.0 ,2.0 ,0.)

         ENDIF
         IF (parton_showers) THEN
            CALL HCDIR('//HISTO/PS98018',' ')
            CALL HCDIR('//PAWC/PS98018',' ')
         ELSE
            CALL HCDIR('//HISTO/98018',' ')
            CALL HCDIR('//PAWC/98018',' ')
         ENDIF

         CALL HBOOK1(iproc*100+10
     &        ,'MC cross section (nb) E?T!"g# 14 GeV',nbin ,-1.0 ,2.0
     &        ,0.)

         CALL HBOOK1(iproc*100+20
     &        ,'MC cross section (nb) E?T!"g# 17 GeV',nbin2 ,-0.75 ,2
     &        .0,0.)

         CALL HBOOK1(iproc*100+30
     &        ,'MC cross section (nb) E?T!"g# 21 GeV',nbin3 ,-0.5 ,2.0
     &        ,0.)

         CALL HBOOK1(iproc*100+40
     &        ,'MC cross section (nb) E?T!"g# 25 GeV',nbin4 ,-0.0 ,2.0
     &        ,0.)

         CALL HBOOK1(iproc*100+50
     &        ,'MC cross section (nb) 134"l#W"l190 GeV',nbin5 ,0.0 ,2
     &        .0,0.)

         CALL HBOOK1(iproc*100+60
     &        ,'MC cross section (nb) 190"l#W"233 GeV',nbin6 ,-0.5 ,2
     &        .0,0.)

         CALL HBOOK1(iproc*100+70
     &        ,'MC cross section (nb) 233"l#W"l277 GeV',nbin7 ,-1.0 ,2
     &        .0 ,0.)


C     --- photoproduction cuts

         ybjcut(1)=0.2
         ybjcut(2)=0.4
         ybjcut(3)=0.6
         ybjcut(4)=0.85
         q2cut(1)=0.
         q2cut(2)=4.

         Etcut(1)=14.
         Etcut(2)=17.
         Etcut(3)=21.
         Etcut(4)=25.

C     --- standard cone radius is 1.0
         CALL HZJETRAD(2,CONER)
         IF (CONER.lt.0.0) THEN
            CONER=1.0
         ENDIF
         CALL HZJTNAME(chjet,jetf)

         WRITE(6,*)'**********************************************'
         WRITE(6,*)'* HZ98018 called, histograms will be output. *'
         WRITE(6,*)'*     Jet finder selected : ',jetf,'           *'
         WRITE(6,1001)'*        with cone radius : ',CONER,'   *'
         WRITE(6,*)'**********************************************'

 1001    FORMAT(A29,F5.2,A13)

      ELSE IF (intiflag.eq.2) THEN
C     *** Filling runs ***

C     *** Change directory to our graphs ***
         IF (parton_showers) THEN
            CALL HCDIR('//PAWC/PS98018',' ')
         ELSE
            CALL HCDIR('//PAWC/98018',' ')
         ENDIF

         q2=hzphokin(1)
         IF (q2.eq.-1) THEN
            PRINT*,'HZ98018: HZPHOKIN returns error for Q2'
         ELSEIF (q2.lt.0) THEN
            q2=abs(q2)
         ENDIF
         ybj=hzphokin(3)
         IF (ybj.eq.-1) THEN
            PRINT*,'HZ98018: HZPHOKIN returns error for ybj'
         ENDIF

C     *** Fill histograms for full range ***

         IF ((ybj.ge.ybjcut(1)).and.(ybj.le.ybjcut(4))
     &        .and.(q2.lt.q2cut(2))) Then

            elecE=27.52
            hzflag=HZIBEAM(myip,myil)
            IF (hzflag.ge.0) Then
               elecE=abs(PHEP(4,myil))
            ELSE
               PRINT*,'HZ98018: Electron not found. E=0.001'
               PRINT*,'         event will be rejected'
               elecE=0.001
            ENDIF

            CALL hzjtfind(chjet,CONER,NJET,Jets)

            DO loop=1,NJET
               Et=Jets(loop,3)
               rap=Jets(loop,1)

               IF (Et.gt.Etcut(1)) THEN
                  CALL HFILL(INT(iproc*100+10), REAL(rap),0.,wtx)
                  IF (ybj.lt.ybjcut(2)) THEN
                     CALL HFILL(INT(iproc*100+50), REAL(rap),0.,wtx)
                  ELSEIF (ybj.lt.ybjcut(3)) THEN
                     CALL HFILL(INT(iproc*100+60), REAL(rap),0.,wtx)
                  ELSE
                     CALL HFILL(INT(iproc*100+70), REAL(rap),0.,wtx)
                  ENDIF
               ENDIF
               IF (Et.gt.Etcut(2)) THEN
                  CALL HFILL(INT(iproc*100+20), REAL(rap), 0. ,wtx)
               ENDIF
               IF (Et.gt.Etcut(3)) THEN
                  CALL HFILL(INT(iproc*100+30), REAL(rap), 0. ,wtx)
               ENDIF
               IF (Et.gt.Etcut(4)) THEN
                  CALL HFILL(INT(iproc*100+40), REAL(rap), 0. ,wtx)
               ENDIF

            ENDDO

         ENDIF                  ! Q2 & y cuts

      ELSE IF (intiflag.eq.3) THEN
C     *** Termination run ***
C *** Change directory ***
         IF (parton_showers) THEN
            CALL HCDIR('//PAWC/PS98018',' ')
         ELSE
            CALL HCDIR('//PAWC/98018',' ')
         ENDIF
C *** Finish off histograms ***

         IF (Xsec.eq.0) THEN
            PRINT*,'HZ98018: termination called with zero cross section'
            PRINT*,'          cross section graph meaningless'
            PRINT*,'          in process :',iproc*1000
            Xsec=1
          ENDIF
          IF (Ntot.eq.0) THEN
            PRINT*,'HZ98018: termination called with no total events'
            PRINT*,'          cross section graph meaningless'
            PRINT*,'          in process :',iproc*1000
            Ntot=1
          ENDIF

C --- store Xsec and Ntot for both direct and resolved events, in pb.
          mhXsec(iproc)=Xsec*1000.
          mhntot(iproc)=Ntot

          IF (iproc.eq.2) THEN
C --- only finally
C --- create proper cross-section data
             CALL HBOOK1(-10,'Data cross section (nb) E?T!"g# 14 GeV'
     &          ,nbin ,-1.0 ,2.0 ,0.)

             CALL HBOOK1(-20,'Data cross section (nb) E?T!"g# 17 GeV'
     &          ,nbin2 ,-0.75 ,2.0 ,0.)

             CALL HBOOK1(-30,'Data cross section (nb) E?T!"g# 21 GeV'
     &          ,nbin3 ,-0.5 ,2.0 ,0.)

             CALL HBOOK1(-40,'Data cross section (nb) E?T!"g# 25 GeV'
     &            ,nbin4 ,0.0 ,2.0 ,0.)

             CALL HBOOK1(-50,'Data cross section (nb) 134"l#W"l190 GeV'
     &            ,nbin5 ,0.0 ,2.0 ,0.)

             CALL HBOOK1(-60,'Data cross section (nb) 190"l#W"233 GeV'
     &            ,nbin6 ,-0.5 ,2.0 ,0.)

             CALL HBOOK1(-70,'Data cross section (nb) 233"l#W"l277 GeV'
     &            ,nbin7 ,-1.0 ,2.0 ,0.)

             CALL HPAK(-10,etacr)
             CALL HPAK(-20,etacr2)
             CALL HPAK(-30,etacr3)
             CALL HPAK(-40,etacr4)
             CALL HPAK(-50,etacr5)
             CALL HPAK(-60,etacr6)
             CALL HPAK(-70,etacr7)

             DO ivec=1,nbin
                pttemp(ivec)=sqrt(cresta(ivec)**2+cresys(ivec)**2)
             ENDDO
             CALL HPAKE(-10,pttemp)

             DO ivec=1,nbin2
                pttemp2(ivec)=sqrt(cresta2(ivec)**2+cresys2(ivec)**2)
             ENDDO
             CALL HPAKE(-20,pttemp2)

             DO ivec=1,nbin3
                pttemp3(ivec)=sqrt(cresta3(ivec)**2+cresys3(ivec)**2)
             ENDDO
             CALL HPAKE(-30,pttemp3)

             DO ivec=1,nbin4
                pttemp4(ivec)=sqrt(cresta4(ivec)**2+cresys4(ivec)**2)
             ENDDO
             CALL HPAKE(-40,pttemp4)

             DO ivec=1,nbin5
                pttemp5(ivec)=sqrt(cresta5(ivec)**2+cresys5(ivec)**2)
             ENDDO
             CALL HPAKE(-50,pttemp5)

             DO ivec=1,nbin6
                pttemp6(ivec)=sqrt(cresta6(ivec)**2+cresys6(ivec)**2)
             ENDDO
             CALL HPAKE(-60,pttemp6)

             DO ivec=1,nbin7
                pttemp7(ivec)=sqrt(cresta7(ivec)**2+cresys7(ivec)**2)
             ENDDO
             CALL HPAKE(-70,pttemp7)

C --- normalise resolved/direct component histograms
            CALL HOPERA(110,'+e',110,110,REAL(4*mhXsec(1)/mhNtot(1)),0.)
            CALL HOPERA(210,'+e',210,210,REAL(4*mhXsec(2)/mhNtot(2)),0.)
            CALL HOPERA(120,'+e',120,120,REAL(4*mhXsec(1)/mhNtot(1)),0.)
            CALL HOPERA(220,'+e',220,220,REAL(4*mhXsec(2)/mhNtot(2)),0.)
            CALL HOPERA(130,'+e',130,130,REAL(2*mhXsec(1)/mhNtot(1)),0.)
            CALL HOPERA(230,'+e',230,230,REAL(2*mhXsec(2)/mhNtot(2)),0.)
            CALL HOPERA(140,'+e',140,140,REAL(2*mhXsec(1)/mhNtot(1)),0.)
            CALL HOPERA(240,'+e',240,240,REAL(2*mhXsec(2)/mhNtot(2)),0.)
            CALL HOPERA(150,'+e',150,150,REAL(2*mhXsec(1)/mhNtot(1)),0.)
            CALL HOPERA(250,'+e',250,250,REAL(2*mhXsec(2)/mhNtot(2)),0.)
            CALL HOPERA(160,'+e',160,160,REAL(2*mhXsec(1)/mhNtot(1)),0.)
            CALL HOPERA(260,'+e',260,260,REAL(2*mhXsec(2)/mhNtot(2)),0.)
            CALL HOPERA(170,'+e',170,170,REAL(2*mhXsec(1)/mhNtot(1)),0.)
            CALL HOPERA(270,'+e',270,270,REAL(2*mhXsec(2)/mhNtot(2)),0.)

C --- now calculate cross-section graphs 10,20,30,40,50,70
            CALL HOPERA(110,'+e',210,10,1.,1.)
            CALL HOPERA(120,'+e',220,20,1.,1.)
            CALL HOPERA(130,'+e',230,30,1.,1.)
            CALL HOPERA(140,'+e',240,40,1.,1.)
            CALL HOPERA(150,'+e',250,50,1.,1.)
            CALL HOPERA(160,'+e',260,60,1.,1.)
            CALL HOPERA(170,'+e',270,70,1.,1.)
            CALL HZCHISQ(-10,10)
            CALL HZCHISQ(-20,20)
            CALL HZCHISQ(-30,30)
            CALL HZCHISQ(-40,40)
            CALL HZCHISQ(-50,50)
            CALL HZCHISQ(-60,60)
            CALL HZCHISQ(-70,70)
          ENDIF

        ELSE
C *** End ***
          PRINT*,'HZ98018:Please run routine with iflag set to 1,2 or 3'
          PRINT*,'        with +1000 or +2000 for DIR or RES events.'
        ENDIF

        RETURN
        END
*CMZ :  1.02/06 04/02/99  11.23.04  by  Tancredi Carli
*CMZ :  1.02/00 04/10/98  22.18.08  by  Tancredi Carli
*CMZ :  1.01/15 03/09/98  19.46.00  by  Tancredi Carli
*-- Author :    Hannes Jung   13/03/98
      subroutine HZ98029(IFLAG)
****************************************************************************
* Purpose: diffractive hadron production in DIS
*
*
* Event selection:
*
* Running:
*
* Arguments: iflag=1 initialisation
*            iflag=1 filling
*            iflag=3 termination
*
* written by:
****************************************************************************
      IMPLICIT NONE
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
* common that gives the position of particles in X and Y system
      integer nxobj,nyobj,nxgag,nygag
      double precision pom
      common /diffhad/pom(5),nxobj(5000),nyobj(5000),nxgag,nygag
*
      Integer numjet
      Parameter (numjet=50)
      Double precision pj(numjet,8)
      Double precision pbeam(4),pgam(4),pcm(4),ph(5),plab(5,NMXHEP)
*
      Integer i,iflag,ihep
      Character*5 xxxx
*
      Real pi,rd,eb,ee
      Parameter (ee=27.5)
      Integer iel,idum,ibeam
      Parameter (pi=3.1415927,rd=180./pi)
      Integer nentry
      Real x,y,q2,enel,thel,efwd,th,lx,lxj
*
      Integer ierr
      Integer maxhi,modjet,maxjet
      Parameter (maxhi=2000,modjet=2,maxjet=30)
      Real  selj(maxjet,4),help,empz,empzh,xg,empzl,empzhl,xgl
      Integer ipjet(maxjet),l,k
      Real nev(maxhi),lum,xw,nev2(maxhi)
      Real deta,ptj2,thj
      Real xpom, x_pom,beta,xgluon,shat,p_sh(4),p_mx(4),mx2,mx
      Real xmas,ymas,t
      Real pj1,pj2,pr
      Integer njet,nj,nsel,ij,idhe,nhst,iy
      Double precision rcone
      Parameter (rcone=1.)
      Logical lp,twojet,hadpro
      Data lp/.false./
*********************************************************************
      Integer nx
      Real n2,nall,nall2,nall3
      Real xmin,xmax
      save xxxx,nev,nall
      Data xxxx/'98029'/,NENTRY/0/
      Real nmx(3),npt2,nxf
      Integer npt2bin,nxfbin,nxptbin,iprot
      parameter (npt2bin=6)
      parameter (nxfbin=14)
      parameter (nxptbin=14)
      Real pt2,pt2bin(npt2bin+1),ptl,xf,xfbin(nxfbin+1)
      Real xptbin(nxptbin+1),eta
      Data pt2bin/0.0,0.5,1.,1.5,2.,2.5,4.0/
      Data xfbin/-1.,-0.61,-0.35,-0.2,-0.11,-0.06,-0.03,0.0,
     +            0.03,0.06,0.11,0.2,0.35,0.61,1./

      Data xptbin/-1.,-0.61,-0.35,-0.2,-0.11,-0.06,-0.03,0.0,
     +            0.03,0.06,0.11,0.2,0.35,0.61,1./
*
* xf data points
      Real xfdat(14)
      data xfdat /0.0          ,0.6128334,2.502780,
     +            6.722888     ,14.35409 ,25.47832,
     +            38.97226     ,41.50776 ,25.50608,
     +            15.86608     ,7.249624 ,2.898936,
     +            0.6434051    ,0.3205689E-01/
      Real xfdate(14)
      data xfdate/0.0          ,0.1639854,0.3604059,
     +            0.8731437    ,1.864209 ,3.442043 ,
     +            4.914548     ,4.464791 ,2.808532 ,
     +            1.886804     ,1.006006 ,0.4336618,
     +            0.1044459    ,0.6333744E-02/

* seagull data points
*
      Real seag(14)
      data seag  /0.0          ,0.6129190,0.4426591,
     +            0.4094211    ,0.2504560,0.1961280,
     +            0.1547809    ,0.1507783,0.2177576,
     +            0.2894962    ,0.3887810,0.5986921,
     +            0.9272553    ,0.0/
      Real seage(14)
      data seage /0.0          ,0.2672890    ,0.1001036    ,
     +            0.7536040E-01,0.4259405E-01,0.3402222E-01,
     +            0.2724520E-01,0.2423158E-01,0.3575291E-01,
     +            0.4611826E-01,0.6093225E-01,0.1087604    ,
     +            0.2259952    ,0.0/
*
* Pt2 points
*
      Real pt2dat(6)
      Data pt2dat /0.6894866    ,0.1620546    ,0.5348691E-01,
     +             0.2778080E-01,0.2245054E-01,0.6371100E-02/
      Real pt2date(6)
      Data pt2date/0.1251314    ,0.4664608E-01,0.1258624E-01,
     +             0.1053530E-01,0.1044376E-01,0.2364720E-02/
*
* energyflow points
*---------------------------------------------------
*eta       3<Mx<8
*----------------------------------------------------
      real efmx1(24)
      data efmx1/0.0          ,0.0          ,0.0          ,
     +           0.0          ,0.0          ,0.0          ,
     +           0.2319668    ,0.4187408    ,0.6852522    ,
     +           0.9642797    ,1.237603     ,1.440106     ,
     +           1.714669     ,1.433049     ,0.9741630    ,
     +           0.5792634    ,0.3224706    ,0.0          ,
     +           0.0          ,0.0          ,0.0          ,
     +           0.0          ,0.0          ,0.0          /
*---------------------------------------------------
*eta       8<Mx<18
*----------------------------------------------------
      real efmx2(24)
      data efmx2/0.0          ,0.0          ,0.0          ,
     +           0.0          ,0.0          ,0.2670097    ,
     +           0.7485002    ,1.604767     ,1.990809     ,
     +           2.205431     ,1.873415     ,1.597115     ,
     +           2.063725     ,2.324681     ,2.757001     ,
     +           2.329961     ,1.149755     ,0.6476511    ,
     +           0.3185704    ,0.0          ,0.0          ,
     +           0.0          ,0.0000000E+00,0.0          /

*---------------------------------------------------
*eta       18>Mx
*----------------------------------------------------
      real efmx3(24)
      data efmx3/0.0          ,0.0          ,0.0          ,
     +           0.0          ,0.0          ,0.6814263    ,
     +           2.567204     ,3.731685     ,4.114427     ,
     +           3.002993     ,2.170356     ,1.912852     ,
     +           2.107126     ,2.985842     ,4.156892     ,
     +           5.070118     ,3.515426     ,2.059493     ,
     +           1.000870     ,0.0          ,0.0          ,
     +           0.0          ,0.0          ,0.0          /

*Energy Flow Errors
*
*---------------------------------------------------
*eta       3<Mx<8
*----------------------------------------------------
      real efmx1e(24)
      data efmx1e/0.0          ,0.0          ,0.0          ,
     +            0.0          ,0.0          ,0.0          ,
     +            0.7838635E-01,0.1610065    ,0.2110434    ,
     +            0.2595083    ,0.1390658    ,0.1493511    ,
     +            0.1886857    ,0.2149692    ,0.2015068    ,
     +            0.1189617    ,0.6361540E-01,0.0          ,
     +            0.0          ,0.0          ,0.0          ,
     +            0.0          ,0.0          ,0.0          /

*---------------------------------------------------
*eta       8<Mx<18
*----------------------------------------------------
      real efmx2e(24)
      data efmx2e/0.0          ,0.0          ,0.0          ,
     +            0.0          ,0.0          ,0.1448712    ,
     +            0.1818503    ,0.6667079E-01,0.1105839    ,
     +            0.1221576    ,0.1314093    ,0.1032115    ,
     +            0.1336651    ,0.1858400    ,0.2905588    ,
     +            0.2857165    ,0.1343448    ,0.1143797    ,
     +            0.9657340E-01,0.0          ,0.0          ,
     +            0.0          ,0.0          ,0.0          /

*---------------------------------------------------
*eta       18>Mx
*----------------------------------------------------
      real efmx3e(24)
      data efmx3e/0.0          ,0.0          ,0.0          ,
     +            0.0          ,0.0          ,0.2279920    ,
     +            0.4425851    ,0.5789824    ,0.5070215    ,
     +            0.2493457    ,0.2377237    ,0.1537880    ,
     +            0.2004447    ,0.2493169    ,0.4504904    ,
     +            0.7132304    ,0.6227964    ,0.4177885    ,
     +            0.1989908    ,0.0          ,0.0          ,
     +            0.0          ,0.0          ,0.0          /


*********************************************************************
*
*                      Initialization
*
*********************************************************************
      NENTRY=NENTRY+1
*
      IF (iflag.eq.1) then
*
         nall=0.
         nall2=0.
         nall3=0.
         n2=0.
         npt2=0.
         nxf=0.
         call Vzero(nev,maxhi)
         call Vzero(nev2,maxhi)
         call Vzero(nmx,3)
*
*
* Initialisation: The following MUST always be done
* (i) make subdirectory in PAWC
* - use the name as the xxxxxx in HZxxxxxx subroutine
* (i) make subdirectory in o/p file
*
         Call hcdir('//PAWC',' ')
         call hmdir(xxxx,'S')
         Call hcdir('//HISTO',' ')
         call hmdir(xxxx,'S')
*
* book histos
*
         nx=6
         xmin=0.05e-2
         xmax=0.35e-02
*
         call hbook1(221,'  y     ',100,0.,1.,0.)
         call hbook1(222,'  Q2     ',100,0.,100.,0.)
         call hbook1(223,'  xpom    ',100,0.,0.1,0.)
         call hbook1(224,'  M_x  0-20  ',100,0.,20.,0.)
         call hbook1(225,'  M_x  0-100  ',100,0.,100.,0.)
         call hbook1(226,'  z ',100,0.,1.,0.)
         call hbook1(227,'  pt ',100,0.,50.,0.)
         call hbook1(228,'  M_y  0-20  ',100,0.,20.,0.)
         call hbook1(229,'  M_y  0-100  ',100,0.,100.,0.)


*
* pack data into histograms
*
*         Call hpak (-122,secpt)
*         Call hpake(-122,stapt)

* histos for hadron production
         call hbook1(1001,'  eta* 3<mx<8      ',24,-6.,6.,0.)
         call hbook1(1002,'  eta* 8<mx<18     ',24,-6.,6.,0.)
         call hbook1(1003,'  eta* 18<mx<30    ',24,-6.,6.,0.)
         call hbookb(1010,'  pt2 8<mx<18    ',npt2bin,pt2bin,0.)
         call hbookb(1011,'  xf 8<mx<18    ',nxfbin,xfbin,0.)
         call hbookb(1012,'  pt2mean 8<mx<18    ',nxptbin,xptbin,0.)
         call hbook1(-1001,' data  eta* 3<mx<8      ',24,-6.,6.,0.)
         call hbook1(-1002,' data  eta* 8<mx<18     ',24,-6.,6.,0.)
         call hbook1(-1003,' data  eta* 18<mx<30    ',24,-6.,6.,0.)
         call hbookb(-1010,' data pt2 8<mx<18    ',npt2bin,pt2bin,0.)
         call hbookb(-1011,' data xf 8<mx<18    ',nxfbin,xfbin,0.)
         call hbookb(-1012,' data pt2mean 8<mx<18    '
     +     ,nxptbin,xptbin,0.)
* pack data into histograms
*
         Call hpak (-1001,efmx1)
         Call hpake(-1001,efmx1e)
         Call hpak (-1002,efmx2)
         Call hpake(-1002,efmx2e)
         Call hpak (-1003,efmx3)
         Call hpake(-1003,efmx3e)
         Call hpak (-1011,xfdat)
         Call hpake(-1011,xfdate)
         Call hpak (-1010,pt2dat)
         Call hpake(-1010,pt2date)
         Call hpak (-1012,seag)
         Call hpake(-1012,seage)
         write(6,*) ' in hz98029 '
*
*********************************************************************
*
*                      Event Processing
*
*********************************************************************
      Else if(iflag.eq.2) then
*
* Filling: The following MUST always be done
* (i) move to the correct sub-directory in PAWC
*
         call hcdir('//PAWC/'//xxxx,' ')
*
         xw=wtx
         nall=nall+xw
*
         ierr=HZIBEAM(ibeam,idum)
         if (.not.(ierr.eq.1)) then
            write(6,*) 'HZ'//xxxx,' beams not found ! '
            return
         else
            Do i=1,4
               pbeam(i)=PHEP(i,IBEAM)
            enddo
         endif
*
         eb=real(PHEP(4,idum))
         if (abs(abs(eb)-ee).gt.0.1) then
            if (nentry.lt.10) then
               write(6,*) 'HZ'//xxxx,' Electron not at ',ee,' ! ',eb
            elseif (nentry.eq.10) then
               write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     +         ' ...last message ! '
            endif
            return
         endif
         ierr=HZIPGAM(ph)
         if (ierr.eq.-1) then
            write(6,*) 'HZ'//xxxx,' boson vector not found ! '
C           call VZERO(ph,5)
            Do i=1,5
             ph(i)=0.
            enddo
         else
            Do i=1,4
               pgam(i)=ph(i)
            enddo
         endif
*
* Event selection
*
         q2=real(HZDISKIN(1))
         x =real(HZDISKIN(2))
         y =real(HZDISKIN(3))

         deta = -999.
         njet = 0
*
         if (lp) then
            write(*,*) 'Hz'//xxxx,' x y q2=',x,y,q2
         endif
*
* get electron variables for kinematic selection
*
         iel=HZIDELEC(idum)
         if (iel.eq.-1) then
            write(*,*) 'Hz'//xxxx,' electron not found '
            return
         endif
         enel=real(PHEP(4,iel))
         thel=real(HZPHMANG(PHEP(3,iel), sqrt(PHEP(1,iel)**2+PHEP(2,
     +   iel)**2)))*rd
*
*
*  do diffractive selection
         x_pom=1.
         xpom=999.
         do i=1,4
            p_mx(i)=0.
         enddo
         Do 10   ihep=1,nhep
* do not count scattered electron
            if(ihep.eq.iel) goto 10
            idhe=idhep(ihep)
*  proton tag

            if ( abs(idhe).eq.2212.and.jmohep(1,ihep).eq.2 ) then
               iprot = ihep
               goto 11
            endif
   10    continue
   11    continue
         call hzhadgap(xmas,ymas,xpom,t)
         do i=1,4
            pbeam(i)=pom(i)
         enddo
         mx2=xmas**2
         if( xpom.le.x_pom) x_pom=xpom
         if (lp) then
            write(6,*) 'Hz'//xxxx,' enel= ',enel,' thel= ',thel
            write(6,*) 'Hz'//xxxx,' y= ',y,' q2= ',q2
            write(6,*) 'Hz'//xxxx,' x_pom= ',x_pom,' m_x ',sqrt(mx2)
         endif
         if(x_pom.lt.x) then
            if(lp) then
               write(6,*) ' hz98029: x < x_pom = '
               write(6,*) ' hz98029: x = ',x,' x_pom = ',xpom,' t = ',t
               write(6,*) ' hz98029: xmas = ',xmas,' ymas = ',ymas
               write(6,*) ' hz98029: q2 = ',q2,' y = ',y
               write(6,*) 'Hz'//xxxx,' nxgag,nygag ',nxgag,nygag
               write(6,*) 'Hz'//xxxx,' nxobj ',(nxobj(i),i=1,nxgag)
               write(6,*) 'Hz'//xxxx,' nyobj ',(nyobj(i),i=1,nygag)
C               call hzlulist(1)
            endif
            return
         endif

         hadpro=.true.

         if (y.lt.0.05) hadpro=.false.
         if (y.gt.0.6) hadpro=.false.
         if (q2.lt.7.5) hadpro=.false.
         if (q2.gt.100.) hadpro=.false.
         if (x_pom.gt.0.025) hadpro=.false.
         if (ymas.gt.1.6) hadpro=.false.
         if (abs(t).gt.1.0) hadpro=.false.
*
*  hadron production
         if(hadpro) then
            nall3 = nall3 + xw
            mx=sqrt(amax1(0.,mx2))
            if(mx.ge.3.0.and.mx.lt.8.0) then
               nmx(1)=nmx(1)+xw
            elseif(mx.ge.8.0.and.mx.lt.18.0) then
               nmx(2)=nmx(2)+xw
            elseif(mx.ge.18.0.and.mx.lt.30.0) then
               nmx(3)=nmx(3)+xw
            endif
            if(mx.ge.8.0.and.mx.lt.18.0) then
               npt2=npt2+xw
               nxf=nxf+xw
            endif
            ierr=HZIPGAM(ph)
            if (ierr.eq.-1) then
               write(6,*) 'HZ'//xxxx,' boson vector not found ! '
C              call VZERO(ph,5)
               Do i=1,5
                ph(i)=0.
               enddo
            else
               Do i=1,4
                  pgam(i)=ph(i)
               enddo
            endif
*
            call HZHCMINI(pbeam,pgam,ierr)
            if (ierr.eq.1) then
               write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
               return
            endif
*
*       loop and boost
*
            nhst = 1
            do ihep=nhst,nhep
               Do i=1,4
                  Ph(i)=PHEP(i,ihep)
                  Plab(i,ihep)=PHEP(i,ihep)
                  phep(i,ihep)=0.0
               enddo
*
               call HZHCM(ph,pcm,ierr)
               if (ierr.eq.1) then
                  write(6,*) 'HZ'//xxxx,' problem with boost to cms '
     +            //'! '
                  return
               endif
*

               if (isthep(ihep).ne.1.or.ihep.eq.iel) then
                  th=real(HZPHMANG(PHEP(3,ihep), sqrt(PHEP(1,ihep)**
     +            2+PHEP(2,ihep)**2)))*rd
               endif
*
               Do i=1,4
                  PHEP(i,ihep)=Pcm(i)
               enddo
* do not count particles assigned to Y system
*                  write(6,*) ' hz98029 nyobj(iy) ',(nyobj(iy),iy=1,nygag)
               do iy=1,nygag
                  if(ihep.eq.nyobj(iy)) goto 30
               enddo
               if(ihep.ne.iel) then
                  if(isthep(ihep).eq.1.and.phep(4,ihep).ne.0.0) then
                     eta= real(phep(4,ihep)+phep(3,ihep))/(phep(4,ihep)
     +               - phep(3,ihep))
                     eta = 0.5*log(eta)
                     pr = real(phep(1,ihep)**2 + phep(2,ihep)**2)
                     eta = sign(log(min((sqrt(pr + real(phep(3,ihep))**
     +               2) - abs(real(phep(3,ihep))))/sqrt(pr),1e20)),
     +               real(phep(3, ihep)))

                     if(mx.ge.3.0.and.mx.lt.8.0) then
                        call hfill(1001,eta,0.,sngl(phep(4,ihep)*xw)
     +                  )
                     elseif(mx.ge.8.0.and.mx.lt.18.0) then
                        call hfill(1002,eta,0.,sngl(phep(4,ihep)*xw)
     +                  )
                     elseif(mx.ge.18.0.and.mx.lt.30.0) then
                        call hfill(1003,eta,0.,sngl(phep(4,ihep)*xw)
     +                  )
                     endif
                     if(mx.ge.8.0.and.mx.lt.18.0.and.ihchrg(ihep)
     +               .ne.0) then
                        pt2=real(phep(1,ihep)**2 + phep(2,ihep)**
     +                  2)
                        xf = 2.*real(phep(3,ihep))/mx
                        if(xf.ge.0.2.and.xf.lt.0.4) call hfill(1010,
     +                  pt2,0.,xw)
                        call hfill(1011,xf,0.,xw)
                        call hfill(1012,xf,0.,pt2*xw)
                     endif
                  endif
               endif
   30          continue
            enddo
* fill original PHEP vectors
            do ihep=nhst,nhep
               Do i=1,4
                  PHEP(i,ihep)= Plab(i,ihep)
               enddo
            enddo
         endif
*

*********************************************************************
*
*                      Termination
*
*********************************************************************

      Else if(iflag.eq.3) then

* Termination: The following MUST always be done
* (i) Move to the correct PAW subdirectory
*
         call hcdir('//PAWC/'//xxxx,' ')
*
         lum=999999999.
         if (xsec.ne.0.) then
            lum=real(nall)/real(xsec)
         else
            write(6,*) 'hz',xxxx,' xsec=0 ! '
         endif
*
         write(6,*) 'hzhad: Total Cross= ', real(xsec),' nall= ',nall
*
*
*      normalize the histos
*
*

* now the hadron production
         if(nall3.gt.1) then
            do i=1,3
               call hzhinrm( 1000+i, 0, nmx(i), 1 )
               call hzchisq(-1*(1000+i),1000+i)
            enddo
            call hzhinrm( 1010, 0, npt2, 1 )
            call hzchisq(-1010,1010)
            call hopera(1012,'/',1011,1012,1.,1.)
            call hzhinrm( 1011, 0, nxf, 1 )
            call hzchisq(-1011,1011)
         endif
      endif
*
      RETURN
      END
*CMZ :  2.00/04 31/07/2000  20.46.13  by  Tancredi Carli
*CMZ :  1.02/06 05/02/99  10.10.45  by  Tancredi Carli
*CMZ :  1.02/02 23/11/98  14.51.38  by  Tancredi Carli
*-- Author :    Tancredi Carli   23/11/98
*****************************************************************************
	Subroutine HZ98038(imode)
*****************************************************************************
* Running: Ee=27.5 (positrons), Ep=820, no polarization
*
* purpose: produce histograms for:
*
*          jet shape variables in lab frame:  differential jetshp rho,
*          ---------------------------------  integrated jetshp psi
*
*          jetfinder PXCONE with cone radius = 1 is used
*
*          event selection:
*          i)     Q**2 > 100 GeV**2
*          for NC events:
*          NCii)  energy of scattered lepton > 10 GeV
*          NCiii) y < 0.95
*          NCiv)  for eta(lepton) > 2: Et of scattered lepton > 20 GeV
*          for CC events:
*          CCii)  pt of neutrino > 11 GeV
*
*          jet selection:
*          Ji)    Et(jet) > 14 GeV
*          Jii)  -1 < eta(jet) < 2
*
*
* note:    CC event processing not implemented yet !
*
* produced histos:
*          - figure number is that one from the paper,
*          - number in parentheses is number of produced MC histogram
*          - ZEUS data histograms have corresponding negative numbers plus
*            offset=-100 for statistical errors only,
*            offset=-300 for total up error,
*            offset=-400 for total down error
*
*          note: chi**2 is calculated using only statistical errors for
*                ZEUS data
*
*          FIG. 1: NC - DIFFERENTIAL JET SHAPES (et > 14 GeV, Q2>100 GeV2)
*          (11:) -1<eta<0, (12:) 0<eta<1, (13:) 1<eta<1.5, (14:) 1.5<eta<2
*
*          FIG. 2: NC - DIFFERENTIAL JET SHAPES (-1<eta<2, Q2>100 GeV2)
*          (21:) 14<et<21, (22:) 21<et<29, (23:) 29<et<37, (24:) 37<et<45
*
*          FIG. 3: NC - INTEGRATED JET SHAPES at r/R=0.5 (Q2>100 GeV2)
*          (31:) as a function of eta (ET > 14 GeV)
*          (32:) as a function of ET
*
*          FIG. 4: CC -  DIFFERENTIAL JET SHAPES (-1<eta<2, Q2>100 GeV2)
*          (41:) 14<et<21, (42:) 21<et<29, (43:) 29<et<37, (44:) 37<et<45
*
*          FIG. 5: CC - INTEGRATED JET SHAPES at r/R=0.5 (Q2>100 GeV2)
*          (51:) as a function of eta (ET > 14 GeV)
*          (52:) as a function of ET
*
*          FIG. 6: RATIO OF CC TO NC DIFFERENTIAL JET SHAPES
*          (61:) 14<Et<21, (62:) 21<Et<29, (63:) 29<Et<37, (64:) 37<Et<45
*          note: only histos with ZEUS data, no MC histos for FIG.6
*                are produced
*
*          FIG. 7: NC - INTEGRATED JET SHAPE
*          (Q2>100 GeV2, Et>14 GeV, -1<eta<2)
*
*          FIG. 9: INTEGRATED JET SHAPES IN NC AND CC DIS
*          (Q2 > 100 GeV2, 37<Et<45 GeV)
*
*
* arguments:  iflag=1 initialisation
*             iflag=1002 NC event filling
*                  =2002 CC event filling
*             iflag=3 termination
*
*             note: call this routine only with iflag=1 and iflag=3
*                   only once
*
* comments:   - be careful with (Snowmass) convention with massive hadrons
*             (Et not exactly equal to pt); this subroutine uses the pt-scheme
*             - with the definition of the integrated jet shape psi in
*             the paper DESY-98-038, psi(r/R=1) is identical equal to 1
*
* structure:  called subroutines and functions:
*             from hbook lib:  hcdir,hmdir,hbookb,hbook1,
*                              hpak,hpake,hfill
*             from HzTool lib: HzDiskin,HzIdelec,(HzIdntro,)
*                              HzPt, HzJtfind, HzJetshp, HzMeanHi
*             and some subroutines contained in this file
*
* written by: Andreas von Manteuffel
*
* reference:  DESY-98-038
*
**********************************************************************

      IMPLICIT NONE

****************************************************************
*     DECLARATIONS for HzTool stuff
****************************************************************
*
* HERA Tuning defined commons

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZJETCMN.
*
*     MAXHZJETS: maxmial number of jet allowed
*     NUMJETS: number of jets from jet algo
*     NSEL  : number of selected jets
*     IPJET : pointer to selected jets
*     JETS  : Jet variables (eta,phi,et,e,px,py,pz,m) in choosen frame
*     IJETNO: pointer which objects in PHEP common belong to jets
*
      INTEGER MAXHZJETS
      PARAMETER (MAXHZJETS=50)
      INTEGER NSEL,NUMJETS,IPJET(MAXHZJETS),IJETNO(NMXHEP)
      DOUBLE PRECISION JETS(MAXHZJETS,8)
*
      COMMON /HZJETCMN/JETS,NUMJETS,NSEL,IPJET,IJETNO
*
*
*KEND.

****************************************************************
*     DECLARATIONS for ZEUS histos
****************************************************************

      Real rhnc11(10), rhnc11a(10), rhnc11tu(10), rhnc11td(10)	
      Real rhnc12(10), rhnc12a(10), rhnc12tu(10), rhnc12td(10)	
      Real rhnc13(10), rhnc13a(10), rhnc13tu(10), rhnc13td(10)	
      Real rhnc14(10), rhnc14a(10), rhnc14tu(10), rhnc14td(10)	

      Real rhnc21(10), rhnc21a(10), rhnc21tu(10), rhnc21td(10)
      Real rhnc22(10), rhnc22a(10), rhnc22tu(10), rhnc22td(10)	
      Real rhnc23(10), rhnc23a(10), rhnc23tu(10), rhnc23td(10)	
      Real rhnc24(10), rhnc24a(10), rhnc24tu(10), rhnc24td(10)	

      Real eta3bins(5), eta3(4)
      Real psta3(4), psta3a(4), psta3tu(4), psta3td(4)
      Real et3bins(5), et3(4)
      Real pset3(4), pset3a(4), pset3tu(4), pset3td(4)

      Real rhcc41(10), rhcc41a(10), rhcc41tu(10), rhcc41td(10)
      Real rhcc42(10), rhcc42a(10), rhcc42tu(10), rhcc42td(10)	
      Real rhcc43(10), rhcc43a(10), rhcc43tu(10), rhcc43td(10)	
      Real rhcc44(10), rhcc44a(10), rhcc44tu(10), rhcc44td(10)	

      Real eta5bins(5), eta5(4)
      Real psta5(4), psta5a(4), psta5tu(4), psta5td(4)
      Real et5bins(5), et5(4)
      Real pset5(4), pset5a(4), pset5tu(4), pset5td(4)

      Real rhrt61(10), rhrt61a(10), rhrt61tu(10), rhrt61td(10)
      Real rhrt62(10), rhrt62a(10), rhrt62tu(10), rhrt62td(10)	
      Real rhrt63(10), rhrt63a(10), rhrt63tu(10), rhrt63td(10)	
      Real rhrt64(10), rhrt64a(10), rhrt64tu(10), rhrt64td(10)	

      Real psnc7(10), psnc7a(10), psnc7tu(10), psnc7td(10)
      Real psnc9(10), psnc9a(10), psnc9tu(10), psnc9td(10)
      Real pscc9(10), pscc9a(10), pscc9tu(10), pscc9td(10)

* save contents
      Save eta3bins, eta3, et3bins, et3
      Save eta5bins, eta5, et5bins, et5


****************************************************************
*        ZEUS DATA
****************************************************************

c *** note: variable names for ZEUS histos:
c     4 alphanum. digits for histo type,
c     1 digit for figure no. in the paper,
c    (1 digit for histo no. in figure,)
c     suffix: no suffix -> ordinate value
c             a         -> statistic. error
c             tu        -> total error up
c             td        -> total error down


c *** FIG. 1: NC - DIFFERENTIAL JET SHAPES (et > 14 GeV, Q2>100 GeV2)
c *** (11:) -1<eta<0, (12:) 0<eta<1, (13:) 1<eta<1.5, (14:) 1.5<eta<2
*
      Data rhnc11   / 3.923, 2.623, 1.269, 0.768, 0.481,
     .                0.322, 0.275, 0.203, 0.157, 0.119 /
      Data rhnc11a  / 0.111, 0.055, 0.031, 0.024, 0.019,
     .                0.014, 0.013, 0.010, 0.009, 0.007 /
      Data rhnc11tu / 0.208, 0.056, 0.046, 0.048, 0.024,
     .                0.025, 0.017, 0.013, 0.011, 0.009 /
      Data rhnc11td / 0.208, 0.092, 0.032, 0.028, 0.020,
     .                0.018, 0.023, 0.011, 0.010, 0.008 /

      Data rhnc12   / 4.033, 2.625, 1.244, 0.704, 0.452,
     .                0.338, 0.254, 0.195, 0.156, 0.120 /
      Data rhnc12a  / 0.065, 0.032, 0.018, 0.013, 0.010,
     .                0.009, 0.007, 0.006, 0.004, 0.004 /
      Data rhnc12tu / 0.106, 0.035, 0.024, 0.038, 0.022,
     .                0.017, 0.012, 0.010, 0.007, 0.007 /
      Data rhnc12td / 0.150, 0.035, 0.020, 0.016, 0.013,
     .                0.016, 0.009, 0.006, 0.006, 0.005 /

      Data rhnc13   / 3.861, 2.552, 1.280, 0.743, 0.488,
     .                0.316, 0.238, 0.179, 0.153, 0.133 /
      Data rhnc13a  / 0.085, 0.037, 0.022, 0.017, 0.013,
     .                0.010, 0.008, 0.006, 0.005, 0.005 /
      Data rhnc13tu / 0.138, 0.061, 0.028, 0.030, 0.018,
     .                0.015, 0.017, 0.014, 0.006, 0.006 /
      Data rhnc13td / 0.124, 0.045, 0.027, 0.021, 0.015,
     .                0.012, 0.009, 0.007, 0.006, 0.009 /

      Data rhnc14   / 3.828, 2.533, 1.270, 0.688, 0.477,
     .                0.317, 0.257, 0.198, 0.156, 0.124 /
      Data rhnc14a  / 0.081, 0.038, 0.018, 0.013, 0.010,
     .                0.008, 0.007, 0.006, 0.005, 0.004 /
      Data rhnc14tu / 0.120, 0.074, 0.048, 0.045, 0.030,
     .                0.023, 0.017, 0.007, 0.012, 0.005 /
      Data rhnc14td / 0.104, 0.045, 0.022, 0.015, 0.012,
     .                0.011, 0.008, 0.007, 0.006, 0.006 /

c *** FIG. 2: NC - DIFFERENTIAL JET SHAPES (-1<eta<2, Q2>100 GeV2)
c *** (21:) 14<et<21, (22:) 21<et<29, (23:) 29<et<37, (24:) 37<et<45
*
      Data rhnc21   / 3.629, 2.667, 1.352, 0.772, 0.511,
     .                0.354, 0.281, 0.211, 0.170, 0.135 /
      Data rhnc21a  / 0.047, 0.024, 0.013, 0.010, 0.008,
     .                0.006, 0.005, 0.004, 0.003, 0.003 /
      Data rhnc21tu / 0.135, 0.027, 0.020, 0.033, 0.015,
     .                0.017, 0.012, 0.008, 0.007, 0.005 /
      Data rhnc21td / 0.134, 0.049, 0.017, 0.014, 0.011,
     .                0.013, 0.008, 0.005, 0.005, 0.005 /

      Data rhnc22   / 4.479, 2.528, 1.089, 0.620, 0.394,
     .                0.268, 0.206, 0.161, 0.128, 0.104 /
      Data rhnc22a  / 0.097, 0.041, 0.021, 0.016, 0.013,
     .                0.010, 0.008, 0.007, 0.006, 0.005 /
      Data rhnc22tu / 0.116, 0.107, 0.057, 0.038, 0.036,
     .                0.014, 0.011, 0.009, 0.007, 0.006 /
      Data rhnc22td / 0.142, 0.046, 0.030, 0.023, 0.015,
     .                0.010, 0.009, 0.008, 0.006, 0.008 /

      Data rhnc23   / 4.849, 2.209, 1.031, 0.545, 0.353,
     .                0.279, 0.178, 0.150, 0.128, 0.095 /
      Data rhnc23a  / 0.162, 0.065, 0.034, 0.025, 0.024,
     .                0.018, 0.012, 0.010, 0.010, 0.007 /
      Data rhnc23tu / 0.216, 0.153, 0.037, 0.056, 0.040,
     .                0.019, 0.014, 0.012, 0.013, 0.010 /
      Data rhnc23td / 0.228, 0.068, 0.034, 0.029, 0.025,
     .                0.045, 0.013, 0.011, 0.022, 0.007 /

      Data rhnc24   / 5.526, 1.932, 0.915, 0.473, 0.284,
     .                0.183, 0.125, 0.100, 0.072, 0.088 /
      Data rhnc24a  / 0.337, 0.097, 0.061, 0.038, 0.031,
     .                0.024, 0.015, 0.011, 0.009, 0.015 /
      Data rhnc24tu / 0.337, 0.243, 0.213, 0.095, 0.061,
     .                0.039, 0.036, 0.029, 0.024, 0.015 /
      Data rhnc24td / 0.600, 0.098, 0.062, 0.038, 0.031,
     .                0.024, 0.019, 0.011, 0.009, 0.020 /

c *** FIG. 3: NC - INTEGRATED JET SHAPES at r/R=0.5 (Q2>100 GeV2)
*
c *** (31:) as a function of eta (ET > 14 GeV)
      Data eta3bins / -1.0, 0.0, 1.0, 1.5, 2.0 /
      Data eta3     / -0.50, 0.50, 1.25, 1.75 /
      Data psta3    / 0.894, 0.895, 0.900, 0.894 /
      Data psta3a   / 0.004, 0.002, 0.004, 0.003 /
      Data psta3tu  / 0.006, 0.004, 0.005, 0.005 /
      Data psta3td  / 0.008, 0.005, 0.005, 0.005 /

c *** (32:) as a function of ET
      Data et3bins  / 14.0, 21.0, 29.0, 37.0, 45.0 /
      Data et3      / 16.7, 24.2, 32.2, 40.4 /
      Data pset3    / 0.886, 0.915, 0.915, 0.944 /
      Data pset3a   / 0.002, 0.003, 0.005, 0.007 /
      Data pset3tu  / 0.004, 0.005, 0.012, 0.008 /
      Data pset3td  / 0.005, 0.005, 0.006, 0.010 /

c *** FIG. 4: CC -  DIFFERENTIAL JET SHAPES (-1<eta<2, Q2>100 GeV2)
c *** (41:) 14<et<21, (42:) 21<et<29, (43:) 29<et<37, (44:) 37<et<45
*
      Data rhcc41   / 3.733, 2.819, 1.190, 0.718, 0.524,
     .                0.402, 0.231, 0.178, 0.189, 0.093 /
      Data rhcc41a  / 0.369, 0.214, 0.094, 0.085, 0.063,
     .                0.062, 0.043, 0.035, 0.031, 0.026 /
      Data rhcc41tu / 0.374, 0.215, 0.119, 0.086, 0.064,
     .                0.063, 0.047, 0.035, 0.032, 0.026 /
      Data rhcc41td / 0.386, 0.215, 0.094, 0.085, 0.064,
     .                0.062, 0.044, 0.036, 0.032, 0.026 /

      Data rhcc42   / 4.344, 2.856, 0.907, 0.537, 0.352,
     .                0.271, 0.208, 0.146, 0.171, 0.087 /
      Data rhcc42a  / 0.451, 0.208, 0.106, 0.062, 0.059,
     .                0.046, 0.045, 0.024, 0.032, 0.022 /
      Data rhcc42tu / 0.457, 0.234, 0.112, 0.073, 0.077,
     .                0.047, 0.046, 0.024, 0.033, 0.023 /
      Data rhcc42td / 0.482, 0.208, 0.106, 0.063, 0.060,
     .                0.046, 0.046, 0.026, 0.032, 0.022 /

      Data rhcc43   / 4.255, 2.198, 0.980, 0.588, 0.381,
     .                0.295, 0.210, 0.179, 0.113, 0.090 /
      Data rhcc43a  / 0.530, 0.193, 0.103, 0.061, 0.051,
     .                0.048, 0.041, 0.056, 0.019, 0.019 /
      Data rhcc43tu / 0.618, 0.206, 0.130, 0.065, 0.055,
     .                0.056, 0.042, 0.056, 0.019, 0.019 /
      Data rhcc43td / 0.540, 0.195, 0.104, 0.066, 0.052,
     .                0.048, 0.052, 0.083, 0.022, 0.022 /

      Data rhcc44   / 6.057, 1.959, 0.723, 0.401, 0.239,
     .                0.218, 0.159, 0.126, 0.041, 0.050 /
      Data rhcc44a  / 0.596, 0.208, 0.080, 0.056, 0.051,
     .                0.058, 0.049, 0.055, 0.010, 0.011 /
      Data rhcc44tu / 0.616, 0.210, 0.085, 0.130, 0.114,
     .                0.089, 0.059, 0.116, 0.032, 0.023 /
      Data rhcc44td / 0.801, 0.250, 0.080, 0.057, 0.051,
     .                0.058, 0.050, 0.055, 0.011, 0.011 /


c *** FIG. 5: CC - INTEGRATED JET SHAPES at r/R=0.5 (Q2>100 GeV2)
*
c *** (51:) as a function of eta (ET > 14 GeV)
      Data eta5bins / -1.0, 0.0, 1.0, 1.5, 2.0 /
      Data eta5     / -0.50, 0.50, 1.25, 1.75 /
      Data psta5    / 0.916, 0.918, 0.900, 0.889 /
      Data psta5a   / 0.013, 0.011, 0.021, 0.028 /
      Data psta5tu  / 0.013, 0.011, 0.021, 0.028 /
      Data psta5td  / 0.014, 0.011, 0.021, 0.028 /

c *** (52:) as a function of ET
      Data et5bins  / 14.0, 21.0, 29.0, 37.0, 45.0 /
      Data et5      / 17.4, 24.7, 32.7, 40.7 /
      Data pset5    / 0.891, 0.910, 0.904, 0.940 /
      Data pset5a   / 0.018, 0.015, 0.019, 0.022 /
      Data pset5tu  / 0.019, 0.016, 0.026, 0.022 /
      Data pset5td  / 0.019, 0.016, 0.019, 0.037 /

c *** FIG. 6: RATIO OF CC TO NC DIFFERENTIAL JET SHAPES
c *** (61:) 14<Et<21, (62:) 21<Et<29, (63:) 29<Et<37, (64:) 37<Et<45
*
      Data rhrt61   / 1.029, 1.057, 0.880, 0.930, 1.025,
     .                1.136, 0.820, 0.844, 1.109, 0.689 /
      Data rhrt61a  / 0.105, 0.083, 0.073, 0.113, 0.128,
     .                0.179, 0.159, 0.169, 0.192, 0.194 /
      Data rhrt61tu / 0.105, 0.085, 0.090, 0.113, 0.128,
     .                0.181, 0.167, 0.169, 0.193, 0.196 /
      Data rhrt61td / 0.110, 0.083, 0.073, 0.114, 0.132,
     .                0.180, 0.159, 0.181, 0.196, 0.194 /

      Data rhrt62   / 0.970, 1.130, 0.833, 0.866, 0.893,
     .                1.009, 1.011, 0.908, 1.334, 0.834 /
      Data rhrt62a  / 0.106, 0.089, 0.102, 0.107, 0.158,
     .                0.183, 0.231, 0.162, 0.268, 0.224 /
      Data rhrt62tu / 0.106, 0.089, 0.102, 0.108, 0.164,
     .                0.183, 0.232, 0.162, 0.269, 0.240 /
      Data rhrt62td / 0.108, 0.089, 0.102, 0.107, 0.158,
     .                0.183, 0.232, 0.169, 0.269, 0.224 /

      Data rhrt63   / 0.878, 0.995, 0.951, 1.080, 1.080,
     .                1.054, 1.177, 1.197, 0.878, 0.947 /
      Data rhrt63a  / 0.117, 0.100, 0.116, 0.141, 0.183,
     .                0.205, 0.269, 0.400, 0.187, 0.234 /
      Data rhrt63tu / 0.126, 0.100, 0.134, 0.143, 0.183,
     .                0.351, 0.270, 0.401, 0.198, 0.234 /
      Data rhrt63td / 0.117, 0.104, 0.117, 0.188, 0.187,
     .                0.205, 0.314, 0.569, 0.188, 0.276 /

      Data rhrt64   / 1.096, 1.014, 0.790, 0.847, 0.843,
     .                1.187, 1.269, 1.261, 0.567, 0.568 /
      Data rhrt64a  / 0.137, 0.134, 0.121, 0.165, 0.225,
     .                0.406, 0.466, 0.621, 0.182, 0.181 /
      Data rhrt64tu / 0.142, 0.134, 0.121, 0.182, 0.285,
     .                0.432, 0.474, 0.823, 0.269, 0.414 /
      Data rhrt64td / 0.137, 0.216, 0.171, 0.167, 0.227,
     .                0.406, 0.470, 0.621, 0.186, 0.182 /

c *** FIG. 7: NC - INTEGRATED JET SHAPE
c *** (Q2>100 GeV2, Et>14 GeV, -1<eta<2)
*
      Data psnc7    / 0.0000, 0.6520, 0.7780, 0.8490, 0.8960,
     .                0.9280, 0.9530, 0.9720, 0.9880, 1.0000 /
      Data psnc7a   / 0.0000, 0.0035, 0.0027, 0.0021, 0.0016,
     .                0.0012, 0.0008, 0.0005, 0.0003, 0.0000 /
      Data psnc7tu  / 0.0000, 0.0092, 0.0066, 0.0047, 0.0036,
     .                0.0022, 0.0015, 0.0010, 0.0005, 0.0000 /
      Data psnc7td  / 0.0000, 0.0085, 0.0062, 0.0041, 0.0029,
     .                0.0020, 0.0013, 0.0008, 0.0004, 0.0000 /

c *** FIG. 9: INTEGRATED JET SHAPES IN NC AND CC DIS
c *** (Q2 > 100 GeV2, 37<Et<45 GeV)
*
c *** NEUTRAL CURRENT
      Data psnc9    / 0.553, 0.759, 0.864, 0.916, 0.944,
     .                0.961, 0.974, 0.984, 0.991, 1.000 /
      Data psnc9a   / 0.034, 0.022, 0.015, 0.011, 0.007,
     .                0.005, 0.004, 0.003, 0.002, 0.000 /
      Data psnc9tu  / 0.034, 0.023, 0.015, 0.011, 0.008,
     .                0.005, 0.004, 0.003, 0.003, 0.000 /
      Data psnc9td  / 0.060, 0.034, 0.020, 0.015, 0.010,
     .                0.007, 0.004, 0.003, 0.002, 0.000 /

c *** CHARGED CURRENT
      Data pscc9    / 0.606, 0.808, 0.878, 0.917, 0.940,
     .                0.963, 0.980, 0.993, 0.995, 1.000 /
      Data pscc9a   / 0.060, 0.041, 0.031, 0.027, 0.022,
     .                0.015, 0.009, 0.002, 0.001, 0.000 /
      Data pscc9tu  / 0.062, 0.041, 0.031, 0.027, 0.022,
     .                0.015, 0.009, 0.002, 0.001, 0.000 /
      Data pscc9td  / 0.080, 0.072, 0.064, 0.050, 0.037,
     .                0.028, 0.022, 0.007, 0.003, 0.000 /


****************************************************************
*     DECLARATIONS for MC histos
****************************************************************

* argument
      Integer imode

* function declaration
      Integer getBinNo2

* other variables
      Logical levtype, lNC, lCC, lfirst, linit
      Parameter(lNC=.true., lCC=.false.)
      Integer iflag, iHistId, ierr, ievtp, ibin, ivartp
      Integer ilepton, idum, ijetfid, ijt, ieta, iEt, ihad, ir
      Character*6 cxxxx
      Character*80 chtitl
      Double Precision drrho(10), drpsi(10)
      Double Precision dQ2, dy
      Double Precision deta, dEt, dpt, dconeR, dEtJet, detaJet
      Double Precision ddumA(MAXHZJETS,8)
      Double Precision djshpRho(10,MAXHZJETS)
      Double Precision djshpPsi(10,MAXHZJETS)

* save contents
      Save lfirst, linit, cxxxx, drrho, drpsi

* settings
      Data lfirst /.true./
      Data linit /.false./
      Data cxxxx /'98038'/

c *** values of r/R for rho (histo filling)
      Data drrho / 0.05D0, 0.15D0, 0.25D0, 0.35D0, 0.45D0,
     .             0.55D0, 0.65D0, 0.75D0, 0.85D0, 0.95D0 /

c *** values of r/R for psi (histo filling)
      Data drpsi / 0.10D0, 0.20D0, 0.30D0, 0.40D0, 0.50D0,
     .             0.60D0, 0.70D0, 0.80D0, 0.90D0, 1.00D0 /



*********************************************************************
*     GET MODE
*********************************************************************

*     get iflag: init=1, evt.process.=2, final=3
      iflag = mod(imode,1000)

      if (iflag.eq.2) then
*     get event type: NC or CC
       ievtp = int(imode/1000)
       if (ievtp.eq.1) then
	 levtype = lNC
       elseif (ievtp.eq.2) then
	 write(6,*)'Hz'//cxxxx,
     .   ' sorry, CC event processing not implemented yet !!!'
	 levtype = lCC
	 return
       else
	 ievtp = 2
	 levtype = lNC
	 if (lfirst) then
	  write(6,*)'Hz'//cxxxx,' WARNING: bad routine call !!!'
	  write(6,*)'Please use argument 1002 for NC event processing'
	  write(6,*)'                 or 2002 for CC event processing.'
	  write(6,*)'Currently assuming NC event processing !'
	  lfirst = .false.
	 endif
       endif
      endif


      if (iflag.eq.1) then
*********************************************************************
*
*                      Initialization
*
*********************************************************************

* check if routine is initialized
         if (linit) then
	  write(6,*)'Hz'//cxxxx,'ERROR: '//
     .      'initialization step should be called only once.'
          goto 9999
         endif

*
*
*      Initialisation: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (ii) make subdirectory in o/p file
*

         call hcdir('//PAWC',' ')
         call hmdir(cxxxx,'S')
         call hcdir('//HISTO',' ')
         call hmdir(cxxxx,'S')

c --- hello world !

	 WRITE(6,*)'***************************************************'
	 WRITE(6,*)'Hz'//cxxxx//' called'
     	 WRITE(6,*)'***************************************************'

c --- build up ZEUS histos and prepare MC histos
	
	 write(chtitl,*) 'rho(r/R) (NC, -1.lt.eta.lt.0)'
	 call ZSrho(11,chtitl,rhnc11,rhnc11a,rhnc11tu,rhnc11td)
	 call MCrho(11,chtitl)
	 write(chtitl,*) 'rho(r/R) (NC, 0.lt.eta.lt.1)'
	 call ZSrho(12,chtitl,rhnc12,rhnc12a,rhnc12tu,rhnc12td)
	 call MCrho(12,chtitl)
	 write(chtitl,*) 'rho(r/R) (NC, 1.lt.eta.lt.1.5)'
	 call ZSrho(13,chtitl,rhnc13,rhnc13a,rhnc13tu,rhnc13td)
	 call MCrho(13,chtitl)
	 write(chtitl,*) 'rho(r/R) (NC, 1.5.lt.eta.lt.2)'
	 call ZSrho(14,chtitl,rhnc14,rhnc14a,rhnc14tu,rhnc14td)
	 call MCrho(14,chtitl)

	 write(chtitl,*) 'rho(r/R) (NC, 14.lt.Et.lt.21)'
	 call ZSrho(21,chtitl,rhnc21,rhnc21a,rhnc21tu,rhnc21td)
	 call MCrho(21,chtitl)
	 write(chtitl,*) 'rho(r/R) (NC, 21.lt.Et.lt.29)'
	 call ZSrho(22,chtitl,rhnc22,rhnc22a,rhnc22tu,rhnc22td)
	 call MCrho(22,chtitl)
	 write(chtitl,*) 'rho(r/R) (NC, 29.lt.Et.lt.37)'
	 call ZSrho(23,chtitl,rhnc23,rhnc23a,rhnc23tu,rhnc23td)
	 call MCrho(23,chtitl)
	 write(chtitl,*) 'rho(r/R) (NC, 37.lt.Et.lt.45)'
	 call ZSrho(24,chtitl,rhnc24,rhnc24a,rhnc24tu,rhnc24td)
	 call MCrho(24,chtitl)

	 write(chtitl,*) 'Psi(0.5) vs. eta (NC, Et.gt.14)'
	 call ZSpsifxd(31,chtitl,4,eta3bins,
     .                 psta3,psta3a,psta3tu,psta3td)
	 call MCpsifxd(31,chtitl,4,eta3bins)
	 write(chtitl,*) 'Psi(0.5) vs. Et (NC)'
	 call ZSpsifxd(32,chtitl,4,et3bins,
     .                 pset3,pset3a,pset3tu,pset3td)
	 call MCpsifxd(32,chtitl,4,et3bins)

	 write(chtitl,*) 'rho(r/R) (CC, 14.lt.Et.lt.21)'
	 call ZSrho(41,chtitl,rhcc41,rhcc41a,rhcc41tu,rhcc41td)
	 call MCrho(41,chtitl)
	 write(chtitl,*) 'rho(r/R) (CC, 21.lt.Et.lt.29)'
	 call ZSrho(42,chtitl,rhcc42,rhcc42a,rhcc42tu,rhcc42td)
	 call MCrho(42,chtitl)
	 write(chtitl,*) 'rho(r/R) (CC, 29.lt.Et.lt.37)'
	 call ZSrho(43,chtitl,rhcc43,rhcc43a,rhcc43tu,rhcc43td)
	 call MCrho(43,chtitl)
	 write(chtitl,*) 'rho(r/R) (CC, 37.lt.Et.lt.45)'
	 call ZSrho(44,chtitl,rhcc44,rhcc44a,rhcc44tu,rhcc44td)
	 call MCrho(44,chtitl)

	 write(chtitl,*) 'Psi(0.5) vs. eta (CC, Et.gt.14)'
	 call ZSpsifxd(51,chtitl,4,eta5bins,
     .                 psta5,psta5a,psta5tu,psta5td)
	 call MCpsifxd(51,chtitl,4,eta5bins)
	 write(chtitl,*) 'Psi(0.5) vs. Et (CC)'
	 call ZSpsifxd(52,chtitl,4,et5bins,
     .                 pset5,pset5a,pset5tu,pset5td)
	 call MCpsifxd(52,chtitl,4,et5bins)

	 write(chtitl,*) 'ratio rho(CC)/rho(NC) (r/R) (14.lt.Et.lt.21)'
	 call ZSrho(61,chtitl,rhrt61,rhrt61a,rhrt61tu,rhrt61td)
	 write(chtitl,*) 'ratio rho(CC)/rho(NC) (r/R) (21.lt.Et.lt.29)'
	 call ZSrho(62,chtitl,rhrt62,rhrt62a,rhrt62tu,rhrt62td)
	 write(chtitl,*) 'ratio rho(CC)/rho(NC) (r/R) (29.lt.Et.lt.37)'
	 call ZSrho(63,chtitl,rhrt63,rhrt63a,rhrt63tu,rhrt63td)
	 write(chtitl,*) 'ratio rho(CC)/rho(NC) (r/R) (37.lt.Et.lt.45)'
	 call ZSrho(64,chtitl,rhrt64,rhrt64a,rhrt64tu,rhrt64td)

	 write(chtitl,*) 'Psi(r/R) (NC, Et.gt.14)'
	 call ZSpsi(71,chtitl,psnc7,psnc7a,psnc7tu,psnc7td)
	 call MCpsi(71,chtitl)

	 write(chtitl,*) 'Psi(r/R) (NC, 37.lt.Et.lt.45)'
	 call ZSpsi(91,chtitl,psnc9,psnc9a,psnc9tu,psnc9td)
	 call MCpsi(91,chtitl)

	 write(chtitl,*) 'Psi(r/R) (CC, 37.lt.Et.lt.45)'
	 call ZSpsi(92,chtitl,pscc9,pscc9a,pscc9tu,pscc9td)
	 call MCpsi(92,chtitl)

* prepare control histo
         write(chtitl,*) 'dn/dQ2 in lab. fr. - control plot'
         call hbook1(1, chtitl, 100, 0., 10000., 0.)

* set flag
         linit = .true.


      else if (iflag.eq.2) then
*********************************************************************
*
*                      Event Processing
*
*********************************************************************

* check if routine is initialized
         if (.not.linit) then
	  write(6,*)'Hz'//cxxxx,'ERROR: '//
     .      'event processing step called without initialization !!!'
	  write(6,*)'Please use argument 1 for initialization step.'
          goto 9999
         endif


*      Filling: The following MUST always be done
*      (i) move to the correct sub-directory in PAWC
*
         call hcdir('//PAWC/'//cxxxx,' ')

****************************************************
* Part A: KINEMATIC CUTS
****************************************************

* get Q2
         dQ2 = HzDiskin(1)
         if (dQ2.le.0.D0) then
            write(6,*) 'HZ'//cxxxx,' unphysical Q2 !'
            goto 9990
         endif

*     fill control histo: Q2 distribution
         call hfill(1, real(dQ2), 0., 1.)

* CUT (i): Q2 > 100 GeV
*---------
         if (dQ2.le.100.D0) goto 9990

* different cuts for NC and CC
	 if (levtype.eqv.lNC) then
c-------------------------------------------------------NC

* detect scattered lepton
	    ilepton = HzIdelec(idum)
	    if (ilepton.eq.-1) then
	       write(6,*) 'Hz'//cxxxx,' lepton not found !'
	       goto 9990
	    endif

* CUT (NCii): energy of scattered lepton > 10 GeV
*------------
	    if (PHEP(4,ilepton).le.10.D0) goto 9990

* get y
	    dy = HzDiskin(3)

* CUT (NCiii):  y < 0.95
*-------------
	    if (dy.ge.0.95D0) goto 9990

* get pseudo-rapidity eta and Et of scattered lepton
         deta = HzEta(ilepton)
         dEt = HzEta(ilepton)

* CUT (NCiv):  for eta(lepton) > 2: Et of scattered lepton > 20 GeV
*------------
	    if ((deta.gt.2.D0).and.(dEt.le.20.D0)) goto 9990
	    	
	 else
c-------------------------------------------------------CC

* detect neutrino
	    ilepton = HzIdntro(idum)
	    if (ilepton.eq.-1) then
	       write(6,*) 'Hz'//cxxxx,' neutrino not found !'
	       goto 9990
	    endif

* get pt of neutrino
	    dpt=hzPt(ilepton)

* CUT (CCii):  pt of neutrino > 11 GeV
*------------
	    if (dpt.le.11.D0) goto 9990
	
	 endif


****************************************************
* Part B: JET FINDING
****************************************************

* choose PXCONE with cone radius = 1.0
	 ijetfid = 2
	 dconeR = 1.D0

* jet finding
	 NUMJETS = 0
	 call hzjtfind(ijetfid,dconeR,idum,ddumA)
	 if (NUMJETS.gt.MAXHZJETS) then
	    write(6,*)
     .	    'HZ'//cxxxx, ' ERROR: number of jets out of range !'
            goto 9990
	 endif

* anything to do ?
	 if (NUMJETS.lt.1) goto 9990

****************************************************
* Part C: CALCULATION OF JET SHAPES
****************************************************

	 call hzjetshp(1, dconeR, djshpRho, djshpPsi, ierr)
	 if (ierr.ne.0) then
	    write(6,*) 'HZ'//cxxxx, ' error in HzJetshp !'
	    goto 9990
	 endif

****************************************************
* Part D: BINNING AND HISTO FILLING
****************************************************
	 numjets=1
* loop over all jets found	
	 do 6500 ijt = 1, NUMJETS

*       get kinematic variables of current jet
	    dEtJet  = JETS(ijt,3)
	    detaJet = JETS(ijt,1)

* BINNING:
*---------
*       get Et and eta bin number (same for NC and CC)
	    iEt  = getBinNo2(4,Et3bins,real(dEtJet))
	    ieta = getBinNo2(4,eta3bins,real(detaJet))

* CUT (Ji): Et(jet) > 14 GeV
*----------
	    if (iEt.lt.1) goto 6500

* CUT (Jii): -1 < eta(jet) < 2
*-----------
	    if ((ieta.lt.1).or.(ieta.gt.4)) goto 6500

	    do ir = 1, 10	! loop over r/R bins

*       fill histos for integrated jet shape psi
	       if (levtype.eqv.lNC) then        ! ---NC
		  call HzMeanHi(71,drpsi(ir),djshpPsi(ir,ijt),wtx)
		  if (iEt.eq.4) then
		     call HzMeanHi(91,drpsi(ir),djshpPsi(ir,ijt),wtx)
		  endif
	       else		                ! ---CC
		  call HzMeanHi(72,drpsi(ir),djshpPsi(ir,ijt),wtx)
		  if (iEt.eq.4) then
		     call HzMeanHi(92,drpsi(ir),djshpPsi(ir,ijt),wtx)
		  endif
	       endif		! NC or CC ?

*       fill histos for differential jet shape rho
	       if (levtype.eqv.lNC) then        ! ---NC
		  call HzMeanHi(10+ieta,drrho(ir),djshpRho(ir,ijt),wtx)
		  if (iEt.ne.5) then
		    call HzMeanHi(20+iEt,drrho(ir),djshpRho(ir,ijt),wtx)
		  endif
	       else	                  	! ---CC
		  if (iEt.ne.5) then
		    call HzMeanHi(40+iEt,drrho(ir),djshpRho(ir,ijt),wtx)
		  endif
	       endif ! NC or CC ?
	    enddo ! next r/R bin

*       fill histos for jet shape psi at fixed value (psi(0.5))
	    if (levtype.eqv.lNC) then
	       call hzMeanHi(31, detaJet, djshpPsi(5,ijt), wtx)
	       call hzMeanHi(32, dEtJet, djshpPsi(5,ijt), wtx)
	    else
	       call hzMeanHi(51, detaJet, djshpPsi(5,ijt), wtx)
	       call hzMeanHi(52, dEtJet, djshpPsi(5,ijt), wtx)
	    endif

 6500	 continue ! next jet

 9990    continue


      else if(iflag.eq.3) then
*********************************************************************
*
*                      Termination
*
*********************************************************************

*      Termination: The following MUST always be done
*      (i) Move to the correct PAW subdirectory
*
         call hcdir('//PAWC/'//cxxxx,' ')

*     note: simple chi-square calculation doesn't make sense due
*           to correlations
	

      endif

 9999 continue
      RETURN
      END



**********************************************************************
*  subroutines called by hz98038:
**********************************************************************

      subroutine ZSpsi (id, chtitl, psi, erra, errtu, errtd)
*****************************************************************************
*     Subroutine ZSpsi builds up 3 histos with ZEUS data:
*       Histo-ID = - (100+id)  for statist. errors (erra) only
*                = - (300+id)  for total up errors (errtu)
*                = - (400+id)  for total down errors (errtd)
*

      Implicit None

      Integer      id
      Real         psi, erra, errtu, errtd
      Character*80 chtitl
      Dimension psi(10)
      Dimension erra(10)
      Dimension errtu(10)
      Dimension errtd(10)

      call hbook1(-100-id, chtitl, 10, 0.05, 1.05, 0.)
      call hpak(-100-id, psi)
      call hpake(-100-id, erra)

      call hbook1(-300-id, chtitl, 10, 0.05, 1.05, 0.)
      call hpak(-300-id, psi)
      call hpake(-300-id, errtu)

      call hbook1(-400-id, chtitl, 10, 0.05, 1.05, 0.)
      call hpak(-400-id, psi)
      call hpake(-400-id, errtd)

      end

      subroutine ZSrho (id, chtitl, rho, erra, errtu, errtd)
*****************************************************************************
*     Subroutine ZSrho builds up 3 histos with ZEUS data:
*       Histo-ID = - (100+id)  for statist. errors (erra) only
*                = - (300+id)  for total up errors (errtu)
*                = - (400+id)  for total down errors (errtd)
*

      Implicit None

      Integer      id
      Real         rho, erra, errtu, errtd
      Character*80 chtitl
      Dimension rho(10)
      Dimension erra(10)
      Dimension errtu(10)
      Dimension errtd(10)

      call hbook1(-100-id, chtitl, 10, 0.00, 1.00, 0.)
      call hpak(-100-id, rho)
      call hpake(-100-id, erra)

      call hbook1(-300-id, chtitl, 10, 0.00, 1.00, 0.)
      call hpak(-300-id, rho)
      call hpake(-300-id, errtu)

      call hbook1(-400-id, chtitl, 10, 0.00, 1.00, 0.)
      call hpak(-400-id, rho)
      call hpake(-400-id, errtd)

      end


      subroutine MCpsi (iid, chtitl)
************************************************************************
*     Subroutine MCpsi prepares histo for generator events:
*
      Implicit None
      Integer      iid
      Character*80 chtitl
      call hbook1(iid, chtitl, 10, 0.05, 1.05, 0.)
      end


      subroutine MCrho (iid, chtitl)
************************************************************************
*     Subroutine MCrho prepares histo for generator events:
*
      Implicit None
      Integer      iid
      Character*80 chtitl
      call hbook1(iid, chtitl, 10, 0.00, 1.00, 0.)
      end



      subroutine ZSpsifxd (iid,chtitl,incx,xbins,psi,erra,errtu,errtd)
************************************************************************
*     Subroutine ZSpsifxd builds up 3 histos with ZEUS data:
*       Histo-ID = - (100+id)  for statist. errors (ae) only
*                = - (300+id)  for total up errors (errtu)
*                = - (400+id)  for total down errors (errtd)
*

      Implicit None

      Integer      iid, incx
      Real         psi, erra, errtu, errtd, xbins
      Character*80 chtitl
      Dimension xbins(incx+1)
      Dimension psi(incx)
      Dimension erra(incx)
      Dimension errtu(incx)
      Dimension errtd(incx)

      call hbookb(-100-iid, chtitl, incx, xbins, 0.)
      call hpak(-100-iid, psi)
      call hpake(-100-iid, erra)

      call hbookb(-300-iid, chtitl, incx, xbins, 0.)
      call hpak(-300-iid, psi)
      call hpake(-300-iid, errtu)

      call hbookb(-400-iid, chtitl, incx, xbins, 0.)
      call hpak(-400-iid, psi)
      call hpake(-400-iid, errtd)

      end



      subroutine MCpsifxd (iid, chtitl, incx, xbins)
************************************************************************
*     Subroutine MCmeans prepares histo for generator events:
*

      Implicit None

      Integer      iid, incx
      Real         xbins
      Character*80 chtitl

      Dimension xbins(incx+1)

      call hbookb(iid, chtitl, incx, xbins, 0.)

      end



      FUNCTION getBinNo2(inc, binArr, val)
************************************************************************
      IMPLICIT NONE
      Integer getBinNo2, inc, icount
      Real binArr, val
      Dimension binArr(inc+1)

      do icount = 1, (inc+1)
	 if (val.le.binArr(icount)) goto 100
      enddo
 100  continue

      getBinNo2 = icount - 1

      RETURN
      END


*CMZ :  1.01/15 17/06/98  15.03.55  by  Pierre Van Mechelen
*-- Author :    Pierre Van Mechelen   06/05/98
c-----------------------------------------------------------------------

      SUBROUTINE HZ98044 (iflag)

c-----------------------------------------------------------------------
c---- Description

c Purpose: Study multiplicity structure of the hadronic final state in
c          diffractive deep inelastic scattering
c
c Event selection: 7.5 < Q2 < 100 GeV2
c                  0.05 < y < 0.6
c                  xpom < 0.05
c                  3 < Mx < 36 GeV
c                  |t| < 1 GeV2
c                  My < 1.6 GeV
c
c Reference: DESY 98-044
c            Eur. Phys. J. C (1998)
c
c Arguments: iflag=1 initialisation
c            iflag=1 filling
c            iflag=3 termination
c
c Written by: Pierre Van Mechelen on 06/05/98

c-----------------------------------------------------------------------
c---- Declarations

      IMPLICIT NONE

c.... HzTool stuff
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.

c.... input variable
      INTEGER iflag

c.... local variables
      LOGICAL          iacc(NMXHEP)
      INTEGER          nacc, ihep, i, j, k, ierr, ibp, ibl, isl,
     &                 id, nt, nf, nb, np, nn,
     &                 index(NMXHEP)
      REAL             p, pz, gap, tmp, w2, mp, nev(7),
     &                 xvec(4), yvec(4), rap(NMXHEP),
     &                 mt(7), mf(7), mb(7), dt(7), df(7), db(7),
     &                 rt(7), rf(7), rb(7), cd(7), fb(7)
      PARAMETER        (mp = 0.938)
      DOUBLE PRECISION pbeam(4), gamma(4), p_lab(4), p_hcms(4)
      CHARACTER*4      low, high

c.... Mx bin limits
      REAL mxbins1(8), mxbins2(4)
      DATA mxbins1 / 4., 6., 8., 11., 15., 19., 24., 36./
      DATA mxbins2 / 3., 8., 15., 30. /

c.... kinematical selection criteria
      REAL q2, q2_low, q2_high
      DATA q2_low  / 7.5  /, q2_high / 100. /
      REAL y,  y_low,  y_high
      DATA y_low   / 0.05 /, y_high  / 0.6  /
      REAL xp, xp_high
      DATA xp_high / 0.05 /
      REAL mx, mx_low, mx_high
      DATA mx_low  / 3.   /, mx_high / 36.  /
      REAL t,  t_high
      DATA t_high  / 1.   /
      REAL my, my_high
      DATA my_high / 1.6  /

c-----------------------------------------------------------------------
c---- Corrected data from H1

      REAL pn(20,3,4), pne(20,3,4), pns(20,3,4)
      REAL pn_tmp(20), pne_tmp(20), pns_tmp(20)

      DATA pn    /
*     forward 1
     &              5.87, 20.96, 28.85, 23.59, 12.86,
     &              5.32,  1.89,  0.48,  0.13,  0.009,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     forward 2
     &              1.60,  8.17, 14.55, 23.24, 19.93,
     &             14.45,  9.28,  4.69,  2.55,  0.90,
     &              0.46,  0.08,  0.024,  0.022,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     forward 3
     &              0.42,  3.30,  6.85, 12.82, 16.29,
     &             17.61, 14.97, 10.85,  7.41,  4.50,
     &              2.48,  1.21,  0.73,  0.34,  0.07,
     &              0.03,  0.00,  0.00,  0.00,  0.00,
*     backward 1
     &              6.38, 21.63, 29.13, 23.63, 12.87,
     &              4.52,  1.29,  0.40,  0.10,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     backward 2
     &              1.17,  8.12, 16.17, 22.27, 20.85,
     &             14.79,  8.93,  4.29,  2.28,  0.64,
     &              0.33,  0.09,  0.021,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     backward 3
     &              0.59,  3.30,  7.55, 13.51, 15.64,
     &             15.80, 13.91, 11.25,  8.26,  4.71,
     &              2.96,  1.13,  0.67,  0.42,  0.16,
     &              0.04,  0.00,  0.00,  0.00,  0.00,
*     positives 1
     &              1.00, 17.14, 38.88, 29.53, 10.74,
     &              2.46,  0.21,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     positives 2
     &              0.03,  2.49, 14.04, 27.54, 27.91,
     &             16.90,  7.40,  2.66,  0.85,  0.09,
     &              0.031,  0.00,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     positives 3
     &              0.005,  0.71,  4.29, 12.16, 19.09,
     &             21.24, 17.25, 12.61,  7.19,  3.26,
     &              1.47,  0.42,  0.20,  0.019,  0.013,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     negatives 1
     &              0.93, 15.92, 39.40, 29.76, 11.29,
     &              2.51,  0.16,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     negatives 2
     &              0.03,  2.43, 14.34, 27.82, 27.63,
     &             16.65,  7.33,  2.64,  0.95,  0.09,
     &              0.026,  0.00,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     negatives 3
     &              0.005,  0.53,  3.69, 12.40, 19.77,
     &             22.44, 17.64, 11.78,  6.56,  3.16,
     &              1.42,  0.35,  0.15,  0.028,  0.023,
     &              0.00,  0.00,  0.00,  0.00,  0.00 /

      DATA pne   /
*     forward 1
     &              0.48,  1.08,  1.02,  0.97,  0.72,
     &              0.36,  0.18,  0.07,  0.03,  0.007,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     forward 2
     &              0.13,  0.58,  0.76,  1.03,  0.82,
     &              0.66,  0.48,  0.26,  0.21,  0.10,
     &              0.09,  0.01,  0.011,  0.010,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     forward 3
     &              0.04,  0.39,  0.54,  0.76,  0.81,
     &              0.74,  0.67,  0.52,  0.38,  0.25,
     &              0.16,  0.13,  0.11,  0.08,  0.02,
     &              0.01,  0.00,  0.00,  0.00,  0.00,
*     backward 1
     &              0.53,  1.07,  1.07,  0.88,  0.62,
     &              0.30,  0.15,  0.11,  0.04,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     backward 2
     &              0.08,  0.48,  0.65,  0.73,  0.76,
     &              0.63,  0.47,  0.28,  0.24,  0.08,
     &              0.08,  0.06,  0.005,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     backward 3
     &              0.04,  0.23,  0.35,  0.50,  0.54,
     &              0.53,  0.51,  0.45,  0.38,  0.25,
     &              0.23,  0.08,  0.10,  0.14,  0.07,
     &              0.04,  0.00,  0.00,  0.00,  0.00,
*     positives 1
     &              0.10,  0.94,  1.45,  1.25,  0.67,
     &              0.26,  0.04,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     positives 2
     &              0.01,  0.22,  0.64,  0.99,  0.89,
     &              0.71,  0.38,  0.19,  0.10,  0.02,
     &              0.016,  0.00,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     positives 3
     &              0.001,  0.08,  0.37,  0.63,  0.75,
     &              0.83,  0.69,  0.59,  0.38,  0.23,
     &              0.16,  0.06,  0.07,  0.010,  0.011,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     negatives 1
     &              0.09,  1.09,  1.72,  1.11,  0.66,
     &              0.29,  0.03,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     negatives 2
     &              0.01,  0.25,  0.79,  1.06,  0.89,
     &              0.65,  0.39,  0.21,  0.13,  0.02,
     &              0.013,  0.00,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     negatives 3
     &              0.001,  0.08,  0.35,  0.72,  0.78,
     &              0.82,  0.69,  0.46,  0.36,  0.23,
     &              0.16,  0.05,  0.03,  0.009,  0.026,
     &              0.00,  0.00,  0.00,  0.00,  0.00 /

      DATA pns   /
*     forward 1
     &              1.42,  4.24,  5.44,  4.11,  2.33,
     &              1.47,  0.83,  0.36,  0.17,  0.102,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     forward 2
     &              0.70,  2.41,  3.19,  4.20,  3.42,
     &              2.48,  2.00,  1.38,  0.80,  0.72,
     &              0.31,  0.31,  0.003,  0.002,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     forward 3
     &              0.24,  1.16,  2.09,  3.22,  3.94,
     &              4.20,  2.84,  2.10,  1.30,  1.05,
     &              0.64,  0.53,  0.33,  0.19,  0.14,
     &              0.08,  0.00,  0.00,  0.00,  0.00,
*     backward 1
     &              2.42,  4.63,  5.74,  4.01,  1.96,
     &              1.32,  0.62,  0.22,  0.05,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     backward 2
     &              0.36,  2.05,  4.02,  5.04,  4.20,
     &              2.87,  1.68,  1.31,  0.91,  0.66,
     &              0.32,  0.13,  0.006,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     backward 3
     &              0.19,  1.01,  2.37,  4.36,  3.67,
     &              3.56,  2.70,  2.28,  1.52,  1.78,
     &              1.07,  1.05,  0.58,  0.26,  0.12,
     &              0.10,  0.00,  0.00,  0.00,  0.00,
*     positives 1
     &              0.35,  4.34,  7.45,  4.85,  2.56,
     &              1.13,  0.43,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     positives 2
     &              0.05,  0.91,  3.52,  5.79,  5.35,
     &              3.09,  2.12,  1.35,  0.57,  0.28,
     &              0.008,  0.00,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     positives 3
     &              0.001,  0.33,  1.63,  3.88,  5.08,
     &              4.76,  3.73,  2.21,  2.18,  1.33,
     &              0.79,  0.54,  0.15,  0.001,  0.001,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     negatives 1
     &              0.40,  4.01,  7.37,  4.97,  2.38,
     &              1.21,  0.46,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     negatives 2
     &              0.05,  1.01,  3.69,  5.72,  5.26,
     &              2.99,  1.95,  1.31,  0.52,  0.34,
     &              0.007,  0.00,  0.00,  0.00,  0.00,
     &              0.00,  0.00,  0.00,  0.00,  0.00,
*     negatives 3
     &              0.001,  0.19,  1.20,  3.83,  4.92,
     &              4.86,  3.45,  2.30,  1.89,  1.41,
     &              0.64,  0.61,  0.10,  0.001,  0.001,
     &              0.00,  0.00,  0.00,  0.00,  0.00 /

      REAL m (7,3),   d (7,3),   r (7,3)
      REAL me(7,3),   de(7,3),   re(7,3)
      REAL ms(7,3),   ds(7,3),   rs(7,3)
      REAL m_tmp(7),  d_tmp(7),  r_tmp(7)
      REAL me_tmp(7), de_tmp(7), re_tmp(7)
      REAL ms_tmp(7), ds_tmp(7), rs_tmp(7)

      DATA m    / 4.66, 5.72, 6.87, 8.18, 9.49,10.85,12.32,
     &            2.32, 3.00, 3.52, 4.08, 4.71, 5.36, 6.28,
     &            2.29, 2.74, 3.33, 4.13, 4.70, 5.53, 6.06 /
      DATA me   / 0.08, 0.09, 0.08, 0.11, 0.16, 0.16, 0.18,
     &            0.05, 0.07, 0.06, 0.06, 0.10, 0.11, 0.11,
     &            0.05, 0.05, 0.05, 0.07, 0.09, 0.11, 0.12 /
      DATA ms   / 0.23, 0.21, 0.28, 0.39, 0.44, 0.54, 0.72,
     &            0.12, 0.13, 0.15, 0.19, 0.20, 0.23, 0.32,
     &            0.13, 0.11, 0.18, 0.25, 0.40, 0.42, 0.47 /

      DATA d    / 1.86, 2.03, 2.43, 2.88, 3.21, 3.47, 4.28,
     &            1.29, 1.51, 1.76, 1.95, 2.12, 2.22, 2.76,
     &            1.31, 1.40, 1.60, 1.91, 2.16, 2.39, 2.81 /
      DATA de   / 0.05, 0.05, 0.05, 0.05, 0.08, 0.11, 0.12,
     &            0.03, 0.03, 0.04, 0.04, 0.05, 0.06, 0.06,
     &            0.03, 0.03, 0.02, 0.03, 0.04, 0.04, 0.08 /
      DATA ds   / 0.14, 0.15, 0.16, 0.19, 0.25, 0.25, 0.27,
     &            0.14, 0.20, 0.20, 0.17, 0.12, 0.13, 0.17,
     &            0.18, 0.08, 0.16, 0.23, 0.25, 0.16, 0.32 /

      DATA r    / 0.944, 0.951, 0.979, 1.001, 1.009, 1.010, 1.039,
     &            0.877, 0.919, 0.966, 0.984, 0.991, 0.985, 1.034,
     &            0.894, 0.897, 0.930, 0.972, 0.998, 1.006, 1.049 /
      DATA re   / 0.009, 0.006, 0.005, 0.004, 0.006, 0.006, 0.006,
     &            0.014, 0.011, 0.011, 0.009, 0.010, 0.010, 0.009,
     &            0.016, 0.013, 0.007, 0.007, 0.008, 0.008, 0.010 /
      DATA rs   / 0.022, 0.017, 0.013, 0.011, 0.014, 0.012, 0.016,
     &            0.058, 0.031, 0.028, 0.036, 0.019, 0.018, 0.022,
     &            0.038, 0.030, 0.041, 0.027, 0.031, 0.015, 0.020 /

      REAL dcd(7), dcde(7), dcds(7)

      DATA dcd  / 1.94, 1.90, 2.15, 2.23, 2.30, 2.56, 2.50 /
      DATA dcde / 0.07, 0.05, 0.07, 0.06, 0.08, 0.11, 0.10 /
      DATA dcds / 0.12, 0.10, 0.10, 0.17, 0.16, 0.19, 0.17 /

      REAL drho(3), drhoe(3), drhos(3)

      DATA drho  / 0.081, 0.108, 0.194 /
      DATA drhoe / 0.032, 0.030, 0.033 /
      DATA drhos / 0.035, 0.041, 0.023 /

      REAL drap(12,3),   drape(12,3),   draps(12,3)
      REAL drap_tmp(12), drape_tmp(12), draps_tmp(12)

      DATA drap   / 0.03, 0.14, 0.41, 0.91, 1.32, 1.84,
     &              1.92, 1.58, 0.84, 0.37, 0.10, 0.04,
*
     &              0.17, 0.48, 1.08, 1.53, 1.91, 2.17,
     &              2.21, 2.01, 1.64, 1.02, 0.51, 0.14,
*
     &              0.58, 1.09, 1.38, 2.09, 2.28, 2.43,
     &              2.46, 2.33, 2.06, 1.82, 1.06, 0.50 /

      DATA drape  / 0.01, 0.02, 0.02, 0.04, 0.05, 0.06,
     &              0.06, 0.05, 0.03, 0.02, 0.01, 0.01,
*
     &              0.07, 0.05, 0.07, 0.06, 0.06, 0.06,
     &              0.07, 0.05, 0.05, 0.04, 0.03, 0.01,
*
     &              0.69, 0.16, 0.10, 0.07, 0.07, 0.08,
     &              0.07, 0.07, 0.06, 0.06, 0.04, 0.03 /

      DATA draps  / 0.02, 0.02, 0.04, 0.06, 0.07, 0.11,
     &              0.11, 0.11, 0.04, 0.03, 0.03, 0.01,
*
     &              0.16, 0.12, 0.18, 0.12, 0.12, 0.11,
     &              0.15, 0.11, 0.11, 0.07, 0.05, 0.04,
*
     &              0.90, 0.63, 0.29, 0.24, 0.14, 0.15,
     &              0.18, 0.14, 0.12, 0.10, 0.09, 0.06 /

      REAL mx1(7), mx2(7), mx3(3), mx4(3)

      DATA mx1 /  3190.0,  3710.0,  7001.5, 10114.0,
     &            9176.7,  9968.4,  16354.2 /
      DATA mx2 /   638.0,   530.0,    737.0,  778.0,
     &             543.0,   468.0,    562.0 /
      DATA mx3 /  8056.8, 17271.0, 28674.9 /
      DATA mx4 /  1492.0,  1515.0,  1359.0 /

c-----------------------------------------------------------------------
c---- Initialisation

      IF (iflag .EQ. 1) THEN

c....   set number of accepted events to zero
        nacc= 0

c....   create subdirectories for use with HBOOK/PAW
        CALL HCDIR ('//PAWC', ' ')
        CALL HMDIR ('98044', 'S')
        CALL HCDIR ('//HISTO', ' ')
        CALL HMDIR ('98044', 'S')

c....   book moca histograms

        DO i = 1, 3
          WRITE (low, '(F4.0)') mxbins2(i)
          WRITE (high,'(F4.0)') mxbins2(i+1)
          id = i*10
          CALL HBOOK1 (id,
     &      'Moca MD - '//low//' .lt. Mx .lt. '//high//' GeV, total',
     &      40, -0.5, 39.5, 0.)
          CALL HBOOK1 (id+1,
     &      'Moca MD - '//low//' .lt. Mx .lt. '//high//' GeV, forward',
     &      40, -0.5, 39.5, 0.)
          CALL HBOOK1 (id+2,
     &      'Moca MD - '//low//' .lt. Mx .lt. '//high//' GeV, backward',
     &      40, -0.5, 39.5, 0.)
          CALL HBOOK1 (id+3,
     &     'Moca MD - '//low//' .lt. Mx .lt. '//high//' GeV, positives',
     &      40, -0.5, 39.5, 0.)
          CALL HBOOK1 (id+4,
     &     'Moca MD - '//low//' .lt. Mx .lt. '//high//' GeV, negatives',
     &      40, -0.5, 39.5, 0.)
          CALL HBOOK1 (id+5,
     &  'Moca rapidity spectrum, '//low//' .lt. Mx .lt. '//high//' GeV',
     &      12, -3.0, +3.0, 0.)
        ENDDO

        DO i = 1, 7
          WRITE (low, '(F4.0)') mxbins1(i)
          WRITE (high,'(F4.0)') mxbins1(i+1)
          id = 100+i*10
          CALL HBOOK1 (id,
     &      'Moca MD - '//low//' .lt. Mx .lt. '//high//', total',
     &      40, -0.5, 39.5, 0.)
          CALL HBOOK1 (id+1,
     &      'Moca MD - '//low//' .lt. Mx .lt. '//high//', forward',
     &      40, -0.5, 39.5, 0.)
          CALL HBOOK1 (id+2,
     &      'Moca MD - '//low//' .lt. Mx .lt. '//high//', backward',
     &      40, -0.5, 39.5, 0.)
          CALL HBOOK1 (id+5,
     &  'Moca rapidity spectrum, '//low//' .lt. Mx .lt. '//high//' GeV',
     &      12, -3.0, +3.0, 0.)
        ENDDO

        CALL HBOOKB (40, 'Moca <n> vs. W, full',
     &               7, mxbins1, 0.)
        CALL HBOOKB (41, 'Moca <n> vs. W, forward',
     &               7, mxbins1, 0.)
        CALL HBOOKB (42, 'Moca <n> vs. W, backward',
     &               7, mxbins1, 0.)
        CALL HBOOKB (43, 'Moca dn/dy (y=0) vs. W',
     &               7, mxbins1, 0.)
        CALL HBOOKB (50, 'Moca D vs. W, full',
     &               7, mxbins1, 0.)
        CALL HBOOKB (51, 'Moca D vs. W, forward',
     &               7, mxbins1, 0.)
        CALL HBOOKB (52, 'Moca D vs. W, backward',
     &               7, mxbins1, 0.)
        CALL HBOOKB (60, 'Moca R2 vs. W, full',
     &               7, mxbins1, 0.)
        CALL HBOOKB (61, 'Moca R2 vs. W, forward',
     &               7, mxbins1, 0.)
        CALL HBOOKB (62, 'Moca R2 vs. W, backward',
     &               7, mxbins1, 0.)

        CALL HBOOKB (70, 'Moca rho vs. W', 7, mxbins1, 0.)

        CALL HBOOKB (90, 'Auxiliary histogram for Mx binning',
     &               7, mxbins1, 0.)
        CALL HBOOKB (91, 'Auxiliary histogram for Mx binning',
     &               7, mxbins1, 0.)
        CALL HBOOKB (92, 'Auxiliary histogram for Mx binning',
     &               3, mxbins2, 0.)
        CALL HBOOKB (93, 'Auxiliary histogram for Mx binning',
     &               3, mxbins2, 0.)

c....   book data histograms (stat errors only)

        DO i = 1, 3
          WRITE (low, '(F4.0)') mxbins2(i)
          WRITE (high,'(F4.0)') mxbins2(i+1)
          id = -i*10
          CALL HBOOK1 (id-1,
     &      'Data MD - '//low//' .lt. Mx .lt. '//high//', forward',
     &               20, -0.5, 19.5, 0.)
          CALL HBOOK1 (id-2,
     &      'Data MD - '//low//' .lt. Mx .lt. '//high//', backward',
     &               20, -0.5, 19.5, 0.)
          CALL HBOOK1 (id-3,
     &      'Data MD - '//low//' .lt. Mx .lt. '//high//', positives',
     &               20, -0.5, 19.5, 0.)
          CALL HBOOK1 (id-4,
     &      'Data MD - '//low//' .lt. Mx .lt. '//high//', negatives',
     &               20, -0.5, 19.5, 0.)
          CALL HBOOK1 (id-5,
     &  'Data rapidity spectrum, '//low//' .lt. Mx .lt. '//high//' GeV',
     &               12, -3.0, +3.0, 0.)
        ENDDO

        CALL HBOOKB (-40, 'Data <n> vs. W, full',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-41, 'Data <n> vs. W, forward',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-42, 'Data <n> vs. W, backward',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-43, 'Data dn/dy (y=0) vs. W',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-50, 'Data D vs. W, full',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-51, 'Data D vs. W, forward',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-52, 'Data D vs. W, backward',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-60, 'Data R2 vs. W, full',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-61, 'Data R2 vs. W, forward',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-62, 'Data R2 vs. W, backward',
     &               7, mxbins1, 0.)

        CALL HBOOKB (-70, 'Data rho vs. W', 3, mxbins2, 0.)

        CALL HBOOKB (-90, 'Auxiliary histogram for Mx binning',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-91, 'Auxiliary histogram for Mx binning',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-92, 'Auxiliary histogram for Mx binning',
     &               3, mxbins2, 0.)
        CALL HBOOKB (-93, 'Auxiliary histogram for Mx binning',
     &               3, mxbins2, 0.)

c....   book data histograms (stat+sys errors)

        DO i = 1, 3
          WRITE (low, '(F4.0)') mxbins2(i)
          WRITE (high,'(F4.0)') mxbins2(i+1)
          id = -100-i*10
          CALL HBOOK1 (id-1,
     &      'Data MD - '//low//' .lt. Mx .lt. '//high//', forward',
     &               20, -0.5, 19.5, 0.)
          CALL HBOOK1 (id-2,
     &      'Data MD - '//low//' .lt. Mx .lt. '//high//', backward',
     &               20, -0.5, 19.5, 0.)
          CALL HBOOK1 (id-3,
     &      'Data MD - '//low//' .lt. Mx .lt. '//high//', positives',
     &               20, -0.5, 19.5, 0.)
          CALL HBOOK1 (id-4,
     &      'Data MD - '//low//' .lt. Mx .lt. '//high//', negatives',
     &               20, -0.5, 19.5, 0.)
          CALL HBOOK1 (id-5,
     &  'Data rapidity spectrum, '//low//' .lt. Mx .lt. '//high//' GeV',
     &               12, -3.0, +3.0, 0.)
        ENDDO

        CALL HBOOKB (-140, 'Data <n> vs. W, full',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-141, 'Data <n> vs. W, forward',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-142, 'Data <n> vs. W, backward',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-143, 'Data dn/dy (y=0) vs. W',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-150, 'Data D vs. W, full',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-151, 'Data D vs. W, forward',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-152, 'Data D vs. W, backward',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-160, 'Data R2 vs. W, full',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-161, 'Data R2 vs. W, forward',
     &               7, mxbins1, 0.)
        CALL HBOOKB (-162, 'Data R2 vs. W, backward',
     &               7, mxbins1, 0.)

        CALL HBOOKB (-170, 'Data rho vs. W', 3, mxbins2, 0.)

c-----------------------------------------------------------------------
c---- Event analysis

      ELSEIF (iflag .EQ. 2) THEN

c....   move to the correct subdirectory in PAWC
        CALL HCDIR ('//PAWC/98044', ' ')

c....   get vectors for boost to hCMS
        ierr = HZIBEAM (ibp, ibl)
        isl = HZIDELEC(id)
        IF (ierr .EQ. 1 .AND. isl .GT. 0) THEN
          DO i = 1, 4
            pbeam(i) = PHEP (i, ibp)
            gamma(i) = PHEP (i, ibl) - PHEP (i, isl)
          ENDDO
        ELSEIF (ierr .NE. 1 .AND. isl .GT. 0) THEN
          PRINT *, 'HZ98044 -- Warning: No beam(s) found,'
          PRINT *, '        -- proton beam energy set to 820 GeV,'
          PRINT *, '        -- positron beam energy set to 27.55 GeV.'
          IF (ierr .EQ.  0) ibp = 0
          IF (ierr .EQ. -1) ibl = 0
          pbeam(1) = 0.
          pbeam(2) = 0.
          pbeam(3) = +820.
          pbeam(4) = +820.
          gamma(1) = - PHEP (1, isl)
          gamma(2) = - PHEP (2, isl)
          gamma(3) = -27.55 - PHEP (3, isl)
          gamma(4) = +27.55 - PHEP (4, isl)
        ELSEIF (isl .LE. 0) THEN
          PRINT *, 'HZ98044 -- Warning: No scattered positron found,'
          PRINT *, '        -- event skipped !'
          GOTO 999
        ENDIF

c....   initialise boost to hCMS
        CALL HZHCMINI (pbeam, gamma, ierr)
        IF (ierr .EQ. 1) THEN
          PRINT *, 'HZ98044 -- Warning: boost to hadronic CMS failed,'
          PRINT *, '        -- event skipped !'
          GOTO 999
        ENDIF

c....   select final state particles and store pseudorapidity in hCMS
        DO ihep = 1, NHEP
          iacc(ihep) = .FALSE.
          rap(ihep) = 9999.
          IF (
     &        ISTHEP(ihep) .EQ. 1 .AND.
     &        ihep .NE. ibp       .AND.
     &        ihep .NE. ibl       .AND.
     &        ihep .NE. isl       .AND.
     &        .TRUE.) THEN
            iacc(ihep) = .TRUE.
            p_lab(1) = PHEP (1, ihep)
            p_lab(2) = PHEP (2, ihep)
            p_lab(3) = PHEP (3, ihep)
            p_lab(4) = PHEP (4, ihep)
            CALL HZHCM(p_lab, p_hcms, ierr)
            IF (ierr .EQ. 1) THEN
              PRINT *,
     &          'HZ98044 -- Warning: boost to hadronic CMS failed,'
              PRINT *, '        -- event skipped !'
              GOTO 999
            ENDIF
c           rap is pseudorapidity !
            p = SQRT(p_hcms(1)**2+p_hcms(2)**2+p_hcms(3)**2)
            pz = p_hcms(3)
            IF (p .GT. ABS(pz)) rap(ihep) = 0.5*(LOG(p+pz)-LOG(p-pz))
          ENDIF
        ENDDO

c....   sort particles with increasing pseudorapidity
        CALL SORTZV (rap, index, NHEP, 1, 0, 0)

c....   look for largest gap
        gap =  0.
        DO ihep = 2, NHEP
          tmp = rap(index(ihep)) - rap(index(ihep-1))
          IF (tmp .GT. gap .AND. iacc(index(ihep))) THEN
            gap = tmp
            id = ihep
          ENDIF
        ENDDO
c       store boundary between X and Y in variable gap
        gap = rap(index(id-1)) + gap/2

c....   get DIS kinematics
        q2 = HZDISKIN (1)
        y  = HZDISKIN (3)
        w2 = HZDISKIN (4)

c....   get diffractive DIS kinematics and select particles of system X
        DO i = 1, 4
          xvec(i) = 0.
          yvec(i) = 0.
        ENDDO
        DO ihep = 1, NHEP
          IF (iacc(ihep)) THEN
            IF (rap(ihep) .GT. gap) THEN
              xvec(1) = xvec(1) + PHEP (1, ihep)
              xvec(2) = xvec(2) + PHEP (2, ihep)
              xvec(3) = xvec(3) + PHEP (3, ihep)
              xvec(4) = xvec(4) + PHEP (4, ihep)
            ELSE
              iacc(ihep) = .FALSE.
              yvec(1) = yvec(1) + PHEP (1, ihep)
              yvec(2) = yvec(2) + PHEP (2, ihep)
              yvec(3) = yvec(3) + PHEP (3, ihep)
              yvec(4) = yvec(4) + PHEP (4, ihep)
            ENDIF
          ENDIF
        ENDDO
        mx = xvec(4)**2 - xvec(1)**2 - xvec(2)**2 - xvec(3)**2
        IF (mx .GT. 0) THEN
          mx = SQRT(mx)
        ELSE
          mx = 0.
        ENDIF
        my = yvec(4)**2 - yvec(1)**2 - yvec(2)**2 - yvec(3)**2
        IF (my .GT. 0) THEN
          my = SQRT(my)
        ELSE
          my = 0.
        ENDIF
        t = (pbeam(4)-yvec(4))**2 - (pbeam(1)-yvec(1))**2
     &    - (pbeam(2)-yvec(2))**2 - (pbeam(3)-yvec(3))**2
        xp = (q2 + mx**2 - t)/(q2 + w2 - mp**2)

c....   select event
        IF (
     &      q2 .GT. q2_low      .AND.  q2 .LT. q2_high  .AND.
     &      y  .GT. y_low       .AND.  y  .LT. y_high   .AND.
     &      mx .GT. mx_low      .AND.  mx .LT. mx_high  .AND.
     &      my .LT. my_high     .AND.
     &      ABS(t) .LT. t_high  .AND.
     &      xp .LT. xp_high     .AND.
     &      .TRUE.) THEN

          nacc = nacc + 1

c....     initialise boost to gamma-pom CMS
          pbeam(1) = xp*pbeam(1)
          pbeam(2) = xp*pbeam(2)
          pbeam(3) = xp*pbeam(3)
          pbeam(4) = xp*pbeam(4)
          CALL HZHCMINI (pbeam, gamma, ierr)

c....     get number of particles in gamma-pom CMS
          nt = 0
          nf = 0
          nb = 0
          np = 0
          nn = 0
          DO ihep = 1, NHEP
            IF (iacc(ihep) .AND. IHCHRG(ihep) .NE. 0) THEN
              p_lab(1) = PHEP(1, ihep)
              p_lab(2) = PHEP(2, ihep)
              p_lab(3) = PHEP(3, ihep)
              p_lab(4) = PHEP(4, ihep)
              CALL HZHCM (p_lab, p_hcms, ierr)
c             rap is real rapidity !
              p = p_hcms(4)
              pz = p_hcms(3)
              rap(ihep) = 9999.
              IF (p .GT. ABS(pz)) rap(ihep) = 0.5*(LOG(p+pz)-LOG(p-pz))
              nt = nt + 1
              IF (rap(ihep) .GT. 0) nf = nf + 1
              IF (rap(ihep) .LT. 0) nb = nb + 1
              IF (IHCHRG(ihep) .GT. 0) np = np + 1
              IF (IHCHRG(ihep) .LT. 0) nn = nn + 1
            ENDIF
          ENDDO

c....     fill histograms
          DO i = 1, 3
            id = i*10
            IF (mx .GT. mxbins2(i) .AND. mx .LT. mxbins2(i+1)) THEN
              CALL HFILL (id,   FLOAT(nt), 0., wtx)
              CALL HFILL (id+1, FLOAT(nf), 0., wtx)
              CALL HFILL (id+2, FLOAT(nb), 0., wtx)
              CALL HFILL (id+3, FLOAT(np), 0., wtx)
              CALL HFILL (id+4, FLOAT(nn), 0., wtx)
              DO ihep = 1, NHEP
                IF (iacc(ihep) .AND. IHCHRG(ihep) .NE. 0)
     &            CALL HFILL (id+5, rap(ihep), 0., wtx)
              ENDDO
            ENDIF
          ENDDO
          DO i = 1, 7
            id = 100+i*10
            IF (mx .GT. mxbins1(i) .AND. mx .LT. mxbins1(i+1)) THEN
              CALL HFILL (id,   FLOAT(nt), 0., wtx)
              CALL HFILL (id+1, FLOAT(nf), 0., wtx)
              CALL HFILL (id+2, FLOAT(nb), 0., wtx)
              DO ihep = 1, NHEP
                IF (iacc(ihep) .AND. IHCHRG(ihep) .NE. 0)
     &            CALL HFILL (id+5, rap(ihep), 0., wtx)
              ENDDO
            ENDIF
          ENDDO

          CALL HFILL (90, mx, 0., mx*wtx)
          CALL HFILL (91, mx, 0., wtx)
          CALL HFILL (92, mx, 0., mx*wtx)
          CALL HFILL (93, mx, 0., wtx)

        ENDIF

c-----------------------------------------------------------------------
c---- Termination

      ELSEIF (iflag .EQ. 3) THEN

c....   move to the correct PAW subdirectory
        call hcdir('//PAWC/98044',' ')

c....   normalise multiplicity distributions and rapidity spectra
        CALL HUNPAK (93, nev, ' ', 1)
        DO i = 1, 3
          id = i*10
          CALL HZHINRM (id,   0, nev(i)/100, 1)
          CALL HZHINRM (id+1, 0, nev(i)/100, 1)
          CALL HZHINRM (id+2, 0, nev(i)/100, 1)
          CALL HZHINRM (id+3, 0, nev(i)/100, 1)
          CALL HZHINRM (id+4, 0, nev(i)/100, 1)
          CALL HZHINRM (id+5, 0, nev(i), 1)
        ENDDO
        CALL HUNPAK (91, nev, ' ', 1)
        DO i = 1, 7
          id = 100+i*10
          CALL HZHINRM (id,   0, nev(i)/100, 1)
          CALL HZHINRM (id+1, 0, nev(i)/100, 1)
          CALL HZHINRM (id+2, 0, nev(i)/100, 1)
          CALL HZHINRM (id+5, 0, nev(i), 1)
        ENDDO

c....   extract moments, central density and forward-backward corr.
        DO i = 1, 7
          id = 100+i*10
          mt(i) = HSTATI (id,   1, ' ', 1)
          mf(i) = HSTATI (id+1, 1, ' ', 1)
          mb(i) = HSTATI (id+2, 1, ' ', 1)
          dt(i) = HSTATI (id,   2, ' ', 1)
          df(i) = HSTATI (id+1, 2, ' ', 1)
          db(i) = HSTATI (id+2, 2, ' ', 1)
          rt(i) = 1 + (dt(i)**2 - mt(i))/mt(i)**2
          rf(i) = 1 + (df(i)**2 - mf(i))/mf(i)**2
          rb(i) = 1 + (db(i)**2 - mb(i))/mb(i)**2
          cd(i) = (HX(id+5, -0.25) + HX(id+5, 0.25))/2
          fb(i) = (dt(i)**2 - df(i)**2 - db(i)**2)/(2*df(i)*db(i))
        ENDDO
        CALL HPAK (40, mt)
        CALL HPAK (41, mf)
        CALL HPAK (42, mb)
        CALl HPAK (43, cd)
        CALL HPAK (50, dt)
        CALL HPAK (51, df)
        CALL HPAK (52, db)
        CALL HPAK (60, rt)
        CALL HPAK (61, rf)
        CALL HPAK (62, rb)
        CALL HPAK (70, fb)

c....   store H1 data in histograms
        DO k = 1, 4
          DO j = 1, 3
            DO i = 1, 20
              pn_tmp (i) = pn (i,j,k)
              pne_tmp(i) = pne(i,j,k)
              pns_tmp(i) = SQRT(pne(i,j,k)**2 + pns(i,j,k)**2)
            ENDDO
            id = -10*j-k
            CALL HPAK  (id, pn_tmp)
            CALL HPAKE (id, pne_tmp)
            CALL HPAK  (id-100, pn_tmp)
            CALL HPAKE (id-100, pns_tmp)
          ENDDO
        ENDDO

        DO j = 1, 3
          DO i = 1, 7
            m_tmp(i)  = m(i,j)
            me_tmp(i) = me(i,j)
            ms_tmp(i) = SQRT(me(i,j)**2 + ms(i,j)**2)
            d_tmp(i)  = d(i,j)
            de_tmp(i) = de(i,j)
            ds_tmp(i) = SQRT(de(i,j)**2 + ds(i,j)**2)
            r_tmp(i)  = r(i,j)
            re_tmp(i) = re(i,j)
            rs_tmp(i) = SQRT(re(i,j)**2 + rs(i,j)**2)
          ENDDO
          CALL HPAK  (-40-j+1,  m_tmp)
          CALL HPAKE (-40-j+1,  me_tmp)
          CALL HPAK  (-140-j+1, m_tmp)
          CALL HPAKE (-140-j+1, ms_tmp)
          CALL HPAK  (-50-j+1,  d_tmp)
          CALL HPAKE (-50-j+1,  de_tmp)
          CALL HPAK  (-150-j+1, d_tmp)
          CALL HPAKE (-150-j+1, ds_tmp)
          CALL HPAK  (-60-j+1,  r_tmp)
          CALL HPAKE (-60-j+1,  re_tmp)
          CALL HPAK  (-160-j+1, r_tmp)
          CALL HPAKE (-160-j+1, rs_tmp)
        ENDDO

        CALL HPAK  (-43, dcd)
        CALL HPAKE (-43, dcde)
        DO i = 1, 7
          dcds(i) = SQRT(dcde(i)**2 + dcds(i)**2)
        ENDDO
        CALL HPAK  (-143, dcd)
        CALL HPAKE (-143, dcds)

        CALL HPAK  (-70, drho)
        CALL HPAKE (-70, drhoe)
        DO i = 1, 3
          drhos(i) = SQRT(drhoe(i)**2 + drhos(i)**2)
        ENDDO
        CALL HPAK  (-170, drho)
        CALL HPAKE (-170, drhos)

        DO j = 1, 3
          DO i = 1, 12
            drap_tmp(i)  = drap(i,j)
            drape_tmp(i) = drape(i,j)
            draps_tmp(i) = SQRT(drape(i,j)**2 + draps(i,j)**2)
          ENDDO
          id = -10*j-5
          CALL HPAK  (id, drap_tmp)
          CALL HPAKE (id, drape_tmp)
          CALL HPAK  (id-100, drap_tmp)
          CALL HPAKE (id-100, draps_tmp)
        ENDDO

        CALL HPAK  (-90, mx1)
        CALL HPAK  (-91, mx2)
        CALL HPAK  (-92, mx3)
        CALL HPAK  (-93, mx4)

c....   print number of accepted events
        PRINT *, 'HZ98044 -- Number of accepted moca events: ', nacc

      ENDIF

c----------------------------------------------------------------------
c---- Return

999   RETURN
      END
*CMZ :  1.02/00 04/10/98  22.21.04  by  Tancredi Carli
*CMZ :  1.01/15 13/08/98  19.15.10  by  Tancredi Carli
*CMZ :  1.01/01 28/03/96  15.50.59  by  Tancredi Carli
*-- Author :
      subroutine HZ98050(IFLAG)
****************************************************************************
* Purpose: Produce fraction of events with a forward jet using a cone
* algorithm (R=1).
*
* The event is accepted if it fulfills the requirements:
*   y>0.1, E_positron >10 GeV
*   0.00045 < x < 0.045
*   1 jet with cone algorithm (radius 1, PXCONE) and:
*     Et > 5 GeV
*     0 < eta < 2.6
*     x_jet > 0.036
*     0.5 < E_t**2/Q2 < 2
*     cos(theta_breit) > 0 (jet in fragmentation region of the breit frame)
*
*    Only 1 entry per event (even if there are 2 jets fulfilling the cuts).
*
*    histograms:
*    1    forward jet cross section in x_bjorken bins in the MC.
*   -1    forward jet cross section in x_bjorken bins in the data.
*     The data are corrected to hadron level. The parton level corrections
*     are not included.
*
*     700  eta distribution of the highest xjet jet
*     701  eta distribution of the second highest xjet jet
*     710  Et distribution of the highest xjet jet
*     711  Et distribution of the second highest xjet jet
*     720  Et2/Q2 distribution of the highest xjet jet (no Et2/Q2 cut applied)
*     721             "            second      "
*
*     These are parton level results. A direct comparison with the data is
*     bound to hadronization uncertainties.
*
*     300  MEPJET cross sections (scale 0.25*kt**2) for forward jets
*     301  MEPJET cross sections (scale 2*kt**2) for forward jets
*     400  BFKL LO for forward jets
*     401  BFKL born for forward jets
*
*     The program gives the number of events with 1 or 2 forward jets
*     The systematics (in the data) are printed at the end
*
* Event selection:
*
* Running:
*
* Arguments: iflag=1 initialisation
*            iflag=1 filling
*            iflag=3 termination
*
* written by:
****************************************************************************
      IMPLICIT NONE
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      Integer iprog
      Real qp_3,qp_2
      Real pthg1,shg1,xpg1,zqg1
      Common/partons/pthg1,shg1,xpg1,zqg1,iprog
c  ntuple jets
      Integer njet,ipro
      Real pthg,shg,xpg,zqg,pth,sh,xp,zq1,zq2,deta
      common/cwnco1/x,q2,y,ipro
      Integer kind(32)
      Integer numjet
      Parameter (numjet=50)
      Double precision pj(numjet,8)
      Double precision pbeam(4),pgam(4),pcm(4),ph(5)
      Double precision pold(4),pnew(4)
*
      Integer i,iflag,ihep,k1
      Character*5 xxxx
*
      Real pi,rd,eb,ee
      Parameter (ee=27.5)
      Integer iel,idum,ibeam,igam,ifj,afj
      Parameter (pi=3.1415927,rd=180./pi)
      Integer nentry
      Real x,y,q2,enel,thel,efwd,th,lx,lxj
      Real ptj21,pt2q21,etaj1
      Real thj,xj,ptb,costhb
      Integer ibin,nj,ij,naj,naj2,np,np4,np5,nsel
*
      Integer ierr
      Integer maxhi,modjet,maxjet
      Parameter (maxhi=100,modjet=2,maxjet=30)
      Real  selj(maxjet,4),help,empz,empzh,xg,empzl,empzhl,xgl
      Integer ipjet(maxjet),l,k,j
      Real nev(maxhi),lum,xw,nev2(maxhi)
      save nev2
      Double precision rcone
      Parameter (rcone=1.)
      Logical lp,fjet,twojet
      Data lp/.false./
      Real nxg(3)
*

      real q2as,ulalps,a1,a2
      double precision alphas2,alphas
      real xjet1
      real etaj(5),xjet(5),pt2q2(5),ptj2(5)
      real eta0,pt2q20,xjet0,pt0

*********************************************************************
*
      Integer nbin,nbin1
      Parameter (nbin=8)
      Parameter (nbin1=16)
      real xout(nbin),xerr(nbin)
      real fx(nbin+1),ptqbin(nbin1+1)
      Data   fx/0.00045,0.0008,0.0014,0.0025,0.0045,0.008,0.014,
     &            0.025,0.045/
      data ptqbin /0.01,0.017,0.03,
     +  0.06,0.1,0.17,0.3,0.6,1.,1.7,3.,6.,10.,17.,30.,60.,100./
*
*********************************************************************
      Integer nx
      Real n2,nall,nall2
      Real xmin,xmax
      Data xxxx/'98050'/,NENTRY/0/
      save xxxx,nev,nall
*********************************************************************
*
*                      data points from zeus
*
*********************************************************************
      real sup(8),sdown(8)
      real fjxs(8),efjxs(8),sysup(8),sysdown(8)
      data fjxs /114.,96.2,77.8,34.4,14.1,6.53,2.65,0.65/
      data efjxs /9.7,6.5,4.7,2.2,1.0,0.54,0.25,0.09/
      data sysup /29.,8.2,5.2,3.8,2.5,0.1,0.3,0.1/
      data sysdown /15.,8.2,6.9,1.9,1.2,0.7,0.3,0.4/
      save sup,sdown
*********************************************************************
*
*                      MEPJET cross sections
*
*********************************************************************
*
* for scale 0.25*kt2
*
      real mep1(8)
      data mep1 /22.90,26.96,20.99,13.46,6.20,2.73,1.24,0.34/
*
* forscale 2*kt2
*
      real mep2(8)
      data mep2 /13.46,21.29,16.80,10.41,5.18,2.43,1.05,0.32/
*********************************************************************
*
*                      BARTELS and Wusthoff cross sections
*
*********************************************************************
*
*     LO BFKL
*
      real bfkl(8)
      data bfkl /147.7,150.9,104.6,46.51,16.26,5.25,1.44,0.23/
*
*     1st term
*
      real born(8)
      data born /28.93,35.50,34.26,18.32,8.38,3.20,1.07,0.19/
*********************************************************************
*
*                      Initialization
*
*********************************************************************
      NENTRY=NENTRY+1
*
      IF (iflag.eq.1) then
*
       nxg(1)=0.
       nxg(2)=0.
       nxg(3)=0.
       nall=0.
       nall2=0.
       n2=0.
       do i = 1,maxhi
          nev(i) = 0.
          nev2(i) = 0.
       enddo
*
*
* Initialisation: The following MUST always be done
* (i) make subdirectory in PAWC
* - use the name as the xxxxxx in HZxxxxxx subroutine
* (i) make subdirectory in o/p file
*
        Call hcdir('//PAWC',' ')
        call hmdir(xxxx,'S')
        Call hcdir('//HISTO',' ')
        call hmdir(xxxx,'S')
*
* book histos
*
*
       call hbook1(31,' nall/cross ',3,0.,3.,0.)
       call hbookb(1 ,' 1 fjets XBj ',nbin,fx,0.)
       call hbookb(-1,' 1 fjets XBj ',nbin,fx,0.)
       call hbook1(700,'ethad 1st fjet',30,0.,30.,0.)
       call hbook1(701,'ethad 2nd fjet',30,0.,30.,0.)
       call hbook1(710,'etahad 1st fjet',15,0.,3.,0.)
       call hbook1(711,'etahad 2nd fjet',15,0.,3.,0.)
       call hbookb(720,'pt2q2 1st fjet',nbin1,ptqbin,0.)
       call hbookb(721,'pt2q2 2nd fjet',nbin1,ptqbin,0.)
       call hbookb(300 ,'MEPJET scale 0.25kt2 ',nbin,fx,0.)
       call hbookb(301 ,'MEPJET scale 2kt2',nbin,fx,0.)
       call hbookb(400 ,'BFKL LO ',nbin,fx,0.)
       call hbookb(401 ,'BFKL 1st term',nbin,fx,0.)
*
*      pack data into histograms ; 8 bins
*
*
       Call hpak (-1,fjxs)
       Call hpake(-1,efjxs)
*
*     pack theory points
*
       call hpak(300,mep1)
       call hpak(301,mep2)
       call hpak(400,bfkl)
       call hpak(401,born)
*
*      add sytematical and statistical error
*
       Do i=1,8
          sup(i) = sqrt(efjxs(i)**2+sysup(i)**2)
          sdown(i) = sqrt(efjxs(i)**2+sysdown(i)**2)
       enddo
*
*********************************************************************
*
*                      Event Processing
*
*********************************************************************
      Else if(iflag.eq.2) then
         do i = 1,5
            etaj(i) = 0.
            pt2q2(i) = 0.
            xjet(i) = 0.
            ptj2(i) = 0.
         enddo

*
*     Filling: The following MUST always be done
*     (i) move to the correct sub-directory in PAWC
*
         call hcdir('//PAWC/'//xxxx,' ')
*
         xw=1.
         nall=nall+xw
*
         ierr=HZIBEAM(ibeam,idum)
         if (.not.(ierr.eq.1)) then
            write(6,*) 'HZ'//xxxx,' beams not found ! '
            return
         else
            Do i=1,4
               pbeam(i)=PHEP(i,IBEAM)
            enddo
         endif
*
         eb=real(PHEP(4,idum))
         if (abs(abs(eb)-ee).gt.0.2) then
            if (nentry.lt.10) then
               write(6,*) 'HZ'//xxxx,' Electron not at ',ee,' ! ',eb
            elseif (nentry.eq.10) then
               write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &              ' ...last message ! '
            endif
            return
         endif
*
* Event selection
*
         q2=real(HZDISKIN(1))
         x =real(HZDISKIN(2))
         y =real(HZDISKIN(3))

         deta = -999.
         njet = 0
         ipro = iprog
*
*
*     get electron variables for kinematic selection
*
       iel=HZIDELEC(idum)
       if (iel.eq.-1) then
        write(*,*) 'Hz'//xxxx,' electron not found '
        return
       endif
       enel=real(PHEP(4,iel))
       thel=real(HZPHMANG(PHEP(3,iel),
     $      sqrt(PHEP(1,iel)**2+PHEP(2,iel)**2)))
*
*     Momentum of the gamma
*
       pgam(1)=-real(PHEP(1,iel))
       pgam(2)=-real(PHEP(2,iel))
       pgam(3)=-eb - real(PHEP(3,iel))
       pgam(4)= eb - real(PHEP(4,iel))
*
       if (lp) then
        write(6,*) 'Hz'//xxxx,' enel= ',enel,' thel= ',thel
        write(6,*) 'Hz'//xxxx,' y= ',y,' q2= ',q2
       endif
*
       fjet=.true.
       if (y.lt.0.1)    fjet=.false.
       if (enel.lt.10.0) then
        fjet=.false.
       endif
*
* Initialize Breit frame boost
*
       call HZBRTINI(pbeam,pgam,ierr)
       if (ierr.eq.1) write(*,*) 'Hz'//xxxx,' Boost failed'
*
* find jets
*
       if (fjet) then
*
          call hzjtfind(modjet,rcone,nj,pj)
*
          if (lp) then
             write(6,*) 'forward jet analysis: nj= ',nj
          endif
          if (nj.gt.numjet) then
             write(6,*) 'hz',xxxx,' too many jets found ! '
             return
          endif
*
          naj=0
          ifj=0
          do 100 ij=1,nj
*
             pold(1) = pj(ij,5)
             pold(2) = pj(ij,6)
             pold(3) = pj(ij,7)
             pold(4) = pj(ij,4)
*
*     Boost jet in the breit frame
*
             call HZBRT(pold,pnew,ierr)
             if (ierr.eq.1) write(*,*) 'Hz'//xxxx,' Boost failed'
             ptb = sqrt(real(pnew(1))**2+real(pnew(2))**2)
             costhb = real(pnew(3)) / sqrt(ptb**2 + real(pnew(3))**2)
*
             if (lp) write(6,'(a,4f9.3)')
     &            ' Jet= ',(real(pj(ij,i)),i=4,7)
*
             ptj21=real(pj(ij,3))
             pt2q21=ptj21**2/q2
             thj=real(HZPHMANG(pj(ij,7),pj(ij,3)) )
             etaj1 = pj(ij,1)
*
*     Get the forward jets
*
             if (
     &          ptj21.gt.5.and.
     &            etaj1.lt.2.6.and.
     &            etaj1.gt.0.) then
                xjet1=real(pj(ij,4))/820.*cos(thj)
                if (costhb.gt.0) then
                   ifj = ifj + 1
                   xjet(ifj) = xjet1
                   ptj2(ifj) = ptj21
                   pt2q2(ifj) = pt2q21
                 etaj(ifj) = etaj1
              endif
           endif
 100    continue
        if (ifj.eq.0)  return
*
*     Save an event if there is a f.j. with 0.5<Et2/Q2<2
*     and xjet>0.036
*
        afj = 0
        do i = 1,ifj
           if (pt2q2(i).lt.2.and.pt2q2(i).gt.0.5) then
              if (xjet(i).gt.0.036) then
                 afj = afj + 1
              endif
           endif
        enddo
        if (afj.ge.1) call hf1(1,x,xw)
*
        if (x.gt.fx(1).and.x.lt.fx(9)) then
           if (afj.eq.1)  nev(1)=nev(1)+xw
           if (afj.eq.2)  nev2(1)=nev2(1)+xw
        endif
*
*     Sort jets by xjet
*
        if (ifj.eq.1) goto 12
        xjet0 = 0.
        do j = 1,ifj
           xjet0 = xjet(j)
           l = j+1
           k1 = 0
           do k  = l,ifj
              if (xjet(k).gt.xjet0) then
                 xjet0 = xjet(k)
                 eta0 = etaj(k)
                 pt0 = ptj2(k)
                 pt2q20 = pt2q2(k)
                 k1 = k
              endif
           enddo
           if (k1.eq.0) goto 12
           xjet(k1) = xjet(j)
           etaj(k1) = etaj(j)
           ptj2(k1) = ptj2(j)
           pt2q2(k1) = pt2q2(j)
           xjet(j) = xjet0
           etaj(j) = eta0
           ptj2(j) = pt0
           pt2q2(j) = pt2q20
        enddo
 12     continue
*
*     Store the histograms
*     highest xjet
*
        if (xjet(1).gt.0.036) then
           call hf1(720,pt2q2(1),xw)
           if (pt2q2(1).gt.0.5.and.pt2q2(1).lt.2.) then
              call hf1(700,ptj2(1),xw)
              call hf1(710,etaj(1),xw)
           endif
        endif
*
*     second highest xjet
*
        if (ifj.eq.1) goto 2000
        if (xjet(2).gt.0.036) then
           if (x.gt.fx(1).and.x.lt.fx(9)) then
              call hf1(721,pt2q2(2),xw)
              if (pt2q2(2).gt.0.5.and.pt2q2(2).lt.2.) then
                 call hf1(701,ptj2(2),xw)
                 call hf1(711,etaj(2),xw)
              endif
           endif
        endif
*
 2000   continue
      endif
*
*********************************************************************
*
*     Termination
*
*********************************************************************

      Else if(iflag.eq.3) then

* Termination: The following MUST always be done
* (i) Move to the correct PAW subdirectory
*
       call hcdir('//PAWC/'//xxxx,' ')
*
       lum=999999999.
       if (xsec.ne.0.) then
        lum=real(nall)/real(xsec)
       else
        write(6,*) 'hz',xxxx,' xsec=0 ! '
       endif
*
        write(6,*) 'hz0050: Total Cross= ',
     &  real(xsec),' nall= ',nall
        write(6,*) '  ZEUS: # of 1 fjets= ',nev(1),' lumi= ',lum
        write(6,*) '  ZEUS: # of 2 fjets= ',nev2(1),' lumi= ',lum
        write(6,*) 'Systematics up (+ statistics)', sup
        write(6,*) 'Systematics down (+ statistics)', sdown
*
* convert in nb
*
        lum = lum * 1000.
*
*
*
        call HBOOKB(1111,'Tx',8,fx,0.)
        call HBARX(0)

        do I = 1,8
           xout(i)=fx(i+1)-fx(i)
           xerr(i)=0.
        enddo
        call HPAK(1111,xout)
        call HPAKE(1111,xerr)
*
*     Normalise to luminosity
*
        call hopera(1,'+E',1,1,1./lum,0.)
        call hopera(700,'+E',700,700,1./lum,0.)
        call hopera(710,'+E',710,710,1./lum,0.)
        call hopera(720,'+E',720,720,1./lum,0.)
        call hopera(701,'+E',701,701,1./lum,0.)
        call hopera(711,'+E',711,711,1./lum,0.)
        call hopera(721,'+E',721,721,1./lum,0.)
        call hopera(1,'/E',1111,1,1.,1.)
        call hzhinfo(1,nev(1))
        call hzchisq(-1,1)
*
      endif
*
      RETURN
      END
*CMZ :  2.00/06 02/05/2002  14.48.48  by  Tancredi Carli
*CMZ :  1.02/05 13/01/99  17.22.17  by  Tancredi Carli
*CMZ :  1.02/01 23/10/98  17.57.20  by  Tancredi Carli
*CMZ :  1.02/00 02/10/98  13.00.48  by  Tancredi Carli
*CMZ :  1.01/15 04/09/98  19.48.48  by  Tancredi Carli
*-- Author : Tancredi Carli
      subroutine HZ98076(IFLAG)
****************************************************************************
* Purpose:
*  Dijet fraction for 5 < Q2 < 100 GeV2
*  as a function of Q2 and x
*  using the cone algorithm
*
* Event selection:
*  156 < theta_e' < 173 deg.
*  E' > 11 GeV
*  y  > 0.05
*
* Jet reconstruction and selection in photon-proton cms:
*  R = 1, p_t_min = 5 GeV, f = 0.75
*  exactly two jets per event fulfilling the above criteria are demanded,
*  in addition |eta_jet1 - eta_jet2| < 2.
*
* In data 112806 DIS events are selected of which 4957 are di-jet events.
* The dijet fractions have been corrected to the hadron level in the phase
* space region given by the cuts under event selection above. They are
* given in bins of Q2 (5 < Q2 < 100 GeV2), integrated over x, and in bins
* of x (0.0001 < x < 0.01), integrated over Q2.
*
* Statistical and systematic errors are included. Not included is an overall
* systematic error of +10% and -8% for the symmetric and +11% and -8% for
* the asymmetric and the sum scenario, arising from the uncertainty of the
* hadronic energy scale of the calorimeter and the uncertainty of the rad.
* QED corrections.
*
* Running:
*
*  Beams: e+ at 27.5 GeV, and p at 820 GeV
*
*  In generating events, besides applying the cuts under event selection
*  above, the ranges in Q2 and x should not have stricter limits than:
*  5 < Q2 < 120 GeV2  and  0.00009 < x < 0.023.
*
* Arguments: iflag=1 initialisation
*            iflag=1 filling
*            iflag=3 termination
*
* written by:
****************************************************************************
      IMPLICIT NONE
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      Integer kind(32)
      Integer numjet
      Parameter (numjet=50)
      Double precision pj(numjet,8)
      Double precision pbeam(4),pgam(4),pcm(4),ph(5),plab(5,NMXHEP)
*
      Integer i,iflag,ihep
      Character*5 xxxx
*
      Real pi,rd,eb,ee
      Parameter (ee=27.5)
      Integer iel,idum,ibeam
      Parameter (pi=3.1415927,rd=180./pi)
      Integer nentry
      Real x,y,q2,enel,thel,th
      Real ptjcut,ptj,ptj1,ptj2,pt2r,thj,deta,thj1,thj2
      Parameter (ptjcut=5.)
      Integer nj,ij,j,nsel
*
      Integer ierr
      Integer maxhi,modjet,maxjet
      Parameter (maxhi=100,modjet=2,maxjet=30)
      Integer ipjet(maxjet),l,k
      Real xw
      Double precision rcone
      Parameter (rcone=1.)
      Logical lp,twojet
      Data lp/.false./
*
* symmetric scenario (5/5 GeV)
*
      Integer nbin
      Parameter (nbin=6)
      Real r2x(nbin),str2x(nbin),sypr2x(nbin),symr2x(nbin),
     &     totpr2x(nbin),totmr2x(nbin),rx(nbin+1)
      Real r2q(nbin),str2q(nbin),sypr2q(nbin),symr2q(nbin),
     &     totpr2q(nbin),totmr2q(nbin),rq2(nbin+1)
      Real nq2(nbin)
*
      Data r2x   / 0.0463, 0.0457, 0.0471, 0.0489, 0.0533, 0.0686/
*     stat. error
      Data str2x / 0.0030, 0.0022, 0.0018, 0.0016, 0.0025, 0.0045/
*     syst. plus error
      Data sypr2x/ 0.0057, 0.0038, 0.0025, 0.0053, 0.0033, 0.0156/
*     syst. minus error
      Data symr2x/-0.0040,-0.0047,-0.0052,-0.0039,-0.0042,-0.0113/
*     bins in x
      Data rx/0.0001,0.00025,0.0005,0.001,0.0025,0.005,0.01/
**
      Data r2q   / 0.0403, 0.0382, 0.0463, 0.0501, 0.0666, 0.0926/
*     stat. error
      Data str2q / 0.0020, 0.0018, 0.0021, 0.0021, 0.0026, 0.0040/
*     syst. plus error
      Data sypr2q/ 0.0049, 0.0032, 0.0029, 0.0058, 0.0061, 0.0063/
*     syst. minus error
      Data symr2q/-0.0038,-0.0024,-0.0020,-0.0058,-0.0035,-0.0097/
*     bins in Q2
      Data  rq2/5.0,11.0,15.0,20.0,30.0,50.0,100.0/
*
* asymmetric or difference scenario (5/7 GeV)
*
      Real r2xd(nbin),str2xd(nbin),sypr2xd(nbin),symr2xd(nbin),
     &     totpr2xd(nbin),totmr2xd(nbin)
      Real r2qd(nbin),str2qd(nbin),sypr2qd(nbin),symr2qd(nbin),
     &     totpr2qd(nbin),totmr2qd(nbin)
*
      Data r2xd   / 0.0309, 0.0272, 0.0278, 0.0304, 0.0329, 0.0436/
*     stat. error
      Data str2xd / 0.0023, 0.0015, 0.0013, 0.0012, 0.0018, 0.0034/
*     syst. plus error
      Data sypr2xd/ 0.0022, 0.0017, 0.0023, 0.0019, 0.0023, 0.0150/
*     syst. minus error
      Data symr2xd/-0.0024,-0.0014,-0.0028,-0.0024,-0.0018,-0.0069/
**
      Data r2qd   / 0.0237, 0.0214, 0.0280, 0.0285, 0.0427, 0.0632/
*     stat. error
      Data str2qd / 0.0014, 0.0012, 0.0015, 0.0014, 0.0020, 0.0031/
*     syst. plus error
      Data sypr2qd/ 0.0044, 0.0012, 0.0028, 0.0020, 0.0031, 0.0031/
*     syst. minus error
      Data symr2qd/-0.0030,-0.0007,-0.0012,-0.0015,-0.0022,-0.0042/
*
* sum scenario (13 GeV)
*
      Real r2xs(nbin),str2xs(nbin),sypr2xs(nbin),symr2xs(nbin),
     &     totpr2xs(nbin),totmr2xs(nbin)
      Real r2qs(nbin),str2qs(nbin),sypr2qs(nbin),symr2qs(nbin),
     &     totpr2qs(nbin),totmr2qs(nbin)
*
      Data r2xs   / 0.0293, 0.0266, 0.0274, 0.0304, 0.0334, 0.0447/
*     stat. error
      Data str2xs / 0.0023, 0.0015, 0.0013, 0.0012, 0.0019, 0.0035/
*     syst. plus error
      Data sypr2xs/ 0.0014, 0.0020, 0.0017, 0.0023, 0.0019, 0.0104/
*     syst. minus error
      Data symr2xs/-0.0027,-0.0014,-0.0017,-0.0028,-0.0021,-0.0059/
**
      Data r2qs   / 0.0225, 0.0208, 0.0280, 0.0296, 0.0417, 0.0635/
*     stat. error
      Data str2qs / 0.0014, 0.0012, 0.0015, 0.0015, 0.0020, 0.0031/
*     syst. plus error
      Data sypr2qs/ 0.0029, 0.0022, 0.0023, 0.0013, 0.0025, 0.0029/
*     syst. minus error
      Data symr2qs/-0.0018,-0.0008,-0.0015,-0.0023,-0.0051,-0.0033/
*
*********************************************************************
*
*********************************************************************
      Integer nx
      Real n2,nall,nall2,n2d,n2s
      Real xmin,xmax
      save xxxx,nall,n2,nentry
      Data xxxx/'98076'/,NENTRY/0/
*********************************************************************
*
*                      Initialization
*
*********************************************************************
      NENTRY=NENTRY+1
*
      IF (iflag.eq.1) then
*
       nall=0.
       nall2=0.
       n2=0.
       n2d=0.
       n2s=0.
*
*
* Initialisation: The following MUST always be done
* (i) make subdirectory in PAWC
* - use the name as the xxxxxx in HZxxxxxx subroutine
* (i) make subdirectory in o/p file
*
        Call hcdir('//PAWC',' ')
        call hmdir(xxxx,'S')
        Call hcdir('//HISTO',' ')
        call hmdir(xxxx,'S')
*
* book histos
*
       call hbookb(120,' dR2/dx (symm. 5/5 GeV)       ',nbin, rx,0.)
       call hbookb(121,' all x        ',nbin, rx,0.)
       call hbookb(130,' dR2/dQ2 (symm. 5/5 GeV)      ',nbin, rq2,0.)
       call hbookb(131,' all Q2       ',nbin, rq2,0.)
       call hbook1(150,'  TH jet1      ',30,0.,180.,0.)
       call hbook1(151,'  TH jet2      ',30,0.,180.,0.)
       call hbook1(152,'  Pt jet1      ',30,0.,30.,0.)
       call hbook1(153,'  Pt jet2      ',30,0.,30.,0.)
*
       call hbookb(220,' dR2/dx (asymm. 5/7 GeV)      ',nbin, rx,0.)
       call hbookb(230,' dR2/dQ2 (asymm. 5/5 GeV)     ',nbin, rq2,0.)
*
       call hbookb(320,' dR2/dx (sum. 13 GeV)         ',nbin, rx,0.)
       call hbookb(330,' dR2/dQ2 (sum 13 GeV)         ',nbin, rq2,0.)
*
       call hbookb(-120,'  dR2/dx       ',nbin, rx,0.)
       call hbookb(-121,'  dR2/dx       ',nbin, rx,0.)
       call hbookb(-122,'  dR2/dx       ',nbin, rx,0.)
*
       call hbookb(-130,'  dR2/dQ2      ',nbin,rq2,0.)
       call hbookb(-131,'  dR2/dQ2      ',nbin,rq2,0.)
       call hbookb(-132,'  dR2/dQ2      ',nbin,rq2,0.)
*
       call hbookb(-220,'  dR2/dx       ',nbin, rx,0.)
       call hbookb(-221,'  dR2/dx       ',nbin, rx,0.)
       call hbookb(-222,'  dR2/dx       ',nbin, rx,0.)
       call hbookb(-230,'  dR2/dQ2      ',nbin,rq2,0.)
       call hbookb(-231,'  dR2/dQ2      ',nbin,rq2,0.)
       call hbookb(-232,'  dR2/dQ2      ',nbin,rq2,0.)
*
       call hbookb(-320,'  dR2/dx       ',nbin, rx,0.)
       call hbookb(-321,'  dR2/dx       ',nbin, rx,0.)
       call hbookb(-322,'  dR2/dx       ',nbin, rx,0.)
       call hbookb(-330,'  dR2/dQ2      ',nbin,rq2,0.)
       call hbookb(-331,'  dR2/dQ2      ',nbin,rq2,0.)
       call hbookb(-332,'  dR2/dQ2      ',nbin,rq2,0.)
*
*
* pack data into histograms
* pack data et/deta in the 9 bins into histograms
*
         Do i=1,nbin
          totpr2x(i) =sqrt(str2x(i)**2 +sypr2x(i)**2)
          totmr2x(i) =sqrt(str2x(i)**2 +symr2x(i)**2)
          totpr2xd(i)=sqrt(str2xd(i)**2+sypr2xd(i)**2)
          totmr2xd(i)=sqrt(str2xd(i)**2+symr2xd(i)**2)
          totpr2xs(i)=sqrt(str2xs(i)**2+sypr2xs(i)**2)
          totmr2xs(i)=sqrt(str2xs(i)**2+symr2xs(i)**2)
          totpr2q(i) =sqrt(str2q(i)**2 +sypr2q(i)**2)
          totmr2q(i) =sqrt(str2q(i)**2 +symr2q(i)**2)
          totpr2qd(i)=sqrt(str2qd(i)**2+sypr2qd(i)**2)
          totmr2qd(i)=sqrt(str2qd(i)**2+symr2qd(i)**2)
          totpr2qs(i)=sqrt(str2qs(i)**2+sypr2qs(i)**2)
          totmr2qs(i)=sqrt(str2qs(i)**2+symr2qs(i)**2)
         enddo
**
         Call hpak (-120,r2x)
         Call hpake(-120,totpr2x)
         Call hpak (-121,r2x)
         Call hpake(-121,totmr2x)
         Call hpak (-122,r2x)
         Call hpake(-122,str2x)
*
         Call hpak (-130,r2q)
         Call hpake(-130,totpr2q)
         Call hpak (-131,r2q)
         Call hpake(-131,totmr2q)
         Call hpak (-132,r2q)
         Call hpake(-132,str2q)
**
         Call hpak (-220,r2xd)
         Call hpake(-220,totpr2xd)
         Call hpak (-221,r2xd)
         Call hpake(-221,totmr2xd)
         Call hpak (-222,r2xd)
         Call hpake(-222,str2xd)
*
         Call hpak (-230,r2qd)
         Call hpake(-230,totpr2qd)
         Call hpak (-231,r2qd)
         Call hpake(-231,totmr2qd)
         Call hpak (-232,r2qd)
         Call hpake(-232,str2qd)
**
         Call hpak (-320,r2xs)
         Call hpake(-320,totpr2xs)
         Call hpak (-321,r2xs)
         Call hpake(-321,totmr2xs)
         Call hpak (-322,r2xs)
         Call hpake(-322,str2xs)
*
         Call hpak (-330,r2qs)
         Call hpake(-330,totpr2qs)
         Call hpak (-331,r2qs)
         Call hpake(-331,totmr2qs)
         Call hpak (-332,r2qs)
         Call hpake(-332,str2qs)
*
*********************************************************************
*
*                      Event Processing
*
*********************************************************************
      Else if(iflag.eq.2) then
*
* Filling: The following MUST always be done
* (i) move to the correct sub-directory in PAWC
*
       call hcdir('//PAWC/'//xxxx,' ')
*
       xw=wtx
       if (xsec.gt.0) then
        nall=nall+xw
C        write(6,*) xsec,' wtx= ',wtx,' nall= ',nall
       endif
*
       ierr=HZIBEAM(ibeam,idum)
       if (.not.(ierr.eq.1)) then
        write(6,*) 'HZ'//xxxx,' beams not found ! '
        return
       else
        Do i=1,4
         pbeam(i)=PHEP(i,IBEAM)
        enddo
       endif
*
       eb=real(PHEP(4,idum))
       if (abs(abs(eb)-ee).gt.0.2) then
        if (nentry.lt.10) then
         write(6,*) 'HZ'//xxxx,' Electron not at ',ee,' ! ',eb
        elseif (nentry.eq.10) then
         write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &   ' ...last message ! '
        endif
        return
       endif
*
* Event selection
*
       q2=real(HZDISKIN(1))
       x =real(HZDISKIN(2))
       y =real(HZDISKIN(3))
*
       if (lp) then
        write(*,*) 'Hz'//xxxx,' x y q2=',x,y,q2
       endif
*
* get electron variables for kinematic selection
*
       iel=HZIDELEC(idum)
       if (iel.eq.-1) then
         write(*,*) 'Hz'//xxxx,' electron not found '
         return
       endif
       enel=real(PHEP(4,iel))
       thel=real(HZPHMANG(PHEP(3,iel),
     $      sqrt(PHEP(1,iel)**2+PHEP(2,iel)**2)))*rd
*
       if (lp) then
        write(6,*) 'Hz'//xxxx,' enel= ',enel,' thel= ',thel
        write(6,*) 'Hz'//xxxx,' y= ',y,' q2= ',q2
       endif
*
       twojet=.true.
       if (y.lt.0.05) then
         twojet=.false.
       elseif (enel.lt.11.0) then
         twojet=.false.
       elseif (thel.lt.156.0) then
         twojet=.false.
       elseif (thel.gt.173.0) then
        twojet=.false.
       endif
*
* find jets
*
       if (twojet) then
*
        if (xsec.gt.0.) then
         nall2=nall2+xw
*
         call hfill(121,x,0.,xw)
         call hfill(131,q2,0.,xw)
*
        endif
*
        ierr=HZIPGAM(ph)
        if (ierr.eq.-1) then
         write(6,*) 'HZ'//xxxx,' boson vector not found ! '
C         call VZERO(ph,5)
         do i=1,5
          ph(i)=0.
         enddo
        else
         Do i=1,4
          pgam(i)=ph(i)
         enddo
        endif
*
        call HZHCMINI(pbeam,pgam,ierr)
        if (ierr.eq.1) then
         write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
         return
        endif
*
*       loop and boost
*
        do 5 ihep=1,nhep
         Do i=1,4
          ph(i)=PHEP(i,ihep)
          plab(i,ihep)=PHEP(i,ihep)
         enddo
*
         call HZHCM(ph,pcm,ierr)
         if (ierr.eq.1) then
          write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
          return
         endif
*
         if (isthep(ihep).eq.1) then
          th=real(HZPHMANG(PHEP(3,ihep),
     $       sqrt(PHEP(1,ihep)**2+PHEP(2,ihep)**2)))*rd
         endif
*
         Do i=1,4
          PHEP(i,ihep)=Pcm(i)
         enddo
*
  5     continue
*
*       find the jets
*
        call hzjtfind(modjet,rcone,nj,pj)
        if (nj.gt.numjet) then
         write(6,*) 'hz',xxxx,' too many jets found ! '
         return
        endif
*
        nsel=0
*
        do ij=1,nj
*
         if (lp) write(6,'(a,4f9.3)')
     &   ' Jet= ',(real(pj(ij,i)),i=4,7)
*
         ptj=real(pj(ij,3))
*
* pt > 5 GeV deta<2
*
         if (ptj.gt.ptjcut) then
          nsel = nsel + 1
          ipjet(nsel)=ij
         endif
        enddo
*
        if (nsel.eq.2) then
         if (lp) write(6,*) nsel,' jet analysis: jets found ! '
*
         deta=abs(pj(ipjet(1),1)-pj(ipjet(2),1))
*
         if (deta.lt.2.) then
          n2=n2+xw
          if (xsec.eq.0) then
           xsec=2
          endif
          call hfill(120,x,0.,xw)
          call hfill(130,q2,0.,xw)
          thj=real(HZPHMANG(pj(ipjet(1),7),pj(ipjet(1),3)) )*rd
          thj1=thj
          call hfill(150,thj1,0.,xw)
          thj2=real(HZPHMANG(pj(ipjet(2),7),pj(ipjet(2),3)) )*rd
          call hfill(151,thj2,0.,xw)
          call hfill(152,real(pj(ipjet(1),3)),0.,xw)
          call hfill(153,real(pj(ipjet(2),3)),0.,xw)
*
          ptj1=real(pj(ipjet(1),3))
          ptj2=real(pj(ipjet(2),3))
          if (ptj1.gt.ptjcut+2.) then
           n2d=n2d+xw
           call hfill(220,x,0.,xw)
           call hfill(230,q2,0.,xw)
          endif
          if (ptj1+ptj2.gt.13.) then
           n2s=n2s+xw
           call hfill(320,x,0.,xw)
           call hfill(330,q2,0.,xw)
          endif
         endif
        endif
*
        do ihep=1,nhep
         Do i=1,4
          PHEP(i,ihep)= plab(i,ihep)
         enddo
        enddo
*
       endif
*********************************************************************
*
*                      Termination
*
*********************************************************************

      Else if(iflag.eq.3) then

* Termination: The following MUST always be done
* (i) Move to the correct PAW subdirectory
*
       call hcdir('//PAWC/'//xxxx,' ')
*
        write(6,*) 'hz',xxxx,' Total Cross= ',
     &  real(xsec),' nall= ',nall
*
*      normalize the histos
*
        write(6,*) 'hz',xxxx,nall2,' out of which: 2+1 jets= ',n2
*
        call hopera(120,'/E',121,120,1.,1.)
        call hzhinfo(120,n2)
        call hzchisq(-120,120)
        call hopera(130,'/E',131,130,1.,1.)
        call hzhinfo(130,n2)
        call hzchisq(-130,130)
*
        call hopera(220,'/E',121,220,1.,1.)
        call hzhinfo(220,n2d)
        call hzchisq(-220,220)
        call hopera(230,'/E',131,230,1.,1.)
        call hzhinfo(230,n2d)
        call hzchisq(-230,230)
*
        call hopera(320,'/E',121,320,1.,1.)
        call hzhinfo(320,n2s)
        call hzchisq(-320,320)
        call hopera(330,'/E',131,330,1.,1.)
        call hzhinfo(330,n2s)
        call hzchisq(-330,330)
*
        if (nall2.ne.0.) then
         do i=0,3
          call hopera(150+i,'+E',150+i,150+i,1./nall2,0.)
          call hzhinfo(150+i,nall2)
         enddo
*
        endif
*
      endif
*
      RETURN
      END
*CMZ :  1.02/05 18/01/99  11.15.56  by  Tancredi Carli
*CMZ :  1.01/15 02/09/98  16.04.36  by  Tancredi Carli
*CMZ :  1.01/05 29/01/97  14.27.55  by  Tancredi Carli
*CMZ :  1.01/03 15/05/96  18.54.11  by  Tancredi Carli
*CMZ :  1.01/02 09/04/96  19.08.20  by  Tancredi Carli
*-- Author :    Tancredi Carli   08/04/96
	Subroutine HZ98087(iflag)
*****************************************************************************
* Running (1994/95): Ee=27.6GeV, Ep=820GeV, no polarization
*
* Produce (2+1) jet rates vs Q2, Jet profiles etc.
*
*      produced histogramms for data:
*               -4: 2+1 jet rates in 4 bins, stat. errors included
*                   40GeV^2<Q^2<4000GeV^2
*             -104: as above, sys. errors also included
*             -204: data on parton level assuming lepto6.5
*      generated histogramms:
*             cuts: W^2>5000GeV^2
*                   zp-cut: zp>0.1
*                   zp=E(jet(i))*(1-cos(th(jet(i))))/den
*                   den=SUM(j=1,2)[E(jet(j))*(1-cos(th(jet(j))))]
*             evcut1: 40<Q^2<100,en. of scattered e+ >14GeV,
*                                th. of scattered e+: 160<th<173
*             evcut2: Q^2>100,y<0.7,en. of scattered e+ >11GeV,
*                                   th. of scattered e+: 10<th<150
*                                   delta-cut:38<delta<70 [GeV]
*             calculated is the ratio of 2+1 jet events to total
*             ((1+1)+(2+1))jet events.
*             where +1 stands for the proton remnant jet.
*
*      histo-numbers:  1: 1+1 jet events are counted
*                      2: 2+1 events
*                      3: total
*                      4: ratio
*      other histos:  10: Dphi eflow forw.
*                     11: Dphi eflow back.
*                     12: Deta eflow forw.
*                     13: Deta eflow back.
*
*                     20: thjet,min
*                     21: thjet,max
*                     22: zp
*                     23: ptjet1 (transversal jet1 momentum)
*                     24: ptjet2 (transversal jet2 momentum)
*
* Arguments: iflag=1 initialisation
*            iflag=2 filling
*            iflag=3 termination
*
*
*  modified by: Reimer Selle (rselle@rec06.desy.de)
*  Corrected: T. Carli 18.1. routine contained preliminary data
*****************************************************************************
*
	IMPLICIT NONE
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*
*                                          subroutine-related var.
*                                          -----------------------

      Integer chjet,iflag,ihep
      DATA chjet/5/
      CHARACTER*6 jetf
      CHARACTER*5 xxxx
      Data xxxx/'98087'/
*
      Integer iel,idum,numjet
      Integer ijetb,ijetf
      Real nev
      Data nev/0./
      Real ee,eb
      Real thmax,thmin,thx,thn,th,et,nom,pom
      Real x,y,q2,w2,thel,enel,rd,pi,dpi
      Parameter (pi=3.1415927,rd=180./pi,dpi=2*pi,ee=27.6)
      Logical lp,evcut,evcut1,evcut2,dcut
      Data lp/.false./
      Real thj,thjet,cosjet,ptjet1,ptjet2
*
      Integer njet
      DOUBLE PRECISION Jets(50,8),coner
      Real qb(5),deta,dphi,eta,phi
      Data qb/40.,100.,300.,700.,4000./
*
      INTEGER i,j,k,ierr,ibeam
*                                            for zp-cut,delta-cut
      Real etmax,etmin,den,zpmax,zpmin,zp
      Real delta,wx
*
      Integer nentry
      Data nentry/0/
*
*********************************************************************
*
*                      data points from H1
*
*********************************************************************
*
*       Variable names:  - ra21: 2+1-jet rate
*                        - rae21: stat. error for ra21
*                        - ras21: stat. and sys errors
*                        - qb (see above): bins in Q^2
      Integer qbin
      Parameter (qbin=4)
*
      Real ra21(qbin), rae21(qbin),ras21(qbin)
      Real pra21(qbin), prae21(qbin),pras21(qbin)
      Data  ra21/33.0e-3,60.0e-3,72.0e-3,82.0e-3/
      Data rae21/4.0e-3,4.0e-3,5.0e-3,8.0e-3/
      Data ras21/8.0e-3,5.0e-3,5.0e-3,8.0e-3/
*
      Data pra21/47.0e-3,73.0e-3,91.0e-3,99.0e-3/
      Data prae21/6.0e-3,5.0e-3,6.0e-3,10.0e-3/
      Data pras21/9.0e-3,8.0e-3,10.0e-3,11.0e-3/
*
*********************************************************************
*
*                      Initialization
*
*********************************************************************

      NENTRY=NENTRY+1
*
      IF (iflag.eq.1) then
*
*
*      Initialisation: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (i) make subdirectory in o/p file
*
       Call hcdir('//PAWC',' ')
       call hmdir(xxxx,'S')
       Call hcdir('//HISTO',' ')
       call hmdir(xxxx,'S')
*
*                                         book and fill data histos
*
       call hbookb(  -4,'2+1 jet rate',4,qb,0.)
       call hbookb(-104,'2+1 jet rate',4,qb,0.)
       call hbookb(-204,'2+1 jet rate',4,qb,0.)
*
       call hpak (-4,ra21)
       call hpake(-4,rae21)
*                                         include sys. errors
       call hpak (-104,ra21)
       call hpake(-104,ras21)
*
       call hpak (-204,pra21)
       call hpake(-204,pras21)
*                                         book generator histos

       call hbookb(1,'sample 1+1',4,qb,0.)
       call  hcopy(1,2,'sample 2+1')
       call  hcopy(1,3,'total')
       call  hcopy(1,4,'Ratio')

       call hbook1(10,' Dphi eflow forw.',50,-pi,pi,0.)
       call hbook1(11,' Dphi eflow back.',50,-pi,pi,0.)
       call hbook1(12,' Deta eflow forw.',50,-3.,4.,0.)
       call hbook1(13,' Deta eflow back.',50,-3.,4.,0.)

*
       call hbook1(20,'thjet-min ',29,0.,145.,0.)
       call hbook1(21,'thjet-max ',29,0.,145.,0.)
       call hbook1(22,'  zp      ',10,0.,0.5,0.)
       call hbook1(23,' ptjet1    ',20,0.,50.,0.)
       call hbook1(24,' ptjet2    ',20,0.,50.,0.)
       call hbook1(25,' E-Pz      ',20,20.,70.,0.)

*
* print-out name of jet-algo used
*
      CALL HZJTNAME(chjet,jetf)
      WRITE(6,*) '**********************************************'
      WRITE(6,*) '* HZ',xxxx,' called                         *'
C      WRITE(6,*) '* Jet finder selected : ',jetf,'             *'
      WRITE(6,*) '**********************************************'
*



*********************************************************************
*
*                      Event Processing
*
*********************************************************************



      Else if(iflag.eq.2) then

*      Filling: The following MUST always be done
*      (i) move to the correct sub-directory in PAWC
*
       call hcdir('//PAWC/'//xxxx,' ')
*
*                                             Event selection
*
       wx=wtx
       q2=real(HZDISKIN(1))
       x =real(HZDISKIN(2))
       y =real(HZDISKIN(3))
       w2=real(HZDISKIN(4))
*
       if (lp) write(6,*) 'Hz'//xxxx,
     & ' x= ',x,' q2 ',q2,' y= ',y,' w2= ',w2
*
*                                             get electron variables
*
       iel=HZIDELEC(idum)
       if (iel.eq.-1) then
        write(6,*) 'Hz'//xxxx,' electron not found '
        goto 9990
       endif
       enel=real(PHEP(4,iel))
       thel=real(HZPHMANG(PHEP(3,iel),
     &               sqrt(PHEP(1,iel)**2+PHEP(2,iel)**2)))*rd
*
       if (lp) write(6,*) 'Hz'//xxxx,
     & ' enel= ',enel,' thel= ',thel
*
       if (lp) write(6,'(A,4f9.3)') 'elec: e,pz,py,pz= ',
     & phep(4,iel),phep(1,iel),phep(2,iel),phep(3,iel)
*
*                                             kinematic selection
*
       evcut=w2.gt. 5000.
       if(.not.evcut) goto 9990
*                                             cuts for sample 1
       evcut1=q2.gt.40. .and. q2.lt.100.
       evcut1=enel.gt.14..and.evcut1
       evcut1=thel.gt.160. .and. thel.lt.173. .and. evcut1

*                                             cuts for sample 2
       evcut2=q2.gt.100. .and. y.lt.0.7
       evcut2=enel.gt.11..and.evcut2
       evcut2=thel.gt.10. .and. thel.lt.150. .and. evcut2
*
       if (lp) then
        write(6,*) ' evcut1= ',evcut1,' evcut2= ',evcut2
       endif
*
*                                             additional zp-cut later on
*                                             delta-cut for evcut2 later
*                                      'pre-check' for generated events
*
       ierr=HZIBEAM(ibeam,idum)
       if (.not.(ierr.eq.1)) then
        write(6,*) 'HZ'//xxxx,' beams not found ! '
        goto 9990
       endif
*
       eb=real(PHEP(4,idum))
       if (abs(abs(eb)-ee).gt.0.2) then
          if (nentry.lt.10) then
           write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,'  ! ',eb
          elseif (nentry.eq.10) then
           write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &     ' ...last message ! '
          endif
        goto 9990
       endif
*                                                   delta-cut
       delta=0.
       Do 5 ihep=1,nhep
         if (isthep(ihep).ne.1) goto 5
         delta = (PHEP(4,ihep)-PHEP(3,ihep))+delta
 5     continue
*
       call hf1(25,delta,wx)
*
*
C       if (lp) write(6,*) ' delta= ',delta
*
       dcut= delta.gt.38..and.delta.lt.70.
       evcut2=evcut2.and.dcut

       if (.not.(evcut1.or.evcut2)) goto 9990

*	
       coner=0.02
       if (lp) then
        write(6,*) ' ..calling hzjtfind chjet= ',chjet,' ycut= ',coner
       endif
*
       if (lp) write(6,*) ' chjet= ',chjet
       CALL hzjtfind(chjet,CONER,NJET,Jets)
*
       thmin=999.
       thmax=-999.
       thn=999.
       thx=-999.
       etmax=0.
       etmin=0.
       zpmax=0.
       zpmin=0.
       den=0.
       zp=0.
       ptjet1=0.
       ptjet2=0.
*
       numjet=0
*                                         not more than 3 jets!
       if (njet.gt.3) goto 9990

*
       do i=1,njet
        if (lp) then
         write(6,'(a,4(x,f9.3),a,f9.3)') ' e,px,py,pz= ',
     &   (real(jets(i,j)),j=4,7),' M= ',
     &   real(jets(i,4)**2-(jets(i,5)**2+jets(i,6)**2+jets(i,7)**2))
        endif
*
        if (jets(i,4).ne.0.) then
C         thj=real(acos(jets(i,7)/jets(i,4)))
         den=jets(i,5)**2+jets(i,6)**2+jets(i,7)**2
         if (den.gt.0.) then
          thj=real(acos(jets(i,7)/sqrt(den)))
         else
          thj=0.
         endif
C        thj=real(HZPHMANG(JETS(i,7),
C     &               sqrt(JETS(i,5)**2+JETS(i,6)**2)))
        else
         thj=0.
        endif
*

        if (thj*rd.ge.10. .and. thj*rd.le.145.) then
         numjet=numjet+1
         if (thj*rd.gt.thmax) then
          thmax=thj*rd
          thx=thj
          etmax=real(jets(i,4))
C          zpmax=real(jets(i,4))-real(jets(i,7))
          zpmax=etmax*(1.-cos(thj))
          ijetf=i
         endif
         if (thj*rd.lt.thmin) then
          thmin=thj*rd
          thn=thj
          etmin=real(jets(i,4))
C          zpmin=real(jets(i,4))-real(jets(i,7))
          zpmin=etmin*(1.-cos(thj))
          ijetb=i
         endif
*
        endif
       enddo
*
C       zpmax= etmax*(1.-cos(thx))
C       zpmin= etmin*(1.-cos(thn))
*
       den=zpmax+zpmin
       if (den.ne.0.) then
        zpmax=zpmax/den
        zpmin=zpmin/den
       else
C        write(6,*) '***Hz',xxxx,' den= 0 !?!? ',thx*rd,thn*rd
        return
       endif
*
       if (zpmax.lt.zpmin) then
          zp=zpmax
       else
          zp=zpmin
       endif
*
       if (numjet.gt.2) goto 9990
*
       if (lp) then
        write(6,*) ' thmin= ',thmin,' thmax= ',thmax
        write(6,*) ' zp= ',zp,' zpx= ',zpmax,' zpi= ',zpmin,den
       endif
*
       if (zp.lt.0.1) goto 9990
*
       if (lp) then
        write(6,*) ' njet= ',njet,' numjet= ',numjet
       endif
*
       if (numjet.eq.1 ) then
        if (xsec.gt.0) then
        call hf1(1,q2,wx)
        endif
       elseif (numjet.eq.2 ) then
        nev=nev+wtx
C        write(6,*) ' wtx= ',wtx,' nev= ',nev
        call hf1(2,q2,wx)
*
        call hf1(20,thmin,wx)
        call hf1(21,thmax,wx)
        call hf1(22,zp,wx)
*
        ptjet1=real(sqrt(jets(1,5)**2+jets(1,6)**2))
        ptjet2=real(sqrt(jets(2,5)**2+jets(2,6)**2))
*
        call hf1(23,ptjet1,wx)
        call hf1(24,ptjet2,wx)
*
        if (lp) then
         write(6,*) ' thmin= ',thmin,' thmax= ',thmax
         write(6,*) ' zp= ',zp,' ptjet= ',ptjet1,ptjet2
         write(6,*) ' ijetf= ',ijetf,' ijetb= ',ijetb
        endif
*

        Do 10 ihep=1,nhep
         if (isthep(ihep).ne.1.or.ihep.eq.iel) goto 10
*
         th=real(HZPHMANG(PHEP(3,ihep),
     &              sqrt(PHEP(1,ihep)**2+PHEP(2,ihep)**2)))
         et=real(PHEP(4,ihep))*sin(th)
             if (abs(     th*rd).lt.1.e-4 .or.
     &          abs(180.-th*rd).lt.1.e-4 ) then
C               write(6,*) xxxx,' th = ',th
                goto 10

             else
                eta = -log(tan( th/2. ))
             endif

         phi=real(HZPHMANG(PHEP(1,ihep),PHEP(2,ihep)))
*
         deta=real(JETS(ijetb,1))-eta
         dphi=real(JETS(ijetb,2))-phi
*
         call hf1(13,deta,et*wx)
         call hf1(11,dphi,et*wx)
*
         deta=real(JETS(ijetf,1))-eta
         dphi=real(JETS(ijetf,2))-phi
         call hf1(12,deta,et*wx)
         call hf1(10,dphi,et*wx)
*
 10     continue
         endif

9990   continue
*
*********************************************************************
*
*                      Termination
*
*********************************************************************

      Else if(iflag.eq.3) then

*      Termination: The following MUST always be done
*      (i) Move to the correct PAW subdirectory
*
       call hcdir('//PAWC/'//xxxx,' ')

        write(*,*) '**hzth002: twojet=',nev
*                                              Normalization
       call HZHINRM(10,0,nev,1)
       call HZHINRM(11,0,nev,1)
       call HZHINRM(12,0,nev,1)
       call HZHINRM(13,0,nev,1)
*                                  N. for thmax,thmin,zp,ptjet1,2
       pom=nev
       if (pom.ne.0) then
        nom= 1/pom
       else
        nom=1.
       endif
*
       call hopera (20,'+E',20,20,nom,0.)
       call hopera (21,'+E',21,21,nom,0.)
       call hopera (22,'+E',22,22,nom,0.)
       call hopera (23,'+E',23,23,nom,0.)
       call hopera (24,'+E',24,24,nom,0.)
*
*                                  alternative norm for 22 in 220!
*                                  N. for 2+1 jet-ratio
        call hopera(1,'+',2,3,1.,1.)
        call hopera(2,'/E',3,4,1.,1.)
        call hzchisq(-4,4)
*
      ENDIF
*

      RETURN
      END
*CMZ :  1.02/06 10/03/99  08.19.12  by  Hannes Jung
*-- Author :
      subroutine HZ98092(IFLAG)
****************************************************************************
* Purpose: diffractive jets in DIS (DESY 98-092)
*
*
* Event selection:
*
* Running:
*
* Arguments: iflag=1 initialisation
*            iflag=1 filling
*            iflag=3 termination
*
* written by:
****************************************************************************
      IMPLICIT NONE
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
* common that gives the position of particles in X and Y system
      integer nxobj,nyobj,nxgag,nygag
      double precision pom
      common /diffhad/pom(5),nxobj(5000),nyobj(5000),nxgag,nygag


      Integer numjet
      Parameter (numjet=50)
      Double precision pj(numjet,8)
      Double precision pbeam(4),pgam(4),pcm(4),ph(5),plab(5,NMXHEP)
*
      Integer i,iflag,ihep
      Character*5 xxxx
*
      Real pi,rd,eb,ee
      Parameter (ee=27.5)
      Integer iel,idum,ibeam
      Parameter (pi=3.1415927,rd=180./pi)
      Integer nentry
      Real x,y,q2,enel,thel,efwd,th,lx,lxj
*
      Integer ierr
      Integer maxhi,modjet,maxjet
      Parameter (maxhi=2000,modjet=2,maxjet=30)
      Real  selj(maxjet,4),help,empz,empzh,xg,empzl,empzhl,xgl
      Integer ipjet(maxjet),l,k
      Real nev(maxhi),lum,xw,nev2(maxhi)
      Real deta,ptj2,thj
      Real xpom, x_pom,beta,xgluon,shat,p_sh(4),p_mx(4),mx2,mx
      Real xmas,ymas,t
      Real xgamma,eta1,eta2
      Real eppz,empzj,eppzj
      Real pj1,pj2,pr
      Integer njet,nj,nsel,ij,idhe,nhst,iy,ix
      Double precision rcone
      Parameter (rcone=1.)
      Logical lp,disjet,gamjet
      Data lp/.false./
*      Data lp/.true./
*********************************************************************
      Integer nx,iprot
      Real n2,n2g,nall,nall2,nall2g
      Real xmin,xmax
      save xxxx,nev,nall
      Data xxxx/'98092'/,NENTRY/0/
      integer nz
      parameter (nz=4)
      real dxzb(5),dxz(4),dsecz(4),derz(4),dsysz(4),dstaz(4)
      data dxzb/0.2,0.4,0.6,0.8,1.0/
      data dxz/   0.3,    0.5,    0.7,   0.9/
      data dsecz/117.,67.7,20.2,7.09/
      data derz/ 41.6  , 25.3   ,11.5   , 6.7  /
      data dsysz/26.6  , 13.0   ,5.3    , 2.33   /
      data dstaz/32.   , 21.7   ,10.2    ,6.3/
      integer npt
      parameter (npt=2)
      real dptb(3),dptx(2),dsecpt(2),derpt(2),dsyspt(2),dstapt(2)
      data dptb/5.0, 7.0, 10.0/
      data dptx/   6.0 ,  8.5/
      data dsecpt/43.3 ,  8.82/
      data derpt/ 11.8   ,2.53  /
      data dsyspt/10.    ,1.8  /
      data dstapt/6.2    ,1.78/
* now photo production
      integer gng
      parameter (gng=4)
      real gxgb(5),gxg(4),gsecxg(4),gerxg(4),gsysxg(4),gstaxg(4)
      data gxgb/0.2,0.4,0.6,0.8,1.0/
      data gxg/   0.3,    0.5,    0.7,   0.9/
      data gsecxg/415.3,688.1,1051.2,738.3/
      data gerxg/ 86.4,119.3,141.7,114.6 /
      data gstaxg/65.8,82.7,101.7,78.3/
      data gsysxg/56.0,86.0,98.7,83.7/
      integer gnz
      parameter (gnz=4)
      real gxzb(5),gxz(4),gsecz(4),gerz(4),gsysz(4),gstaz(4)
      data gxzb/0.2,0.4,0.6,0.8,1.0/
      data gxz/   0.3,    0.5,    0.7,   0.9/
      data gsecz/966.2,860.2,718.2,241.0/
      data gerz/ 215.97,152.1,115.3,50. /
      data gstaz/116.9,87.8,73.9,41.6/
      data gsysz/181.6,124.2,88.5,27.7 /
      integer gnpt
      parameter (gnpt=4)
      real gptb(5),gptx(4),gsecpt(4),gerpt(4),gsyspt(4),gstapt(4)
      data gptb/5.0, 7.0, 9.0,11.0,13.0/
      data gptx/   6.0 ,  8.0, 10.0, 12.0/
      data gsecpt/419.7,137.4,47.4,7.1/
      data gerpt/ 50.3,21.9,7.3,2.5 /
      data gstapt/21.4   ,11.7, 5.7, 2.1   /
      data gsyspt/ 45.5,18.5,4.5,1.4/
      integer gneta
      parameter (gneta=6)
      real getab(7),getax(6),gseceta(6),gereta(6),gsyseta(6),gstaeta(6)
      data getab/-1.,-0.5,0.0,0.5,1.0,1.5,2.0/
      data gseceta/577.1,674.3,576.1,345.8,175.9,114.1/
      data gereta/ 77.5,86.3,81.4,59.6,39.3,26.1 /
      data gstaeta/51.1,49.6,47.3,35.0,25.8,22.9/
      data gsyseta/57.8,70.6,66.3,48.2,29.7,12.6/

*********************************************************************
*
*                      Initialization
*
*********************************************************************
      NENTRY=NENTRY+1
*
      IF (iflag.eq.1) then
*
         nall=0.
         nall2=0.
         nall2g=0.
         n2=0.
         call Vzero(nev,maxhi)
         call Vzero(nev2,maxhi)
*
*
* Initialisation: The following MUST always be done
* (i) make subdirectory in PAWC
* - use the name as the xxxxxx in HZxxxxxx subroutine
* (i) make subdirectory in o/p file
*
         Call hcdir('//PAWC',' ')
         call hmdir(xxxx,'S')
         Call hcdir('//HISTO',' ')
         call hmdir(xxxx,'S')
*
* book histos
*
         nx=6
         xmin=0.05e-2
         xmax=0.35e-02
*
         call hbook1(221,'  y     ',100,0.,1.,0.)
         call hbook1(222,'  Q2     ',100,0.,100.,0.)
         call hbook1(223,'  xpom    ',100,0.,0.1,0.)
         call hbook1(224,'  M_x  0-20  ',100,0.,20.,0.)
         call hbook1(225,'  M_x  0-100  ',100,0.,100.,0.)
         call hbook1(226,'  z ',100,0.,1.,0.)
         call hbook1(227,'  pt ',100,0.,50.,0.)
         call hbook1(228,'  M_y  0-20  ',100,0.,20.,0.)
         call hbook1(229,'  M_y  0-100  ',100,0.,100.,0.)
         call hbookb(100,' DIS dsigma/dz  data      ',nz, dxzb,0.)
         call hbookb(120,' DIS dsigma/dpt data      ',npt,dptb,0.)

         call hbookb(-100,' DIS dsigma/dz  (err_tot)      ',nz, dxzb,0.)
         call hbookb(-101,' DIS dsigma/dz  (err_syst)     ',nz, dxzb,0.)
         call hbookb(-102,' DIS dsigma/dz  (err_stat)     ',nz, dxzb,0.)
         call hbookb(-120,' DIS dsigma/dpt (err_tot)      ',npt,dptb,0.)
         call hbookb(-121,' DIS dsigma/dpt (err_syst)     ',npt,dptb,0.)
         call hbookb(-122,' DIS dsigma/dpt (err_stat)     ',npt,dptb,0.)

         call hbookb(1000,'  dsigma/dz  mc      ',gnz, gxzb,0.)
         call hbookb(1020,'  dsigma/dpt mc      ',gnpt,gptb,0.)
         call hbookb(1030,'  dsigma/dxgamma mc      ',gng,gxgb,0.)
         call hbookb(1040,'  dsigma/deta mc      ',gneta,getab,0.)

         call hbookb(-1000,'  dsigma/dz  (err_tot)      ',gnz, gxzb,0.)
         call hbookb(-1001,'  dsigma/dz  (err_syst)     ',gnz, gxzb,0.)
         call hbookb(-1002,'  dsigma/dz  (err_stat)     ',gnz, gxzb,0.)
         call hbookb(-1020,'  dsigma/dpt (err_tot)      ',gnpt,gptb,0.)
         call hbookb(-1021,'  dsigma/dpt (err_syst)     ',gnpt,gptb,0.)
         call hbookb(-1022,'  dsigma/dpt (err_stat)     ',gnpt,gptb,0.)
         call hbookb(-1030,'  dsigma/dxgamma (err_tot)  ',gng, gxgb,0.)
         call hbookb(-1031,'  dsigma/dxgamma (err_syst) ',gng, gxgb,0.)
         call hbookb(-1032,'  dsigma/dxgamma (err_stat) ',gng, gxgb,0.)
         call hbookb(-1040,'  dsigma/deta (err_tot)   ',gneta,getab,0.)
         call hbookb(-1041,'  dsigma/deta (err_syst)  ',gneta,getab,0.)
         call hbookb(-1042,'  dsigma/deta (err_stat)  ',gneta,getab,0.)




*
* pack data into histograms
*
         Call hpak (-100,dsecz)
         Call hpake(-100,derz)
         Call hpak (-101,dsecz)
         Call hpake(-101,dsysz)
         Call hpak (-102,dsecz)
         Call hpake(-102,dstaz)
         Call hpak (-120,dsecpt)
         Call hpake(-120,derpt)
         Call hpak (-121,dsecpt)
         Call hpake(-121,dsyspt)
         Call hpak (-122,dsecpt)
         Call hpake(-122,dstapt)
* photoproduction data
         Call hpak (-1000,gsecz)
         Call hpake(-1000,gerz)
         Call hpak (-1001,gsecz)
         Call hpake(-1001,gsysz)
         Call hpak (-1002,gsecz)
         Call hpake(-1002,gstaz)
         Call hpak (-1020,gsecpt)
         Call hpake(-1020,gerpt)
         Call hpak (-1021,gsecpt)
         Call hpake(-1021,gsyspt)
         Call hpak (-1022,gsecpt)
         Call hpake(-1022,gstapt)
         Call hpak (-1030,gsecxg)
         Call hpake(-1030,gerxg)
         Call hpak (-1031,gsecxg)
         Call hpake(-1031,gsysxg)
         Call hpak (-1032,gsecxg)
         Call hpake(-1032,gstaxg)
         Call hpak (-1040,gseceta)
         Call hpake(-1040,gereta)
         Call hpak (-1041,gseceta)
         Call hpake(-1041,gsyseta)
         Call hpak (-1042,gseceta)
         Call hpake(-1042,gstaeta)
         write(6,*) 'HZ'//xxxx
*
*********************************************************************
*
*                      Event Processing
*
*********************************************************************
      Else if(iflag.eq.2) then
*
* Filling: The following MUST always be done
* (i) move to the correct sub-directory in PAWC
*
         call hcdir('//PAWC/'//xxxx,' ')
*
         xw=1.
         nall=nall+xw
*
         ierr=HZIBEAM(ibeam,idum)
         if (.not.(ierr.eq.1)) then
            write(6,*) 'HZ'//xxxx,' beams not found ! '
            return
         else
            Do i=1,4
               pbeam(i)=PHEP(i,IBEAM)
            enddo
         endif
*
         eb=real(PHEP(4,idum))
         if (abs(abs(eb)-ee).gt.0.1) then
            if (nentry.lt.10) then
               write(6,*) 'HZ'//xxxx,' Electron not at ',ee,' ! ',eb
            elseif (nentry.eq.10) then
               write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     +         ' ...last message ! '
            endif
            return
         endif
         ierr=HZIPGAM(ph)
         if (ierr.eq.-1) then
            write(6,*) 'HZ'//xxxx,' boson vector not found ! '
C         call VZERO(ph,5)
          Do i=1,5
           ph(i)=0.
          enddo
         else
            Do i=1,4
               pgam(i)=ph(i)
            enddo
         endif
*
* Event selection
*
         q2=abs(HZDISKIN(1))
         if(q2.gt.1) then
            x =real(HZDISKIN(2))
            y =real(HZDISKIN(3))
         else
            q2=abs(hzphokin(1))
            y=hzphokin(3)
         endif

c         write(6,*) ' q2 calc ',q2,abs(HZDISKIN(1)),abs(hzphokin(1))


         deta = -999.
         njet = 0
*
         if (lp) then
            write(*,*) 'Hz'//xxxx,' x y q2=',x,y,q2
         endif
*
* get electron variables for kinematic selection
*
         iel=HZIDELEC(idum)
         if (iel.eq.-1) then
            write(*,*) 'Hz'//xxxx,' electron not found '
            return
         endif
         enel=real(PHEP(4,iel))
         thel=real(HZPHMANG(PHEP(3,iel), sqrt(PHEP(1,iel)**2+PHEP(2,
     +   iel)**2)))*rd
*
*
*  do diffractive selection
         x_pom=1.
         xpom=999.
         do i=1,4
            p_mx(i)=0.
         enddo
         Do 10   ihep=1,nhep
* do not count scattered electron
            if(ihep.eq.iel) goto 10
            idhe=idhep(ihep)
*  proton tag

            if ( abs(idhe).eq.2212.and.jmohep(1,ihep).eq.2 ) then
               iprot = ihep
            endif
   10    continue
         call hzhadgap(xmas,ymas,xpom,t)
         do i=1,5
            pbeam(i)=pom(i)
         enddo
         mx2=xmas**2
         if( xpom.le.x_pom) x_pom=xpom
         if (lp) then
            write(6,*) 'Hz'//xxxx,' enel= ',enel,' thel= ',thel
            write(6,*) 'Hz'//xxxx,' y= ',y,' q2= ',q2
            write(6,*) 'Hz'//xxxx,' x_pom= ',x_pom,' m_x ',sqrt(mx2)
         endif
         if(x_pom.lt.x) then
            if(lp) then
               write(6,*) 'Hz'//xxxx,' x < x_pom = '
               write(6,*) 'Hz'//xxxx,' x = ',x,' x_pom = ',xpom,' t = '
     +         ,t
               write(6,*) 'Hz'//xxxx,' xmas = ',xmas,' ymas = ',ymas
               write(6,*) 'Hz'//xxxx,' q2 = ',q2,' y = ',y
               write(6,*) 'Hz'//xxxx,' nxgag,nygag ',nxgag,nygag
               write(6,*) 'Hz'//xxxx,' nxobj ',(nxobj(i),i=1,nxgag)
               write(6,*) 'Hz'//xxxx,' nyobj ',(nyobj(i),i=1,nygag)
            endif
            return
         endif
* twojet diffractive cuts for DIS
*   0.005 < xpom < 0.05
*   7.5 < Q^2 < 80 GeV^2
*   0.1 < y < 0.7
*   |t| < 1.0 GeV^2
*   M_Y < 1.6 GeV

         disjet=.true.
         gamjet=.true.
         if (y.lt.0.1) disjet=.false.
         if (y.gt.0.7) disjet=.false.
         if (q2.lt.7.5) disjet=.false.
         if (q2.gt.80.) disjet=.false.
         if (x_pom.gt.0.05) disjet=.false.
         if (x_pom.lt.0.005) disjet=.false.
         if (ymas.gt.1.6) disjet=.false.
         if (abs(t).gt.1.0) disjet=.false.

* twojet diffractive cuts photoproduction
*   xpom < 0.05
*   0 < Q^2 < 0.01 GeV^2
*   0.25 < y < 0.7
*   |t| < 1.0 GeV^2
*   M_Y < 1.6 GeV

         if (y.lt.0.25) gamjet=.false.
         if (y.gt.0.7) gamjet=.false.
         if (q2.gt.0.01) gamjet=.false.
         if (x_pom.gt.0.05) gamjet=.false.
         if (ymas.gt.1.6) gamjet=.false.
         if (abs(t).gt.1.0) gamjet=.false.

c         write(6,*) 'hz98092 disjet,gamjet ',disjet,gamjet

*
* find jets
         if (disjet) then
*
            nall2=nall2+xw

*
c fill all global histos
            call hfill(221,y,0.,xw)
            call hfill(222,q2,0.,xw)
            call hfill(223,x_pom,0.,xw)
            call hfill(224,xmas,0.,xw)
            call hfill(225,xmas,0.,xw)
            call hfill(228,ymas,0.,xw)
            call hfill(229,ymas,0.,xw)

            ierr=HZIPGAM(ph)
            if (ierr.eq.-1) then
               write(6,*) 'HZ'//xxxx,' boson vector not found ! '
C              call VZERO(ph,5)
               Do i=1,5
                ph(i)=0.
               enddo
            else
               Do i=1,4
                  pgam(i)=ph(i)
               enddo
            endif
*
            call HZHCMINI(pbeam,pgam,ierr)
            if (ierr.eq.1) then
               write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
               return
            endif
*
*       loop and boost
*
            empzh=0.
            empzhl=0.
            nhst = 1
            do 20 ihep=nhst,nhep
               Do i=1,4
                  Ph(i)=PHEP(i,ihep)
                  Plab(i,ihep)=PHEP(i,ihep)
                  phep(i,ihep)=0.0
               enddo
*
* do not count scattered electron
               if(ihep.eq.iel) goto 20
* do not count particles assigned to Y system
               do iy=1,nygag
                  if(ihep.eq.nyobj(iy)) goto 20
               enddo
               call HZHCM(ph,pcm,ierr)
               if (ierr.eq.1) then
                  write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
                  return
               endif
*
               if (isthep(ihep).ne.1.or.ihep.eq.iel) then
                  th=real(HZPHMANG(PHEP(3,ihep), sqrt(PHEP(1,ihep)**2+
     +            PHEP(2,ihep)**2)))*rd
               endif
*
               Do i=1,4
                  PHEP(i,ihep)=Pcm(i)

               enddo
               if (isthep(ihep).ne.1.or.ihep.eq.iel) goto 20
               empzh=empzh+phep(4,ihep)+phep(3,ihep)
               if (th.gt.3.3.and.th.lt.176.) then
                  empzhl=empzhl+phep(4,ihep)+phep(3,ihep)
               endif

*
   20       continue
*
*       find the jets
*
            call hzjtfind(modjet,rcone,nj,pj)
            if (nj.gt.numjet) then
               write(6,*) 'Hz'//xxxx,' too many jets found ! '
               return
            endif
*
            nsel = 0
*
            do ij=1,nj
*
               ptj2=real(pj(ij,3))
*
*
* pt>5 GeV deta<2 qjcone
*
               if (ptj2.gt.5.) then
                  nsel = nsel + 1
                  ipjet(nsel)=ij
               endif
            enddo
*
            njet = nsel
            if (nsel.eq.2) then
               deta=abs(pj(ipjet(1),1)-pj(ipjet(2),1))
               if (lp) write(6,*) ' deta= ',deta,pj(ipjet(1),1),
     +         pj(ipjet(2),1)
*
* calculate shat and z_pom
               do i=1,4
                  p_sh(i)=pj(ipjet(1),3+i)+pj(ipjet(2),3+i)
               enddo
               shat=p_sh(1)**2 - p_sh(2)**2 - p_sh(3)**2 - p_sh(4)**2
               xgluon=(q2 + shat)/(q2 + mx2)
               if(lp) then
                  write(6,*) ' shat ',shat,mx2
                  write(6,*) ' z ',xgluon
               endif
               n2=n2+xw
c fill global histograms
               pj1=real(pj(ipjet(1),3))
               pj2=real(pj(ipjet(2),3))
               if(lp) then
                  write(6,*) ' pt_jets ',pj1,pj2
               endif
               call hfill(100,xgluon,0.,xw)
               call hfill(120,pj1,0.,xw)
               call hfill(120,pj2,0.,xw)
               call hfill(226,xgluon,0.,xw)
               call hfill(227,pj1,0.,xw)
               call hfill(227,pj2,0.,xw)
*
               empz=empz+pj(ipjet(2),4)+pj(ipjet(2),7)
               if (lp) write(6,*) ' Jet2: thj= ',thj,' EmPz= ', real(pj
     +         (ipjet(2),4)+pj(ipjet(2),7))
*
*
               if (empzh.ne.0.) then
                  xg=empz/empzh
               else
                  xg=-999.
               endif
*
               if (empzhl.ne.0.) then
                  xgl=empz/empzhl
               else
                  xgl=-999.
               endif


            endif
            do ihep=nhst,nhep
               Do i=1,4
                  PHEP(i,ihep)= Plab(i,ihep)
               enddo
            enddo
         endif

* here do the photoproduction stuff
         if (gamjet) then
*
            nall2g=nall2g+xw
c            write(6,*) ' gamjet ',nall2g,nall
            nhst = 1
* fill e+pz,e-pz from mx system
            eppz = 0.
            empz = 0.
            eppzj = 0.
            empzj = 0.
            do ix = 1,nxgag
               ihep = nxobj(ix)
               eppz = eppz + phep(4,ihep) - phep(3,ihep)
               empz = empz + phep(4,ihep) + phep(3,ihep)
            enddo
            do 30 ihep=nhst,nhep
               Do i=1,4
                  Ph(i)=PHEP(i,ihep)
                  Plab(i,ihep)=PHEP(i,ihep)
                  phep(i,ihep)=0.0
               enddo
*
* do not count scattered electron
               if(ihep.eq.iel) goto 30
* do not count particles assigned to Y system
               do iy=1,nygag
                  if(ihep.eq.nyobj(iy)) goto 30
               enddo
               Do i=1,4
                  PHEP(i,ihep)=Plab(i,ihep)
               enddo
   30       continue
*
*       find the jets
*
            call hzjtfind(modjet,rcone,nj,pj)
            if (nj.gt.numjet) then
               write(6,*) 'hz',xxxx,' too many jets found ! '
               return
            endif
            nsel = 0
*
            do ij=1,nj
*
               ptj2=real(pj(ij,3))
*
*
* pt>5 GeV deta<2 qjcone
*
               if (ptj2.gt.5.) then
                  nsel = nsel + 1
                  ipjet(nsel)=ij
               endif
            enddo
*
            njet = nsel
            if (nsel.eq.2) then
               deta=abs(pj(ipjet(1),1)-pj(ipjet(2),1))
*
* calculate shat and z_pom
               do i=1,4
                  p_sh(i)=pj(ipjet(1),3+i)+pj(ipjet(2),3+i)
               enddo
               n2g=n2g+xw
               pj1=real(pj(ipjet(1),3))
               pj2=real(pj(ipjet(2),3))
               empzj=pj(ipjet(1),4)+pj(ipjet(1),7) + pj(ipjet(2),4)+
     +         pj(ipjet(2),7)
               eppzj=pj(ipjet(1),4)-pj(ipjet(1),7) + pj(ipjet(2),4)-
     +         pj(ipjet(2),7)
*
*
               if (empz.ne.0.) then
                  xgluon=empzj/empz
               else
                  xgluon=-999.
               endif
               if (eppz.ne.0.) then
                  xgamma=eppzj/eppz
               else
                  xgamma=-999.
               endif
               eta1=real(pj(ipjet(1),1))
               eta2=real(pj(ipjet(2),1))
               if(eta1.gt.-1.0.and.eta1.lt.2.0.and.eta2.gt.-1.0.
     +         and.eta2.lt.2.0) then
                  call hfill(1000,xgluon,0.,xw)
                  call hfill(1020,pj1,0.,xw)
                  call hfill(1020,pj2,0.,xw)
                  call hfill(1030,xgamma,0.,xw)
                  call hfill(1040,eta1,0.,xw)
                  call hfill(1040,eta2,0.,xw)
               endif
            endif
            do ihep=nhst,nhep
               Do i=1,4
                  PHEP(i,ihep)= Plab(i,ihep)
               enddo
            enddo
         endif

*********************************************************************
*
*                      Termination
*
*********************************************************************

      Else if(iflag.eq.3) then

* Termination: The following MUST always be done
* (i) Move to the correct PAW subdirectory
*
         call hcdir('//PAWC/'//xxxx,' ')
*
         lum=999999999.
         if (xsec.ne.0.) then
            lum=real(nall)/real(xsec)
         else
            write(6,*) 'hz',xxxx,' xsec=0 ! '
         endif
*
         write(6,*) 'Hz'//xxxx,': Total Cross= ',
     +      real(xsec),' nall= ',nall
*
*
*      normalize the histos
*
         write(6,*) 'Hz'//xxxx,nall2,' out of which: DIS jets= ',n2
         write(6,*) 'Hz'//xxxx,nall2g,' out of which: gam-prod jets= ',
     +   n2g
         if(nall2.gt.1) then
*
* now do the cross section normalisation
            call hopera(100,'+E',100,100,1./lum,0.)
            call hzhinfo(100,nev(100))
            call hopera(120,'+E',120,120,1./lum,0.)
            call hzhinfo(120,nev(120))
* now normalise histo with 1/binwidth
            call hzhinrm( 100, 0, 1., 1 )
            call hzhinrm( 120, 0, 1., 1 )
         endif
         if(nall2g.gt.1) then
*
* now do the cross section normalisation
            call hopera(1000,'+E',1000,1000,1./lum,0.)
            call hzhinfo(1000,nev(1000))
            call hopera(1020,'+E',1020,1020,1./lum,0.)
            call hzhinfo(1020,nev(1020))
            call hopera(1030,'+E',1030,1030,1./lum,0.)
            call hzhinfo(1030,nev(1030))
            call hopera(1040,'+E',1040,1040,1./lum,0.)
            call hzhinfo(1040,nev(1040))
* now normalise histo with 1/binwidth
            call hzhinrm( 1000, 0, 1., 1 )
            call hzhinrm( 1020, 0, 1., 1 )
            call hzhinrm( 1030, 0, 1., 1 )
            call hzhinrm( 1040, 0, 1., 1 )
         endif
*

      endif
*
      RETURN
      END
*CMZ :  1.02/06 22/03/99  09.37.35  by  Hannes Jung
*CMZ :  1.02/00 06/10/98  23.41.03  by  Tancredi Carli
*-- Author :
      subroutine HZ98143(IFLAG)
****************************************************************************
* Purpose: histograms for the fwd jet analysis
*
* Event selection: y>0.1, 0.0001<x<0.004, E'>11, 160<Th_e<173 -> DIS
*                  Ej>28.7, PTj>3.5, 7<Th_j<20 -> Fwd Jets
*                  0.5<PTj**2/Q2<2      -> Mueller Jets
* jet algo used: CDF with ptmin=2
* Arguments: iflag=1 initialisation
*            iflag=2 filling
*            iflag=3 termination
*
* written by: G. Contreras/Th. Wengler/H. Jung
*
* Purpose: histograms for the fwd pi0 and
*          Charged Particle Analysis by H1
* Plots for fwd-part. paper
* For the fwd jets:
* histos for fwd jets
*  301 dsigma/dx  fwd jet (pt>3.5)
*  302 dsigma/dx  fwd jet (pt>5.0)
*  303 dsigma/dphi fwd jet, highx
*  304 dsigma/dphi fwd jet, lowx
* DATA H1
* -301 dsigma/dx  fwd jet (pt>3.5) (sta err)
* -1301 dsigma/dx  fwd jet (pt>3.5) (tot err)
* -302 dsigma/dx  fwd jet (pt>5.0) (sta err)
* -1302 dsigma/dx  fwd jet (pt>5.0) (tot err)
* -303 dsigma/dphi fwd jet, highx  (sta err)
* -1303 dsigma/dphi fwd jet, highx  (tot err)
* -304 dsigma/dphi fwd jet, lowx  (sta err)
* -1304 dsigma/dphi fwd jet, lowx  (tot err)
*
*
* For the pi0 analysis: 3 plots: 0.01 < x_pi < 0.015, Pt_pi0 > 1GeV
*                                0.015< x_pi < 0.15,  Pt_pi0 > 1GeV
*                                0.01 < x_pi < 0.15,  Pt_pi0 > 2GeV
*
* For the Carged Particles: 1 plot: 0.01 < x_pi < 0.015, Pt_pi0 > 1GeV
*
* Output Histograms:
*
*--------------------------------------------------------------------
* Histogram   Description
*--------------------------------------------------------------------
*                                              Data Histograms
*--------------------------------------------------------------------
* -201 1/N dn_pi/dx_bj, (pi0),0.01<x_pi<0.015, Pt_pi0>1GeV (sta err)
*-1201 1/N dn_pi/dx_bj, (pi0),0.01<x_pi<0.015, Pt_pi0>1GeV  (tot err)
* -202 1/N dn_pi/dx_bj, (pi0),0.015<x_p <0.15, Pt_pi >1GeV  (sta err)
*-1202 1/N dn_pi/dx_bj, (pi0),0.015<x_pi<0.15, Pt_pi0>1GeV  (tot err)
* -203 1/N dn_pi/dx_bj, (pi0),0.01<x_pi<0.15, Pt_pi0>2GeV  (sta err)
*-1203 1/N dn_pi/dx_bj, (pi0),0.01<x_pi<0.15, Pt_pi0>2GeV  (tot err)
* -204 1/N dn_pi/dx_bj, (pi-+pi+)/2,0.01<x_pi<0.015, Pt_pi0>1GeV (sta)
*-1204 1/N dn_pi/dx_bj, (pi-+pi+)/2,0.01<x_pi<0.015, Pt_pi0>1GeV (tot)
* -205 1/N dn_p/dx_bj, Ch. Part.,0.01<x_pi<0.015, Pt_pi0>1GeV  (sta)
*-1205 1/N dn_p/dx_bj, Ch. Part.,0.01<x_pi<0.015, Pt_pi0>1GeV (tot)
*--------------------------------------------------------------------
*                                              Monte Carlo Histograms
*--------------------------------------------------------------------
*  201   1/N dn_pi/dx_bj, (pi0), 0.01 < x_pi < 0.015, Pt_pi0>1GeV
*  202   1/N dn_pi/dx_bj, (pi0), 0.015< x_pi < 0.15,  Pt_pi0>1GeV
*  203   1/N dn_pi/dx_bj, (pi0), 0.01 < x_pi < 0.15,  Pt_pi0>2GeV
*  204   1/N dn_pi/dx_bj, (pi-+pi+)/2, 0.01<x_pi<0.015, Pt_pi0>1GeV
*  205   1/N dn_p/dx_bj, Char. Part., 0.01<x_pi<0.015, Pt_pi0>1GeV
****************************************************************************
      IMPLICIT NONE
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.

*
      Integer numjet
      Parameter (numjet=50)
      Double precision pj(numjet,8)
*
      Integer i,iflag
      Character*5 xxxx
      save xxxx
      Integer nentry
*      Data xxxx/'98143'/,NENTRY/0/
      Data xxxx/'98143'/,NENTRY/0/

      Real Npass
      Real ptpi,thpi,xpi
*
      Real pi,rd
      Integer iel,idum,ibeam
      Parameter (pi=3.1415927,rd=180./pi)
      Real x,y,q2
      Integer nj,ij
*
      Integer ierr
      Integer maxhi,modjet,maxjet
      Parameter (maxhi=100,modjet=2,maxjet=30)
      Real lumnb,lumpb
      Double precision rcone
      Parameter (rcone=1.d0)
***********************************
*
* Define bins for histograms
*
* bin in x
      real bx(7)
      data bx/0.0001,0.0005,0.001,0.0015,0.002,0.003,0.004/
* bin in Delta_phi
      real bdphi(7)
      data bdphi/0.0,30.,60.,90.,120.,150.,180./
* pi0 bins in x_bj
      real bxpi(6)
      data bxpi/0.0002,0.00052,0.00084,0.0012,0.00164,0.00236/
* pi+-/Charged part.  bins in x_bj
      real bxpm(6)
      data bxpm/0.0003,0.0006,0.0009,0.0013,0.0017,0.0025/
*
* Define Variables
*
* Nevt -> number of events
* Njet -> number of jets
* Nfwd -> number of FWD jets
* Nmue -> number of Mueller jets
      real Nevt, Njet, Nfwd, Nmue
      save Nevt, Njet, Nfwd, Nmue
* Ee -> electron energy
* The -> electron theta
* Phe -> electron phi
* Ej ->  jet energy
* Thj -> jet theta
* Phj -> jet phi
* Ptj -> jet pt
      real Ee, The, Phe, Ej, Thj, Phj, Ptj
      real deltaphi,pt2q2
*
* define cut parameters for fwd. jets
*
      real ylow, xlow, xmed, xhigh, eelow, thelow, thehigh
      real ejlow, ptjlow, thjlow, thjhigh, pt2q2low, pt2q2high
      parameter(ylow=0.1)
      parameter(xlow=0.0001)
      parameter(xmed=0.001)
      parameter(xhigh=0.004)
      parameter(eelow=11.)
      parameter(thelow=160.)
      parameter(thehigh=173.)
      parameter(ejlow=28.7)
      parameter(ptjlow=3.5)
      parameter(thjlow=7.)
      parameter(thjhigh=20.)
      parameter(pt2q2low=0.5)
      parameter(pt2q2high=2.)

* define cut parameters  for fwd pi
      real ypilow,xpilow,xpihigh,eepilow,thepilow,thepihigh
      parameter(ypilow=0.1)
      parameter(xpilow=0.0002)
      parameter(xpihigh=0.00236)
      parameter(eepilow=12.)
      parameter(thepilow=156.)
      parameter(thepihigh=173.)
      real xpi1lo,xpi1hi,xpi2lo,xpi2hi,xpi3lo,xpi3hi
      real ptpi3lo,ptpilow,thpilow,thpihigh
      parameter(xpi1lo=0.01)
      parameter(xpi2lo=0.015)
      parameter(xpi3lo=0.01)
      parameter(xpi1hi=0.015)
      parameter(xpi2hi=0.15)
      parameter(xpi3hi=0.15)
      parameter(ptpi3lo=2.0)
      parameter(ptpilow=1.0)
      parameter(thpilow=5.0)
      parameter(thpihigh=25.0)
      logical fjet,fpi
      data fjet/.true./,fpi/.true./
*
* define H1 data
*
* cross section vs x (data, stat error, tot error) pt>3.5
      real csx(6),csxse(6),csxte(6)
      data csx/81.,171.,112.,69.,67.,32./
      data csxse/12.,8.,6.,5.,5.,3./
      data csxte/17.,27.,17.,12.,12.,6./
* cross section vs x Pt>5
      real csx6(6),csx6se(6),csx6te(6)
      data csx6/11.,63.,66.,48.,55.,28./
      data csx6se/8.,5.,5.,4.,5.,3./
      data csx6te/9.,13.,10.,10.,10.,6.0/
* cross section vs Delta_phi high x
      real csph(6), csphse(6), csphte(6)
      data csph/28.,36.,43.,49.,60.,69./
      data csphse/3.,3.,4.,4.,4.,5./
      data csphte/5.,5.,7.,9.,9.,13./
* cross section vs Delta_phi low x
      real cspl(6), csplse(6), csplte(6)
      data cspl/36.,40.,45.,45.,42.,51./
      data csplse/5.,4.,7.,7.,7.,4./
      data csplte/7.,7.,9.,10.,10.,10./
**********************************************************************
* define H1 data for new cuts for fwd-part. paper**************
**********************************************************************
*
* pi0 data 1/N dn_pi/dx_bj for the four dif. lower cutoffs in xpi ----
      real pi0x11(5),pi0xse11(5),pi0xte11(5)
      real pi0x12(5),pi0xse12(5),pi0xte12(5)
      real pi0x13(5),pi0xse13(5),pi0xte13(5)
* data
      data pi0x11/18.62, 10.97, 9.41, 6.06, 2.98/
      data pi0x12/14.86,  7.44, 5.44, 2.84, 1.28/
      data pi0x13/10.81,  6.65, 5.23, 2.24, 1.04/
* stat. error
      data pi0xse11/2.13, 1.52, 1.48, 1.06, 0.56/
      data pi0xse12/2.07, 1.25, 0.92, 0.56, 0.26/
      data pi0xse13/1.71, 1.33, 1.06, 0.50, 0.23/
* total error
      data pi0xte11/4.67, 2.94, 3.73, 1.83, 0.80/
      data pi0xte12/5.33, 2.19, 2.40, 1.37, 0.45/
      data pi0xte13/4.10, 3.12, 2.07, 0.80, 0.38/

* pi+-/2 extrapol. data 1/N dn/dpi for lowest cutoff in xpi ----------
      real pipx1(5),pipxse1(5),pipxte1(5)

* data
      data pipx1/15.59, 15.10, 10.28, 5.12, 2.29/
* stat. error
      data pipxse1/1.99, 2.37, 1.7, 1.1, 0.47/
* total error
      data pipxte1/5.01, 4.97, 3.39, 1.67, 0.92/
* Charged part. data 1/N dn/dpi for lowest cutoff in xpi -------------
      real cpx1(5),cpxse1(5),cpxte1(5)
* data
      data cpx1/48.73, 47.19, 32.14, 16.0, 7.17/
* stat. error
      data cpxse1/6.2, 7.4, 5.3, 3.4, 1.47/
* total error
      data cpxte1/15.6, 15.5, 10.6, 5.3, 2.9/
*********************************************************************
*
*                      Initialization
*
*********************************************************************
      NENTRY=NENTRY+1
*
      IF (iflag.eq.1) then
*
         Nevt=0
         Npass=0
*
*
* Initialisation: The following MUST always be done
* (i) make subdirectory in PAWC
* - use the name as the xxxxxx in HZxxxxxx subroutine
* (i) make subdirectory in o/p file
*
         Call hcdir('//PAWC',' ')
         call hmdir(xxxx,'S')
         Call hcdir('//HISTO',' ')
         call hmdir(xxxx,'S')
*
* book histos
*
* histos for events after DIS cuts
         call hbookb(101,'x_bj Dis',6,bx,0.0)
         call hbook1(103,'y Dis',50,0.1,0.8,0.)
         call hbook1(104,'Q2 Dis',50,0.,100.,0.)

* histos for fwd jets
         call hbookb(301,'x_bj fwd jet (pt>3.5)',6,bx,0.0)
         call hbookb(302,'x_bj fwd jet (pt>5.0)',6,bx,0.0)
         call hbookb(303,'Ph1j-phe fwd jet highx',6,bdphi,0.)
         call hbookb(304,'Ph1j-phe fwd jet lowx',6,bdphi,0.)
* histos for fwd pi

         call hbookb(201,'x_bj fwd pi0',5,bxpi,0.0)
         call hbookb(202,'x_bj fwd pi0',5,bxpi,0.0)
         call hbookb(203,'x_bj fwd pi0',5,bxpi,0.0)
         call hbookb(204,'x_bj fwd pi+-',5,bxpm,0.0)
         call hbookb(205,'x_bj ch.part.',5,bxpm,0.0)

* data histos
* divide by 1000 to go from pb to nb
         do i=1,6
            csx(i) = csx(i)/1000.
            csxse(i) = csxse(i)/1000.
            csxte(i) = csxte(i)/1000.
            csx6(i) = csx6(i)/1000.
            csx6se(i) = csx6se(i)/1000.
            csx6te(i) = csx6te(i)/1000.
         enddo
* cross section vs x (data stat error, tot error) pt>3.5
         call hbookb(-301,'H1 cs vs x (stat err)',6,bx,0.)
         call hpak(-301,csx)
         call hpake(-301,csxse)
         call hbookb(-1301,'H1 cs vs x (tot err)',6,bx,0.)
         call hpak(-1301,csx)
         call hpake(-1301,csxte)
* cross section vs x Pt>5
         call hbookb(-302,'H1 cs vs x (stat err,pt>5.)',6,bx,0.)
         call hpak(-302,csx6)
         call hpake(-302,csx6se)
         call hbookb(-1302,'H1 cs vs x (tot err,pt>5.)',6,bx,0.)
         call hpak(-1302,csx6)
         call hpake(-1302,csx6te)
* cross section vs Delta_phi high x
         call hbookb(-303,'H1 cs vs dphi (high x, stat)',6,bdphi,0.)
         call hpak(-303,csph)
         call hpake(-303,csphse)
         call hbookb(-1303,'H1 cs vs dphi (high x, tot)',6,bdphi,0.)
         call hpak(-1303,csph)
         call hpake(-1303,csphte)
* cross section vs Delta_phi low x
         call hbookb(-304,'H1 cs vs dphi (low x, stat)',6,bdphi,0.)
         call hpak(-304,cspl)
         call hpake(-304,csplse)
         call hbookb(-1304,'H1 cs vs dphi (low x, tot)',6,bdphi,0.)
         call hpak(-1304,cspl)
         call hpake(-1304,csplte)
* data for fwd pi
         call hbookb(-201,'H1 cs x_bj fwd pi0 stat',5,bxpi,0.0)
         call hbookb(-1201,'H1 cs x_bj fwd pi0 tot',5,bxpi,0.0)
         call hbookb(-202,'H1 cs x_bj fwd pi0 stat',5,bxpi,0.0)
         call hbookb(-1202,'H1 cs x_bj fwd pi0 tot',5,bxpi,0.0)
         call hbookb(-203,'H1 cs x_bj fwd pi0 stat',5,bxpi,0.0)
         call hbookb(-1203,'H1 cs x_bj fwd pi0 tot',5,bxpi,0.0)
         call hbookb(-204,'H1 cs x_bj fwd pi+- stat',5,bxpm,0.0)
         call hbookb(-1204,'H1 cs x_bj fwd pi+- tot',5,bxpm,0.0)
         call hbookb(-205,'H1 cs x_bj ch.part. stat',5,bxpm,0.0)
         call hbookb(-1205,'H1 cs x_bj ch.part. tot',5,bxpm,0.0)
* -- pi0
         call hpak(-201,pi0x11)
         call hpake(-201,pi0xse11)
         call hpak(-1201,pi0x11)
         call hpake(-1201,pi0xte11)

         call hpak(-202,pi0x12)
         call hpake(-202,pi0xse12)
         call hpak(-1202,pi0x12)
         call hpake(-1202,pi0xte12)

         call hpak(-203,pi0x13)
         call hpake(-203,pi0xse13)
         call hpak(-1203,pi0x13)
         call hpake(-1203,pi0xte13)
* -- pi+-
         call hpak(-204,pipx1)
         call hpake(-204,pipxse1)
         call hpak(-1204,pipx1)
         call hpake(-1204,pipxte1)
* -- charg. part.
         call hpak(-205,cpx1)
         call hpake(-205,cpxse1)
         call hpak(-1205,cpx1)
         call hpake(-1205,cpxte1)


*
*********************************************************************
*
*                      Event Processing
*
*********************************************************************
      Else if(iflag.eq.2) then
*
* Filling: The following MUST always be done
* (i) move to the correct sub-directory in PAWC
*
         call hcdir('//PAWC/'//xxxx,' ')
*
         Nevt = Nevt + wtx
*
         ierr=HZIBEAM(ibeam,idum)

*
* get kinematics
*
         q2=real(HZDISKIN(1))
         x =real(HZDISKIN(2))
         y =real(HZDISKIN(3))
*
* get electron
*
         iel=HZIDELEC(idum)
         if (iel.eq.-1) then
            write(*,*) 'Hz'//xxxx,' electron not found '
            return
         endif
         Ee=real(PHEP(4,iel))
         The=real(HZPHMANG(PHEP(3,iel), sqrt(PHEP(1,iel)**2+PHEP(2,iel)
     +   **2)))*rd
         Phe = HZPHMANG(PHEP(1,iel),PHEP(2,iel))*rd
*
* select DIS events for fwd jets
*
         fjet=.true.
         if (ylow.gt.y) fjet=.false.
         if (xlow.gt.x.or.xhigh.lt.x) fjet=.false.
         if (eelow.gt.Ee.or.thelow.gt.The.
     +      or.thehigh.lt.The) fjet=.false.

* select DIS events for fwd pi
         fpi=.true.
         if (x.lt.xpilow) fpi=.false.
         if (x.gt.xpihigh) fpi=.false.
         if (y.lt.ypilow) fpi=.false.
         if (Ee.lt.Eepilow.or.The.lt.Thepilow. or.The.gt.Thepihigh)
     +   fpi=.false.
*
* fill Dis histos
*
         if(fjet.or.fpi) then
            call hfill(101,x,0.,wtx)
            call hfill(102,x,0.,wtx)
            call hfill(103,y,0.,wtx)
            call hfill(104,q2,0.,wtx)
         endif
         if(fjet) then
*
* find jets
*
            call hzjtfind(modjet,rcone,nj,pj)
*
            if (nj.le.0) return
            if (nj.gt.numjet) then
               write(6,*) 'hz',xxxx,' too many jets found ! '
               return
            endif
            Njet=0
            Nfwd = 0
            Nmue = 0
*
* look for fwd jets, it is assumed that in pj they are ordered in pt
            do 10   ij=1,nj
*
               ej=real(pj(ij,4))
               ptj=real(pj(ij,3))
               thj=real(HZPHMANG(pj(ij,7),pj(ij,3)) )*rd
               Phj =real(HZPHMANG(pj(ij,5),pj(ij,6)))*rd
*
               if (ptj.lt.ptjlow) goto 10
               Njet=Njet+1
               if ( (thj.gt.thjlow.and.thj.lt.thjhigh) .and.
     +         (ej.gt.ejlow) ) then
*     you got a fwd jet!
                  Nfwd = Nfwd + 1

* mueller jets
                  pt2q2=Ptj**2/q2
                  if (pt2q2.gt.pt2q2low.and.pt2q2.lt.pt2q2high) then
                     Nmue = Nmue+1
                     if (Nmue.eq.1) then
                        call hfill(301,x,0.,wtx)
                        deltaphi=abs(Phj-Phe)
                        if(deltaphi.gt.180.) deltaphi=-deltaphi+360.
                        if (x.lt.xmed) call hfill(303,deltaphi,0.,wtx)
                        if (x.gt.xmed) call hfill(304,deltaphi,0.,wtx)
                        if (Ptj.gt.5.) then
                           call hfill(302,x,0.,wtx)
                        endif
                     endif
                  endif
               endif
   10       continue
         endif
         if(fpi) then
* count number of events passing the DIS cuts
            Npass=Npass+WTX

* find pi0s, pi+- and Charg. Part.  and fill histos
            do i=1,nhep
               ptpi=sqrt(PHEP(1,i)**2+PHEP(2,i)**2)
               thpi=real(HZPHMANG(PHEP(3,i), sqrt(PHEP(1,i)**2+PHEP(2,
     +         i)**2)))*rd
               xpi=real(PHEP(4,i))/820.0

               if(ptpi.gt.ptpilow.and. thpi.gt.thpilow.and. thpi.lt.thp
     +         ihigh) then
* pi0's ---------------------------------------------------
                  if(iabs(idhep(i)).eq.111) then
                     if(xpi.gt.xpi1lo.and.xpi.lt.xpi1hi) call hf1(201,
     +               x,wtx)
                     if(xpi.gt.xpi2lo.and.xpi.lt.xpi2hi) call hf1(202,
     +               x,wtx)
                     if(xpi.gt.xpi3lo.and.xpi.lt.xpi3hi.and. ptpi.gt.pt
     +               pi3lo) call hf1(203,x,wtx)
                  endif

* pi+- ----------------------------------------------------
                  if(iabs(idhep(i)).eq.211) then
                     if(xpi.gt.xpi1lo.and.xpi.lt.xpi1hi) call hf1(204,
     +               x,wtx)
                  endif

* charged particles ---------------------------------------
                  if((isthep(i).eq.1).and.(ihchrg(i).ne.0)) then
                     if(xpi.gt.xpi1lo.and.xpi.lt.xpi1hi) call hf1(205,
     +               x,wtx)
                  endif
               endif

            enddo
         endif

*
*********************************************************************
*
*                      Termination
*
*********************************************************************

      Else if(iflag.eq.3) then

* Termination: The following MUST always be done
* (i) Move to the correct PAW subdirectory
*
         call hcdir('//PAWC/'//xxxx,' ')
*
         lumnb=999999.
         lumpb=999999.
         if (xsec.ne.0.) then
            lumnb=1000.*real(Nevt)/real(xsec)
            lumpb=real(Nevt)/real(xsec)
            print *,'Number of events procesed:',Nevt
            print *,'Total cross section:',xsec
            print *,'Equivalent luminosity [nb] :',lumnb
         else
            write(6,*) 'hz',xxxx,' xsec=0 ! '
         endif
*
*      normalize the histos
*
* jets
         call hopera(101,'+E',101,101,1./lumnb,0.)
         call hopera(103,'+E',103,103,1./lumnb,0.)
         call hopera(104,'+E',104,104,1./lumnb,0.)

         call hopera(301,'+E',301,301,1./lumnb,0.)
         call hopera(302,'+E',302,302,1./lumnb,0.)
         call hopera(303,'+E',303,303,1./lumpb,0.)
         call hopera(304,'+E',304,304,1./lumpb,0.)
         call hzhinrm(101, 0, 1. , 1 )
         call hzhinrm(103, 0, 1. , 1 )
         call hzhinrm(104, 0, 1. , 1 )
         call hzhinrm(301, 0, 1. , 1 )
         call hzhinrm(302, 0, 1. , 1 )
         call hzhinrm(303, 0, 1. , 1 )
         call hzhinrm(304, 0, 1. , 1 )
         call hzhinrm(-301, 0, 1. , 1 )
         call hzhinrm(-302, 0, 1. , 1 )
         call hzhinrm(-303, 0, 1. , 1 )
         call hzhinrm(-304, 0, 1. , 1 )
         call hzhinrm(-1301, 0, 1. , 1 )
         call hzhinrm(-1302, 0, 1. , 1 )
         call hzhinrm(-1303, 0, 1. , 1 )
         call hzhinrm(-1304, 0, 1. , 1 )
* pi0,pi+-,charg.part. histograms
         do i=201,203
            call hzhinrm(i, 0,real(Npass) , 1 )
         enddo
         call hzhinrm(204, 0,real(2*Npass) , 1 )
         call hzhinrm(205, 0,real(Npass) , 1 )

      endif
*
      RETURN
      END
*CMZ :  1.02/06 03/03/99  19.22.28  by  Tancredi Carli
*-- Author :
*****************************************************************************
	Subroutine HZ98162(iflag)
*****************************************************************************
* This photoproduction routine has to be run twice with the following
* code additions:
* 	+1000 for the DIRECT component run.
*	+2000 for the RESOLVED component run.
* for all three phases (iflag=1,2,3)
*
* iflag = 1,2 or 3 depending on wether it is the initialization,
*		processing or termination phase (respectively)
*
* The default jetfinder is PXCONE
* To change jetfinder use these values to call the initialisation phase.
* 1 + 10 * (jetfinder number)
* (This routine produces histograms in reference to
* paper:Measurement of three-jet distributions in photoproduction at HERA,
* Physics Letter B443(1998)394-408)
*
* Monte Carlo histograms produced:
* ================================
* id 40-44 are the number of unweighted direct events which pass the cuts
* id 50-54 are the number of unweighted resolved events which pass the cuts
* id 60-64 are the normalised cross section in pb. These graphs are
*		meaningless unless Xsec and Ntot are set before
*		calling the termination routine.
*		(Xsec - total cross section returned by MC)
*		(Ntot - number of events passed to this routine)
* id 161-164 are area renormalised versions of 61-64
*
* Data graphs produced:
* =====================
* id -60 to -64 are measured data, corresponding to MC graphs 60-64.
* The errors are the quadrative addition of systematic and statistical
* errors, with the  largest value (up or down) taken as error. This is
* only an approximation to the asymetric errors of published graphs.
*
*       Cuts : 	Q2 < 1 GeV^2           ^
*               0.2 < y < 0.8          ^
* And at least two jets with
*               E_T^jet > 6 GeV and    ^
* & third with  E_T^jet > 5 GeV
*               eta^JET < |2.4|        ^
* In addition   M345 > 50 GeV^2        ^
*               X_3 < 0.95             ^
*               |cos(theta_3)| < 0.8   ^
*
* Recommended value for Ptmin is 6.5 GeV (to be set in driver routine)
*
* Author : Eileen Heaphy
*
*****************************************************************************
*
* HERA Tuning defined commons
	
	implicit none
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.

	character*6 jetf

	integer NJET, counter(2,2)
	double precision Jets(50,8), CONER
	double precision ybj,q2
	double precision P1_dbl(4),P2_dbl(4)
	double precision P1_lab(4),P2_lab(4)
	double precision mhxsec(2),mhntot(2)
	double precision xboost,yboost,zboost
	double precision Pnew_dbl(4),P3new_dbl(4),P4new_dbl(4)
        double precision P5new_dbl(4)
	double precision ptot_act(4),p3_act(4),p4_act(4),p5_act(4)
	real dir_xsec, res_xsec, tot_xsec

	integer cut_test(2)
	integer loop,loop2,count, i, j, k
	real    rap,Et, Mass
	real    ybjcut(2),q2cut(2),Masscut
	real    rapcut(2),Etcut(2),X3_cut,cos_t3_cut(2)

	real    Ptest(5),Etest(5),Mtest(5), test_value(5)
	real    Ptot(4), P3(4),P4(4),P5(4),Imass, Mom2_tot
	real    E2, E, Pnew(4),P3new(4),P4new(4),P5new(4)
	real    P3lab(4),P4lab(4),P5lab(4),test(4)
	real    X3,X4,X5 ,Pav(4),P1(4),P2(4)
	real    cross1(4),cross2(4),dot1,dot2, dot3,dot4,dot5,dot6
	real    cos_phi3,cos_theta3, sum(3), phi3
	real    testy(4)


C *** Data for Invariant Mass
	real xbin0(10)
	real bin0_err(9)
	real mass_cr(9)
	real stat_err(9) ! statistical error
	real x0_sys_up(9) ! systematic err +
	real x0_sys_dn(9) ! systematic err -
	real err0(9)

c *** cos_theta_3
	real xbin1(17)
	real bin1_err(16)
	real cos_t3_cr(16)
	real stat1(16)
	real sys1_up(16)
	real sys1_dn(16)
	real err1(16)

c *** psi_3
	real xbin2(17)
	real bin2_err(16)
	real phi3_cr(16)
	real stat2(16)
	real sys2_up(16)
	real sys2_dn(16)
	real err2(16)

c *** X3
	real xbin3(8)
	real bin3_err(7)
	real X3_cr(7)
	real stat3(7)
	real sys3_up(7)
	real sys3_dn(7)
	real err3(7)

c *** X4
	real xbin4(11)
	real bin4_err(10)
	real X4_cr(10)
	real stat4(10)
	real sys4_up(10)
	real sys4_dn(10)
	real err4(10)

	real xfactor(2)
        real inv_xtot

C *** Data points for Et.gt.8 GeV
	data xbin0/50, 55, 60, 65, 72, 80, 90, 100, 120, 160/
	data mass_cr/12.57, 6.855, 4.733, 2.455, 1.575, 0.535, 0.305,
     &          0.158, 0.023/
	data stat_err/0.535, 0.364, 0.325, 0.176, 0.142, 0.074,
     &	    0.055, 0.031, 0.011/
	data x0_sys_up/1.566, 0.443, 0.884, 0.18, 0.151, 0.114, 0.031,
     &      0.009, 0.005/
	data x0_sys_dn/0.511, 0.244, 0.219, 0.072, 0.163, 0.091, 0.027,
     &         0.056, 0.008/

	data xbin1/-0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1, 0.0,
     &          0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8/	
	data cos_t3_cr/1.209, 0.866, 0.584, 0.532, 0.426, 0.279, 0.367,
     &          0.306, 0.366, 0.359, 0.529, 0.451, 0.525, 0.732,
     &          0.981, 1.485/
	data stat1/0.08, 0.072, 0.056, 0.056, 0.051,
     &          0.036, 0.048, 0.039, 0.047,
     &          0.048, 0.063, 0.052, 0.058,
     &          0.074, 0.079, 0.105 /
	data sys1_up/0.111, 0.02, 0.075, 0.05, 0.022, 0.119, 0.456, 0.103,
     &          0.057, 0.022, 0.034, 0.117, 0.035, 0.081, 0.076, 0.105/
	data sys1_dn/0.044, 0.171, 0.041, 0.045, 0.039, 0.019,0.05,0.015,
     &          0.039, 0.112, 0.091, 0.038, 0.031, 0.214, 0.024, 0.214/

	data xbin2/0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8,
     &          2.0, 2.2, 2.4, 2.6, 2.8, 3.0, 3.2/
	data phi3_cr/0.297, 0.335, 0.336, 0.365, 0.308, 0.215, 0.220,
     &          0.256, 0.213, 0.297, 0.332, 0.341, 0.371, 0.415,
     &          0.443, 0.360/
	data stat2/0.31E-01, 0.33E-01, 0.36E-01, 0.35E-01,
     &          0.31E-01,
     &          0.25E-01, 0.26E-01, 0.29E-01, 0.25E-01,
     &          0.31E-01, 0.32E-01, 0.32E-01, 0.34E-01,
     &          0.37E-01, 0.4E-01, 0.33E-01/
	data sys2_up/0.047, 0.112, 0.047, 0.031, 0.028, 0.025, 0.015,
     &          0.031,0.031, 0.021, 0.018, 0.026, 0.011, 0.037, 0.015,
     &          0.036/
	data sys2_dn/0.031, 0.022, 0.045, 0.024, 0.02, 0.017, 0.052,
     &          0.053, 0.022, 0.031, 0.067, 0.021, 0.023, 0.014, 0.056,
     &          0.048/


	data xbin3/0.67, 0.71, 0.75, 0.79, 0.83, 0.87, 0.91, 0.95/
	data X3_cr/0.449, 1.251, 1.983, 2.758, 4.453, 6.151, 7.954/
	data stat3/0.078, 0.134, 0.160, 0.195, 0.259, 0.318, 0.376/
	data sys3_up/0.058, 0.085, 0.125, 0.23, 0.198, 0.149, 0.258/
	data sys3_dn/0.07, 0.076, 0.181, 0.219, 0.129, 0.191, 0.33/


	data xbin4/0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85,
     &           0.9, 0.95, 1.0/
	data X4_cr/0.264, 1.629, 3.024, 3.869, 3.616, 2.915, 2.936,
     &           1.64, 0.107, 0.0/
	data stat4/0.072, 0.147, 0.195, 0.212, 0.241, 0.187, 0.216,
     &          0.184, 0.058, 0.00/
	data sys4_up/0.055, 0.218, 0.174, 0.158, 0.221, 0.447, 0.036,
     &          0.136, 0.103, 0.00/

	integer intiflag, chjet, iproc, iflag
	save chjet

C --- NB :jet finder in paper -- KTCLUS
	data chjet/2/
	real pttemp(12)
	integer ivec,jvec


C --- choose direct/resolved
C --- recommend 1 - DIRECT, 2 - RESOLVED
	if (iflag.gt.1000) then
	   iproc=INT(iflag/1000)
	   intiflag=MOD(iflag,1000)
	endif
	if ((iproc.gt.2).or.(iproc.lt.1)) then
	   PRINT*,'HZ98162 : Badly called routine'
	   PRINT*,'          please set intiflag +1000 or +2000'
	endif

C --- choose jet finder
	if ((intiflag.gt.10).and.(MOD(intiflag,10).eq.1)) then
	   chjet=INT(intiflag/10)
	   intiflag=MOD(intiflag,10)
	endif

	if (intiflag.eq.1) then ! #
C *** Initialisation run ***
C *** Create directories ***

	if (iproc.eq.1) then
	   CALL HCDIR('//HISTO',' ')
	   CALL HMDIR('98162','S')
	   CALL HCDIR('//PAWC',' ')
	   CALL HMDIR('98162','S')
	
           call hbookb(60,'Invariant Mass, ',9,xbin0,0.)
	   call hbookb(61,'Cos_theta3, ',16,xbin1,0.)
	   call hbookb(62,'psi3, ',16,xbin2,0.)
	   call hbookb(63,'X3, ',7,xbin3,0.)
	   call hbookb(64,'X4, ',10,xbin4,0.)

	   call hbookb(161,'Area renorm(AR) cos_theta3',16,xbin1,0.)
           call hbookb(162,'AR psi3',16,xbin2,0.)
	   call hbookb(163,'AR X3',7,xbin3,0.)
	   call hbookb(164,'AR X4',10,xbin4,0.)
 	endif

	if (iproc.eq.2) then
	   Ntot = 0
	endif

	CALL HCDIR('//HISTO/98162',' ')
	CALL HCDIR('//PAWC/98162',' ')
	
	if (iproc.eq.1) then
	   call hbookb(40,'Invariant Mass, Direct',9,xbin0,0.)
	   call hbookb(41,'Cos_theta3, Direct',16,xbin1,0.)
	   call hbookb(42,'psi3, Direct',16,xbin2,0.)
	   call hbookb(43,'X3, Direct',7,xbin3,0.)
	   call hbookb(44,'X4, Direct',10,xbin4,0.)
	endif
	if (iproc.eq.2) then
	   call hbookb(50,'Invariant Mass, Resolved',9,xbin0,0.)
	   call hbookb(51,'Cos_theta3, Resolved',16,xbin1,0.)
	   call hbookb(52,'psi3, Resolved',16,xbin2,0.)
	   call hbookb(53,'X3, Resolved',7,xbin3,0.)
	   call hbookb(54,'X4, Resolved',10,xbin4,0.)
	endif

	CALL HIDOPT(0,'stat')
	CALL HBARX(0)

c-CUTS--------
	ybjcut(1)=0.2
	ybjcut(2)=0.8

	q2cut(1)=0.
	q2cut(2)=1
	
	rapcut(1)= -2.4
	rapcut(2)=2.4

	Etcut(1)=5.0
	Etcut(2)=6.0

	Masscut=50

	X3_cut=0.95

	cos_t3_cut(1)=-0.8
	cos_t3_cut(2)= 0.8

	if (iproc.eq.1) then
	   counter(1,1) = 0
	   counter(1,2) = 0
        else
	   counter(2,1) = 0
	   counter(2,2) = 0
	endif

C --- standard cone radius is 1.0
	CALL HZJETRAD(2,CONER)
	if (CONER.lt.0.0) then
	    CONER=1.0
	endif
	CALL HZJTNAME(chjet,jetf)
	WRITE(6,*)'**********************************************'
	WRITE(6,*)'* HZ98162 called, histograms will be output. *'
	WRITE(6,*)'*     Jet finder selected : ',jetf,'           *'
	WRITE(6,1001)'*        with cone radius : ',CONER,'   *'
	WRITE(6,*)'**********************************************'

 1001	FORMAT(A29,F5.2,A13)

	else if (intiflag.eq.2) then ! #
C *** Filling runs ***
	
C *** Change directory to our graphs ***
	CALL HCDIR('//PAWC/98162',' ')

c *** get jets
	q2=hzphokin(1)
	if (q2.eq.-1) then
	    PRINT*,'HZ98162: HZPHOKIN returns error for Q2'
	elseif (q2.lt.0) then
	    q2=abs(q2)
	endif
	ybj=hzphokin(3)
	if (ybj.eq.-1) then
	   PRINT*,'HZ98162: HZPHOKIN returns error for ybj'
	endif


      	CALL hzjtfind(chjet,CONER,NJET,Jets)

	do i=1,3
	   P3lab(i) = real(Jets(1,i+4))
	   P4lab(i) = real(Jets(2,i+4))
	   P5lab(i) = real(Jets(3,i+4))
	enddo

	P3lab(4) = real(Jets(1,4))
	P4lab(4) = real(Jets(2,4))
	P5lab(4) = real(Jets(3,4))

	do i=1,4
	   Ptot(i) = P3lab(i) + P4lab(i) + P5lab(i)
	enddo

	Mom2_tot = 0

	do i = 1,3
	   Mom2_tot = Mom2_tot + Ptot(i)*Ptot(i)
	enddo

	E2 = Ptot(4)*Ptot(4)
	E  = sqrt(E2)
	Mass = sqrt(E2 - Mom2_tot)

C**********DO BOOST**into cms frame for 3-jets****

	
	xboost = -1.0*dble(Ptot(1)) / dble(E)
	yboost = -1.0*dble(Ptot(2)) / dble(E)
	zboost = -1.0*dble(Ptot(3)) / dble(E)

	do i=1,4
	   p3_act(i) = dble(P3lab(i))
	   p4_act(i) = dble(P4lab(i))
	   p5_act(i) = dble(P5lab(i))
	   ptot_act(i) = dble(Ptot(i))
	enddo

	CALL HZBOOST(xboost,yboost, zboost,p3_act,P3new_dbl)
	CALL HZBOOST(xboost,yboost, zboost,p4_act,P4new_dbl)
	CALL HZBOOST(xboost,yboost, zboost,p5_act,P5new_dbl)
	CALL HZBOOST(xboost,yboost, zboost,ptot_act,Pnew_dbl)

	do i=1,4
	   P3new(i) = real(P3new_dbl(i))
	   P4new(i) = real(P4new_dbl(i))
	   P5new(i) = real(P5new_dbl(i))
	   Pnew(i)  = real(Pnew_dbl(i))
	enddo

c**** swap so E3 > E4 > E5 ***
*******************************       	

      If (P3new(4).lt.P4new(4)) then
	 do i=1,4
            testy(i) = P3new(i)
	    P3new(i) = P4new(i)
	    P4new(i) = testy(i)
	 enddo
      endif
 	
      If (P4new(4).lt.P5new(4)) then
         do i=1,4
            testy(i) = P4new(i)
            P4new(i) = P5new(i)
            P5new(i) = testy(i)
         enddo
      endif
 	
      If (P3new(4).lt.P4new(4)) then
         do i=1,4
	    testy(i) = P3new(i)
            P3new(i) = P4new(i)
            P4new(i) = testy(i)
         enddo
      endif
	
      do i=1,4
         P3(i) = P3new(i)
         P4(i) = P4new(i)
         P5(i) = P5new(i)
      enddo
	
********************************
****** DALITZ variables X3,X4, X5
	X3 = (2 * P3(4)) /Mass
	X4 = (2 * P4(4)) /Mass
	X5 = (2 * P5(4)) /Mass
	
******* Pav ********= P1 - P2*************
	P1_lab(1) = 0
	P1_lab(2) = 0
	P1_lab(3) = 820.0
	P1_lab(4) = 820.0


	P2_lab(1) = 0
	P2_lab(2) = 0
	P2_lab(3) = -27.52
	P2_lab(4) = 27.52


	CALL HZBOOST(xboost,yboost,zboost, P1_lab,P1_dbl)
	CALL HZBOOST(xboost,yboost,zboost, P2_lab,P2_dbl)

	do i=1,4
	   P1(i) = real(P1_dbl(i))
	   P2(i) = real(P2_dbl(i))
	enddo

	do i=1,3
	   Pav(i) = P1(i) - P2(i)
	enddo

********** calculate cos theta 3  ***
	dot4 = 0
	dot5 = 0
	dot6 = 0
	do i=1,3
	   dot4 = dot4 + Pav(i)*P3(i)
	   dot5 = dot5 + Pav(i)*Pav(i)
	   dot6 = dot6 + P3(i)*P3(i)
	enddo

	cos_theta3 = dot4 / ( sqrt(dot5)*sqrt(dot6) )

********** cos phi 3 = cos_phi3

	
	call cross(P3,Pav,cross1)
	call cross(P4,P5,cross2)

	dot1 = 0
	dot2 = 0
	dot3 = 0

	do i=1,3
	   dot1 = dot1 + cross1(i)*cross1(i)
	   dot2 = dot2 + cross2(i)*cross2(i)
	   dot3 = dot3 + cross1(i)*cross2(i)
	enddo


	cos_phi3 = dot3 / (sqrt(dot1) * sqrt(dot2) )
	phi3     = acos( cos_phi3)
	
***** Implement cuts ******************

	cut_test(1) = 0
	cut_test(2) = 0

	do loop=1,3
	   Et=real(Jets(loop,3))
	   rap=real(Jets(loop,1))
	
	   if (Et.gt.Etcut(1)) cut_test(2) = cut_test(2) +1
	   if (Et.gt.Etcut(2)) cut_test(1) = cut_test(1) +1
	   if (rap.gt.rapcut(1).and.rap.lt.rapcut(2)) then
               cut_test(2)= cut_test(2)+1
	   endif
	enddo

cccc if successful event cut_test(1) = 2 or 3
	
	IF ( ybj.ge.ybjcut(1).and.ybj.le.ybjcut(2) ) then
	   cut_test(2) = cut_test(2) + 1
	ENDIF

	IF ( q2.lt.q2cut(2).and.Mass.gt.Masscut ) then
	   cut_test(2) = cut_test(2) + 1
	ENDIF

	IF ( X3.lt.X3_cut) then
	   cut_test(2) = cut_test(2) + 1
	endif

	if (cos_theta3.gt.cos_t3_cut(1).and.cos_theta3.lt.cos_t3_cut(2)
     &     ) then
	   cut_test(2) = cut_test(2) + 1
        endif

CCC IF SUCCESFUL  cut_test(2) = 10

	If ( cut_test(1).ge.2.and.cut_test(2).eq.10) then !$
	   counter(iproc,1) = counter(iproc,1) + 1
	   CALL HFILL(INT(30+(iproc*10)), REAL(Mass) , 0. ,wtx)
	   CALL HFILL(INT(31+(iproc*10)), REAL(cos_theta3) , 0. ,wtx)
	   CALL HFILL(INT(32+(iproc*10)), REAL(phi3) , 0. ,wtx)
	   CALL HFILL(INT(33+(iproc*10)), REAL(X3), 0. ,wtx)
	   CALL HFILL(int(34+(iproc*10)), REAL(X4), 0. ,wtx)

	ELSE !$
	   counter(iproc,2) = counter(iproc,2) + 1
	ENDIF !$

	ELSE IF (intiflag.eq.3) THEN !#
C *** Termination run ***
C *** Change directory ***
	CALL HCDIR('//PAWC/98162',' ')
	
	IF (Xsec.eq.0) THEN
	   PRINT*,'HZ98162: termination called with zero cross section'
	   PRINT*,'          cross section graph meaningless'
	   PRINT*,'	      in process :',iproc*1000
	   Xsec=1
	ENDIF
	IF (Ntot.eq.0) THEN
	   PRINT*,'HZ98162: termination called with no total events'
	   PRINT*,'          cross section graph meaningless'
	   PRINT*,'	      in process :',iproc*1000
	   Ntot=1
	ENDIF

C --- store Xsec and Ntot for both direct and resolved events.
	mhXsec(iproc)=Xsec
	mhntot(iproc)=Ntot
	
	IF (iproc.eq.2) THEN !%
C- create data plots --------
c - plots are in pb
	   mhXsec(1) = mhXsec(1)*1E09
	   mhXsec(2) = mhXsec(2)*1E09

c- create histograms for systematic + statistical errors

	   do i=1,9
	      if (x0_sys_dn(i).gt.x0_sys_up(i) ) then
	         err0(i) = sqrt(stat_err(i)**2+x0_sys_dn(i)**2)
              else
	         err0(i) = sqrt(stat_err(i)**2+x0_sys_up(i)**2)
	      endif
	   enddo

	   do i=1,16
	      if (sys1_dn(i).gt.sys1_up(i) ) then
	         err1(i) = sqrt(stat1(i)**2+sys1_dn(i)**2)
              else
	         err1(i) = sqrt(stat1(i)**2+sys1_up(i)**2)
	      endif
	   enddo

	   do i=1,16
	      if (sys2_dn(i).gt.sys2_up(i) ) then
	         err2(i) = sqrt(stat2(i)**2+sys2_dn(i)**2)
              else
	         err2(i) = sqrt(stat2(i)**2+sys2_up(i)**2)
	      endif
	   enddo

	   do i=1,7
	      if (sys3_dn(i).gt.sys3_up(i) ) then
	         err3(i) = sqrt(stat3(i)**2+sys3_dn(i)**2)
              else
	         err3(i) = sqrt(stat3(i)**2+sys3_up(i)**2)
	      endif
	   enddo

	   do i=1,10
	      if (sys4_dn(i).gt.sys4_up(i) ) then
	         err4(i) = sqrt(stat4(i)**2+sys4_dn(i)**2)
              else
	         err4(i) = sqrt(stat4(i)**2+sys4_up(i)**2)
	      endif
	   enddo

c ---- Fill Histograms with data -------

	   CALL HBOOKB(-60,'data m345',9 ,xbin0 ,0.)
	   call hpak(-60,mass_cr)
	   call hpake(-60,err0)

	
	   call hbookb(-61,'data cos_theta3',16,xbin1,0.)
	   call hpak(-61,cos_t3_cr)
	   call hpake(-61,err1)

	   call hbookb(-62,'data phi3',16,xbin2,0.)
	   call hpak(-62,phi3_cr)
	   call hpake(-62,err2)

	   call hbookb(-63,'data X3',7,xbin3,0.)
	   call hpak(-63,X3_cr)
	   call hpake(-63,err3)

	   call hbookb(-64,'data X4',10,xbin4,0.)
	   call hpak(-64,X4_cr)
	   call hpake(-64,err4)

C --- only finally
C --- create proper cross-section graph

           print*,"Direct  events, passed cuts ",counter(1,1)
	   print*,"Direct  events, failed cuts ",counter(1,2)
	   print*,"Total  ",( counter(1,1)+counter(1,2) )

	   print*,"Resolved evnts, passed cuts ",counter(2,1)
	   print*,"Resolved evnts, failed cuts ",counter(2,2)
	   print*,"Total  ",( counter(2,1)+counter(2,2) )


	   CALL HBOOKB(100,'renorm m345',9 ,xbin0 ,0.)
 	   CALL HBOOKB(101,'renorm cos(theta3)',16 ,xbin1 ,0.)
           CALL HBOOKB(102,'renorm phi3',16 ,xbin2 ,0.)
	   CALL HBOOKB(103,'renorm X3',7 ,xbin3 ,0.)
	   CALL HBOOKB(104,'renorm X4',10 ,xbin4 ,0.)

c -------- work out 1/bin_width for each histo ----------

	   DO ivec=1,9
	      xbin0(ivec)=1/( xbin0(ivec+1)-xbin0(ivec) )
	      bin0_err(ivec)= 0
	   ENDDO

	   DO ivec=1,16
	      xbin1(ivec)=1/( xbin1(ivec+1)-xbin1(ivec) )
	      xbin2(ivec)=1/( xbin2(ivec+1)-xbin2(ivec) )
	      bin1_err(ivec) = 0
	      bin2_err(ivec) = 0
	   ENDDO

	   DO ivec=1,7
	      xbin3(ivec)=1/( xbin3(ivec+1)-xbin3(ivec) )
	      bin3_err(ivec) = 0
	   ENDDO


           DO ivec=1,10
              xbin4(ivec)=1/( xbin4(ivec+1)-xbin4(ivec) )
	      bin4_err(ivec) = 0
           ENDDO


	   CALL  HPAK (100,xbin0)
	   call  hpake(100,bin0_err)

	   CALL  HPAK (101,xbin1)
	   call  hpake(101,bin1_err)

	   CALL  HPAK (102,xbin2)
	   call  hpake(102,bin2_err)

	   CALL  HPAK (103,xbin3)
	   call  hpake(103,bin3_err)

	   CALL  HPAK (104,xbin4)
	   call  hpake(104,bin4_err)



	   xfactor(1) = REAL( mhXsec(1)/mhNtot(1) )
	   xfactor(2) = REAL( mhXsec(2)/mhNtot(2) )

	dir_xsec = real( ( counter(1,1) * mhXsec(1) ) / mhntot(1) )
	res_xsec = real( ( counter(2,1) * mhXsec(2) ) / mhntot(2) )
	tot_xsec = dir_xsec + res_xsec

	inv_xtot = 1.0 / tot_xsec
c	write(6,*)'Cross section, direct   = ', dir_xsec
c	write(6,*)'Cross section, resolved = ', res_xsec
c       write(6,*)'Cross section, total    = ', tot_xsec

c -- divide by tot cr-sec ----

	   call hopera(40,'*e',100,400,xfactor(1),1.)
	   call hopera(41,'*e',101,401,xfactor(1),1.)
	   call hopera(42,'*e',102,402,xfactor(1),1.)
	   call hopera(43,'*e',103,403,xfactor(1),1.)
	   call hopera(44,'*e',104,404,xfactor(1),1.)

	   call hopera(50,'*e',100,500,xfactor(2),1.)
	   call hopera(51,'*e',101,501,xfactor(2),1.)
	   call hopera(52,'*e',102,502,xfactor(2),1.)
	   call hopera(53,'*e',103,503,xfactor(2),1.)
	   call hopera(54,'*e',104,504,xfactor(2),1.)

	   call hopera(400,'+e',500,60,1.,1.)
	   call hopera(401,'+e',501,61,1.,1.)
	   call hopera(402,'+e',502,62,1.,1.)
	   call hopera(403,'+e',503,63,1.,1.)
	   call hopera(404,'+e',504,64,1.,1.)

	   call hopera(61,'+e',61,161,0.,inv_xtot)
	   call hopera(62,'+e',62,162,0.,inv_xtot)
	   call hopera(63,'+e',63,163,0.,inv_xtot)
	   call hopera(64,'+e',64,164,0.,inv_xtot)



	ENDIF !%
	ELSE  !#
C *** End ***
	   PRINT*,'HZ98162 Please run routine with iflag set to 1,2 or 3'
	ENDIF !#


	RETURN
	END
*CMZU:  1.02/04 07/12/98  15.41.41  by  Douglas M. Jansen
*-- Author :    Douglas M. Jansen   10/11/98
      subroutine HZ98169(IFLAG)
****************************************************************************
* Purpose: produced histograms for the distributions...
*          Event selection:
*          Reference:
* Arguments: iflag=1 initialisation
*            iflag=1 filling
*            iflag=3 termination
*
* written by: Douglas M. Jansen on 10/11/98
*
* This routine plots the semi-inclusive structure functions for
* leading proton and neutron production with pt <= 200 MeV/c.
* The semi-inclusive cross section e p -> e N X, where N is either
* a final state proton or neutron, is parameteried by F2LB(x,Q2,z)
* similar to the definition of F2D(3).
*
* Beams: 27.5 GeV positrons, 820 GeV protons   [1995/96 HERA running]
*
* Event selection:
* 2 GeV2 < Q2 < 50 GeV2
* 6E-5 < x < 6E-3
* Baryon pt, defined with respect to the incident proton
* beam, is less than or equal to 200 MeV
*
* Histograms:
* 101 - 112: The proton data points for F2LB(3).
* 201 - 212: The Monte Carlo predictions for protons.
* 301 - 312: The neutron data points for F2LB(3).
* 401 - 412: The Monte Carlo predictions for neutrons.
*
* The kumac k_98169 makes two nice plots.
*
* Reference: DESY: 98-169
*
****************************************************************************
      IMPLICIT NONE
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      Integer ihep,iflag
*     DESY Preprint number 98-169
      Character*5 xxxx
      Data xxxx/'98169'/

      real q2,x,pt,enel,enep,rsec
      real xlow, xhigh
      integer nentry,ierr,ibeam,ilep

      real pbin1(4),pbin2(4),pbin3(4),pbin4(4)
      real pbin5(4),pbin6(4),pbin7(4),pbin8(4)
      real pbin9(4),pbin10(4),pbin11(4),pbin12(4)
      real pebin1(4),pebin2(4),pebin3(4),pebin4(4)
      real pebin5(4),pebin6(4),pebin7(4),pebin8(4)
      real pebin9(4),pebin10(4),pebin11(4),pebin12(4)
      real nbin1(4),nbin2(4),nbin3(4),nbin4(4)
      real nbin5(4),nbin6(4),nbin7(4),nbin8(4)
      real nbin9(4),nbin10(4),nbin11(4),nbin12(4)
      real nebin1(4),nebin2(4),nebin3(4),nebin4(4)
      real nebin5(4),nebin6(4),nebin7(4),nebin8(4)
      real nebin9(4),nebin10(4),nebin11(4),nebin12(4)

      real scale1,scale2,scale3,scale4,scale5,scale6
      real scale7,scale8,scale9,scale10,scale11,scale12

      data pbin1 / 0.0514, 0.0590, 0.0580, 0.0499/
      data pbin2 / 0.0392, 0.0550, 0.0595, 0.0528/
      data pbin3 / 0.0357, 0.0354, 0.0403, 0.0461/
      data pbin4 / 0.0684, 0.0807, 0.1030, 0.0887/
      data pbin5 / 0.0631, 0.0619, 0.0626, 0.0572/
      data pbin6 / 0.0770, 0.0652, 0.0873, 0.1080/
      data pbin7 / 0.0411, 0.0859, 0.0736, 0.0631/
      data pbin8 / 0.0419, 0.1126, 0.0699, 0.0832/
      data pbin9 / 0.1024, 0.1168, 0.1253, 0.1114/
      data pbin10 / 0.0839, 0.0715, 0.0759, 0.0500/
      data pbin11 / 0.0737, 0.1030, 0.0398, 0.0840/
      data pbin12 / 0.1179, 0.1047, 0.0734, 0.0784/

      data pebin1 / 0.01223, 0.01069, 0.01018, 0.01354/
      data pebin2 / 0.00827, 0.00807, 0.00828, 0.01275/
      data pebin3 / 0.00956, 0.00742, 0.00800, 0.01272/
      data pebin4 / 0.01573, 0.01296, 0.01488, 0.02205/
      data pebin5 / 0.01615, 0.01254, 0.01205, 0.01638/
      data pebin6 / 0.02244, 0.01528, 0.01789, 0.03059/
      data pebin7 / 0.01404, 0.01745, 0.01530, 0.01945/
      data pebin8 / 0.01650, 0.02614, 0.01911, 0.02802/
      data pebin9 / 0.02746, 0.02278, 0.02322, 0.03218/
      data pebin10 / 0.02538, 0.01796, 0.01890, 0.01896/
      data pebin11 / 0.03003, 0.02822, 0.01676, 0.03201/
      data pebin12 / 0.03514, 0.02442, 0.01958, 0.02730/

      data nbin1 / 0.0829, 0.0470, 0.0396, 0.0125/
      data nbin2 / 0.0673, 0.0378, 0.0315, 0.0066/
      data nbin3 / 0.0582, 0.0296, 0.0257, 0.0059/
      data nbin4 / 0.1150, 0.0664, 0.0526, 0.0091/
      data nbin5 / 0.0952, 0.0450, 0.0414, 0.0101/
      data nbin6 / 0.1228, 0.0752, 0.0442, 0.0220/
      data nbin7 / 0.0984, 0.0527, 0.0488, 0.0080/
      data nbin8 / 0.0812, 0.0458, 0.0412, 0.0033/
      data nbin9 / 0.1295, 0.0749, 0.0533, 0.0202/
      data nbin10 / 0.0918, 0.0512, 0.0457, 0.0141/
      data nbin11 / 0.1650, 0.0952, 0.0509, 0.0433/
      data nbin12 / 0.1018, 0.0702, 0.0499, 0.0148/

      data nebin1 / 0.0225, 0.0168, 0.0074, 0.0076/
      data nebin2 / 0.0179, 0.0133, 0.0055, 0.0040/
      data nebin3 / 0.0155, 0.0105, 0.0047, 0.0037/
      data nebin4 / 0.0310, 0.0236, 0.0097, 0.0059/
      data nebin5 / 0.0257, 0.0161, 0.0076, 0.0062/
      data nebin6 / 0.0347, 0.0275, 0.0100, 0.0138/
      data nebin7 / 0.0272, 0.0192, 0.0095, 0.0055/
      data nebin8 / 0.0227, 0.0168, 0.0082, 0.0034/
      data nebin9 / 0.0362, 0.0274, 0.0116, 0.0133/
      data nebin10 / 0.0255, 0.0187, 0.0091, 0.0090/
      data nebin11 / 0.0497, 0.0365, 0.0165, 0.0283/
      data nebin12 / 0.0297, 0.0260, 0.0114, 0.0112/
*
*
* Data points from plots
*
*
      IF (iflag.eq.1) then
*
*      Initialisation: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (i) make subdirectory in o/p file
*
       nentry=0
       Call hcdir('//PAWC',' ')
       call hmdir(xxxx,'S')
       Call hcdir('//HISTO',' ')
       call hmdir(xxxx,'S')
*
*      book your histograms
*

* *** For the proton data points ***
      xlow =580./820.
      xhigh=740./820.

      CALL HBOOK1(101,'proton x?L!',4,xlow,xhigh,0.)
      CALL HBOOK1(102,'proton x?L!',4,xlow,xhigh,0.)
      CALL HBOOK1(103,'proton x?L!',4,xlow,xhigh,0.)
      CALL HBOOK1(104,'proton x?L!',4,xlow,xhigh,0.)
      CALL HBOOK1(105,'proton x?L!',4,xlow,xhigh,0.)
      CALL HBOOK1(106,'proton x?L!',4,xlow,xhigh,0.)
      CALL HBOOK1(107,'proton x?L!',4,xlow,xhigh,0.)
      CALL HBOOK1(108,'proton x?L!',4,xlow,xhigh,0.)
      CALL HBOOK1(109,'proton x?L!',4,xlow,xhigh,0.)
      CALL HBOOK1(110,'proton x?L!',4,xlow,xhigh,0.)
      CALL HBOOK1(111,'proton x?L!',4,xlow,xhigh,0.)
      CALL HBOOK1(112,'proton x?L!',4,xlow,xhigh,0.)

* *** For the proton Monte Carlo prediction ***
      CALL HBOOK1(201,'proton x?L!',50,0.,1.,0.)
      CALL HBOOK1(202,'proton x?L!',50,0.,1.,0.)
      CALL HBOOK1(203,'proton x?L!',50,0.,1.,0.)
      CALL HBOOK1(204,'proton x?L!',50,0.,1.,0.)
      CALL HBOOK1(205,'proton x?L!',50,0.,1.,0.)
      CALL HBOOK1(206,'proton x?L!',50,0.,1.,0.)
      CALL HBOOK1(207,'proton x?L!',50,0.,1.,0.)
      CALL HBOOK1(208,'proton x?L!',50,0.,1.,0.)
      CALL HBOOK1(209,'proton x?L!',50,0.,1.,0.)
      CALL HBOOK1(210,'proton x?L!',50,0.,1.,0.)
      CALL HBOOK1(211,'proton x?L!',50,0.,1.,0.)
      CALL HBOOK1(212,'proton x?L!',50,0.,1.,0.)

* *** For the neutron data points ***
      CALL HBOOK1(301,'neutron x?L!',4,0.2,1.,0.)
      CALL HBOOK1(302,'neutron x?L!',4,0.2,1.,0.)
      CALL HBOOK1(303,'neutron x?L!',4,0.2,1.,0.)
      CALL HBOOK1(304,'neutron x?L!',4,0.2,1.,0.)
      CALL HBOOK1(305,'neutron x?L!',4,0.2,1.,0.)
      CALL HBOOK1(306,'neutron x?L!',4,0.2,1.,0.)
      CALL HBOOK1(307,'neutron x?L!',4,0.2,1.,0.)
      CALL HBOOK1(308,'neutron x?L!',4,0.2,1.,0.)
      CALL HBOOK1(309,'neutron x?L!',4,0.2,1.,0.)
      CALL HBOOK1(310,'neutron x?L!',4,0.2,1.,0.)
      CALL HBOOK1(311,'neutron x?L!',4,0.2,1.,0.)
      CALL HBOOK1(312,'neutron x?L!',4,0.2,1.,0.)

* *** For the neutron Monte Carlo prediction ***

      CALL HBOOK1(401,'neutron x?L!',50,0.,1.,0.)
      CALL HBOOK1(402,'neutron x?L!',50,0.,1.,0.)
      CALL HBOOK1(403,'neutron x?L!',50,0.,1.,0.)
      CALL HBOOK1(404,'neutron x?L!',50,0.,1.,0.)
      CALL HBOOK1(405,'neutron x?L!',50,0.,1.,0.)
      CALL HBOOK1(406,'neutron x?L!',50,0.,1.,0.)
      CALL HBOOK1(407,'neutron x?L!',50,0.,1.,0.)
      CALL HBOOK1(408,'neutron x?L!',50,0.,1.,0.)
      CALL HBOOK1(409,'neutron x?L!',50,0.,1.,0.)
      CALL HBOOK1(410,'neutron x?L!',50,0.,1.,0.)
      CALL HBOOK1(411,'neutron x?L!',50,0.,1.,0.)
      CALL HBOOK1(412,'neutron x?L!',50,0.,1.,0.)

* *** FILL THE HISTOGRAMS WITH THE DATA POINTS ***
      CALL HPAK(101,PBIN1)
      CALL HPAK(102,PBIN2)
      CALL HPAK(103,PBIN3)
      CALL HPAK(104,PBIN4)
      CALL HPAK(105,PBIN5)
      CALL HPAK(106,PBIN6)
      CALL HPAK(107,PBIN7)
      CALL HPAK(108,PBIN8)
      CALL HPAK(109,PBIN9)
      CALL HPAK(110,PBIN10)
      CALL HPAK(111,PBIN11)
      CALL HPAK(112,PBIN12)

      CALL HPAKE(101,PEBIN1)
      CALL HPAKE(102,PEBIN2)
      CALL HPAKE(103,PEBIN3)
      CALL HPAKE(104,PEBIN4)
      CALL HPAKE(105,PEBIN5)
      CALL HPAKE(106,PEBIN6)
      CALL HPAKE(107,PEBIN7)
      CALL HPAKE(108,PEBIN8)
      CALL HPAKE(109,PEBIN9)
      CALL HPAKE(110,PEBIN10)
      CALL HPAKE(111,PEBIN11)
      CALL HPAKE(112,PEBIN12)

      CALL HPAK(301,NBIN1)
      CALL HPAK(302,NBIN2)
      CALL HPAK(303,NBIN3)
      CALL HPAK(304,NBIN4)
      CALL HPAK(305,NBIN5)
      CALL HPAK(306,NBIN6)
      CALL HPAK(307,NBIN7)
      CALL HPAK(308,NBIN8)
      CALL HPAK(309,NBIN9)
      CALL HPAK(310,NBIN10)
      CALL HPAK(311,NBIN11)
      CALL HPAK(312,NBIN12)

      CALL HPAKE(301,NEBIN1)
      CALL HPAKE(302,NEBIN2)
      CALL HPAKE(303,NEBIN3)
      CALL HPAKE(304,NEBIN4)
      CALL HPAKE(305,NEBIN5)
      CALL HPAKE(306,NEBIN6)
      CALL HPAKE(307,NEBIN7)
      CALL HPAKE(308,NEBIN8)
      CALL HPAKE(309,NEBIN9)
      CALL HPAKE(310,NEBIN10)
      CALL HPAKE(311,NEBIN11)
      CALL HPAKE(312,NEBIN12)

      Else if(iflag.eq.2) then
*      Filling: The following MUST always be done
*      (i) move to the correct sub-directory in PAWC
*
       call hcdir('//PAWC/'//xxxx,' ')

       q2 = real(hzdiskin(1))
       x  = real(hzdiskin(2))

       enel=0.
       enep=0.
       ierr=HZIBEAM(ibeam,ilep)
       if(ierr.ne.1) then
          write(6,*) 'HZ'//xxxx,' beams not found ! '
          return
        else
          enel=real(PHEP(4,ilep))
          enep=real(PHEP(4,ibeam))
        endif

        if(abs(enel-27.5).ge.0.2.or.abs(enep-820.0).ge.0.2) then
           nentry=nentry+1
           if(nentry.lt.5) then
             write(6,*)'HZ'//xxxx,' Beam Energies not correct!!',
     &       enel,enep
             return
           elseif(nentry.eq.5) then
             write(6,*)'HZ'//xxxx,
     &       ' Beam Energies not correct - Last Message!!'
             return
           else
             return
           endif
        endif

*
*       Fill the histograms
*
        do 10 ihep = 1, nhep
          if (isthep(ihep).ne.1.or.ihep.eq.ibeam) goto 10

          pt=real(dsqrt(PHEP(1,IHEP)**2+PHEP(2,IHEP)**2))
          if(pt.gt.0.2) goto 10

* *** FILL PROTON HISTOGRAMS ***
          if (idhep(ihep).eq.2212) then

              IF(Q2.GE.2.AND.Q2.LT.3.5.AND.X.GE.0.00006.AND.
     *           X.LT.0.00018) THEN
                 CALL HFILL(201,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.2.AND.Q2.LT.3.5.AND.X.GE.0.00018.AND.
     *           X.LT.0.00060) THEN
                 CALL HFILL(202,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.2.AND.Q2.LT.3.5.AND.X.GE.0.00060.AND.
     *           X.LT.0.0018) THEN
                 CALL HFILL(203,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.3.5.AND.Q2.LT.6.0.AND.X.GE.0.00018.AND.
     *           X.LT.0.00060) THEN
                 CALL HFILL(204,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.3.5.AND.Q2.LT.6.0.AND.X.GE.0.00060.AND.
     *           X.LT.0.0018) THEN
                 CALL HFILL(205,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.6.0.AND.Q2.LT.10.0.AND.X.GE.0.00018.AND.
     *           X.LT.0.00060) THEN
                 CALL HFILL(206,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.6.0.AND.Q2.LT.10.0.AND.X.GE.0.00060.AND.
     *           X.LT.0.0018) THEN
                 CALL HFILL(207,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.6.0.AND.Q2.LT.10.0.AND.X.GE.0.0018.AND.
     *           X.LT.0.0060) THEN
                 CALL HFILL(208,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.10.0.AND.Q2.LT.20.0.AND.X.GE.0.00060.AND.
     *           X.LT.0.0018) THEN
                 CALL HFILL(209,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.10.0.AND.Q2.LT.20.0.AND.X.GE.0.0018.AND.
     *           X.LT.0.0060) THEN
                 CALL HFILL(210,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.20.0.AND.Q2.LT.50.0.AND.X.GE.0.00060.AND.
     *           X.LT.0.0018) THEN
                 CALL HFILL(211,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.20.0.AND.Q2.LT.50.0.AND.X.GE.0.0018.AND.
     *           X.LT.0.0060) THEN
                 CALL HFILL(212,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

          endif

* *** FILL NEUTRON HISTOGRAMS ***
          if (idhep(ihep).eq.2112) then

              IF(Q2.GE.2.AND.Q2.LT.3.5.AND.X.GE.0.00006.AND.
     *           X.LT.0.00018) THEN
                 CALL HFILL(401,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.2.AND.Q2.LT.3.5.AND.X.GE.0.00018.AND.
     *           X.LT.0.00060) THEN
                 CALL HFILL(402,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.2.AND.Q2.LT.3.5.AND.X.GE.0.00060.AND.
     *           X.LT.0.0018) THEN
                 CALL HFILL(403,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.3.5.AND.Q2.LT.6.0.AND.X.GE.0.00018.AND.
     *           X.LT.0.00060) THEN
                 CALL HFILL(404,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.3.5.AND.Q2.LT.6.0.AND.X.GE.0.00060.AND.
     *           X.LT.0.0018) THEN
                 CALL HFILL(405,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.6.0.AND.Q2.LT.10.0.AND.X.GE.0.00018.AND.
     *           X.LT.0.00060) THEN
                 CALL HFILL(406,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.6.0.AND.Q2.LT.10.0.AND.X.GE.0.00060.AND.
     *           X.LT.0.0018) THEN
                 CALL HFILL(407,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.6.0.AND.Q2.LT.10.0.AND.X.GE.0.0018.AND.
     *           X.LT.0.0060) THEN
                 CALL HFILL(408,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.10.0.AND.Q2.LT.20.0.AND.X.GE.0.00060.AND.
     *           X.LT.0.0018) THEN
                 CALL HFILL(409,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.10.0.AND.Q2.LT.20.0.AND.X.GE.0.0018.AND.
     *           X.LT.0.0060) THEN
                 CALL HFILL(410,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.20.0.AND.Q2.LT.50.0.AND.X.GE.0.00060.AND.
     *           X.LT.0.0018) THEN
                 CALL HFILL(411,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

              IF(Q2.GE.20.0.AND.Q2.LT.50.0.AND.X.GE.0.0018.AND.
     *           X.LT.0.0060) THEN
                 CALL HFILL(412,real(PHEP(4,IHEP)/PHEP(4,IBEAM)),0.,1.)
              ENDIF

          endif

 10     continue
*
      Else if(iflag.eq.3) then
*      Termination: The following MUST always be done
*      (i) Move to the correct PAW subdirectory
*
       call hcdir('//PAWC/'//xxxx,' ')
*
*      Histo manipulation
*
      rsec=REAL(XSEC)/1000.0

      SCALE1 = RSEC/NTOT/0.02/46.34171
      SCALE2 = RSEC/NTOT/0.02/61.27304
      SCALE3 = RSEC/NTOT/0.02/59.57490
      SCALE4 = RSEC/NTOT/0.02/31.85264
      SCALE5 = RSEC/NTOT/0.02/32.39826
      SCALE6 = RSEC/NTOT/0.02/16.07404
      SCALE7 = RSEC/NTOT/0.02/17.52318
      SCALE8 = RSEC/NTOT/0.02/20.34958
      SCALE9 = RSEC/NTOT/0.02/12.28553
      SCALE10= RSEC/NTOT/0.02/14.92930
      SCALE11= RSEC/NTOT/0.02/6.23943
      SCALE12= RSEC/NTOT/0.02/8.44929

      call hopera(201,'+',201,201,0.,SCALE1)
      call hopera(202,'+',202,202,0.,SCALE2)
      call hopera(203,'+',203,203,0.,SCALE3)
      call hopera(204,'+',204,204,0.,SCALE4)
      call hopera(205,'+',205,205,0.,SCALE5)
      call hopera(206,'+',206,206,0.,SCALE6)
      call hopera(207,'+',207,207,0.,SCALE7)
      call hopera(208,'+',208,208,0.,SCALE8)
      call hopera(209,'+',209,209,0.,SCALE9)
      call hopera(210,'+',210,210,0.,SCALE10)
      call hopera(211,'+',211,211,0.,SCALE11)
      call hopera(212,'+',212,212,0.,SCALE12)

      call hopera(401,'+',401,401,0.,SCALE1)
      call hopera(402,'+',402,402,0.,SCALE2)
      call hopera(403,'+',403,403,0.,SCALE3)
      call hopera(404,'+',404,404,0.,SCALE4)
      call hopera(405,'+',405,405,0.,SCALE5)
      call hopera(406,'+',406,406,0.,SCALE6)
      call hopera(407,'+',407,407,0.,SCALE7)
      call hopera(408,'+',408,408,0.,SCALE8)
      call hopera(409,'+',409,409,0.,SCALE9)
      call hopera(410,'+',410,410,0.,SCALE10)
      call hopera(411,'+',411,411,0.,SCALE11)
      call hopera(412,'+',412,412,0.,SCALE12)

*      Deal with data plots
*
      Endif
*
      RETURN
*
      END
*CMZ :  1.02/08 01/04/99  20.58.49  by  Tancredi Carli
*CMZ :  1.02/06 03/03/99  19.27.54  by  Tancredi Carli
*CMZ :  0.00/03 16/11/98  23.44.07  by  Tancredi Carli
*-- Author :    Tancredi Carli   23/10/98
      subroutine hz98210 (iflag)
**********************************************************************
* Running: Ee=27.5(positrons), Ep=820, no polarization
*
* purpose: produce histograms for:
*
*          INTEGRATED JET SHAPE (psi) in Breit frame
*          (using different jetfinders, in bins of Et(jet) and eta(jet))
*       &
*          SUBJET MULTIPLICITIES in Breit frame
*          (using KTCLUS, in bins of Et(jet) and eta(jet))
*
*
*          event selection:
*            i)    energy of scattered lepton >  11 GeV
*            ii)   156 < polar scattering angle of lepton < 173
*            iii)  y > 0.15
*            iv)   Q**2 > 10 GeV**2
*
*          jet selection:
*            Ji)   number of jets >= 2
*            only the two jets with highest Et are considered
*            Jii)  for both jets: Et(jet) in Breit frame > 5 GeV
*            Jiii) for both jets: -1 < eta(jet) in lab. frame < 2
*
*          used Jetalgorithms:
*            Jetfinder 1: KTCLUS
*            Jetfinder 2: PXCONE with cone radius = 1.0
*            Jetfinder 3: PXCONE with cone radius = 0.7
*
*          Et-binning:
*            Et bin 1:   5 GeV < Et(jet) in Breit frame < 8 GeV
*            Et bin 2:   Et(jet) in Breit frame > 8 GeV
*          eta-binning:
*            eta bin 1:  eta(jet) in Breit frame < 1.5
*            eta bin 2:  1.5 < eta(jet) in Breit frame < 2.2
*            eta bin 3:  eta(jet) in Breit frame > 2.2
*
*
* produced histos:
*
*          MC histos for subjet multiplicities:
*             id = 120+(Etbin-1)*10+etabin
*          MC histos for integrated jet shapes:
*             id = 100*jetfinder+Etbin*10+etabin
*
*          Histos with H1 data have corresponding negative numbers plus
*             offset = 0:      for combined errors
*             offset = -1000:  for statistical errors only
*             offset = -2000:  for systematical errors only
*
* arguments: iflag=1 initialisation
*            iflag=2 filling
*            iflag=3 termination
*
* comments:   - be careful with (Snowmass) convention with massive hadrons
*             (Et not exactly equal to pt); this subroutine uses the pt-scheme
*             - with the definition of the integrated jet shape psi in
*             the referenced paper, psi(r/R=1) is in general not equal to 1
*
* structure:  called subroutines and functions:
*             from hbook lib:  hcdir,hmdir,hbookb,hbook1,
*                              hpak,hpake,hfill,hbarx
*             from HzTool lib: HzSvhepc, HzRchepc, HzBrtini, HzBrt,
*                              HzJtfind, HzBrtoLa, HzSubjm, HzJetshp,
*                              HzMeanHi, HzHinfo
*                              HzDiskin,HzIdelec,HzTheta, HzIbeam,
*                              HzIpgam
*             and some subroutines contained in this file
*
* written by: Andreas von Manteuffel
*
* reference:  'Untersuchung interner Jet-Struktur in tiefinelastischer
*              Streuung im H1-Experiment', Lars Sonnenschein,
*              III. Physikalisches Institut der Technischen Hochschule
*              Aachen, March 1998 (PITHA 98/4)
*
**********************************************************************
      IMPLICIT NONE
**********************************************************************
*     DECLARATIONS for HzTool stuff
**********************************************************************
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZJETCMN.
*
*     MAXHZJETS: maxmial number of jet allowed
*     NUMJETS: number of jets from jet algo
*     NSEL  : number of selected jets
*     IPJET : pointer to selected jets
*     JETS  : Jet variables (eta,phi,et,e,px,py,pz,m) in choosen frame
*     IJETNO: pointer which objects in PHEP common belong to jets
*
      INTEGER MAXHZJETS
      PARAMETER (MAXHZJETS=50)
      INTEGER NSEL,NUMJETS,IPJET(MAXHZJETS),IJETNO(NMXHEP)
      DOUBLE PRECISION JETS(MAXHZJETS,8)
*
      COMMON /HZJETCMN/JETS,NUMJETS,NSEL,IPJET,IJETNO
*
*
*KEND.
*********************************************************************
*     DECLARATIONS for H1 histos
*********************************************************************
*
* jet shape and subjet multiplicity variables for H1 data:
      Real rtoRbins(11)
*
      Real psiA1a(10), psiaA1a(10), psiyA1a(10)
      Real psiA1b(10), psiaA1b(10), psiyA1b(10)
      Real psiA1c(10), psiaA1c(10), psiyA1c(10)
      Real psiA2a(10), psiaA2a(10), psiyA2a(10)
      Real psiA2b(10), psiaA2b(10), psiyA2b(10)
      Real psiA2c(10), psiaA2c(10), psiyA2c(10)

      Real psiB1a(10), psiaB1a(10), psiyB1a(10)
      Real psiB1b(10), psiaB1b(10), psiyB1b(10)
      Real psiB1c(10), psiaB1c(10), psiyB1c(10)
      Real psiB2a(10), psiaB2a(10), psiyB2a(10)
      Real psiB2b(10), psiaB2b(10), psiyB2b(10)
      Real psiB2c(10), psiaB2c(10), psiyB2c(10)

      Real psiC1a(10), psiaC1a(10), psiyC1a(10)
      Real psiC1b(10), psiaC1b(10), psiyC1b(10)
      Real psiC1c(10), psiaC1c(10), psiyC1c(10)
      Real psiC2a(10), psiaC2a(10), psiyC2a(10)
      Real psiC2b(10), psiaC2b(10), psiyC2b(10)
      Real psiC2c(10), psiaC2c(10), psiyC2c(10)

      Real lycutbns(14)

      Real smpl1a(13), smpla1a(13), smply1a(13)
      Real smpl1b(13), smpla1b(13), smply1b(13)
      Real smpl1c(13), smpla1c(13), smply1c(13)
      Real smpl2a(13), smpla2a(13), smply2a(13)
      Real smpl2b(13), smpla2b(13), smply2b(13)
      Real smpl2c(13), smpla2c(13), smply2c(13)


*********************************************************************
*     H1 DATA
*********************************************************************

* H1 integrated jet shape (psi)

* use following 'binning' for r/R in order to get points in histo
* at right positions
      Data rtoRbins  / 0.05, 0.15, 0.25, 0.35, 0.45, 0.55,
     .                 0.65, 0.75, 0.85, 0.95, 1.05 /

* suffix in variable labels mean:

*     A.. : jetfinder KTCLUS
*     B.. : jetfinder PXCONE with cone radius = 1.0
*     C.. : jetfinder PXCONE with cone radius = 0.7

*     .1. : 5 < Et < 8 GeV
*     .2. : Et > 8 GeV

*     ..a : eta < 1.5
*     ..b : 1.5 < eta < 2.2
*     ..c : eta > 2.2


      Data psiA1a  / 0.1503, 0.3612, 0.5539, 0.7003, 0.7998,
     .               0.8658, 0.9139, 0.9430, 0.9654, 0.9803 /
      Data psiaA1a / 0.0078, 0.0094, 0.0086, 0.0070, 0.0053,
     .               0.0038, 0.0028, 0.0020, 0.0015, 0.0010 /
      Data psiyA1a / 0.0159, 0.0188, 0.0165, 0.0092, 0.0090,
     .               0.0073, 0.0044, 0.0033, 0.0032, 0.0026 /

      Data psiA1b  / 0.1188, 0.3289, 0.5188, 0.6552, 0.7627,
     .               0.8398, 0.8965, 0.9361, 0.9609, 0.9753 /
      Data psiaA1b / 0.0085, 0.0116, 0.0108, 0.0091, 0.0069,
     .               0.0052, 0.0039, 0.0027, 0.0019, 0.0014 /
      Data psiyA1b / 0.0120, 0.0172, 0.0178, 0.0125, 0.0106,
     .               0.0075, 0.0058, 0.0051, 0.0034, 0.0036 /

      Data psiA1c  / 0.1474, 0.2832, 0.4644, 0.6170, 0.7317,
     .               0.8232, 0.8917, 0.9345, 0.9587, 0.9762 /
      Data psiaA1c / 0.0110, 0.0109, 0.0106, 0.0091, 0.0073,
     .               0.0054, 0.0040, 0.0030, 0.0022, 0.0016 /
      Data psiyA1c / 0.0275, 0.0201, 0.0207, 0.0155, 0.0120,
     .               0.0092, 0.0071, 0.0058, 0.0051, 0.0050 /

      Data psiA2a  / 0.1888, 0.4392, 0.6265, 0.7475, 0.8306,
     .               0.8804, 0.9174, 0.9449, 0.9644, 0.9799 /
      Data psiaA2a / 0.0109, 0.0121, 0.0104, 0.0083, 0.0064,
     .               0.0047, 0.0036, 0.0027, 0.0019, 0.0013 /
      Data psiyA2a / 0.0252, 0.0188, 0.0179, 0.0126, 0.0134,
     .               0.0116, 0.0070, 0.0066, 0.0031, 0.0018 /

      Data psiA2b  / 0.1317, 0.3946, 0.5829, 0.7107, 0.7983,
     .               0.8638, 0.9078, 0.9397, 0.9610, 0.9763 /
      Data psiaA2b / 0.0083, 0.0120, 0.0105, 0.0083, 0.0064,
     .               0.0047, 0.0035, 0.0027, 0.0019, 0.0013 /
      Data psiyA2b / 0.0094, 0.0153, 0.0181, 0.0140, 0.0096,
     .               0.0085, 0.0077, 0.0049, 0.0042, 0.0039 /

      Data psiA2c  / 0.1934, 0.4649, 0.6076, 0.7178, 0.7946,
     .               0.8524, 0.8986, 0.9292, 0.9557, 0.9710 /
      Data psiaA2c / 0.0124, 0.0138, 0.0111, 0.0087, 0.0065,
     .               0.0050, 0.0037, 0.0029, 0.0022, 0.0016 /
      Data psiyA2c / 0.0178, 0.0297, 0.0193, 0.0150, 0.0113,
     .               0.0084, 0.0069, 0.0070, 0.0037, 0.0029 /


      Data psiB1a  / 0.1260, 0.3150, 0.4868, 0.6247, 0.7301,
     .               0.8093, 0.8726, 0.9221, 0.9653, 0.9999 /
      Data psiaB1a / 0.0063, 0.0080, 0.0080, 0.0072, 0.0062,
     .               0.0051, 0.0040, 0.0029, 0.0019, 0.0001 /
      Data psiyB1a / 0.0081, 0.0150, 0.0151, 0.0167, 0.0122,
     .               0.0089, 0.0072, 0.0053, 0.0035, 0.0001 /

      Data psiB1b  / 0.0905, 0.2554, 0.4075, 0.5527, 0.6641,
     .               0.7501, 0.8331, 0.8970, 0.9527, 0.9994 /
      Data psiaB1b / 0.0065, 0.0090, 0.0094, 0.0091, 0.0078,
     .               0.0064, 0.0051, 0.0036, 0.0022, 0.0002 /
      Data psiyB1b / 0.0118, 0.0158, 0.0151, 0.0172, 0.0131,
     .               0.0158, 0.0169, 0.0124, 0.0042, 0.0006 /

      Data psiB1c  / 0.0841, 0.2483, 0.4068, 0.5375, 0.6648,
     .               0.7585, 0.8343, 0.8984, 0.9543, 0.9995 /
      Data psiaB1c / 0.0064, 0.0096, 0.0102, 0.0094, 0.0087,
     .               0.0071, 0.0059, 0.0044, 0.0026, 0.0003 /
      Data psiyB1c / 0.0137, 0.0316, 0.0305, 0.0248, 0.0251,
     .               0.0198, 0.0152, 0.0092, 0.0060, 0.0004 /

      Data psiB2a  / 0.1792, 0.4149, 0.6091, 0.7270, 0.8132,
     .               0.8694, 0.9121, 0.9478, 0.9753, 0.9998 /
      Data psiaB2a / 0.0100, 0.0120, 0.0108, 0.0088, 0.0073,
     .               0.0056, 0.0042, 0.0030, 0.0018, 0.0001 /
      Data psiyB2a / 0.0187, 0.0177, 0.0136, 0.0117, 0.0110,
     .               0.0104, 0.0070, 0.0054, 0.0020, 0.0002 /

      Data psiB2b  / 0.1378, 0.3891, 0.5800, 0.7030, 0.7915,
     .               0.8587, 0.9062, 0.9419, 0.9765, 0.9997 /
      Data psiaB2b / 0.0080, 0.0108, 0.0101, 0.0089, 0.0074,
     .               0.0056, 0.0042, 0.0030, 0.0016, 0.0001 /
      Data psiyB2b / 0.0093, 0.0134, 0.0146, 0.0130, 0.0096,
     .               0.0074, 0.0056, 0.0048, 0.0022, 0.0003 /

      Data psiB2c  / 0.1666, 0.3841, 0.5429, 0.6472, 0.7308,
     .               0.7995, 0.8617, 0.9080, 0.9568, 0.9990 /
      Data psiaB2c / 0.0104, 0.0118, 0.0109, 0.0094, 0.0081,
     .               0.0066, 0.0050, 0.0037, 0.0021, 0.0002 /
      Data psiyB2c / 0.0158, 0.0183, 0.0172, 0.0131, 0.0108,
     .               0.0088, 0.0068, 0.0051, 0.0044, 0.0005 /


      Data psiC1a  / 0.0996, 0.2627, 0.4326, 0.5817, 0.7006,
     .               0.7791, 0.8559, 0.9191, 0.9661, 1.0000 /
      Data psiaC1a / 0.0066, 0.0096, 0.0100, 0.0092, 0.0077,
     .               0.0065, 0.0050, 0.0035, 0.0022, 0.0001 /
      Data psiyC1a / 0.0116, 0.0176, 0.0213, 0.0174, 0.0144,
     .               0.0115, 0.0081, 0.0059, 0.0030, 0.0002 /

      Data psiC1b  / 0.1047, 0.2640, 0.4167, 0.5540, 0.6813,
     .               0.7562, 0.8342, 0.9005, 0.9601, 0.9995 /
      Data psiaC1b / 0.0092, 0.0121, 0.0124, 0.0115, 0.0102,
     .               0.0086, 0.0066, 0.0047, 0.0028, 0.0005 /
      Data psiyC1b / 0.0168, 0.0271, 0.0281, 0.0290, 0.0253,
     .               0.0222, 0.0174, 0.0065, 0.0052, 0.0002 /

      Data psiC1c  / 0.0779, 0.2146, 0.3714, 0.4924, 0.5953,
     .               0.7070, 0.7926, 0.8846, 0.9457, 1.0000 /
      Data psiaC1c / 0.0078, 0.0110, 0.0120, 0.0111, 0.0100,
     .               0.0087, 0.0072, 0.0054, 0.0032, 0.0001 /
      Data psiyC1c / 0.0123, 0.0200, 0.0307, 0.0197, 0.0190,
     .               0.0243, 0.0188, 0.0103, 0.0059, 0.0007 /

      Data psiC2a  / 0.1799, 0.3720, 0.5477, 0.6899, 0.7859,
     .               0.8499, 0.9006, 0.9369, 0.9707, 0.9996 /
      Data psiaC2a / 0.0131, 0.0141, 0.0134, 0.0118, 0.0089,
     .               0.0068, 0.0054, 0.0040, 0.0023, 0.0000 /
      Data psiyC2a / 0.0228, 0.0170, 0.0153, 0.0138, 0.0110,
     .               0.0099, 0.0063, 0.0044, 0.0040, 0.0004 /

      Data psiC2b  / 0.1155, 0.3333, 0.5338, 0.6572, 0.7586,
     .               0.8444, 0.8911, 0.9402, 0.9746, 1.0000 /
      Data psiaC2b / 0.0089, 0.0129, 0.0124, 0.0105, 0.0087,
     .               0.0066, 0.0051, 0.0033, 0.0021, 0.0000 /
      Data psiyC2b / 0.0144, 0.0177, 0.0183, 0.0144, 0.0113,
     .               0.0099, 0.0072, 0.0067, 0.0037, 0.0003 /

      Data psiC2c  / 0.1646, 0.3922, 0.5781, 0.7067, 0.7898,
     .               0.8430, 0.8968, 0.9372, 0.9715, 1.0000 /
      Data psiaC2c / 0.0129, 0.0159, 0.0144, 0.0119, 0.0098,
     .               0.0077, 0.0060, 0.0042, 0.0024, 0.0000 /
      Data psiyC2c / 0.0230, 0.0226, 0.0293, 0.0312, 0.0221,
     .               0.0152, 0.0099, 0.0080, 0.0041, 0.0001 /


* H1 mean subjet multiplicity (using KTCLUS) vs lg y_cut

* use following 'binning' for log(y_cut) in order to get points
* in histo at right positions
      Data lycutbns  / -3.125, -2.875, -2.625, -2.375,
     .                 -2.125, -1.875, -1.625, -1.375,
     .                 -1.125, -0.875, -0.625, -0.375,
     .                 -0.125,  0.125 /


* suffix in variable labels mean:

*     .1. : 5 < Et < 8 GeV
*     .2. : Et > 8 GeV

*     ..a : eta < 1.5
*     ..b : 1.5 < eta < 2.2
*     ..c : eta > 2.2


      Data smpl1a  / 4.144, 3.602, 3.155, 2.750, 2.330,
     .               1.932, 1.611, 1.340, 1.131, 1.012,
     .               1.000, 1.000, 1.000 /
      Data smpla1a / 0.043, 0.038, 0.033, 0.028, 0.024,
     .               0.021, 0.017, 0.015, 0.011, 0.004,
     .               0.000, 0.000, 0.000 /
      Data smply1a / 0.081, 0.088, 0.065, 0.042, 0.039,
     .               0.037, 0.032, 0.032, 0.020, 0.007,
     .               0.000, 0.000, 0.000 /

      Data smpl1b  / 4.374, 3.841, 3.328, 2.830, 2.391,
     .               2.029, 1.698, 1.391, 1.144, 1.025,
     .               1.000, 1.000, 1.000 /
      Data smpla1b / 0.054, 0.048, 0.042, 0.035, 0.030,
     .               0.026, 0.022, 0.020, 0.015, 0.005,
     .               0.000, 0.000, 0.000 /
      Data smply1b / 0.112, 0.085, 0.077, 0.070, 0.051,
     .               0.043, 0.054, 0.036, 0.032, 0.012,
     .               0.000, 0.000, 0.000 /

      Data smpl1c  / 4.589, 3.930, 3.400, 2.957, 2.451,
     .               2.082, 1.788, 1.440, 1.186, 1.042,
     .               1.000, 1.000, 1.000 /
      Data smpla1c / 0.052, 0.046, 0.041, 0.035, 0.031,
     .               0.027, 0.024, 0.021, 0.016, 0.007,
     .               0.000, 0.000, 0.000 /
      Data smply1c / 0.078, 0.067, 0.071, 0.053, 0.053,
     .               0.041, 0.039, 0.030, 0.025, 0.018,
     .               0.000, 0.000, 0.000 /

      Data smpl2a  / 4.143, 3.593, 3.114, 2.611, 2.126,
     .               1.733, 1.458, 1.220, 1.065, 1.005,
     .               1.000, 1.000, 1.000 /
      Data smpla2a / 0.056, 0.047, 0.042, 0.035, 0.030,
     .               0.025, 0.021, 0.017, 0.011, 0.005,
     .               0.000, 0.000, 0.000 /
      Data smply2a / 0.086, 0.083, 0.069, 0.078, 0.065,
     .               0.039, 0.035, 0.025, 0.014, 0.008,
     .               0.000, 0.000, 0.000 /

      Data smpl2b  / 4.480, 3.759, 3.179, 2.690, 2.232,
     .               1.893, 1.529, 1.302, 1.082, 1.000,
     .               1.000, 1.000, 1.000 /
      Data smpla2b / 0.053, 0.046, 0.041, 0.036, 0.030,
     .               0.026, 0.022, 0.019, 0.012, 0.004,
     .               0.000, 0.000, 0.000 /
      Data smply2b / 0.087, 0.076, 0.058, 0.054, 0.042,
     .               0.044, 0.032, 0.028, 0.020, 0.009,
     .               0.000, 0.000, 0.000 /

      Data smpl2c  / 4.424, 3.767, 3.187, 2.655, 2.192,
     .               1.796, 1.499, 1.275, 1.091, 1.000,
     .               1.000, 1.000, 1.000 /
      Data smpla2c / 0.055, 0.049, 0.044, 0.038, 0.031,
     .               0.026, 0.022, 0.019, 0.013, 0.005,
     .               0.000, 0.000, 0.000 /
      Data smply2c / 0.081, 0.087, 0.080, 0.054, 0.054,
     .               0.059, 0.037, 0.028, 0.022, 0.014,
     .               0.000, 0.000, 0.000 /

*********************************************************************
*     DECLARATIONS for MC histos
*********************************************************************

* function declaration
      integer getBinNo

*     variable names: i.... -> integer
*                     d.... -> double precision
*                     c.... -> character
*                     no special prefix -> real

* constants
      Real PI,RD
      Parameter (PI=3.1415927,RD=180./PI)

* other variables

      Character*8 cxxxx
      Data cxxxx/'hz98210'/

      Logical lp
      Integer iid, iEtbin, ietabin, iycut
      Integer ilept, ierr, ibeam, idum, imu, ijf, ijetfid, ijt
      Integer ihad, ir, ieta, iEt, iflag, iNhad, icount
      Integer isubjm(13)

      Character*80 chtitl
      Character*10 rout
      Data rout/'**hzjtshap'/
      Real y, Q2, thetae
      Real N(3,2,3), EtBins(2), etaBins(2)
      Real EtBrt (2), etaBrt (2), etaLab (2)
      Real ycut(13)
      Double Precision dpLab (4), dpBrt (4)
      Double Precision dpBeam(4), dpGam(4), dp5(5)
      Double Precision dconeR
      Double Precision djetsBrt (MAXHZJETS, 8)
      Double Precision djetsLab (MAXHZJETS, 8)
      Double Precision djshpRho(10,MAXHZJETS)
      Double Precision djshpPsi(10,MAXHZJETS)
      Double Precision dsubjmpl
      Double Precision drtoRval(10), dlycutvl(13)


* save contents
      save cxxxx
      save N, drtoRval, dlycutvl, ycut, EtBins, etaBins, lp

* settings
      Data lp /.false./
      Data EtBins / 5., 8. /
      Data etaBins / 1.5, 2.2 /

*   for histo filling:
      Data drtoRval  / 0.1D0, 0.2D0, 0.3D0, 0.4D0, 0.5D0,
     .                 0.6D0, 0.7D0, 0.8D0, 0.9D0, 1.0D0 /

*     note: lycutsm = lg y_cut
      Data dlycutvl / -3.00D0, -2.75D0, -2.50D0, -2.25D0,
     .                -2.00D0, -1.75D0, -1.50D0, -1.25D0,
     .                -1.00D0, -0.75D0, -0.50D0, -0.25D0,
     .                 0.00D0 /
      Data ycut / 1.E-3, 1.7782794E-3, 3.1622777E-3, 5.6234133E-3,
     .            1.E-2, 1.7782794E-2, 3.1622777E-2, 5.6234133E-2,
     .            1.E-1, 1.7782794E-1, 3.1622777E-1, 5.6234133E-1,
     .            1. /


*********************************************************************
*
*                      Initialization
*
*********************************************************************


*

      if (iflag.eq.1) then
*
*
*      Initialisation: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (ii) make subdirectory in o/p file
*

         call hcdir('//PAWC',' ')
         call hmdir(cxxxx,'S')
         call hcdir('//HISTO',' ')
         call hmdir(cxxxx,'S')

         write (6,*) '****************************************'
         write (6,*) ' Hz',cxxxx,' initialization step'
         write (6,*) '****************************************'

*
* remind:
*     HistoIDs:  ID < 0  for H1 data
*                ID > 0  for corresponding generator histos
*               |ID| = i        for combined errors
*               |ID| = 1000 + i  for statist. errors only
*               |ID| = 2000 + i  for system. errors only
*
*

* build up H1-histos and prepare MC-histos

* KTCLUS
*     integrated jet shape psi
         write(chtitl,*)
     .        'Psi Breit (KTCLUS, 5.lt.Et.lt.8, eta.lt.1.5)'
         call H1Histo(111,chtitl,10,rtoRbins,psiA1a,psiaA1a,psiyA1a)
         call MCpsiHi(111,chtitl)
         write(chtitl,*)
     .        'Psi Breit (KTCLUS, 5.lt.Et.lt.8, 1.5.lt.eta.lt.2.2)'
         call H1Histo(112,chtitl,10,rtoRbins,psiA1b,psiaA1b,psiyA1b)
         call MCpsiHi(112,chtitl)
         write(chtitl,*)
     .        'Psi Breit (KTCLUS, 5.lt.Et.lt.8, 2.2.lt.eta)'
         call H1Histo(113,chtitl,10,rtoRbins,psiA1c,psiaA1c,psiyA1c)
         call MCpsiHi(113,chtitl)
         write(chtitl,*)
     .        'Psi Breit (KTCLUS, 8.lt.Et, eta.lt.1.5)'
         call H1Histo(121,chtitl,10,rtoRbins,psiA2a,psiaA2a,psiyA2a)
         call MCpsiHi(121,chtitl)
         write(chtitl,*)
     .        'Psi Breit (KTCLUS, 8.lt.Et, 1.5.lt.eta.lt.2.2)'
         call H1Histo(122,chtitl,10,rtoRbins,psiA2b,psiaA2b,psiyA2b)
         call MCpsiHi(122,chtitl)
         write(chtitl,*)
     .        'Psi Breit (KTCLUS, 8.lt.Et, 2.2.lt.eta)'
         call H1Histo(123,chtitl,10,rtoRbins,psiA2c,psiaA2c,psiyA2c)
         call MCpsiHi(123,chtitl)
*     subjet multiplicity
         write(chtitl,*) 'mean N(subjet) vs log(ycut) in Breit fr.'//
     .                   '(5.lt.Et.lt.8,eta.lt.1.5)'
         call H1Histo(131,chtitl,13,lycutbns,smpl1a,smpla1a,smply1a)
         call MCsmHi(131,chtitl)
         write(chtitl,*) 'mean N(subjet) vs log(ycut) in Breit fr.'//
     .                   '(5.lt.Et.lt.8, 1.5.lt.eta.lt.2.2)'
         call H1Histo(132,chtitl,13,lycutbns,smpl1b,smpla1b,smply1b)
         call MCsmHi(132,chtitl)
         write(chtitl,*) 'mean N(subjet) vs log(ycut) in Breit fr.'//
     .                   '(5.lt.Et.lt.8, 2.2.lt.eta)'
         call H1Histo(133,chtitl,13,lycutbns,smpl1c,smpla1c,smply1c)
         call MCsmHi(133,chtitl)
         write(chtitl,*) 'mean N(subjet) vs log(ycut) in Breit fr.'//
     .                   '(8.lt.Et, eta.lt.1.5)'
         call H1Histo(141,chtitl,13,lycutbns,smpl2a,smpla2a,smply2a)
         call MCsmHi(141,chtitl)
         write(chtitl,*) 'mean N(subjet) vs log(ycut) in Breit fr.'//
     .                   '(8.lt.Et, 1.5.lt.eta.lt.2.2)'
         call H1Histo(142,chtitl,13,lycutbns,smpl2b,smpla2b,smply2b)
         call MCsmHi(142,chtitl)
         write(chtitl,*) 'mean N(subjet) vs log(ycut) in Breit fr.'//
     .                   '(8.lt.Et, 2.2.lt.eta)'
         call H1Histo(143,chtitl,13,lycutbns,smpl2c,smpla2c,smply2c)
         call MCsmHi(143,chtitl)

* PXCONE with cone radius = 1.0
         write(chtitl,*)
     .       'Psi Breit (PXCONE(R=1.0), 5.lt.Et.lt.8, eta.lt.1.5)'
         call H1Histo(211,chtitl,10,rtoRbins,psiB1a,psiaB1a,psiyB1a)
         call MCpsiHi(211,chtitl)
         write(chtitl,*)
     .    'Psi Breit (PXCONE(R=1.0), 5.lt.Et.lt.8, 1.5.lt.eta.lt.2.2)'
         call H1Histo(212,chtitl,10,rtoRbins,psiB1b,psiaB1b,psiyB1b)
         call MCpsiHi(212,chtitl)
         write(chtitl,*)
     .       'Psi Breit (PXCONE(R=1.0), 5.lt.Et.lt.8, 2.2.lt.eta)'
         call H1Histo(213,chtitl,10,rtoRbins,psiB1c,psiaB1c,psiyB1c)
         call MCpsiHi(213,chtitl)
         write(chtitl,*)
     .       'Psi Breit (PXCONE(R=1.0), 8.lt.Et, eta.lt.1.5)'
         call H1Histo(221,chtitl,10,rtoRbins,psiB2a,psiaB2a,psiyB2a)
         call MCpsiHi(221,chtitl)
         write(chtitl,*)
     .       'Psi Breit (PXCONE(R=1.0), 8.lt.Et, 1.5.lt.eta.lt.2.2)'
         call H1Histo(222,chtitl,10,rtoRbins,psiB2b,psiaB2b,psiyB2b)
         call MCpsiHi(222,chtitl)
         write(chtitl,*)
     .       'Psi Breit (PXCONE(R=1.0), 8.lt.Et, 2.2.lt.eta)'
         call H1Histo(223,chtitl,10,rtoRbins,psiB2c,psiaB2c,psiyB2c)
         call MCpsiHi(223,chtitl)

* PXCONE with cone radius = 0.7
         write(chtitl,*)
     .       'Psi Breit (PXCONE(R=0.7), 5.lt.Et.lt.8, eta.lt.1.5)'
         call H1Histo(311,chtitl,10,rtoRbins,psiC1a,psiaC1a,psiyC1a)
         call MCpsiHi(311,chtitl)
         write(chtitl,*)
     .    'Psi Breit (PXCONE(R=0.7), 5.lt.Et.lt.8, 1.5.lt.eta.lt.2.2)'
         call H1Histo(312,chtitl,10,rtoRbins,psiC1b,psiaC1b,psiyC1b)
         call MCpsiHi(312,chtitl)
         write(chtitl,*)
     .       'Psi Breit (PXCONE(R=0.7), 5.lt.Et.lt.8, 2.2.lt.eta)'
         call H1Histo(313,chtitl,10,rtoRbins,psiC1c,psiaC1c,psiyC1c)
         call MCpsiHi(313,chtitl)
         write(chtitl,*)
     .       'Psi Breit (PXCONE(R=0.7), 8.lt.Et, eta.lt.1.5)'
         call H1Histo(321,chtitl,10,rtoRbins,psiC2a,psiaC2a,psiyC2a)
         call MCpsiHi(321,chtitl)
         write(chtitl,*)
     .       'Psi Breit (PXCONE(R=0.7), 8.lt.Et, 1.5.lt.eta.lt.2.2)'
         call H1Histo(322,chtitl,10,rtoRbins,psiC2b,psiaC2b,psiyC2b)
         call MCpsiHi(322,chtitl)
         write(chtitl,*)
     .       'Psi Breit (PXCONE(R=0.7), 8.lt.Et, 2.2.lt.eta)'
         call H1Histo(323,chtitl,10,rtoRbins,psiC2c,psiaC2c,psiyC2c)
         call MCpsiHi(323,chtitl)

* prepare control histos

         write(chtitl,*) 'dn/dQ2 in lab. fr. - control plot'
         call hbook1(1, chtitl, 100, 0., 10000., 0.)
         call hbarx(1)

         write(chtitl,*) 'dn/dEe in lab. fr. - control plot'
         call hbook1(2, chtitl, 100, 0., 100., 0.)
         call hbarx(2)

         write(chtitl,*) 'dn/dthetae in lab. fr. - control plot'
         call hbook1(3, chtitl, 50, 0., 180., 0.)
         call hbarx(3)

         write(chtitl,*) 'dn/dy in lab. fr. - control plot'
         call hbook1(4, chtitl, 100, 0., 1., 0.)
         call hbarx(4)

         write(chtitl,*) 'dn/dEt(jet) in Breit fr. - control plot'
         call hbook1(5, chtitl, 20, 0., 20., 0.)
         call hbarx(5)

         write(chtitl,*) 'dn/deta(jet) in lab. fr. - control plot'
         call hbook1(6, chtitl, 20, -4., 4., 0.)
         call hbarx(6)

         write(chtitl,*) 'dn/deta(jet) in Breit fr. - control plot'
         call hbook1(7, chtitl, 20, -4., 4., 0.)
         call hbarx(7)

         write(chtitl,*) 'reached checkpoints - control plot'
         call hbook1(10, chtitl, 50, -0.5, 49.5, 0.)


* init number of jets
         do ijt = 1,3
            do iEt = 1,2
               do ieta = 1,3
                  N(ijt,iEt,ieta) = 0.
               enddo
            enddo
         enddo

*********************************************************************
*
*                      Event Processing
*
*********************************************************************

      else if (iflag.eq.2) then

*      Filling: The following MUST always be done
*      (i) move to the correct sub-directory in PAWC
*
         call hcdir('//PAWC/'//cxxxx,' ')

* first of all: save the HEP event prime common
         call HzSvhepc

****************************************************
* Part A: KINEMATIC CUTS
****************************************************
         call hfill(10,1.,0.,1.)

* get Q2
         Q2 = real(HzDiskin(1))
         if (Q2.le.0.) then
            write(6,*) 'HZ'//cxxxx,' ERROR: unphysical Q2 !!!'
            goto 9990
         endif


*     fill control histo: Q2 distribution
         call hfill(1, Q2, 0., 1.)


* CUT (iv): Q2 > 10 GeV
*----------
         if (Q2.le.10.) goto 9990
         call hfill(10,2.,0.,1.)

* detect scattered lepton
         ilept = HzIdelec(idum)
         if (ilept.eq.-1) then
            write(6,*) 'Hz'//cxxxx,' ERROR: lepton not found !!!'
            goto 9990
         endif

*     fill control histo: lepton energy distribution
         call hfill(2, real(PHEP(4,ilept)), 0., 1.)

* CUT (i): energy of scattered lepton > 11 GeV
*---------
         if (real(PHEP(4,ilept)).le.11.) goto 9990
         call hfill(10,3.,0.,1.)

* get polar angle of scattered lepton
         thetae = RD * real(HzTheta(ilept))
*     fill control histo: polar angle of scattered lepton
         call hfill(3, thetae, 0., 1.)

* CUT (ii): polar angle of scattered lepton within (156, 173)
*----------
         if ((thetae.le.156.).or.(thetae.ge.173.)) goto 9990
         call hfill(10,4.,0.,1.)

* get y
         y = real(HzDiskin(3))

*     fill control histo: y distribution
         call hfill(4, y, 0., 1.)


* CUT (iii):  y > 0.15
*-----------
         if (y.le.0.15) goto 9990
         call hfill(10,5.,0.,1.)


****************************************************
* Part B: BOOST TO BREIT FRAME
****************************************************

* detect beam proton
         ierr = HzIbeam(ibeam,idum)
         if (.not.(ierr.eq.1)) then
            write(6,*) 'HZ'//cxxxx,' ERROR: beams not found ! '
            goto 9990
         else
            do imu = 1, 4
               dpBeam(imu)=PHEP(imu,IBEAM)
            enddo
         endif

* detect virtual boson
         ierr = HzIpgam(dp5)
         if (ierr.eq.-1) then
            write(6,*) 'HZ'//cxxxx,' ERROR: boson vector not found ! '
            goto 9990
         else
            do imu = 1, 4
               dpGam(imu) = dp5(imu)
            enddo
         endif

* init boost to Breit frame
         call HzBrtini (dpBeam, dpGam, ierr)
         if (ierr.eq.-1) then
            write(6,*)
     .          'HZ'//cxxxx,' problem with boost to Breit frame !'
            goto 9990
         endif


* boost to Breit frame

*     loop over particle array
C         if (lp) then
C          write(6,*) rout,' PHEP in LAB: '
C          call hzlihep(2)
C         endif
         do ihad = 1, NHEP
*     skip unstable particles and lepton
            if ((isthep(ihad).eq.1).and.(ihad.ne.ilept)) then
*     perform boost to Breit frame
               do imu = 1, 4
                  dpLab(imu) = PHEP(imu, ihad)
               enddo
               call HzBrt(dpLab, dpBrt, ierr)
               if (ierr.eq.-1) then
                  write(6,*) 'HZ'//cxxxx,
     .                 ' problem with boost to Breit frame ! '
                  goto 9990
               endif
*     overwrite HEP particle array with 4-vectors boosted to Breit frame
               do imu = 1, 4
                  PHEP(imu, ihad) = dpBrt(imu)
               enddo
            endif
         enddo
*
* loop over 3 different jetalgorithms and -settings
*--------------------------------------------------
 3333    continue
C         if (lp) then
C          write(6,*) rout,' PHEP in BREIT: '
C          call hzlihep(2)
C         endif
*
         do 6000 ijf = 1, 3

****************************************************
* Part C: JET FINDING
****************************************************
            call hfill(10,6.,0.,1.)


            if (ijf.eq.1) then
*     KTCLUS
               ijetfid = 3
               dconeR = 1.D0
            elseif (ijf.eq.2) then
*     PXCONE with cone radius = 1.0
               ijetfid = 2
               dconeR = 1.D0
            elseif(ijf.eq.3) then
*     PXCONE with cone radius = 0.7
               ijetfid = 2
               dconeR = 7.D-1
            endif

* jet finding
            call hzjtfind(ijetfid,dconeR,idum,djetsBrt)
            if (lp) then
             write(6,*) rout,' ijet= ',ijetfid
             call hzlijet(numjets,jets)
            endif
****************************************************
* Part D: JET CUTS
****************************************************
* note: jetfinder is assumed to sort jets by Et

* CUT (Ji): number of jets >= 2
*----------
            if (NUMJETS.lt.2) goto 6000
            call hfill(10,7.,0.,1.)


*     get kinematic variables of first two jets
            do ijt = 1,2
               EtBrt(ijt) = real(JETS(ijt,3))
               call hfill(5,EtBrt(ijt),0.,1.)
               etaBrt(ijt) = real(JETS(ijt,1))
               call hfill(7,etaBrt(ijt),0.,1.)
            enddo

* CUT (Jii): there must be two jets with Et > 5 GeV each
*-----------
            if ((EtBrt(1).le.5.).or.(EtBrt(2).le.5.)) goto 6000
            call hfill(10,8.,0.,1.)

* boost jets from Breit to lab. frame
            call hzBrtoLa(2,djetsBrt,djetsLab)
            if (lp) then
             write(6,*) rout,' jets in lab '
             call hzlijet(2,djetsLab)
            endif
* CUT (Jiii): pseudo-rapidity eta of the two jets with highest Et within (-1,2)
*------------
            do ijt = 1,2
              etaLab(ijt)=real(djetsLab(ijt,1))
              call hfill(6,etaLab(ijt),0.,1.)
              if ((etaLab(ijt).le.-1.).or.(etaLab(ijt).ge.2.)) goto 6000
            enddo

            call hfill(10,9.,0.,1.)


*******************************************************************
* Part E: CALCULATION OF PSI, SUBJET MULTIPLICITY AND HISTOFILLING
*******************************************************************

            if (ijf.eq.1) then
*     prepare calculation of subjet multiplicity
               call HzSubjm(1, 0, 13, ycut, isubjm, ierr)
               if (ierr.eq.-1) goto 9990
            endif

*     calculate jet shapes
            call HzJetshp(0, dconeR, djshpRho, djshpPsi, ierr)
            if (ierr.eq.-1) goto 9990

* loop over jets
            do ijt = 1, 2

* get Et bin-no (=1,2) and eta bin-no (=1,2,3)
               iEtbin = getBinNo(1, EtBins, EtBrt(ijt))
               ietaBin = getBinNo(1, etaBins, etaBrt(ijt)) + 1
               if ((iEtbin.lt.1).or.(iEtbin.gt.2).or.
     &             (ietabin.lt.1).or.(ietabin.gt.3)) then
*     note: this should never happen (due to cuts above)
                  write(6,*) 'HZ'//cxxxx, ' ERROR: invalid bin number !'
                  goto 6000
               endif
               call hfill(10,10.+real((iEtbin-1)*3+ietaBin),0.,1.)

* increase normalization constant (no of jets)
               N(ijf,iEtbin,ietabin) = N(ijf,iEtbin,ietabin)+wtx

* fill histo for integrated jet shape
               iid = ijf*100+iEtbin*10+ietabin
               do ir = 1, 10
C                  write(6,*) ir,' x,y= ',drtoRval(ir),djshpPsi(ir,ijt)
                  call HzMeanHi(iid,drtoRval(ir),djshpPsi(ir,ijt),wtx)
               enddo

               if (ijf.eq.1) then
* calculate subjet multiplicity
                  call HzSubjm(2, ijt, 13, ycut, isubjm, ierr)
C                  write(6,*)'subjm(1),(13):',isubjm(1),isubjm(13)
                  if (ierr.eq.-1) goto 9990
* fill histo for subjet multiplicity
                  iid = 120+iEtbin*10+ietabin
C                 write(6,*) ' filling = ',iid
                  do iycut = 1, 13
                     dsubjmpl = dble(isubjm(iycut))
C                     write(6,*) iid,' dly= ',dlycutvl(iycut),'wtx= ',wtx
                     call HzMeanHi(iid,dlycutvl(iycut),dsubjmpl,wtx)
                  enddo
               endif
            enddo
 6000    continue

 9990    continue

* recover the HEP event prime common !
         call HzRchepc

*********************************************************************
*
*                      Termination
*
*********************************************************************

      else if(iflag.eq.3) then

*      Termination: The following MUST always be done
*      (i) Move to the correct PAW subdirectory
*
         call hcdir('//PAWC/'//cxxxx,' ')
         call hfill(10,43.,0.,1.)

         do ijf = 1, 3
          do iEt = 1, 2
           do ieta = 1, 3
              if (N(ijf, iEt, ieta).gt.0.) then
* write number of jets
                 iid = ijf*100+iEt*10+ieta
                 call HzHinfo(iid, N(ijf, iEt, ieta))
                 if (ijf.eq.1) then
                    iid = 120+iEt*10+ieta
                    call HzHinfo(iid, N(ijf, iEt, ieta))
                 endif
*     note: simple chi-square calculation doesn't make sense due
*           to correlations
              endif
           enddo
          enddo
         enddo

      endif

      return

      end
************************************************************************







********************************************
* SUBROUTINES used by subroutine Hz:
********************************************


      subroutine H1Histo (iid, chtitl, incx, xbins, n, ae, ye)
************************************************************************
*     Subroutine H1Histo builds up 3 histos with H1 data:
*       Histo-ID = - id        for combined errors (ce)
*                = - (1000+id)  for statist. errors (ae) only
*                = - (2000+id)  for syst. errros (ye) only
*

      Implicit None

      Integer      iid, incx, i
      Real         n, ae, ye, xbins
      Real         ce(20)
      Character*80 chtitl
      Dimension xbins(incx+1)
      Dimension n(incx)
      Dimension ae(incx)
      Dimension ye(incx)

      do i = 1, incx
         ce(i) = sqrt( ae(i)**2. + ye(i)**2. )
      enddo

      call hbookb(-iid, chtitl, incx, xbins, 0.)
      call hpak(-iid, n)
      call hpake(-iid, ce)

      call hbookb(-1000-iid, chtitl, incx, xbins, 0.)
      call hpak(-1000-iid, n)
      call hpake(-1000-iid, ae)

      call hbookb(-2000-iid, chtitl, incx, xbins, 0.)
      call hpak(-2000-iid, n)
      call hpake(-2000-iid, ye)

      end


      subroutine MCpsiHi (iid, chtitl)
************************************************************************
*     Subroutine MCpsiHi prepares histo for generator events:
*
      Implicit None
      Integer      iid
      Character*80 chtitl
      call hbook1(iid, chtitl, 10, 0.05, 1.05, 0.)
      end


      subroutine MCsmHi (iid, chtitl)
************************************************************************
*     Subroutine MCsmHi prepares histo for generator events:
*
      Implicit None
      Integer      iid
      Character*80 chtitl
      call hbook1(iid, chtitl, 13, -3.125, 0.125, 0.)
      end


      FUNCTION getBinNo(inc, binArr, val)
************************************************************************
      IMPLICIT NONE
      Integer getBinNo, inc, icount
      Real binArr, val
      Dimension binArr(inc+1)

      do icount = 1, (inc+1)
	 if (val.le.binArr(icount)) goto 100
      enddo
 100  continue

      getBinNo = icount - 1

      RETURN
      END

* eof
*CMZ :  1.02/08 02/08/99  15.45.44  by  Tancredi Carli
*-- Author :
      Subroutine HZ99057(iflag)
*****************************************************************************
* This photoproduction routine has to be run twice with the following
* code additions:
*       +1000 for the DIRECT component run.
*       +2000 for the RESOLVED component run.
* for all three phases (iflag=1,2,3)
*
*      +10000 to run on parton showers instead of final state particles.
*
* iflag = 1,2 or 3 depending on wether it is the initialization,
*               processing or termination phase (respectively)
*
* The default jetfinder is KTCLUS
* To change jetfinder use these values to call the initialisation phase.
* 1 + 10 * (jetfinder number)
*
* This routine produces the follwoing Monte Carlo graphs:
* id 10 is d(sigma)/d(eta) in pb for all x_gamma, all y, 2nd jet backward
* id 11 is d(sigma)/d(eta) in pb for all x_gamma, all y, 2nd jet central
* id 12 is d(sigma)/d(eta) in pb for all x_gamma, all y, 2nd jet forward
* id 13 is d(sigma)/d(eta) in pb for high x_gamma, all y, 2nd jet backward
* id 14 is d(sigma)/d(eta) in pb for high x_gamma, all y, 2nd jet central
* id 15 is d(sigma)/d(eta) in pb for high x_gamma, all y, 2nd jet forward
* id 16 is d(sigma)/d(eta) in pb for all x_gamma, high y, 2nd jet backward
* id 17 is d(sigma)/d(eta) in pb for all x_gamma, high y, 2nd jet central
* id 18 is d(sigma)/d(eta) in pb for all x_gamma, high y, 2nd jet forward
* id 19 is d(sigma)/d(eta) in pb for high x_gamma, high y, 2nd jet backward
* id 20 is d(sigma)/d(eta) in pb for high x_gamma, high y, 2nd jet central
* id 21 is d(sigma)/d(eta) in pb for high x_gamma, high y, 2nd jet forward
*
* id 22 is d(sigma)/d(et) in pb for all x_gamma, 1<eta_2<2, 1<eta_1<2
* id 23 is d(sigma)/d(et) in pb for all x_gamma, 0<eta_2<1, 1<eta_1<2
* id 24 is d(sigma)/d(et) in pb for all x_gamma,-1<eta_2<0, 1<eta_1<2
* id 25 is d(sigma)/d(et) in pb for all x_gamma, 0<eta_2<1, 0<eta_1<1
* id 26 is d(sigma)/d(et) in pb for all x_gamma,-1<eta_2<0, 0<eta_1<1
* id 27 is d(sigma)/d(et) in pb for all x_gamma,-1<eta_2<0,-1<eta_1<0
* id 28 is d(sigma)/d(et) in pb for high x_gamma, 1<eta_2<2, 1<eta_1<2
* id 29 is d(sigma)/d(et) in pb for high x_gamma, 0<eta_2<1, 1<eta_1<2
* id 30 is d(sigma)/d(et) in pb for high x_gamma,-1<eta_2<0, 1<eta_1<2
* id 31 is d(sigma)/d(et) in pb for high x_gamma, 0<eta_2<1, 0<eta_1<1
* id 32 is d(sigma)/d(et) in pb for high x_gamma,-1<eta_2<0, 0<eta_1<1
* id 33 is d(sigma)/d(et) in pb for high x_gamma,-1<eta_2<0,-1<eta_1<0
*
*               These graphs will be
*               meaningless unless Xsec and Ntot are set before
*               calling the termination routine.
*               (Xsec - total cross section returned by MC)
*               (Ntot - number of events passed to this routine)
*
*     Note: Since the systematic errors on the data are very asymmetric,
*     they are not included properly on these plots. The lowest (up or
*     down) error is included. The rest should be dealt with seperately
*     in a fitting procedure.
*
*
* Cuts :        Q2 < 1
*               0.2< y_bj < 0.85
*               Depending on graph Et > 11, 14
*
*
* Author : Jon Butterworth (jmb@hep.ucl.ac.uk)
*
* Reference : DESY-99-057
*
*
*
*****************************************************************************
*
* HERA Tuning defined commons

      IMPLICIT NONE

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.

      CHARACTER*6 jetf

      INTEGER NJET
      DOUBLE PRECISION Jets(50,8)
      DOUBLE PRECISION CONER

      DOUBLE PRECISION elecE
      INTEGER i,j,myil,myip
      INTEGER loop,loop2,count
      DOUBLE PRECISION xgam
      DOUBLE PRECISION phi(2),px(2),py(2),pz(2),ptsq(2)
      DOUBLE PRECISION ppsq(2),energy(2),mass(2)
      DOUBLE PRECISION rap(2),Et(2)
      DOUBLE PRECISION ybj,q2

C --- cuts arrays
      DOUBLE PRECISION ybjcut(3),q2cut(2)
      DOUBLE PRECISION rapcut(4),Etcut(5)

C --- private copies of Xsec and Ntot from HERACMN
      DOUBLE PRECISION mhxsec(2),mhntot(2)

C *** Data for all xgamma, all y 2nd jet backwards
      REAL eta10(5),etacr10(5),cresta10(5)
      REAL cresys10(5)
      DATA eta10/-0.25, 0.25, 0.75, 1.25, 1.75/
      DATA etacr10/88., 209., 258., 240., 201./
      DATA cresta10/5., 9., 9., 9., 8./
      DATA cresys10/6.,10.,4.,9.,7./

C *** Data for all xgamma, all y, 2nd jet central
      REAL eta11(6),etacr11(6),cresta11(6)
      REAL cresys11(6)
      DATA eta11/-0.75,-0.25, 0.25, 0.75, 1.25, 1.75/
      DATA etacr11/115.,353., 513., 558., 541., 486./
      DATA cresta11/7., 11., 13., 14., 13.,13./
      DATA cresys11/4.,11.,16.,19.,1.,6./

C *** Data for all xgamma, all y, 2nd jet forward
      REAL eta12(6),etacr12(6),cresta12(6)
      REAL cresys12(6)
      DATA eta12/-0.75,-0.25, 0.25, 0.75, 1.25, 1.75/
      DATA etacr12/113., 328., 479., 549., 416., 358./
      DATA cresta12/6., 11., 12., 14., 12.,11./
      DATA cresys12/10.,7.,4.,1.,9.,12./

C *** Data for high xgamma, all y 2nd jet backwards
      REAL eta13(5),etacr13(5),cresta13(5)
      REAL cresys13(5)
      DATA eta13/-0.25, 0.25, 0.75, 1.25, 1.75/
      DATA etacr13/80., 185., 204., 173., 129./
      DATA cresta13/5., 8., 8., 8., 7./
      DATA cresys13/8.,13.,9.,15.,12./

C *** Data for high xgamma, all y, 2nd jet central
      REAL eta14(6),etacr14(6),cresta14(6)
      REAL cresys14(6)
      DATA eta14/-0.75,-0.25, 0.25, 0.75, 1.25, 1.75/
      DATA etacr14/109.,283., 359., 339., 273., 195./
      DATA cresta14/7., 10., 11., 11., 9.,8./
      DATA cresys14/3.,14.,19.,26.,15.,14./

C *** Data for high xgamma, all y, 2nd jet forward
      REAL eta15(6),etacr15(6),cresta15(6)
      REAL cresys15(6)
      DATA eta15/-0.75,-0.25, 0.25, 0.75, 1.25, 1.75/
      DATA etacr15/94.,210., 241., 227., 95., 30./
      DATA cresta15/6., 8., 9., 9., 6.,3./
      DATA cresys15/11.,14.,20.,7.,6.,2./

C *** Data for all xgamma, high y 2nd jet backwards
      REAL eta16(5),etacr16(5),cresta16(5)
      REAL cresys16(5)
      DATA eta16/-0.25, 0.25, 0.75, 1.25, 1.75/
      DATA etacr16/88., 208., 232., 185., 152./
      DATA cresta16/5., 9., 9., 8., 7./
      DATA cresys16/6.,12.,2.,11.,2./

C *** Data for all xgamma, high y, 2nd jet central
      REAL eta17(6),etacr17(6),cresta17(6)
      REAL cresys17(6)
      DATA eta17/-0.75,-0.25, 0.25, 0.75, 1.25, 1.75/
      DATA etacr17/115.,326., 284., 218., 162., 153./
      DATA cresta17/7., 11., 10., 9., 7.,7./
      DATA cresys17/4.,11.,6.,3.,12.,3./

C *** Data for all xgamma, high y, 2nd jet forward
      REAL eta18(6),etacr18(6),cresta18(6)
      REAL cresys18(6)
      DATA eta18/-0.75,-0.25, 0.25, 0.75, 1.25, 1.75/
      DATA etacr18/110.,227., 186., 128., 122., 117./
      DATA cresta18/6., 9., 8., 6., 6.,6./
      DATA cresys18/10.,8.,4.,11.,4.,11./

C *** Data for high xgamma, high y 2nd jet backwards
      REAL eta19(5),etacr19(5),cresta19(5)
      REAL cresys19(5)
      DATA eta19/-0.25, 0.25, 0.75, 1.25, 1.75/
      DATA etacr19/80., 183., 178., 122., 84./
      DATA cresta19/5., 8., 8., 6., 5./
      DATA cresys19/8.,15.,4.,13.,3./

C *** Data for high xgamma, high y, 2nd jet central
      REAL eta20(6),etacr20(6),cresta20(6)
      REAL cresys20(6)
      DATA eta20/-0.75,-0.25, 0.25, 0.75, 1.25, 1.75/
      DATA etacr20/108.,255., 152., 66., 27., 15./
      DATA cresta20/7., 9., 7., 5., 3.,2./
      DATA cresys20/4.,9.,5.,0.,2.,2./

C *** Data for high xgamma, high y, 2nd jet forward
      REAL eta21(4),etacr21(4),cresta21(4)
      REAL cresys21(4)
      DATA eta21/-0.75,-0.25, 0.25, 0.75/
      DATA etacr21/91.,118., 37., 5./
      DATA cresta21/6., 6., 3., 1.2/
      DATA cresys21/10.,5.,0.,2.5/

C *** Data for all xgamma, 1<eta_2<2, 1<eta_1<2
      REAL etcr22(8),cresta22(8)
      REAL cresysu22(8),cresysd22(8),binedge22(9)
      DATA etcr22/49.6,30.4,15.0,6.2,2.8,1.53,0.39,0.099/
      DATA cresta22/2.3,1.6,1.1,0.7,0.4,0.29,0.14,0.070/
      DATA cresysu22/4.0,1.0,0.5,0.7,0.3,0.05,0.05,0.183/
      DATA cresysd22/2.0,2.9,1.9,0.7,0.3,0.6,0.06,0.009/
      DATA binedge22/14.,17.,21.,25.,29.,35.,41.,48.,55./

C *** Data for all xgamma, 0<eta_2<1, 1<eta_1<2
      REAL etcr23(8),cresta23(8)
      REAL cresysu23(8),cresysd23(8),binedge23(9)
      DATA etcr23/73.7,40.4,17.9,8.2,2.8,1.18,0.20,0.28/
      DATA cresta23/2.0,1.3,0.9,0.6,0.3,0.18,0.07,0.10/
      DATA cresysu23/1.7,0.7,0.2,0.1,0.7,0.25,0.15,0.04/
      DATA cresysd23/3.0,2.6,1.3,1.0,0.6,0.41,0.03,0.19/
      DATA binedge23/14.,17.,21.,25.,29.,35.,41.,48.,55./

C *** Data for all xgamma, -1<eta_2<0, 1<eta_1<2
      REAL etcr24(5),cresta24(5)
      REAL cresysu24(5),cresysd24(5),binedge24(6)
      DATA etcr24/41.2,16.9,5.1,1.56,0.42/
      DATA cresta24/1.6,0.8,0.5,0.26,0.11/
      DATA cresysu24/2.4,0.5,0.7,0.17,0.24/
      DATA cresysd24/7.1,1.4,0.4,0.23,0.05/
      DATA binedge24/14.,17.,21.,25.,29.,35./

C *** Data for all xgamma, 0<eta_2<1, 0<eta_1<1
      REAL etcr25(6),cresta25(6)
      REAL cresysu25(6),cresysd25(6),binedge25(7)
      DATA etcr25/81.8,42.5,18.2,7.5,2.4,0.49/
      DATA cresta25/3.0,1.9,1.2,0.8,0.4,0.16/
      DATA cresysu25/3.1,0.5,2.4,0.3,0.1,0.14/
      DATA cresysd25/1.8,4.8,2.5,0.7,0.3,0.04/
      DATA binedge25/14.,17.,21.,25.,29.,35.,41./

C *** Data for all xgamma, -1<eta_2<0, 0<eta_1<1
      REAL etcr26(5),cresta26(5)
      REAL cresysu26(5),cresysd26(5),binedge26(6)
      DATA etcr26/46.2,18.3,4.4,0.97,0.093/
      DATA cresta26/1.7,0.9,0.4,0.20,0.046/
      DATA cresysu26/4.4,0.7,0.6,0.29,0.030/
      DATA cresysd26/8.9,3.1,0.2,0.29,0.063/
      DATA binedge26/14.,17.,21.,25.,29.,35./

C *** Data for all xgamma, -1<eta_2<0, -1<eta_1<0
      REAL etcr27(2),cresta27(2)
      REAL cresysu27(2),cresysd27(2),binedge27(3)
      DATA etcr27/13.6,1.81/
      DATA cresta27/1.2,0.37/
      DATA cresysu27/0.9,1.16/
      DATA cresysd27/2.2,0.54/
      DATA binedge27/14.,17.,21./

C *** Data for high xgamma, 1<eta_2<2, 1<eta_1<2
      REAL etcr28(8),cresta28(8)
      REAL cresysu28(8),cresysd28(8),binedge28(9)
      DATA etcr28/1.28,4.2,4.1,2.8,1.29,0.91,0.24,0.099/
      DATA cresta28/0.37,0.6,0.6,0.5,0.28,0.23,0.11,0.070/
      DATA cresysu28/1.32,0.6,0.3,0.3,0.38,0.05,0.07,0.096/
      DATA cresysd28/0.73,1.2,0.5,0.5,0.21,0.32,0.06,0.009/
      DATA binedge28/14.,17.,21.,25.,29.,35.,41.,48.,55./

C *** Data for high xgamma, 0<eta_2<1, 1<eta_1<2
      REAL etcr29(8),cresta29(8)
      REAL cresysu29(8),cresysd29(8),binedge29(9)
      DATA etcr29/29.0,18.4,8.7,5.1,1.85,0.83,0.125,0.21/
      DATA cresta29/1.3,0.9,0.6,0.4,0.23,0.15,0.056,0.09/
      DATA cresysu29/1.1,1.6,0.6,0.1,0.39,0.30,0.092,0.06/
      DATA cresysd29/3.4,1.9,0.7,0.8,0.35,0.32,0.012,0.16/
      DATA binedge29/14.,17.,21.,25.,29.,35.,41.,48.,55./

C *** Data for high xgamma, -1<eta_2<0, 1<eta_1<2
      REAL etcr30(5),cresta30(5)
      REAL cresysu30(5),cresysd30(5),binedge30(6)
      DATA etcr30/26.2,11.8,4.1,1.48,0.39/
      DATA cresta30/1.2,0.7,0.4,0.19,0.046/
      DATA cresysu30/3.2,0.7,0.6,0.13,0.20/
      DATA cresysd30/5.9,1.1,0.5,0.22,0.02/
      DATA binedge30/14.,17.,21.,25.,29.,35./

C *** Data for high xgamma, 0<eta_2<1, 0<eta_1<1
      REAL etcr31(6),cresta31(6)
      REAL cresysu31(6),cresysd31(6),binedge31(7)
      DATA etcr31/48.6,27.8,13.2,6.1,1.9,0.49/
      DATA cresta31/2.3,1.5,1.0,0.7,0.3,0.16/
      DATA cresysu31/4.4,1.6,2.1,0.1,0.2,0.11/
      DATA cresysd31/2.1,3.5,2.0,1.0,0.3,0.10/
      DATA binedge31/14.,17.,21.,25.,29.,35.,41./

C *** Data for high xgamma, -1<eta_2<0, 0<eta_1<1
      REAL etcr32(5),cresta32(5)
      REAL cresysu32(5),cresysd32(5),binedge32(6)
      DATA etcr32/37.1,15.4,4.2,0.93,0.093/
      DATA cresta32/1.5,0.8,0.4,0.19,0.046/
      DATA cresysu32/3.5,1.1,0.5,0.22,0.030/
      DATA cresysd32/7.7,2.5,0.2,0.32,0.063/
      DATA binedge32/14.,17.,21.,25.,29.,35./

C *** Data for high xgamma, -1<eta_2<0, -1<eta_1<0
      REAL etcr33(2),cresta33(2)
      REAL cresysu33(2),cresysd33(2),binedge33(3)
      DATA etcr33/12.4,1.74/
      DATA cresta33/1.2,0.36/
      DATA cresysu33/1.0,1.12/
      DATA cresysd33/2.0,0.52/
      DATA binedge33/14.,17.,21./

      INTEGER intiflag, chjet, iproc, iflag
      SAVE chjet
C     --- choose same jet finder as in the paper --- KTCLUS
      DATA chjet/3/
      INTEGER hzflag

      REAL pttemp(9)
      INTEGER ivec,jvec
      REAL sqrt
      REAL bw(8), zero(8)
      DATA zero /8*0./

      LOGICAL parton_showers

      parton_showers=.FALSE.
      intiflag=iflag
      IF (intiflag.gt.10000) THEN
         parton_showers=.TRUE.
         intiflag=MOD(intiflag,10000)
      ENDIF

C     --- choose direct/resolved
C     --- recommend 1 - DIRECT, 2 - RESOLVED
      IF (intiflag.gt.1000) THEN
         iproc=INT(intiflag/1000)
         intiflag=MOD(intiflag,1000)
      ENDIF

      IF ((iproc.gt.2).or.(iproc.lt.1)) THEN
         PRINT*,'HZ99057 : Badly called routine'
         PRINT*,'          please set intiflag +1000 or +2000'
      ENDIF

C     --- choose jet finder
      IF ((intiflag.gt.10).and.(MOD(intiflag,10).eq.1)) THEN
         chjet=INT(intiflag/10)
         intiflag=MOD(intiflag,10)
      ENDIF

      IF (parton_showers) THEN
         chjet=-1*chjet
      ENDIF

      IF (intiflag.eq.1) THEN
C     *** Initialisation run ***
C     *** Create directories ***
         IF (iproc.eq.1) THEN
            CALL HCDIR('//HISTO',' ')
            IF (parton_showers) THEN
               CALL HMDIR('PS99057','S')
               CALL HCDIR('//PAWC',' ')
               CALL HMDIR('PS99057','S')
            ELSE
               CALL HMDIR('99057','S')
               CALL HCDIR('//PAWC',' ')
               CALL HMDIR('99057','S')
            ENDIF

            CALL HBOOK1(10,'MC: All y,xgamma, 2nd jet backward'
     &           ,5 ,-0.5 ,2.0 ,0.)
            CALL HBOOK1(11,'MC: All y,xgamma, 2nd jet central'
     &           ,6 ,-1.0 ,2.0 ,0.)
            CALL HBOOK1(12,'MC: All y,xgamma, 2nd jet forward'
     &           ,6 ,-1.0 ,2.0 ,0.)

            CALL HBOOK1(13,'MC: All y,high xgamma, 2nd jet backward'
     &           ,5 ,-0.5 ,2.0 ,0.)
            CALL HBOOK1(14,'MC: All y,high xgamma, 2nd jet central'
     &           ,6 ,-1.0 ,2.0 ,0.)
            CALL HBOOK1(15,'MC: All y,high xgamma, 2nd jet forward'
     &           ,6 ,-1.0 ,2.0 ,0.)

            CALL HBOOK1(16,'MC: High y,all xgamma, 2nd jet backward'
     &           ,5 ,-0.5 ,2.0 ,0.)
            CALL HBOOK1(17,'MC: High y,all xgamma, 2nd jet central'
     &           ,6 ,-1.0 ,2.0 ,0.)
            CALL HBOOK1(18,'MC: High y,all xgamma, 2nd jet forward'
     &           ,6 ,-1.0 ,2.0 ,0.)

            CALL HBOOK1(19,'MC: High y,high xgamma, 2nd jet backward'
     &           ,5 ,-0.5 ,2.0 ,0.)
            CALL HBOOK1(20,'MC: High y,high xgamma, 2nd jet central'
     &           ,6 ,-1.0 ,2.0 ,0.)
            CALL HBOOK1(21,'MC: High y,high xgamma, 2nd jet forward'
     &           ,4 ,-1.0 ,1.0 ,0.)

c     ET plots

            CALL HBOOKB(22,'MC:Both Jets Forward, all xgamma',8
     &           ,binedge22,0.)

            CALL HBOOKB(23,'MC: 1 Forward 2 middle, all xgamma',8
     &           ,binedge23,0.)

            CALL HBOOKB(24,'MC: 1 Forward 2 back, all xgamma',5
     &           ,binedge24,0.)

            CALL HBOOKB(25,'MC: Both jets central, all xgamma',6
     &           ,binedge25,0.)

            CALL HBOOKB(26,'MC: 1 middle, 2 back, all xgamma',5
     &           ,binedge26,0.)

            CALL HBOOKB(27,'MC: Both jet backward, all xgamma',2
     &           ,binedge27,0.)

            CALL HBOOKB(28,'MC:Both Jets Forward, high xgamma',8
     &           ,binedge28,0.)

            CALL HBOOKB(29,'MC: 1 Forward 2 middle, high xgamma',8
     &           ,binedge29,0.)

            CALL HBOOKB(30,'MC: 1 Forward 2 back, high xgamma',5
     &           ,binedge30,0.)

            CALL HBOOKB(31,'MC: Both jets central, high xgamma',6
     &           ,binedge31,0.)

            CALL HBOOKB(32,'MC: 1 middle, 2 back, high xgamma',5
     &           ,binedge32,0.)

            CALL HBOOKB(33,'MC: Both jet backward, high xgamma',2
     &           ,binedge33,0.)

         ENDIF
         IF (parton_showers) THEN
            CALL HCDIR('//HISTO/PS99057',' ')
            CALL HCDIR('//PAWC/PS99057',' ')
         ELSE
            CALL HCDIR('//HISTO/99057',' ')
            CALL HCDIR('//PAWC/99057',' ')
         ENDIF

         CALL HBOOK1(iproc*100+10,'MC: All y,xgamma, 2nd jet backward'
     &        ,5 ,-0.5 ,2.0 ,0.)
         CALL HBOOK1(iproc*100+11,'MC: All y,xgamma, 2nd jet central'
     &        ,6 ,-1.0 ,2.0 ,0.)
         CALL HBOOK1(iproc*100+12,'MC: All y,xgamma, 2nd jet forward'
     &        ,6 ,-1.0 ,2.0 ,0.)

         CALL HBOOK1(iproc*100+13
     &        ,'MC: All y,high xgamma, 2nd jet backward',5 ,-0.5 ,2.0 ,0
     &        .)
         CALL HBOOK1(iproc*100+14
     &        ,'MC: All y,high xgamma, 2nd jet central',6 ,-1.0 ,2.0 ,0.
     &        )
         CALL HBOOK1(iproc*100+15
     &        ,'MC: All y,high xgamma, 2nd jet forward',6 ,-1.0 ,2.0 ,0.
     &        )

         CALL HBOOK1(iproc*100+16
     &        ,'MC: High y,all xgamma, 2nd jet backward',5 ,-0.5 ,2.0 ,0
     &        .)
         CALL HBOOK1(iproc*100+17
     &        ,'MC: High y,all xgamma, 2nd jet central',6 ,-1.0 ,2.0 ,0.
     &        )
         CALL HBOOK1(iproc*100+18
     &        ,'MC: High y,all xgamma, 2nd jet forward',6 ,-1.0 ,2.0 ,0.
     &        )

         CALL HBOOK1(iproc*100+19
     &        ,'MC: High y,high xgamma, 2nd jet backward',5 ,-0.5 ,2.0
     &        ,0.)
         CALL HBOOK1(iproc*100+20
     &        ,'MC: High y,high xgamma, 2nd jet central',6 ,-1.0 ,2.0 ,0
     &        .)
         CALL HBOOK1(iproc*100+21
     &        ,'MC: High y,high xgamma, 2nd jet forward',4 ,-1.0 ,1.0 ,0
     &        .)

c     ET plots

         CALL HBOOKB(iproc*100+22,'MC:Both Jets Forward, all xgamma',8
     &        ,binedge22,0.)

         CALL HBOOKB(iproc*100+23,'MC: 1 Forward 2 middle, all xgamma',8
     &        ,binedge23,0.)

         CALL HBOOKB(iproc*100+24,'MC: 1 Forward 2 back, all xgamma',5
     &           ,binedge24,0.)

         CALL HBOOKB(iproc*100+25,'MC: Both jets central, all xgamma',6
     &        ,binedge25,0.)

         CALL HBOOKB(iproc*100+26,'MC: 1 middle, 2 back, all xgamma',5
     &        ,binedge26,0.)

         CALL HBOOKB(iproc*100+27,'MC: Both jet backward, all xgamma',2
     &        ,binedge27,0.)

         CALL HBOOKB(iproc*100+28,'MC:Both Jets Forward, high xgamma',8
     &        ,binedge28,0.)

         CALL HBOOKB(iproc*100+29,'MC: 1 Forward 2 middle, high xgamma'
     &        ,8,binedge29,0.)

         CALL HBOOKB(iproc*100+30,'MC: 1 Forward 2 back, high xgamma',5
     &        ,binedge30,0.)

         CALL HBOOKB(iproc*100+31,'MC: Both jets central, high xgamma',6
     &        ,binedge31,0.)

         CALL HBOOKB(iproc*100+32,'MC: 1 middle, 2 back, high xgamma',5
     &        ,binedge32,0.)

         CALL HBOOKB(iproc*100+33,'MC: Both jet backward, high xgamma',2
     &        ,binedge33,0.)


C     --- photoproduction cuts

         ybjcut(1)=0.2
         ybjcut(2)=0.5
         ybjcut(3)=0.85
         q2cut(1)=0.
         q2cut(2)=1.

C     --- basic cuts for et and  rapidity plots
         Etcut(1)=14.0
         Etcut(2)=11.0
         rapcut(1)=-1.0
         rapcut(2)=0.0
         rapcut(3)=1.0
         rapcut(4)=2.0

C     --- standard cone radius is 1.0
         CALL HZJETRAD(2,CONER)
         IF (CONER.lt.0.0) THEN
            CONER=1.0
         ENDIF
         CALL HZJTNAME(chjet,jetf)

         WRITE(6,*)'**********************************************'
         WRITE(6,*)'* HZ99057 called, histograms will be output. *'
         WRITE(6,*)'*     Jet finder selected : ',jetf,'           *'
         WRITE(6,1001)'*        with cone radius : ',CONER,'   *'
         WRITE(6,*)'**********************************************'

 1001    FORMAT(A29,F5.2,A13)

      ELSE IF (intiflag.eq.2) THEN
C     *** Filling runs ***

C     *** Change directory to our graphs ***
         IF (parton_showers) THEN
            CALL HCDIR('//PAWC/PS99057',' ')
         ELSE
            CALL HCDIR('//PAWC/99057',' ')
         ENDIF

         q2=hzphokin(1)
         IF (q2.eq.-1) THEN
            PRINT*,'HZ99057: HZPHOKIN returns error for Q2'
         ELSEIF (q2.lt.0) THEN
            q2=abs(q2)
         ENDIF
         ybj=hzphokin(3)
         IF (ybj.eq.-1) THEN
            PRINT*,'HZ99057: HZPHOKIN returns error for ybj'
         ENDIF

C     *** Fill our histogram ***

         IF ((ybj.ge.ybjcut(1)).and.(ybj.le.ybjcut(3))
     &        .and.(q2.lt.q2cut(2))) Then

            elecE=27.5
            hzflag=HZIBEAM(myip,myil)
            IF (hzflag.ge.0) Then
               elecE=abs(PHEP(4,myil))
            ELSE
               PRINT*,'HZ99057: Electron not found. E=0.001'
               PRINT*,'         event will be rejected'
               elecE=0.001
            ENDIF

            CALL hzjtfind(chjet,CONER,NJET,Jets)

            IF (NJET.ge.2) THEN
               DO loop=1,2
                  Et(loop)=Jets(loop,3)
                  rap(loop)=Jets(loop,1)
               ENDDO
c     ET cut
               IF ((Et(2).gt.Etcut(2)).and.(et(1).gt.ETcut(1))) THEN

c     Overall rapidity cuts
                  IF ((rap(1).gt.rapcut(1).and.rap(1).lt.rapcut(4)).and
     &                 .(rap(2).gt.rapcut(1).and.rap(2).lt.rapcut(4)))
     &                 THEN

c     Calculate xgamma
                     xgam=(Et(1)*exp(-1*rap(1))+Et(2)*exp(-1*rap(2)))
     &                    /(2*ybj*elecE)

c     Fill the rapidity plots.
                     DO i=1,2
                        j=3-i
                        IF (rap(i).gt.rapcut(1).and.rap(i).lt.rapcut(2))
     &                       THEN
                           CALL HFILL(INT(iproc*100+10), REAL(rap(j)) ,
     &                          0.,wtx)
                        ENDIF
                        IF (rap(i).gt.rapcut(2).and.rap(i).lt.rapcut(3))
     &                       THEN
                           CALL HFILL(INT(iproc*100+11), REAL(rap(j)) ,
     &                          0.,wtx)
                        ENDIF
                        IF (rap(i).gt.rapcut(3).and.rap(i).lt.rapcut(4))
     &                       THEN
                           CALL HFILL(INT(iproc*100+12), REAL(rap(j)) ,
     &                          0.,wtx)
                        ENDIF
                        IF (xgam.ge.0.75) THEN
                           IF (rap(i).gt.rapcut(1).and.rap(i).lt
     &                          .rapcut(2))THEN
                              CALL HFILL(INT(iproc*100+13), REAL(rap(j))
     &                             ,0.,wtx)
                           ENDIF
                           IF (rap(i).gt.rapcut(2).and.rap(i).lt
     &                          .rapcut(3))THEN
                              CALL HFILL(INT(iproc*100+14), REAL(rap(j))
     &                             ,0.,wtx)
                           ENDIF
                           IF (rap(i).gt.rapcut(3).and.rap(i).lt
     &                          .rapcut(4))THEN
                              CALL HFILL(INT(iproc*100+15), REAL(rap(j))
     &                             ,0.,wtx)
                           ENDIF

                        ENDIF
                        IF (ybj.gt.ybjcut(2)) THEN

                           IF (rap(i).gt.rapcut(1).and.rap(i).lt
     &                          .rapcut(2))THEN
                              CALL HFILL(INT(iproc*100+16), REAL(rap(j))
     &                             ,0.,wtx)
                           ENDIF
                           IF (rap(i).gt.rapcut(2).and.rap(i).lt
     &                          .rapcut(3))THEN
                              CALL HFILL(INT(iproc*100+17), REAL(rap(j))
     &                             ,0.,wtx)
                           ENDIF
                           IF (rap(i).gt.rapcut(3).and.rap(i).lt
     &                          .rapcut(4))THEN
                              CALL HFILL(INT(iproc*100+18), REAL(rap(j))
     &                             ,0.,wtx)
                           ENDIF
                           IF (xgam.ge.0.75) THEN
                              IF (rap(i).gt.rapcut(1).and.rap(i).lt
     &                             .rapcut(2))THEN
                                 CALL HFILL(INT(iproc*100+19),
     &                                REAL(rap(j)),0.,wtx)
                              ENDIF
                              IF (rap(i).gt.rapcut(2).and.rap(i).lt
     &                             .rapcut(3))THEN
                                 CALL HFILL(INT(iproc*100+20),
     &                                REAL(rap(j)),0.,wtx)
                              ENDIF
                              IF (rap(i).gt.rapcut(3).and.rap(i).lt
     &                             .rapcut(4))THEN
                                 CALL HFILL(INT(iproc*100+21),
     &                                REAL(rap(j)),0.,wtx)
                              ENDIF
                           ENDIF
                        ENDIF
                     ENDDO


c     Fill the ET  plots.
                     DO i=1,2
                        j=3-i

                        IF ((rap(i).gt.rapcut(3).and.rap(i).lt.rapcut(4)
     &                       ).AND.(rap(j).gt.rapcut(3).and.rap(j).lt
     &                       .rapcut(4))) THEN
                           CALL HFILL(INT(iproc*100+22), REAL(MAX(et(j)
     &                          ,et(i))) ,0.,wtx)
                           IF (xgam.GT.0.75) THEN
                              CALL HFILL(INT(iproc*100+28),
     &                             REAL(MAX(et(j),et(i))) ,0.,wtx)
                           ENDIF
                        ENDIF

                        IF ((rap(i).gt.rapcut(3).and.rap(i).lt.rapcut(4)
     &                       ).AND.(rap(j).gt.rapcut(2).and.rap(j).lt
     &                       .rapcut(3))) THEN
                           CALL HFILL(INT(iproc*100+23), REAL(MAX(et(j)
     &                          ,et(i))) ,0.,wtx)
                           IF (xgam.GT.0.75) THEN
                              CALL HFILL(INT(iproc*100+29),
     &                             REAL(MAX(et(j),et(i))) ,0.,wtx)
                           ENDIF
                        ENDIF

                        IF ((rap(i).gt.rapcut(3).and.rap(i).lt.rapcut(4)
     &                       ).AND.(rap(j).gt.rapcut(1).and.rap(j).lt
     &                       .rapcut(2))) THEN
                           CALL HFILL(INT(iproc*100+24), REAL(MAX(et(j)
     &                          ,et(i))) ,0.,wtx)
                           IF (xgam.GT.0.75) THEN
                              CALL HFILL(INT(iproc*100+30),
     &                             REAL(MAX(et(j),et(i))) ,0.,wtx)
                           ENDIF
                        ENDIF

                        IF ((rap(i).gt.rapcut(2).and.rap(i).lt.rapcut(3)
     &                       ).AND.(rap(j).gt.rapcut(2).and.rap(j).lt
     &                       .rapcut(3))) THEN
                           CALL HFILL(INT(iproc*100+25), REAL(MAX(et(j)
     &                          ,et(i))) ,0.,wtx)
                           IF (xgam.GT.0.75) THEN
                              CALL HFILL(INT(iproc*100+31),
     &                             REAL(MAX(et(j),et(i))) ,0.,wtx)
                           ENDIF
                        ENDIF

                        IF ((rap(i).gt.rapcut(2).and.rap(i).lt.rapcut(3)
     &                       ).AND.(rap(j).gt.rapcut(1).and.rap(j).lt
     &                       .rapcut(2))) THEN
                           CALL HFILL(INT(iproc*100+26), REAL(MAX(et(j)
     &                          ,et(i))) ,0.,wtx)
                           IF (xgam.GT.0.75) THEN
                              CALL HFILL(INT(iproc*100+32),
     &                             REAL(MAX(et(j),et(i))) ,0.,wtx)
                           ENDIF
                        ENDIF

                        IF ((rap(i).gt.rapcut(1).and.rap(i).lt.rapcut(2)
     &                       ).AND.(rap(j).gt.rapcut(1).and.rap(j).lt
     &                       .rapcut(2))) THEN
                           CALL HFILL(INT(iproc*100+27), REAL(MAX(et(j)
     &                          ,et(i))) ,0.,wtx)
                           IF (xgam.GT.0.75) THEN
                              CALL HFILL(INT(iproc*100+33),
     &                             REAL(MAX(et(j),et(i))) ,0.,wtx)
                           ENDIF
                        ENDIF

                     ENDDO
                  ENDIF
               ENDIF
            ENDIF

         ENDIF                  ! Q2 & y cuts

      ELSE IF (intiflag.eq.3) THEN
C     *** Termination run ***
C     *** Change directory ***
         IF (parton_showers) THEN
            CALL HCDIR('//PAWC/PS99057',' ')
         ELSE
            CALL HCDIR('//PAWC/99057',' ')
         ENDIF

C     *** Finish off histograms ***

         IF (Xsec.eq.0) THEN
            PRINT*,'HZ99057: termination called with zero cross section'
            PRINT*,'          cross section graph meaningless'
            PRINT*,'          in process :',iproc*1000
            Xsec=1
         ENDIF
         IF (Ntot.eq.0) THEN
            PRINT*,'HZ99057: termination called with no total events'
            PRINT*,'          cross section graph meaningless'
            PRINT*,'          in process :',iproc*1000
            Ntot=1
         ENDIF

C     --- store Xsec and Ntot for both direct and resolved events.
         mhXsec(iproc)=Xsec*1000.
         mhntot(iproc)=Ntot

         IF (iproc.eq.2) THEN
C     --- only finally
C     --- create proper cross-section data

            CALL HBOOK1(-10,'Data: All y,xgamma, 2nd jet backward'
     &           ,5 ,-0.5 ,2.0 ,0.)
            CALL HBOOK1(-11,'Data: All y,xgamma, 2nd jet central'
     &           ,6 ,-1.0 ,2.0 ,0.)
            CALL HBOOK1(-12,'Data: All y,xgamma, 2nd jet forward'
     &           ,6 ,-1.0 ,2.0 ,0.)

            CALL HBOOK1(-13,'Data: All y,high xgamma, 2nd jet backward'
     &           ,5 ,-0.5 ,2.0 ,0.)
            CALL HBOOK1(-14,'Data: All y,high xgamma, 2nd jet central'
     &           ,6 ,-1.0 ,2.0 ,0.)
            CALL HBOOK1(-15,'Data: All y,high xgamma, 2nd jet forward'
     &           ,6 ,-1.0 ,2.0 ,0.)

            CALL HBOOK1(-16,'Data: High y,all xgamma, 2nd jet backward'
     &           ,5 ,-0.5 ,2.0 ,0.)
            CALL HBOOK1(-17,'Data: High y,all xgamma, 2nd jet central'
     &           ,6 ,-1.0 ,2.0 ,0.)
            CALL HBOOK1(-18,'Data: High y,all xgamma, 2nd jet forward'
     &           ,6 ,-1.0 ,2.0 ,0.)

            CALL HBOOK1(-19,'Data: High y,high xgamma, 2nd jet backward'
     &           ,5 ,-0.5 ,2.0 ,0.)
            CALL HBOOK1(-20,'Data: High y,high xgamma, 2nd jet central'
     &           ,6 ,-1.0 ,2.0 ,0.)
            CALL HBOOK1(-21,'Data: High y,high xgamma, 2nd jet forward'
     &           ,4 ,-1.0 ,1.0 ,0.)

c     ET plots

            CALL HBOOKB(-22,'Data:Both Jets Forward, all xgamma'
     &           ,8,binedge22,0.)

            CALL HBOOKB(-23
     &           ,'Data: 1 Forward 2 middle, all xgamma',8,binedge23,0.)

            CALL HBOOKB(-24,'Data: 1 Forward 2 back, all xgamma'
     &           ,5,binedge24,0.)

            CALL HBOOKB(-25,'Data: Both jets central, all xgamma'
     &           ,6,binedge25,0.)

            CALL HBOOKB(-26,'Data: 1 middle, 2 back, all xgamma'
     &           ,5,binedge26,0.)

            CALL HBOOKB(-27,'Data: Both jet backward, all xgamma'
     &           ,2,binedge27,0.)

            CALL HBOOKB(-28,'Data:Both Jets Forward, high xgamma'
     &           ,8,binedge28,0.)

            CALL HBOOKB(-29
     &           ,'Data: 1 Forward 2 middle, high xgamma',8,binedge29,0.
     &           )

            CALL HBOOKB(-30,'Data: 1 Forward 2 back, high xgamma'
     &           ,5,binedge30,0.)

            CALL HBOOKB(-31
     &           ,'Data: Both jets central, high xgamma',6,binedge31,0.)

            CALL HBOOKB(-32,'Data: 1 middle, 2 back, high xgamma'
     &           ,5,binedge32,0.)

            CALL HBOOKB(-33
     &           ,'Data: Both jet backward, high xgamma',2,binedge33,0.)


            CALL HPAK(-10,etacr10)
            DO ivec=1,5
               pttemp(ivec)=sqrt(cresta10(ivec)**2+cresys10(ivec)**2)
            ENDDO
            CALL HPAKE(-10,pttemp)

            CALL HPAK(-11,etacr11)
            DO ivec=1,6
               pttemp(ivec)=sqrt(cresta11(ivec)**2+cresys11(ivec)**2)
            ENDDO
            CALL HPAKE(-11,pttemp)

            CALL HPAK(-12,etacr12)
            DO ivec=1,6
               pttemp(ivec)=sqrt(cresta12(ivec)**2+cresys12(ivec)**2)
            ENDDO
            CALL HPAKE(-12,pttemp)

            CALL HPAK(-13,etacr13)
            DO ivec=1,5
               pttemp(ivec)=sqrt(cresta13(ivec)**2+cresys13(ivec)**2)
            ENDDO
            CALL HPAKE(-13,pttemp)

            CALL HPAK(-14,etacr14)
            DO ivec=1,6
               pttemp(ivec)=sqrt(cresta14(ivec)**2+cresys14(ivec)**2)
            ENDDO
            CALL HPAKE(-14,pttemp)

            CALL HPAK(-15,etacr15)
            DO ivec=1,6
               pttemp(ivec)=sqrt(cresta15(ivec)**2+cresys15(ivec)**2)
            ENDDO
            CALL HPAKE(-15,pttemp)

            CALL HPAK(-16,etacr16)
            DO ivec=1,5
               pttemp(ivec)=sqrt(cresta16(ivec)**2+cresys16(ivec)**2)
            ENDDO
            CALL HPAKE(-16,pttemp)

            CALL HPAK(-17,etacr17)
            DO ivec=1,6
               pttemp(ivec)=sqrt(cresta17(ivec)**2+cresys17(ivec)**2)
            ENDDO
            CALL HPAKE(-17,pttemp)

            CALL HPAK(-18,etacr18)
            DO ivec=1,6
               pttemp(ivec)=sqrt(cresta18(ivec)**2+cresys18(ivec)**2)
            ENDDO
            CALL HPAKE(-18,pttemp)

            CALL HPAK(-19,etacr19)
            DO ivec=1,5
               pttemp(ivec)=sqrt(cresta19(ivec)**2+cresys19(ivec)**2)
            ENDDO
            CALL HPAKE(-19,pttemp)

            CALL HPAK(-20,etacr20)
            DO ivec=1,6
               pttemp(ivec)=sqrt(cresta20(ivec)**2+cresys20(ivec)**2)
            ENDDO
            CALL HPAKE(-20,pttemp)

            CALL HPAK(-21,etacr21)
            DO ivec=1,4
               pttemp(ivec)=sqrt(cresta21(ivec)**2+cresys21(ivec)**2)
            ENDDO
            CALL HPAKE(-21,pttemp)

            CALL HPAK(-22,etcr22)
            DO ivec=1,8
               pttemp(ivec)=sqrt(cresta22(ivec)**2+( (cresysu22(ivec)
     &              +cresysd22(ivec))/2.0 )**2 )
            ENDDO
            CALL HPAKE(-22,pttemp)

            CALL HPAK(-23,etcr23)
            DO ivec=1,8
               pttemp(ivec)=sqrt(cresta23(ivec)**2+( (cresysu23(ivec)
     &              +cresysd23(ivec))/2.0 )**2 )
            ENDDO
            CALL HPAKE(-23,pttemp)

            CALL HPAK(-24,etcr24)
            DO ivec=1,5
               pttemp(ivec)=sqrt(cresta24(ivec)**2+( (cresysu24(ivec)
     &              +cresysd24(ivec))/2.0 )**2 )
            ENDDO
            CALL HPAKE(-24,pttemp)

            CALL HPAK(-25,etcr25)
            DO ivec=1,6
               pttemp(ivec)=sqrt(cresta25(ivec)**2+( (cresysu25(ivec)
     &              +cresysd25(ivec))/2.0 )**2 )
            ENDDO
            CALL HPAKE(-25,pttemp)

            CALL HPAK(-26,etcr26)
            DO ivec=1,5
               pttemp(ivec)=sqrt(cresta26(ivec)**2+( (cresysu26(ivec)
     &              +cresysd26(ivec))/2.0 )**2 )
            ENDDO
            CALL HPAKE(-26,pttemp)

            CALL HPAK(-27,etcr27)
            DO ivec=1,2
               pttemp(ivec)=sqrt(cresta27(ivec)**2+( (cresysu27(ivec)
     &              +cresysd27(ivec))/2.0 )**2 )
            ENDDO
            CALL HPAKE(-27,pttemp)

            CALL HPAK(-28,etcr28)
            DO ivec=1,8
               pttemp(ivec)=sqrt(cresta28(ivec)**2+( (cresysu28(ivec)
     &              +cresysd28(ivec))/2.0 )**2 )
            ENDDO
            CALL HPAKE(-28,pttemp)

            CALL HPAK(-29,etcr29)
            DO ivec=1,8
               pttemp(ivec)=sqrt(cresta29(ivec)**2+( (cresysu29(ivec)
     &              +cresysd29(ivec))/2.0 )**2 )
            ENDDO
            CALL HPAKE(-29,pttemp)

            CALL HPAK(-30,etcr30)
            DO ivec=1,5
               pttemp(ivec)=sqrt(cresta30(ivec)**2+( (cresysu30(ivec)
     &              +cresysd30(ivec))/2.0 )**2 )
            ENDDO
            CALL HPAKE(-30,pttemp)

            CALL HPAK(-31,etcr31)
            DO ivec=1,6
               pttemp(ivec)=sqrt(cresta31(ivec)**2+( (cresysu31(ivec)
     &              +cresysd31(ivec))/2.0 )**2 )
            ENDDO
            CALL HPAKE(-31,pttemp)

            CALL HPAK(-32,etcr32)
            DO ivec=1,5
               pttemp(ivec)=sqrt(cresta32(ivec)**2+( (cresysu32(ivec)
     &              +cresysd32(ivec))/2.0 )**2 )
            ENDDO
            CALL HPAKE(-32,pttemp)

            CALL HPAK(-33,etcr33)
            DO ivec=1,2
               pttemp(ivec)=sqrt(cresta33(ivec)**2+( (cresysu33(ivec)
     &              +cresysd33(ivec))/2.0 )**2 )
            ENDDO
            CALL HPAKE(-33,pttemp)


c     Create the bin width histograms (52-63)

            CALL HBOOKB(52,'bin width',8
     &           ,binedge22,0.)
            CALL HBOOKB(53,'bin width',8
     &           ,binedge23,0.)
            CALL HBOOKB(58,'bin width',8
     &           ,binedge28,0.)
            CALL HBOOKB(59,'bin width',8
     &           ,binedge29,0.)
            DO i=1,8
               bw(i)=1.0/(binedge22(i+1)-binedge22(i))
            ENDDO
            CALL HPAK(52,bw)
            CALL HPAKE(52,zero)
            CALL HPAK(53,bw)
            CALL HPAKE(53,zero)
            CALL HPAK(58,bw)
            CALL HPAKE(58,zero)
            CALL HPAK(59,bw)
            CALL HPAKE(59,zero)

            CALL HBOOKB(54,'bin width',5
     &           ,binedge24,0.)
            CALL HBOOKB(56,'bin width',5
     &           ,binedge26,0.)
            CALL HBOOKB(60,'bin width',5
     &           ,binedge30,0.)
            CALL HBOOKB(62,'bin width',5
     &           ,binedge32,0.)
            DO i=1,5
               bw(i)=1.0/(binedge24(i+1)-binedge24(i))
            ENDDO
            CALL HPAK(54,bw)
            CALL HPAKE(54,zero)
            CALL HPAK(56,bw)
            CALL HPAKE(56,zero)
            CALL HPAK(60,bw)
            CALL HPAKE(60,zero)
            CALL HPAK(62,bw)
            CALL HPAKE(62,zero)

            CALL HBOOKB(55,'bin width',6
     &           ,binedge25,0.)
            CALL HBOOKB(61,'bin width',6
     &           ,binedge31,0.)
            DO i=1,6
               bw(i)=1.0/(binedge25(i+1)-binedge25(i))
            ENDDO
            CALL HPAK(55,bw)
            CALL HPAKE(55,zero)
            CALL HPAK(61,bw)
            CALL HPAKE(61,zero)

            CALL HBOOKB(57,'bin width',2
     &           ,binedge27,0.)
            CALL HBOOKB(63,'bin width',2
     &           ,binedge33,0.)
            DO i=1,2
               bw(i)=1.0/(binedge27(i+1)-binedge27(i))
            ENDDO
            CALL HPAK(57,bw)
            CALL HPAKE(57,zero)
            CALL HPAK(63,bw)
            CALL HPAKE(63,zero)


C     --- normalise resolved/direct component histograms for eta plots
c     NB Factor of two comes from bin width = 0.5.
            DO i=10,21
               CALL HOPERA(100+i,'+e',100+i,100+i,REAL(2*mhXsec(1)
     &              /mhNtot(1)),0.)
               CALL HOPERA(200+i,'+e',200+i,200+i,REAL(2*mhXsec(2)
     &              /mhNtot(2)),0.)
            ENDDO

C     --- normalise resolved/direct component histograms for et plots
            DO i=22,33
               CALL HOPERA(100+i,'*e',30+i,100+i,REAL(mhXsec(1)/mhNtot(1
     &              )),1.)
               CALL HOPERA(200+i,'*e',30+i,200+i,REAL(mhXsec(2)/mhNtot(2
     &              )),1.)
            ENDDO

C     --- now calculate cross-section graphs (eta and et)
            DO i=10,33
               CALL HOPERA(100+i,'+e',200+i,i,1.,1.)
            ENDDO

         ENDIF

      ELSE
C     *** End ***
         PRINT*,'HZ99057:Please run routine with iflag set to 1,2 or 3'
         PRINT*,'        with +1000 or +2000 for DIR or RES events.'
      ENDIF

      RETURN
      END
*CMZ :  2.00/00 13/08/99  14.19.39  by  Tancredi Carli
*-- Author :
      SUBROUTINE HZC96132(iflag)
*****************************************************************************
* This photoproduction routine has to be run thrice with the following
* code additions:
* 	+1000 for the DIRECT component run.
*	+2000 for the SINGLY-RESOLVED component run.
*       +3000 for the DOUBLY-RESOLVED component run
* for all three phases (iflag=1,2,3)
*
* iflag = 1,2 or 3 depending on wether it is the initialization,
*		processing or termination phase (respectively)
*
* The default jetfinder is PXCONE
* To change jetfinder use these values to call the initialisation phase.
* 1 + 10 * (jetfinder number)
*
* This routine prduces the following graphs:
*     10  Corresponds to figure 7 in paper
*     11  Figure 8
*     20  Figure 9
*     21  Figure 10
*
* Cuts : 	Anti-tag on scattered beam particles (< 25 mrad)
*               Et > 3 GeV
*               |jet rapidity| < 1.0
*
* Recommended value for Ptmin is 2.2 GeV (to be set in MC set up)
*
* Author : Russell Taylor (rjt@hep.ucl.ac.uk)
*
* Reference: CERN-PPE/96-132
*            Zeit. fur Physik C73 (1997) 433
*
*****************************************************************************
*
* HERA Tuning defined commons

	IMPLICIT NONE
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*

	CHARACTER*6 jetf

	INTEGER njet,njet2
	DOUBLE PRECISION jets(50,8)
	DOUBLE PRECISION coner
        DOUBLE PRECISION hzeekin
	
	INTEGER loop,loop2,nloop
	DOUBLE PRECISION rap(10),Et(10)
	DOUBLE PRECISION ybj,q2,angle
	DOUBLE PRECISION ybjcut(2),q2cut(2)
	DOUBLE PRECISION Etcut(6)
	DOUBLE PRECISION mhxsec(3)
	INTEGER mhntot(3)
        REAL norm

        INTEGER ivec
        REAL temp(7)

C --- Data for one-jet Et graph (|eta|<1)
        REAL xbins(7)
        REAL det(6),det_e(6),det_esys(6)
        DATA xbins/3.0,4.0,5.0,6.5,8.5,11.0,16.0/
        DATA det/163.4,36.0,18.0,8.4,1.8,0.78/
        DATA det_e/5.8,2.3,1.5,1.0,0.3,0.17/
        DATA det_esys/26.7,7.7,3.6,1.8,0.5,0.24/

C --- Data for two-jet Et graph (|eta|<1)
        REAL det2(6),det2_e(6),det2_esys(6)
        DATA det2/36.0,18.4,8.7,3.7,1.13,0.32/
        DATA det2_e/2.9,2.0,1.1,0.6,0.28,0.09/
        DATA det2_esys/4.2,3.5,0.8,1.4,0.34,0.17/

C --- Data for rapidity graphs
C --- one-jet (Et>3 GeV)
        REAL drap(4),drap_e(4),drap_esys(4)
        DATA drap/277.,262.,228.,240./
        DATA drap_e/16.,15.,12.,13./
        DATA drap_esys/27.,29.,32.,56./
C --- two-jet (Et>3 GeV)
        REAL drap2(4),drap2_e(4),drap2_esys(4)
        DATA drap2/67.,92.,74.,72./
        DATA drap2_e/7.,9.,8.,8./
        DATA drap2_esys/11.,12.,9.,12./

	INTEGER intiflag, chjet, iproc, iflag
	SAVE chjet
C --- Default jet finder (as used in paper) -- PXCONE
	DATA chjet/2/

C --- choose direct/resolved
C --- recommend 1 - DIRECT, 2 - 1-RESOLVED, 3 - 2-RESOLVED
	IF (iflag.gt.1000) THEN
	  iproc=INT(iflag/1000)
	  intiflag=MOD(iflag,1000)
	ENDIF
	IF ((iproc.gt.3).or.(iproc.lt.1)) THEN
	  PRINT*,'HZC98113 : Badly called routine'
	  PRINT*,'           set intiflag +1000, +2000 or +3000'
	ENDIF

C --- choose jet finder
	IF ((intiflag.gt.10).and.(MOD(intiflag,10).eq.1)) THEN
	  chjet=INT(intiflag/10)
	  intiflag=MOD(intiflag,10)
	ENDIF

	IF (intiflag.eq.1) THEN
C *** Initialisation run ***
C *** Create directories ***
	  IF (iproc.eq.1) THEN
	    CALL HCDIR('//HISTO',' ')
	    CALL HMDIR('C96132','S')
	    CALL HCDIR('//PAWC',' ')
	    CALL HMDIR('C96132','S')

            CALL HBOOKB(-10,'Data 1-Jet X-Sec(pb), |eta|<1',6,xbins,0.)
            CALL HBOOKB(-110,'Data 1-Jet X-Sec(pb), |eta|<1',6,xbins,0.)
            CALL HPAK(-10,det)
            CALL HPAKE(-10,det_e)

            DO ivec=1,6
               temp(ivec)=sqrt(det_e(ivec)**2+det_esys(ivec)**2)
            ENDDO
            CALL HPAK(-110,det)
            CALL HPAKE(-110,temp)

            CALL HBOOKB(-11,'Data 2-Jet X-Sec(pb), |eta|<1',6,xbins,0.)
            CALL HBOOKB(-111,'Data 2-Jet X-Sec(pb), |eta|<1',6,xbins,0.)
            CALL HPAK(-11,det2)
            CALL HPAKE(-11,det2_e)

            DO ivec=1,6
               temp(ivec)=sqrt(det2_e(ivec)**2+det2_esys(ivec)**2)
            ENDDO
            CALL HPAK(-111,det2)
            CALL HPAKE(-111,temp)

            CALL HBOOK1(-20,'Data 1-jet X-Sec(pb), Et(jet)>3',
     &                        4,0.0,1.0,0.)
            CALL HBOOK1(-120,'Data 1-jet X-Sec(pb), Et(jet)>3',
     &                        4,0.0,1.0,0.)
            CALL HPAK(-20,drap)
            CALL HPAKE(-20,drap_e)

            DO ivec=1,4
               temp(ivec)=sqrt(drap_e(ivec)**2+drap_esys(ivec)**2)
            ENDDO
            CALL HPAK(-120,drap)
            CALL HPAKE(-120,temp)

            CALL HBOOK1(-21,'Data 2-jet X-Sec(pb), Et(jet1,2)>3',
     &                        4,0.0,1.0,0.)
            CALL HBOOK1(-121,'Data 2-jet X-Sec(pb), Et(jet1,2)>3',
     &                        4,0.0,1.0,0.)
            CALL HPAK(-21,drap2)
            CALL HPAKE(-21,drap2_e)

            DO ivec=1,4
               temp(ivec)=sqrt(drap2_e(ivec)**2+drap2_esys(ivec)**2)
            ENDDO
            CALL HPAK(-121,drap2)
            CALL HPAKE(-121,temp)


            CALL HBOOKB(10,'MC 1-jet X-Sec(pb), |eta|<1',6,xbins,0.)
            CALL HBOOKB(11,'MC 2-jet X-Sec(pb), |eta|<1',6,xbins,0.)
            CALL HBOOK1(20,'MC 1-jet X-Sec(pb), Et(jet)>3',
     &                        4,0.0,1.0,0.)
            CALL HBOOK1(21,'MC 2-jet X-Sec(pb), Et(jet1,2)>3',
     &                        4,0.0,1.0,0.)

          ENDIF

          CALL HCDIR('//HISTO/C96132',' ')
          CALL HCDIR('//PAWC/C96132',' ')

          CALL HBOOKB(10+iproc*100,'MC component',6,xbins,0.)
          CALL HBOOKB(11+iproc*100,'MC component',6,xbins,0.)
          CALL HBOOK1(20+iproc*100,'MC component',4,0.0,1.0,0.)
          CALL HBOOK1(21+iproc*100,'MC component',4,0.0,1.0,0.)
          CALL HBARX(0)

C	  ybjcut(1)=0.0
C	  ybjcut(2)=1.0
C	  q2cut(1)=0.
C	  q2cut(2)=1.8      !rough estimate - will do for now

C --- standard cone radius is 1.0
	  CALL HZJETRAD(2,CONER)
	  IF (CONER.lt.0.0) THEN
	    CONER=1.0
	  ENDIF
	  CALL HZJTNAME(chjet,jetf)
	  WRITE(6,*)'***********************************************'
	  WRITE(6,*)'* HZC96132 called, histograms will be output. *'
	  WRITE(6,*)'*     Jet finder selected : ',jetf,'            *'
	  WRITE(6,1001)'*        with cone radius : ',CONER,'          *'
	  WRITE(6,*)'***********************************************'

 1001	  FORMAT(A29,F5.2,A11)

	ELSE IF (intiflag.eq.2) THEN
C *** Filling runs ***
	
C *** Change directory to our graphs ***
	  CALL HCDIR('//PAWC/C96132',' ')

C	  q2=hzeekin(1)
C	  IF (q2.eq.-1) THEN
C	    PRINT*,'HZC98113: HZEEKIN returns error for Q2'
C	  ELSEIF (q2.lt.0) THEN
C	    q2=abs(q2)
C	  ENDIF

          angle=hzeekin(2)

C *** Fill our histogram ***

	  IF (angle.lt.0.025) Then

      	    CALL hzjtfind(chjet,CONER,NJET,Jets)

            IF (NJET.ge.1) THEN
               njet2=1
               DO loop=1,NJET
                 IF ((Jets(loop,3).ge.3.0).and.(ABS(Jets(loop,1))
     &                   .le.1.0)) THEN
   	           Et(njet2)=Jets(loop,3)
	           rap(njet2)=Jets(loop,1)
                   CALL HFILL(iproc*100+10,REAL(Et(njet2)),0.,wtx)
                   CALL HFILL(iproc*100+20,REAL(ABS(rap(njet2))),0.,wtx)
                   njet2=njet2+1
                 ENDIF
               ENDDO
               IF (njet2.ge.3) THEN
                 CALL HFILL(iproc*100+11,REAL(Et(1)),0.,wtx)
                 CALL HFILL(iproc*100+11,REAL(Et(2)),0.,wtx)
                 CALL HFILL(iproc*100+21,REAL(ABS(rap(1))),0.,wtx)
                 CALL HFILL(iproc*100+21,REAL(ABS(rap(2))),0.,wtx)
               ENDIF
            ENDIF

          ENDIF             !anti-tag cut

	ELSE IF (intiflag.eq.3) THEN
C *** Termination run ***
C *** Change directory ***
	  CALL HCDIR('//PAWC/C96132',' ')
C *** Finish off histograms ***
	  IF (Xsec.eq.0) THEN
	    PRINT*,'HZC96132: termination called with zero cross section'
	    PRINT*,'          cross section graph meaningless'
	    PRINT*,'	      in process :',iproc*1000
	    Xsec=1
	  ENDIF
	  IF (Ntot.eq.0) THEN
	    PRINT*,'HZC96132: termination called with no total events'
	    PRINT*,'          cross section graph meaningless'
	    PRINT*,'          in process :',iproc*1000
	    Ntot=1
	  ENDIF

C --- store Xsec and Ntot for both direct and resolved events.
	  mhXsec(iproc)=1000*Xsec
	  mhntot(iproc)=Ntot

C --- normalise direct/resolved histograms
          norm=0.
          norm=REAL(mhntot(iproc)/mhXsec(iproc))
          CALL HZHINRM(100*iproc+10,0,norm,1)
          CALL HZHINRM(100*iproc+20,0,norm,1)
          CALL HZHINRM(100*iproc+11,0,norm,1)
          CALL HZHINRM(100*iproc+21,0,norm,1)

          IF (iproc.eq.2) THEN
             CALL HOPERA(110,'+e',210,10,1.,1.)
             CALL HOPERA(120,'+e',220,20,1.,1.)
             CALL HOPERA(111,'+e',211,11,1.,1.)
             CALL HOPERA(121,'+e',221,21,1.,1.)
          ENDIF

          IF (iproc.eq.3) THEN
             CALL HOPERA(310,'+e',10,10,1.,1.)
             CALL HOPERA(320,'+e',20,20,1.,1.)
             CALL HOPERA(311,'+e',11,11,1.,1.)
             CALL HOPERA(321,'+e',21,21,1.,1.)

             CALL HZCHISQ(-110,10)
             CALL HZCHISQ(-111,11)
             CALL HZCHISQ(-120,20)
             CALL HZCHISQ(-121,21)
          ENDIF

        ELSE
C *** End ***
          PRINT*,'HZC96132:Please run with iflag set to 1,2 or 3'
          ENDIF

        RETURN
        END
*CMZ :  2.00/00 13/08/99  14.21.41  by  Tancredi Carli
*-- Author : Johannes Elmsheuser
      subroutine HZC98091(IFLAG)
****************************************************************************
*     HZc98091.f
*
* This photoproduction routine has to be run thrice with the following
* code additions:
* 	+1000 for the DIRECT component run.
*	+2000 for the SINGLY-RESOLVED component run.
*       +3000 for the DOUBLY-RESOLVED component run
* for all three phases (iflag=1,2,3)
*
* iflag = 1,2 or 3 depending on whether it is the initialization,
*		processing or termination phase (respectively)
*
* This routine produces the following graphs:
*     10-13 Correspond to figure 3 in paper
*     20-23 figure 5
*     30-33 figure 6
*     40,41 figure 7a,b
*     50,51 figure 8a,b
*
* Event selection:
*     charged hadrons: t > 0.3ns, abs(eta) < 1.5
*
* Reference: CERN-EP/98-091 or hep-ex/9808009
*            Published in Eur.Phys.J.C6:253-264,1999
*
* works well with: PHOJET 1.10 and PYTHIA
*
* written by  : Johannes Elmsheuser
*
* last change : 03 Aug 99
****************************************************************************
      IMPLICIT NONE
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      Integer MSTU,MSTJ
      REAL  PARU,PARJ
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
*
      Integer ihep,iflag,initflag, ivec, iproc
      INTEGER i,j,loop,IC,kshortflag, hadronflag
      INTEGER Ntot_store(3)
      DOUBLE PRECISION angle, w
      DOUBLE PRECISION hzeekin
      DOUBLE PRECISION xsec_store(3)
      DOUBLE PRECISION eta,pt
      REAL norm, temp(19)
      DOUBLE PRECISION HzETA
      Integer Hzlchge
*
* Data points from plots
*
C     P(10)/1,2,3,4,5,6,7,8,9,10/
C     --- Data Table 1: 10 < W < 30 GeV
      Real xbin(22)
      Real data1(21),data1_e(21),data1_s(21)
      Data xbin/0.12,0.28,0.44,0.60,0.80,1.00,1.20,1.40,1.60,1.80,2.00,
     +     2.20,2.40,2.60,2.80,3.00,3.50,4.00,5.00,6.00,8.00,15.00/
      Data data1/31100.0,27000.0,16000.0,8000.0,3380.0,1480.0,664.0,
     +		329.0,175.0,100.0,60.4,41.8,20.6,20.4,11.2,10.9,6.03,
     +     2.99,1.40,0.0,0.0/
      Data data1_e/100.0,100.0,100.0,60.0,40.0,20.0,16.0,11.0,8.0,6.0,
     +     4.8,3.9,3.0,3.1,2.5,1.6,1.35,0.82,0.64,0.0,0.0/
      Data data1_s/2400.0,2000.0,1000.0,460.0,170.0,80.0,40.0,21.0,11.0,
     +     7.0,3.7,2.7,0.8,0.7,0.5,1.1,0.21,0.33,0.07,0.0,0.0/
C     --- Data Table 1: 30 < W < 55 GeV
      Real data2(21),data2_e(21),data2_s(21)
      Data data2/10600.0,8800.0,5310.0,2670.0,1260.0,595.0,292.0,
     +     155.0,90.1,59.6,32.9,21.5,16.4,10.1,9.18,4.26,3.58,1.07,
     +     0.712,0.274,0.11/
      Data data2_e/100.0,60.0,40.0,30.0,20.0,12.0,9.0,7.0,4.9,3.9,2.9,
     +     2.3,2.0,1.6,1.55,0.65,0.62,0.25,0.238,0.122,0.073/
      Data data2_s/800.0,580.0,320.0,140.0,60.0,22.0,12.0,6.0,5.5,3.8,
     +     1.3,2.0,0.7,0.8,1.1,0.68,0.32,0.04,0.044,0.015,0.036/
C     --- Data Table 2: 55 < W < 125 GeV
      Real data3(21),data3_e(21),data3_s(21)
      Data data3/5850.0,4750.0,2920.0,1530.0,725.0,389.0,191.0,104.0,
     +     62.0,37.8,25.3,17.2,11.0,7.89,5.09,3.18,2.07,0.93,0.33,
     +		0.124,0.0264/
      Data data3_e/50.0,40.0,30.0,20.0,15.0,10.0,7.0,6.0,4.1,3.3,2.7,
     +     2.2,1.8,1.49,1.15,0.59,0.48,0.244,0.167,0.076,0.0176/
      Data data3_s/580.0,460.0,280.0,120.0,47.0,20.0,9.0,4.0,1.8,2.0,
     +     0.6,0.4,0.2,0.23,0.34,0.04,0.1,0.058,0.064,0.005,0.0023/
C     --- Data Table 2: 10 < W < 125 GeV
      Real data4(21),data4_e(21),data4_s(21)
      Data data4/47800.0,40500.0,24200.0,12100.0,5330.0,2450.0,1140.0,
     +     587.0,328.0,200.0,120.0,81.0,50.0,38.1,27.0,17.7,11.6,
     +     4.32,1.95,0.597,0.11/
      Data data4_e/200.0,100.0,100.0,100.0,40.0,30.0,20.0,13.0,10.0,8.0,
     +     6.0,4.9,3.8,3.4,2.9,1.6,1.3,0.61,0.45,0.201,0.046/
      Data data4_s/3800.0,3100.0,1700.0,700.0,270.0,120.0,60.0,31.0,
     +     19.0,11.0,6.0,5.7,2.0,1.8,1.1,0.7,0.4,0.19,0.09,0.04,
     +     0.007/
C     --- Data Table 3: 10 < W < 30 GeV
      Real ebin(6),data5(5),data5_e(5),data5_s(5)
      Data ebin/0.0,0.3,0.6,0.9,1.2,1.5/
      Data data5/9910.0,9980.0,10050.0,10010.0,9540.0/
      Data data5_e/60.0,60.0,60.0,60.0,60.0/
      Data data5_s/700.0,710.0,710.0,710.0,670.0/
C     --- Data Table 3: 30 < W < 55 GeV
      Real data6(5),data6_e(5),data6_s(5)
      Data data6/3270.0,3330.0,3410.0,3430.0,3330.0/
      Data data6_e/30.0,30.0,30.0,30.0,30.0/
      Data data6_s/200.0,190.0,190.0,200.0,190.0/
C     --- Data Table 3: 55 < W < 125 GeV
      Real data7(5),data7_e(5),data7_s(5)
      Data data7/1800.0,1850.0,1880.0,1930.0,1900.0/
      Data data7_e/20.0,20.0,20.0,20.0,20.0/
      Data data7_s/160.0,170.0,170.0,160.0,160.0/
C     --- Data Table 3: 10 < W < 125 GeV
      Real data8(5),data8_e(5),data8_s(5)
      Data data8/14970.0,15160.0,15330.0,15350.0,14750.0/
	Data data8_e/60.0,70.0,70.0,70.0,60.0/
	Data data8_s/1120.0,1130.0,1140.0,1150.0,1080.0/
C     --- Data Table 4: 10 < W < 30 GeV
	Real data9(5),data9_e(5),data9_s(5)
	Data data9/82.6,93.3,77.2,79.5,81.7/
	Data data9_e/4.7,4.9,4.5,4.7,4.7/
	Data data9_s/3.7,4.9,2.4,3.5,3.1/
C     --- Data Table 4: 30 < W < 55 GeV
	Real data10(5),data10_e(5),data10_s(5)
	Data data10/45.1,43.6,46.6,43.9,45.6/
	Data data10_e/2.7,2.7,2.8,2.9,3.0/
	Data data10_s/2.0,0.9,4.4,2.7,1.9/
C     --- Data Table 4: 55 < W < 125 GeV
	Real data11(5),data11_e(5),data11_s(5)
	Data data11/30.7,29.1,32.1,31.4,33.5/
	Data data11_e/2.4,2.3,2.5,2.5,2.6/
	Data data11_s/0.7,0.9,0.7,1.2,0.7/
C     --- Data Table 4: 10 < W < 125 GeV
	Real data12(5),data12_e(5),data12_s(5)
	Data data12/162.0,165.0,159.0,155.0,160.0/
	Data data12_e/6.0,6.0,6.0,6.0,6.0/
	Data data12_s/9.0,8.0,9.0,7.0,7.0/
C     --- Data Table 5: 10 < W < 125 GeV
	Real pbin(8),data13(7),data13_e(7),data13_s(7)
	Data pbin/1.0,1.2,1.5,1.9,2.4,3.0,4.0,5.5/
	Data data13/206.2,100.2,32.9,13.5,5.2,2.0,0.4/
	Data data13_e/17.4,8.9,4.5,2.6,1.3,0.7,0.3/
	Data data13_s/16.1,8.5,3.7,1.3,0.7,0.2,0.1/
C     --- Data Table 6: 10 < W < 125 GeV
	Real data14(5),data14_e(5),data14_s(5)
	Data data14/61.7,63.1,72.4,70.2,58.0/
	Data data14_e/7.2,7.3,7.8,8.0,7.5/
	Data data14_s/5.2,5.4,6.1,4.7,4.0/
C     --- Data Table 7: 10 < W < 35 GeV
	Real data15(7),data15_e(7),data15_s(7)
	Data data15/127.3,73.6,19.8,9.8,1.7,0.9,0.0/
	Data data15_e/14.6,8.4,3.4,2.8,0.9,0.4,0.0/
	Data data15_s/12.6,6.6,2.5,1.3,0.2,0.3,0.0/
C     --- Data Table 7: 35 < W < 125 GeV
	Real data16(7),data16_e(7),data16_s(7)
	Data data16/75.0,30.0,13.1,4.4,2.9,1.0,0.3/
	Data data16_e/9.5,4.3,3.0,1.2,0.8,0.6,0.3/
	Data data16_s/5.1,2.3,2.3,0.4,0.6,0.2,0.1/
*
C     --- choose direct/resolved
C     --- recommend 1 - DIRECT, 2 - RESOLVED
	IF (iflag.gt.1000) THEN
	  iproc=INT(iflag/1000)
c          kshortflag=INT((iflag-iproc*1000)/100)
c          If (kshortflag.eq.1) Then
c            initflag=MOD(iflag,1000)-100
c          Else
            initflag=MOD(iflag,1000)
c          EndIf
	ENDIF
	IF ((iproc.gt.3).or.(iproc.lt.1)) THEN
          Print*,'iflag =',iflag
          Print*,'iproc =',iproc
          Print*,'initflag =',initflag
          Print*,'kshortflag =',kshortflag
	  PRINT*,'HZc98091 : Badly called routine'
	  PRINT*,'           please set initflag +1000 or +2000'
	ENDIF

	IF (initflag.eq.1) THEN	

C     *** Initialisation run ***
C     *** Create directories ***
          IF (iproc.eq.1) THEN
            CALL HCDIR('//HISTO',' ')
	    CALL HMDIR('c98091','S')
	    CALL HCDIR('//PAWC',' ')
	    CALL HMDIR('c98091','S')

	    CALL HBOOKB(-10,'diff. incl. charged hadron xsec
     +           dsigm/dpt 10 < W < 30 GeV',21,xbin ,0.)
            CALL HBOOKB(-110,'diff. incl. charged hadron xsec
     +           dsigm/dpt 10 < W < 30 GeV',21,xbin,0.)
            CALL HPAK(-10,data1)
            CALL HPAKE(-10,data1_e)
            DO ivec=1,19
              temp(ivec)=sqrt(data1_e(ivec)**2+data1_s(ivec)**2)
            ENDDO
            CALL HPAK(-110,data1)
            CALL HPAKE(-110,temp)

	    CALL HBOOKB(-11,'diff. incl. charged hadron xsec
     +           dsigm/dpt 30 < W < 55 GeV',21 ,xbin ,0.)
            CALL HBOOKB(-111,'diff. incl. charged hadron xsec
     +           dsigm/dpt 30 < W < 55 GeV',21,xbin,0.)
            CALL HPAK(-11,data2)
            CALL HPAKE(-11,data2_e)
            DO ivec=1,21
              temp(ivec)=sqrt(data2_e(ivec)**2+data2_s(ivec)**2)
            ENDDO
            CALL HPAK(-111,data2)
            CALL HPAKE(-111,temp)

	    CALL HBOOKB(-12,'diff. incl. charged hadron xsec
     +           dsigm/dpt 55 < W < 125 GeV',21 ,xbin ,0.)
            CALL HBOOKB(-112,'diff. incl. charged hadron xsec
     +           dsigm/dpt 55 < W < 125 GeV',21,xbin,0.)
            CALL HPAK(-12,data3)
            CALL HPAKE(-12,data3_e)
            DO ivec=1,21
              temp(ivec)=sqrt(data3_e(ivec)**2+data3_s(ivec)**2)
            ENDDO
            CALL HPAK(-112,data3)
            CALL HPAKE(-112,temp)

	    CALL HBOOKB(-13,'diff. incl. charged hadron xsec
     +           dsigm/dpt 10 < W < 125 GeV',21 ,xbin, 0.)
            CALL HBOOKB(-113,'diff. incl. charged hadron xsec
     +           dsigm/dpt 10 < W < 125 GeV',21,xbin, 0.)
            CALL HPAK(-13,data4)
            CALL HPAKE(-13,data4_e)
            DO ivec=1,21
              temp(ivec)=sqrt(data4_e(ivec)**2+data4_s(ivec)**2)
            ENDDO
            CALL HPAK(-113,data4)
            CALL HPAKE(-113,temp)

	    CALL HBOOKB(-20,'diff. incl. charged hadron xsec
     +           dsigm/deta 10 < W < 30 GeV pt>120MeV',5 ,ebin ,0.)
            CALL HBOOKB(-120,'diff. incl. charged hadron xsec
     +           dsigm/deta 10 < W < 30 GeV pt>120MeV',5 ,ebin,0.)
            CALL HPAK(-20,data5)
            CALL HPAKE(-20,data5_e)
            DO ivec=1,5
              temp(ivec)=sqrt(data5_e(ivec)**2+data5_s(ivec)**2)
            ENDDO
            CALL HPAK(-120,data5)
            CALL HPAKE(-120,temp)

	    CALL HBOOKB(-21,'diff. incl. charged hadron xsec
     +           dsigm/deta 30 < W < 55 GeV pt>120MeV',5 ,ebin ,0.)
            CALL HBOOKB(-121,'diff. incl. charged hadron xsec
     +           dsigm/deta 30 < W < 55 GeV pt>120MeV',5 ,ebin,0.)
            CALL HPAK(-21,data6)
            CALL HPAKE(-21,data6_e)
            DO ivec=1,5
              temp(ivec)=sqrt(data6_e(ivec)**2+data6_s(ivec)**2)
            ENDDO
            CALL HPAK(-121,data6)
            CALL HPAKE(-121,temp)

	    CALL HBOOKB(-22,'diff. incl. charged hadron xsec
     +           dsigm/deta 55 < W < 125 GeV pt>120MeV',5 ,ebin ,0.)
            CALL HBOOKB(-122,'diff. incl. charged hadron xsec
     +           dsigm/deta 55 < W < 125 GeV pt>120MeV',5 ,ebin,0.)
            CALL HPAK(-22,data7)
            CALL HPAKE(-22,data7_e)
            DO ivec=1,5
              temp(ivec)=sqrt(data7_e(ivec)**2+data7_s(ivec)**2)
            ENDDO
            CALL HPAK(-122,data7)
            CALL HPAKE(-122,temp)

	    CALL HBOOKB(-23,'diff. incl. charged hadron xsec
     +           dsigm/deta 10 < W < 125 GeV pt>120MeV',5 ,ebin ,0.)
            CALL HBOOKB(-123,'diff. incl. charged hadron xsec
     +           dsigm/deta 10 < W < 125 GeV pt>120MeV',5 ,ebin,0.)
            CALL HPAK(-23,data8)
            CALL HPAKE(-23,data8_e)
            DO ivec=1,5
              temp(ivec)=sqrt(data8_e(ivec)**2+data8_s(ivec)**2)
            ENDDO
            CALL HPAK(-123,data8)
            CALL HPAKE(-123,temp)

	    CALL HBOOKB(-30,'diff. incl. charged hadron xsec
     +           dsigm/deta 10 < W < 30 GeV pt>1.5GeV',5 ,ebin ,0.)
            CALL HBOOKB(-130,'diff. incl. charged hadron xsec
     +           dsigm/deta 10 < W < 30 GeV pt>1.5GeV',5 ,ebin,0.)
            CALL HPAK(-30,data9)
            CALL HPAKE(-30,data9_e)
            DO ivec=1,5
              temp(ivec)=sqrt(data9_e(ivec)**2+data9_s(ivec)**2)
            ENDDO
            CALL HPAK(-130,data9)
            CALL HPAKE(-130,temp)

	    CALL HBOOKB(-31 ,'diff. incl. charged hadron xsec
     +           dsigm/deta 30 < W < 55 GeV pt>1.5GeV',5 ,ebin ,0.)
            CALL HBOOKB(-131,'diff. incl. charged hadron xsec
     +           dsigm/deta 30 < W < 55 GeV pt>1.5GeV',5 ,ebin,0.)
            CALL HPAK(-31 ,data10)
            CALL HPAKE(-31 ,data10_e)
            DO ivec=1,5
              temp(ivec)=sqrt(data10_e(ivec)**2+data10_s(ivec)**2)
            ENDDO
            CALL HPAK(-131,data10)
            CALL HPAKE(-131,temp)

	    CALL HBOOKB(-32 ,'diff. incl. charged hadron xsec
     +           dsigm/deta 55 < W < 125 GeV pt>1.5GeV',5 ,ebin ,0.)
            CALL HBOOKB(-132,'diff. incl. charged hadron xsec
     +           dsigm/deta 55 < W < 125 GeV pt>1.5GeV',5 ,ebin,0.)
            CALL HPAK(-32 ,data11)
            CALL HPAKE(-32 ,data11_e)
            DO ivec=1,5
              temp(ivec)=sqrt(data11_e(ivec)**2+data11_s(ivec)**2)
            ENDDO
            CALL HPAK(-132,data11)
            CALL HPAKE(-132,temp)

	    CALL HBOOKB(-33 ,'diff. incl. charged hadron xsec
     +           dsigm/deta 10 < W < 125 GeV pt>1.5GeV',5 ,ebin ,0.)
            CALL HBOOKB(-133,'diff. incl. charged hadron xsec
     +           dsigm/deta 10 < W < 125 GeV pt>1.5GeV',5 ,ebin,0.)
            CALL HPAK(-33 ,data12)
            CALL HPAKE(-33 ,data12_e)
            DO ivec=1,5
              temp(ivec)=sqrt(data12_e(ivec)**2+data12_s(ivec)**2)
            ENDDO
            CALL HPAK(-133,data12)
            CALL HPAKE(-133,temp)

	    CALL HBOOKB(-40 ,'diff. incl. K0S production xsec
     +           dsigm/dpt 10 < W < 125 GeV',7 ,pbin ,0.)
            CALL HBOOKB(-140,'diff. incl. K0S production xsec
     +           dsigm/dpt 10 < W < 125 GeV',7 ,pbin,0.)
            CALL HPAK(-40 ,data13)
            CALL HPAKE(-40 ,data13_e)
            DO ivec=1,7
              temp(ivec)=sqrt(data13_e(ivec)**2+data13_s(ivec)**2)
            ENDDO
            CALL HPAK(-140,data13)
            CALL HPAKE(-140,temp)

	    CALL HBOOKB(-41 ,'diff. incl. K0S production xsec
     +           dsigm/deta 10 < W < 125 GeV',5 ,ebin ,0.)
            CALL HBOOKB(-141,'diff. incl. K0S production xsec
     +           dsigm/deta 10 < W < 125 GeV',5 ,ebin,0.)
            CALL HPAK(-41 ,data14)
            CALL HPAKE(-41 ,data14_e)
            DO ivec=1,5
              temp(ivec)=sqrt(data14_e(ivec)**2+data14_s(ivec)**2)
            ENDDO
            CALL HPAK(-141,data14)
            CALL HPAKE(-141,temp)

	    CALL HBOOKB(-50 ,'diff. incl. K0S production xsec
     +           dsigm/dpt 10 < W < 35 GeV',7 ,pbin ,0.)
            CALL HBOOKB(-150,'diff. incl. K0S production xsec
     +           dsigm/dpt 10 < W < 35 GeV',7 ,pbin,0.)
            CALL HPAK(-50 ,data15)
            CALL HPAKE(-50 ,data15_e)
            DO ivec=1,7
              temp(ivec)=sqrt(data15_e(ivec)**2+data15_s(ivec)**2)
            ENDDO
            CALL HPAK(-150,data15)
            CALL HPAKE(-150,temp)

	    CALL HBOOKB(-51 ,'diff. incl. K0S production xsec
     +           dsigm/dpt 35 < W < 125 GeV',7 ,pbin ,0.)
            CALL HBOOKB(-151,'diff. incl. K0S production xsec
     +           dsigm/dpt 35 < W < 125 GeV',7 ,pbin,0.)
            CALL HPAK(-51 ,data16)
            CALL HPAKE(-51 ,data16_e)
            DO ivec=1,7
              temp(ivec)=sqrt(data16_e(ivec)**2+data16_s(ivec)**2)
            ENDDO
            CALL HPAK(-151,data16)
            CALL HPAKE(-151,temp)

            Call HBookb(10,'diff. incl. charged hadron xsec
     +           dsigm/dpt 10 < W < 30 GeV',21,xbin,0.)
            Call HBookb(11,'diff. incl. charged hadron xsec
     +           dsigm/dpt 30 < W < 55 GeV',21,xbin,0.)
            Call HBookb(12,'diff. incl. charged hadron xsec
     +           dsigm/dpt 55 < W < 125 GeV',21,xbin,0.)
            Call HBookb(13,'diff. incl. charged hadron xsec
     +           dsigm/dpt 10 < W < 125 GeV',21,xbin,0.)
            Call HBookb(20,'diff. incl. charged hadron xsec
     +           dsigm/deta 10 < W < 30 GeV pt>120MeV',5,ebin,0.)
            Call HBookb(21,'diff. incl. charged hadron xsec
     +           dsigm/deta 30 < W < 55 GeV pt>120MeV',5,ebin,0.)
            Call HBookb(22,'diff. incl. charged hadron xsec
     +           dsigm/deta 55 < W < 125 GeV pt>120MeV',5,ebin,0.)
            Call HBookb(23,'diff. incl. charged hadron xsec
     +           dsigm/deta 10 < W < 125 GeV pt>120MeV',5,ebin,0.)
            Call HBookb(30,'diff. incl. charged hadron xsec
     +           dsigm/deta 10 < W < 30 GeV pt>1.5GeV',5,ebin,0.)
            Call HBookb(31,'diff. incl. charged hadron xsec
     +           dsigm/deta 30 < W < 55 GeV pt>1.5GeV',5,ebin,0.)
            Call HBookb(32,'diff. incl. charged hadron xsec
     +           dsigm/deta 55 < W < 125 GeV pt>1.5GeV',5,ebin,0.)
            Call HBookb(33,'diff. incl. charged hadron xsec
     +           dsigm/deta 10 < W < 125 GeV pt>1.5GeV',5,ebin,0.)
            Call HBookb(40,'diff. incl. K0S production xsec
     +           dsigm/dpt 10 < W < 125 GeV',7,pbin,0.)
            Call HBookb(41,'diff. incl. K0S production xsec
     +           dsigm/deta 10 < W  < 125 GeV',5,ebin,0.)
            Call HBookb(50,'diff. incl. K0S production xsec
     +           dsigm/dpt 10 < W < 35 GeV',7,pbin,0.)
            Call HBookb(51,'diff. incl. K0S production xsec
     +           dsigm/dpt 35 < W < 125 GeV',7,pbin,0.)

	  ENDIF

          Call HBookb(10+iproc*100,'MC component',21,xbin,0.)
          Call HBookb(11+iproc*100,'MC component',21,xbin,0.)
          Call HBookb(12+iproc*100,'MC component',21,xbin,0.)
          Call HBookb(13+iproc*100,'MC component',21,xbin,0.)
          Call HBookb(20+iproc*100,'MC component',5,ebin,0.)
          Call HBookb(21+iproc*100,'MC component',5,ebin,0.)
          Call HBookb(22+iproc*100,'MC component',5,ebin,0.)
          Call HBookb(23+iproc*100,'MC component',5,ebin,0.)
          Call HBookb(30+iproc*100,'MC component',5,ebin,0.)
          Call HBookb(31+iproc*100,'MC component',5,ebin,0.)
          Call HBookb(32+iproc*100,'MC component',5,ebin,0.)
          Call HBookb(33+iproc*100,'MC component',5,ebin,0.)
          Call HBookb(40+iproc*100,'MC component',7,pbin,0.)
          Call HBookb(41+iproc*100,'MC component',5,ebin,0.)
          Call HBookb(50+iproc*100,'MC component',7,pbin,0.)
          Call HBookb(51+iproc*100,'MC component',7,pbin,0.)

          call hbook1(99+iproc*100,'W-Plot',100,0.,200.,0.)

          CALL HCDIR('//HISTO/c98091',' ')
	  CALL HCDIR('//PAWC/c98091',' ')

	  WRITE(6,*)'***********************************************'
	  WRITE(6,*)'* HZC98091 called, histograms will be output. *'
	  WRITE(6,*)'* No jet finder needed                        *'
	  WRITE(6,*)'***********************************************'

        ELSE IF(initflag.eq.2) then

*     Filling: The following MUST always be done
*     (i) move to the correct sub-directory in PAWC
*
          call hcdir('//PAWC/c98091',' ')

          angle = hzeekin(2)
          w = sqrt(hzeekin(4))
          call hfill(99+iproc*100,real(w),0.,1.)

          IF ((angle.ne.-1D0).and. ! anti-tag cut
     +         ((angle.lt.0.033D0).or.(angle.gt.3.1085927D0))) Then
C --- First the K0s
            Do loop=1,NHEP
C     ---- MC - Data 13 ----
              If (IDHEP(loop).eq.310) Then
                pt=sqrt(phep(1,loop)**2+phep(2,loop)**2)
                eta=abs(HZETA(loop))
                If ((pt.ge.1.0).and.(eta.le.1.5)) Then
                  If ((w.ge.10.0).and.(w.le.125.0)) Then
                    Call HFill(iproc*100+40,real(pt),0.,wtx)
                  Endif
                EndIf
C     ---- MC - Data 14 ----
                If ((pt.ge.1.0).and.(eta.le.1.5)) Then
                  If ((w.ge.10.0).and.(w.le.125.0)) Then
                    Call HFill(iproc*100+41,real(eta),0.,wtx)
                  Endif
                EndIf
C     ---- MC-Data 15-16
                If ((pt.ge.1.0).and.(eta.le.1.5)) Then
                  If ((w.ge.10.0).and.(w.le.35.0)) Then
                    Call HFill(iproc*100+50,real(pt),0.,wtx)
                  Endif
                  If ((w.ge.35.0).and.(w.le.125.0)) Then
                    Call HFill(iproc*100+51,real(pt),0.,wtx)
                  Endif
                EndIf
              Endif
            EndDo               ! 1,NHEP for the K0s

C     --- And now the charged hadrons
            If ((Gen(1:3).eq.'PHO').or.(Gen(1:3).eq.'PYT')) Then
C     --- maximum average proper lifetime t>0.3ns
              MSTJ(22) = 2
              PARJ(71) = 90.
C              Call LuExec
              Call Hzfilhep
              hadronflag=1
            EndIf

            Do loop=1,NHEP
              If (Gen(1:3).eq.'PHO') Then ! sort out beam/scattered electons
                If ((JMOHEP(1,loop).gt.5).or.
     +               (JMOHEP(1,loop).eq.4)) Then
                  hadronflag=1
                Else
                  hadronflag=0
                EndIf
              Endif
              IC=HZLCHGE(IDHEP(loop))
              If ((ISTHEP(loop).eq.1).and.(IC.ne.0).and.
     +             (hadronflag.eq.1)) Then
                pt=sqrt(phep(1,loop)**2+phep(2,loop)**2)
                eta=abs(HZETA(loop))
                If (eta.le.1.5) Then
C     ---- MC - Data 1-4 ----
                  If (eta.le.1.5) Then
                    If ((w.ge.10.0).and.(w.le.30.0)) Then
                      Call HFill(iproc*100+10,real(pt),0.,wtx)
                    ElseIf ((w.gt.30.0).and.(w.le.55.0)) Then
                      Call HFill(iproc*100+11,real(pt),0.,wtx)
                    ElseIf ((w.gt.55.0).and.(w.le.125.0)) Then
                      Call HFill(iproc*100+12,real(pt),0.,wtx)
                    EndIf
                    If ((w.ge.10.0).and.(w.le.125.0)) Then
                      Call HFill(iproc*100+13,real(pt),0.,wtx)
                    EndIf
                  EndIf
C     ---- MC - Data 5-8 ----
                  If (pt.ge.0.120) Then
                    If ((w.ge.10.0).and.(w.le.30.0)) Then
                      Call HFill(iproc*100+20,real(eta),0.,wtx)
                    ElseIf ((w.gt.30.0).and.(w.le.55.0)) Then
                      Call HFill(iproc*100+21,real(eta),0.,wtx)
                    ElseIf ((w.gt.55.0).and.(w.le.125.0)) Then
                      Call HFill(iproc*100+22,real(eta),0.,wtx)
                    EndIf
                    If ((w.ge.10.0).and.(w.le.125.0)) Then
                      Call HFill(iproc*100+23,real(eta),0.,wtx)
                    EndIf
                  EndIf
C     ---- MC - Data 9-12 ----
                  If (pt.ge.1.5) Then
                    If ((w.ge.10.0).and.(w.le.30.0)) Then
                      Call HFill(iproc*100+30,real(eta),0.,wtx)
                    ElseIf ((w.gt.30.0).and.(w.le.55.0)) Then
                      Call HFill(iproc*100+31,real(eta),0.,wtx)
                    ElseIf ((w.gt.55.0).and.(w.le.125.0)) Then
                      Call HFill(iproc*100+32,real(eta),0.,wtx)
                    EndIf
                    If ((w.ge.10.0).and.(w.le.125.0)) Then
                      Call HFill(iproc*100+33,real(eta),0.,wtx)
                    EndIf
                  EndIf
                EndIf           ! eta.le.1.5
              EndIf             ! (ISTHEP(loop).eq.1).and.(IC.ne.0)

            EndDo               ! 1,NHEP for hadrons
          Endif                 ! angle.lt.0.033

C     --- reset the proper lifetime for the K0s
          If ((Gen(1:3).eq.'PHO').or.(Gen(1:3).eq.'PYT')) Then
            MSTJ(22) = 2
            PARJ(71) = 10.
C            Call LuExec
          EndIf

C     *** Termination run ***

        ELSE IF(initflag.eq.3) then

          call hcdir('//PAWC/c98091',' ')

C     *** Finish off histograms ***
	  IF (XSec.eq.0) THEN
          PRINT*,'HZC98091: termination called with zero cross section'
            PRINT*,'          cross section graph meaningless'
            PRINT*,'	      in process :',iproc*1000
            XSec=1
	  ENDIF
	  IF (Ntot.eq.0) THEN
            PRINT*,'HZC98091: termination called with no total events'
            PRINT*,'          cross section graph meaningless'
            PRINT*,'          in process :',iproc*1000
            Ntot=1
	  ENDIF
C     --- store Xsec and Ntot for both direct and resolved events.
          xsec_store(iproc)=1000*XSec
	  Ntot_store(iproc)=Ntot

C --- normalise direct/resolved histograms
          norm=Real(Ntot_store(iproc))/Real(xsec_store(iproc))
          CALL HZHINRM(100*iproc+10,0,norm,1)
          CALL HZHINRM(100*iproc+11,0,norm,1)
          CALL HZHINRM(100*iproc+12,0,norm,1)
          CALL HZHINRM(100*iproc+13,0,norm,1)
          CALL HZHINRM(100*iproc+20,0,norm,1)
          CALL HZHINRM(100*iproc+21,0,norm,1)
          CALL HZHINRM(100*iproc+22,0,norm,1)
          CALL HZHINRM(100*iproc+23,0,norm,1)
          CALL HZHINRM(100*iproc+30,0,norm,1)
          CALL HZHINRM(100*iproc+31,0,norm,1)
          CALL HZHINRM(100*iproc+32,0,norm,1)
          CALL HZHINRM(100*iproc+33,0,norm,1)
          CALL HZHINRM(100*iproc+40,0,norm,1)
          CALL HZHINRM(100*iproc+41,0,norm,1)
          CALL HZHINRM(100*iproc+50,0,norm,1)
          CALL HZHINRM(100*iproc+51,0,norm,1)

          IF (iproc.eq.2) THEN
             CALL HOPERA(110,'+e',210,10,1.,1.)
             CALL HOPERA(111,'+e',211,11,1.,1.)
             CALL HOPERA(112,'+e',212,12,1.,1.)
             CALL HOPERA(113,'+e',213,13,1.,1.)
             CALL HOPERA(120,'+e',220,20,1.,1.)
             CALL HOPERA(121,'+e',221,21,1.,1.)
             CALL HOPERA(122,'+e',222,22,1.,1.)
             CALL HOPERA(123,'+e',223,23,1.,1.)
             CALL HOPERA(130,'+e',230,30,1.,1.)
             CALL HOPERA(131,'+e',231,31,1.,1.)
             CALL HOPERA(132,'+e',232,32,1.,1.)
             CALL HOPERA(133,'+e',233,33,1.,1.)
             CALL HOPERA(140,'+e',240,40,1.,1.)
             CALL HOPERA(141,'+e',241,41,1.,1.)
             CALL HOPERA(150,'+e',250,50,1.,1.)
             CALL HOPERA(151,'+e',251,51,1.,1.)

          ENDIF

          IF (iproc.eq.3) THEN
             CALL HOPERA(310,'+e',10,10,1.,1.)
             CALL HOPERA(311,'+e',11,11,1.,1.)
             CALL HOPERA(312,'+e',12,12,1.,1.)
             CALL HOPERA(313,'+e',13,13,1.,1.)
             CALL HOPERA(320,'+e',20,20,1.,1.)
             CALL HOPERA(321,'+e',21,21,1.,1.)
             CALL HOPERA(322,'+e',22,22,1.,1.)
             CALL HOPERA(323,'+e',23,23,1.,1.)
             CALL HOPERA(330,'+e',30,30,1.,1.)
             CALL HOPERA(331,'+e',31,31,1.,1.)
             CALL HOPERA(332,'+e',32,32,1.,1.)
             CALL HOPERA(333,'+e',33,33,1.,1.)
             CALL HOPERA(340,'+e',40,40,1.,1.)
             CALL HOPERA(341,'+e',41,41,1.,1.)
             CALL HOPERA(350,'+e',50,50,1.,1.)
             CALL HOPERA(351,'+e',51,51,1.,1.)

             CALL HZCHISQ(-10,110)
             CALL HZCHISQ(-11,111)
             CALL HZCHISQ(-12,112)
             CALL HZCHISQ(-13,113)
             CALL HZCHISQ(-20,120)
             CALL HZCHISQ(-21,121)
             CALL HZCHISQ(-22,122)
             CALL HZCHISQ(-23,123)
             CALL HZCHISQ(-30,130)
             CALL HZCHISQ(-31,131)
             CALL HZCHISQ(-32,132)
             CALL HZCHISQ(-33,133)
             CALL HZCHISQ(-40,140)
             CALL HZCHISQ(-41,141)
             CALL HZCHISQ(-50,150)
             CALL HZCHISQ(-51,151)

          ENDIF
*
      ELSE
C *** End ***
         PRINT*,'HZC98091:Please run with iflag set to 1,2 or 3'
      ENDIF

      RETURN
*
      END
*CMZ :  2.00/00 13/08/99  15.25.16  by  Tancredi Carli
*-- Author :
      SUBROUTINE HZC98113(iflag)
*****************************************************************************
* This photoproduction routine has to be run thrice with the following
* code additions:
* 	+1000 for the DIRECT component run.
*	+2000 for the SINGLY-RESOLVED component run.
*       +3000 for the DOUBLY-RESOLVED component run
* for all three phases (iflag=1,2,3)
*
* iflag = 1,2 or 3 depending on whether it is the initialization,
*		processing or termination phase (respectively)
*
* The default jetfinder is PXCONE
* To change jetfinder use these values to call the initialisation phase.
* 1 + 10 * (jetfinder number)
*
* This routine produces the following graphs:
*     1-2     Correspond to figure 3 in paper
*     10      Figure 6
*     20-22   Figure 8
*     23-25   Figure 9
*     26-28   Figure 10
*
*     30-33   Figure 4
*     34-37   Figure 5
*     39      Figure 7 (39: MC not correct yet !!!!!!!!)
*
* Cuts : Anti-tag on scattered beam particles (< 33 mrad)
*        Et > 3 GeV
*        |jet rapidity| < 2.0
*        In events with more than two jets, only the two jets with the
*        highest Et values are taken
*
* Recommended value for Ptmin is 2.2 GeV (to be set in MC set up)
*
* Author : Johannes Elmsheuser
*          Russell Taylor
*
* Reference: CERN-EP/98-113 or hep-ex/9808027
*
* last change: 03 Aug 99
*****************************************************************************
*
* HERA Tuning defined commons
*
	IMPLICIT NONE
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZJETCMN.
*
*     MAXHZJETS: maxmial number of jet allowed
*     NUMJETS: number of jets from jet algo
*     NSEL  : number of selected jets
*     IPJET : pointer to selected jets
*     JETS  : Jet variables (eta,phi,et,e,px,py,pz,m) in choosen frame
*     IJETNO: pointer which objects in PHEP common belong to jets
*
      INTEGER MAXHZJETS
      PARAMETER (MAXHZJETS=50)
      INTEGER NSEL,NUMJETS,IPJET(MAXHZJETS),IJETNO(NMXHEP)
      DOUBLE PRECISION JETS(MAXHZJETS,8)
*
      COMMON /HZJETCMN/JETS,NUMJETS,NSEL,IPJET,IJETNO
*
*
*KEND.
*
      CHARACTER*6 jetf
*
      Integer iNormMod
      Double Precision djshpRho(10,MAXHZJETS)
      Double Precision djshpPsi(10,MAXHZJETS)
      Integer ierr
*
      DOUBLE PRECISION coneradius
      DOUBLE PRECISION hzeekin
*	
      INTEGER loop,sum,veto1,veto2,i
      LOGICAL hadron
      DOUBLE PRECISION rap(2),Et(2),Etmean
      DOUBLE PRECISION xplus,xminus,xpdenom,xmdenom
      DOUBLE PRECISION costh,mjj,etabar
      DOUBLE PRECISION ybj,q2,angle
      DOUBLE PRECISION ybjcut(2),q2cut(2)
      DOUBLE PRECISION Etcut(6)
      DOUBLE PRECISION mhxsec(3)
      INTEGER mhntot(3)
      REAL norm
      Integer noent, jetflag(2), numflag
      Integer hzeebeam, kbeam, i1, i2

      INTEGER ivec
      REAL temp(8)

C     --- Data for cos theta* graphs
C     --- Resolved double-events
      REAL dctr(8),dctr_e(8),dctr_esys(8)
      DATA dctr/6.2,2.7,9.7,10.3,10.5,22.7,30.1,51.9/
      DATA dctr_e/1.7,1.1,2.1,2.2,2.2,3.3,3.8,5.0/
      DATA dctr_esys/0.3,0.2,1.1,2.3,1.7,2.4,2.5,3.6/
C     --- Direct results
      REAL dctd(8),dctd_e(8),dctd_esys(8)
      DATA dctd/4.2,5.0,5.6,7.8,6.8,7.2,6.5,15.8/
      DATA dctd_e/1.4,1.5,1.6,1.9,1.8,1.8,1.7,2.7/
      DATA dctd_esys/0.2,0.4,0.4,0.1,0.5,0.4,0.1,0.7/

C     --- Data for Et graph (-2<eta<2)
      REAL xbins(8)
      REAL det(7),det_e(7),det_esys(7)
      DATA xbins/3.0,4.0,5.0,6.5,8.5,11.0,15.0,20.0/
      DATA det/163.0,73.6,27.9,11.5,3.83,1.30,0.12/
      DATA det_e/3.0,2.0,0.9,0.5,0.26,0.14,0.04/
      DATA det_esys/16.0,8.7,3.9,1.4,0.6,0.35,0.13/

C     --- Data for rapidity graphs
C     --- Et(jet1)>4, Et(jet2)>3
      REAL drap(5),drap_e(5),drap_esys(5)
      DATA drap/118.7,114.4,93.4,95.1,81.2/
      DATA drap_e/3.7,3.6,2.9,3.5,3.8/
      DATA drap_esys/12.8,10.7,11.7,11.7,9.7/
C     --- 2-resolved
      REAL drap1(5),drap1_e(5),drap1_esys(5)
      DATA drap1/77.2,73.3,57.2,56.0,60.5/
      DATA drap1_e/3.3,3.1,2.5,2.8,3.4/
      DATA drap1_esys/11.8,10.4,10.9,11.5,10.9/
C     --- Direct
      REAL drap2(5),drap2_e(5),drap2_esys(5)
      DATA drap2/15.3,15.1,13.6,10.9,8.2/
      DATA drap2_e/1.2,1.2,1.1,1.3,1.2/
      DATA drap2_esys/2.5,2.4,2.4,2.2,1.9/
C     --- Et(jet1)>5, Et(jet2)>3
      REAL drap3(5),drap3_e(5),drap3_esys(5)
      DATA drap3/58.3,57.8,49.8,52.8,45.2/
      DATA drap3_e/2.6,2.4,2.0,2.4,2.9/
      DATA drap3_esys/7.7,7.6,6.5,6.6,7.2/
C     --- 2-resolved
      REAL drap4(5),drap4_e(5),drap4_esys(5)
      DATA drap4/35.0,33.6,31.3,28.8,30.2/
      DATA drap4_e/2.3,2.0,2.0,2.0,2.3/
      DATA drap4_esys/6.5,6.0,6.7,5.8,6.2/
C     --- Direct
      REAL drap5(5),drap5_e(5),drap5_esys(5)
      DATA drap5/8.8,9.5,9.2,7.9,5.9/
      DATA drap5_e/0.8,0.9,0.9,1.0,1.0/
      DATA drap5_esys/1.9,1.8,1.9,1.7,1.5/
C     --- Et(jet1)>5, Et(jet2)>5
      REAL drap6(5),drap6_e(5),drap6_esys(5)
      DATA drap6/31.0,32.0,27.6,27.5,18.3/
      DATA drap6_e/1.4,1.6,1.4,1.6,1.5/
      DATA drap6_esys/3.5,3.4,3.2,5.8,3.1/
C     --- 2-resolved
      REAL drap7(5),drap7_e(5),drap7_esys(5)
      DATA drap7/17.2,15.6,11.3,11.0,7.5/
      DATA drap7_e/1.1,1.1,0.9,0.9,0.9/
      DATA drap7_esys/4.4,2.9,3.3,3.1,3.3/
C     --- Direct
      REAL drap8(5),drap8_e(5),drap8_esys(5)
      DATA drap8/8.3,9.3,9.2,7.8,5.8/
      DATA drap8_e/0.9,1.0,1.0,1.0,1.2/
      DATA drap8_esys/1.7,1.8,1.7,1.6,1.5/
C     ---- Transverse energy flow
      Real trans(4),trans_e(4),tbin(5)
      Data trans/0.3905,0.3268,0.2437,0.1385/
      Data trans_e/0.0762,0.0312,0.0173,0.0104/
      Data tbin/0.,0.4,0.6,0.8,1./
C     ---- Jetshapes
C
C binning for histogram 34 (figure 5a)
      Integer Netb
      REAL XBMIN, XBMAX
      PARAMETER (NETB =4, XBMIN=2.5, XBMAX=16.4)
      REAL ETC(NETB)

C     ET-BINS: 3 < ET < 6 GeV
      Real jet1(9),jet1_e(9),jet1_s(9)
      Data jet1/.2209792,.3636379,.5036087,.6257820,.7289678,
     +     .8166003,.8935716,.9538166,1.000000/
      Data jet1_e/.4251001E-02,.4537700E-02,.4329407E-02,
     +     .3867119E-02,.3280415E-02,.2612657E-02,.1900075E-02,
     +     .1155724E-02,.0000000E+00/
      Data jet1_s/.2572477E-01,.1595122E-01,.1230733E-01,
     +     .7950806E-02,.5677925E-02,.3959488E-02,.2665337E-02,
     +     .1580911E-02,.0000000E+00/
C     ---- 6 < ET < 9 GeV
      Real jet2(9),jet2_e(9),jet2_s(9)
      Data jet2/.3612319,.5164152,.6422570,.7395944,.8189481,
     +     .8758704,.9265970,.9692727,1.000000/
      Data jet2_e/.1108723E-01,.1063599E-01,.9360796E-02,
     +     .7935040E-02,.6486599E-02,.5125404E-02,.3604599E-02,
     +     .2081644E-02,.0000000E+00/
      Data jet2_s/.3096824E-01,.2211963E-01,.1510940E-01,
     +     .1281377E-01,.8641682E-02,.6121607E-02,.3990377E-02,
     +     .2297599E-02,.0000000E+00/

C     ---- 9 < ET < 12 GeV
      Real jet3(9),jet3_e(9),jet3_s(9)
      Data jet3/.4528716,.5943354,.7030856,.7907856,.8553009,
     +     .9079834,.9437242,.9722496,1.000000/
      Data jet3_e/.2175449E-01,.2000897E-01,.1729812E-01,
     +     .1406680E-01,.1052341E-01,.8348793E-02,.5439536E-02,
     +     .3591785E-02,.0000000E+00/
      Data jet3_s/.2490672E-01,.2411000E-01,.2292768E-01,
     +     .2052256E-01,.2202065E-01,.1089703E-01,.9541475E-02,
     +     .4307039E-02,.0000000E+00/

C     ---- 12 < ET < 20 GeV
      Real jet4(9),jet4_e(9),jet4_s(9)
      Data jet4/.4908210,.6685935,.7625344,.8306012,.9050242,
     +     .9249423,.9613816,.9755640,1.000000/
      Data jet4_e/.2947415E-01,.2703022E-01,.2326954E-01,
     +     .1910693E-01,.1622896E-01,.1340461E-01,.8709117E-02,
     +     .4654132E-02,.0000000E+00/
      Data jet4_s/.8260044E-01,.4443698E-01,.3638402E-01,
     +     .2428289E-01,.2852339E-01,.1572620E-01,.9763868E-02,
     +     .5021494E-02,.0000000E+00/

C     ---- ET-BINS, r = 0.5
c     ETbin:  4.047              7.149          10.32          14.33
      Real etbin(5),jet5(4),jet5_e(4),jet5_s(4)
      Data etbin/2.5,5.6,8.7,12.3,16.4/
      Data jet5/.6257820,.7395944,.7907856,.8306012/
      Data jet5_e/.3280415E-02,.6486599E-02,.1052341E-01,
     +     .1622896E-01/
      Data jet5_s/.5677925E-02,.8641681E-02,.2202065E-01,
     +     .2852339E-01/

c     ETA-BINS, r = 0.5
c     eta:        0.25         0.75          1.25            1.75
      Real jet6(4),jet6_e(4),jet6_s(4)
      Data jet6/.6474866,.6473133,.6503943,.6857385/
      Data jet6_e/.9075225E-02,.8754758E-02,.1030088E-01,
     +     .1146265E-01/
      Data jet6_s/.2181574E-01,.1929426E-01,.1636410E-01,
     +     .1433685E-01/

c     ----- xg < 0.8
      Real jet7(9),jet7_e(9),jet7_s(9)
      Data jet7/.2136927,.3520198,.4895960,.6108904,.7168605,
     +     .8066437,.8875051,.9510415,1.000000/
      Data jet7_e/.1123197E-01,.1092855E-01,.9323972E-02,
     +     .7639683E-02,.6010768E-02,.4554836E-02,.3251283E-02,
     +     .1840144E-02,.0000000E+00/
      Data jet7_s/.5535422E-01,.1700652E-01,.1648848E-01,
     +     .1059836E-01,.8496173E-02,.7207649E-02,.4426425E-02,
     +     .2081397E-02,.0000000E+00/

c     ----- xg > 0.8
      Real jet8(9),jet8_e(9),jet8_s(9)
      Data jet8/.4236857,.5726522,.7018544,.8035479,.8672054,
     +     .9139441,.9483125,.9782956,1.000000/
      Data jet8_e/.4899294E-02,.5233969E-02,.5062019E-02,
     +     .4590211E-02,.3917607E-02,.3166375E-02,.2321225E-02,
     +     .1400615E-02,.0000000E+00/
      Data jet8_s/.3644661E-01,.3017373E-01,.1955125E-01,
     +     .1054519E-01,.6850822E-02,.5435510E-02,.3964528E-02,
     +     .2780109E-02,.0000000E+00/
*
*
      INTEGER intiflag, chjet, iproc, iflag
      SAVE chjet
C     --- Default jet finder (as used in paper) -- PXCONE
      DATA chjet/2/

C     --- choose direct/resolved
C     --- recommend 1 - DIRECT, 2 - 1-RESOLVED, 3 - 2-RESOLVED
      IF (iflag.gt.1000) THEN
        iproc=INT(iflag/1000)
        intiflag=MOD(iflag,1000)
      ENDIF
      IF ((iproc.gt.3).or.(iproc.lt.1)) THEN
        PRINT*,'HZC98113 : Badly called routine'
        PRINT*,'           set intiflag +1000, +2000 or +3000'
      ENDIF

C     --- choose jet finder
      IF ((intiflag.gt.10).and.(MOD(intiflag,10).eq.1)) THEN
        chjet=INT(intiflag/10)
        intiflag=MOD(intiflag,10)
      ENDIF

      IF (intiflag.eq.1) THEN
C     *** Initialisation run ***
C     *** Create directories ***
        IF (iproc.eq.1) THEN
          CALL HCDIR('//HISTO',' ')
          CALL HMDIR('C98113','S')
          CALL HCDIR('//PAWC',' ')
          CALL HMDIR('C98113','S')

          CALL HBOOK1(-1,'Data X-Sec(pb), 2-Resolved',8,0.,0.85,0.)
          CALL HBOOK1(-101,'Data X-Sec(pb), 2-Resolved',8,0.,0.85,0.)
          CALL HPAK(-1,dctr)
          CALL HPAKE(-1,dctr_e)

          DO ivec=1,8
            temp(ivec)=sqrt(dctr_e(ivec)**2+dctr_esys(ivec)**2)
          ENDDO
          CALL HPAK(-101,dctr)
          CALL HPAKE(-101,temp)

          CALL HBOOK1(-2,'Data X-Sec(pb), Direct',8,0.,0.85,0.)
          CALL HBOOK1(-102,'Data X-Sec(pb), Direct',8,0.,0.85,0.)
          CALL HPAK(-2,dctd)
          CALL HPAKE(-2,dctd_e)

          DO ivec=1,8
            temp(ivec)=sqrt(dctd_e(ivec)**2+dctd_esys(ivec)**2)
          ENDDO
          CALL HPAK(-102,dctd)
          CALL HPAKE(-102,temp)

          CALL HBOOKB(-10,'Data X-Sec(pb), |eta|<2',7,xbins,0.)
          CALL HBOOKB(-110,'Data X-Sec(pb), |eta|<2',7,xbins,0.)
          CALL HPAK(-10,det)
          CALL HPAKE(-10,det_e)

          DO ivec=1,7
            temp(ivec)=sqrt(det_e(ivec)**2+det_esys(ivec)**2)
          ENDDO
          CALL HPAK(-110,det)
          CALL HPAKE(-110,temp)

          CALL HBOOK1(-20,'Data X-Sec(pb), Et(jet1)>4, Et(jet2)>3',
     &         5,0.0,2.0,0.)
          CALL HBOOK1(-120,'Data X-Sec(pb), Et(jet1)>4, Et(jet2)>3',
     &         5,0.0,2.0,0.)
          CALL HPAK(-20,drap)
          CALL HPAKE(-20,drap_e)

          DO ivec=1,5
            temp(ivec)=sqrt(drap_e(ivec)**2+drap_esys(ivec)**2)
          ENDDO
          CALL HPAK(-120,drap)
          CALL HPAKE(-120,temp)

          CALL HBOOK1(-21,'Data X-Sec(pb), 2-resolved',5,0.0,2.0,0.)
          CALL HBOOK1(-121,'Data X-Sec(pb), 2-resolved',5,0.0,2.0,0.)
          CALL HPAK(-21,drap1)
          CALL HPAKE(-21,drap1_e)

          DO ivec=1,5
            temp(ivec)=sqrt(drap1_e(ivec)**2+drap1_esys(ivec)**2)
          ENDDO
          CALL HPAK(-121,drap1)
          CALL HPAKE(-121,temp)

          CALL HBOOK1(-22,'Data X-Sec(pb), Direct',5,0.0,2.0,0.)
          CALL HBOOK1(-122,'Data X-Sec(pb), Direct',5,0.0,2.0,0.)
          CALL HPAK(-22,drap2)
          CALL HPAKE(-22,drap2_e)

          DO ivec=1,5
            temp(ivec)=sqrt(drap2_e(ivec)**2+drap2_esys(ivec)**2)
          ENDDO
          CALL HPAK(-122,drap2)
          CALL HPAKE(-122,temp)

          CALL HBOOK1(-23,'Data X-Sec(pb), Et(jet1)>5, Et(jet2)>3',
     &         5,0.0,2.0,0.)
          CALL HBOOK1(-123,'Data X-Sec(pb), Et(jet1)>5, Et(jet2)>3',
     &         5,0.0,2.0,0.)
          CALL HPAK(-23,drap3)
          CALL HPAKE(-23,drap3_e)

          DO ivec=1,5
            temp(ivec)=sqrt(drap3_e(ivec)**2+drap3_esys(ivec)**2)
          ENDDO
          CALL HPAK(-123,drap3)
          CALL HPAKE(-123,temp)

          CALL HBOOK1(-24,'Data X-Sec(pb), 2-resolved',5,0.0,2.0,0.)
          CALL HBOOK1(-124,'Data X-Sec(pb), 2-resolved',5,0.0,2.0,0.)
          CALL HPAK(-24,drap4)
          CALL HPAKE(-24,drap4_e)

          DO ivec=1,5
            temp(ivec)=sqrt(drap4_e(ivec)**2+drap4_esys(ivec)**2)
          ENDDO
          CALL HPAK(-124,drap4)
          CALL HPAKE(-124,temp)

          CALL HBOOK1(-25,'Data X-Sec(pb), Direct',5,0.0,2.0,0.)
          CALL HBOOK1(-125,'Data X-Sec(pb), Direct',5,0.0,2.0,0.)
          CALL HPAK(-25,drap5)
          CALL HPAKE(-25,drap5_e)

          DO ivec=1,5
            temp(ivec)=sqrt(drap5_e(ivec)**2+drap5_esys(ivec)**2)
          ENDDO
          CALL HPAK(-125,drap5)
          CALL HPAKE(-125,temp)

          CALL HBOOK1(-26,'Data X-Sec(pb), Et(jets)>5',5,0.0,2.0,0.)
          CALL HBOOK1(-126,'Data X-Sec(pb), Et(jets)>5',5,0.0,2.0,0.)
          CALL HPAK(-26,drap6)
          CALL HPAKE(-26,drap6_e)

          DO ivec=1,5
            temp(ivec)=sqrt(drap6_e(ivec)**2+drap6_esys(ivec)**2)
          ENDDO
          CALL HPAK(-126,drap6)
          CALL HPAKE(-126,temp)

          CALL HBOOK1(-27,'Data X-Sec(pb), 2-resolved',5,0.0,2.0,0.)
          CALL HBOOK1(-127,'Data X-Sec(pb), 2-resolved',5,0.0,2.0,0.)
          CALL HPAK(-27,drap7)
          CALL HPAKE(-27,drap7_e)

          DO ivec=1,5
            temp(ivec)=sqrt(drap7_e(ivec)**2+drap7_esys(ivec)**2)
          ENDDO
          CALL HPAK(-127,drap7)
          CALL HPAKE(-127,temp)

          CALL HBOOK1(-28,'Data X-Sec(pb), Direct',5,0.0,2.0,0.)
          CALL HBOOK1(-128,'Data X-Sec(pb), Direct',5,0.0,2.0,0.)
          CALL HPAK(-28,drap8)
          CALL HPAKE(-28,drap8_e)

          DO ivec=1,5
            temp(ivec)=sqrt(drap8_e(ivec)**2+drap8_esys(ivec)**2)
          ENDDO
          CALL HPAK(-128,drap8)
          CALL HPAKE(-128,temp)

          CALL HBOOK1(-30,'Data Jetshape, 3 < Et < 6 GeV',
     +         9,0.15,1.05,0.)
          CALL HBOOK1(-130,'Data Jetshape, 3 < Et < 6 GeV',
     +         9,0.15,1.05,0.)
          CALL HPAK(-30,jet1)
          CALL HPAKE(-30,jet1_e)
          DO ivec=1,9
            temp(ivec)=sqrt(jet1_e(ivec)**2+jet1_s(ivec)**2)
          ENDDO
          CALL HPAK(-130,jet1)
          CALL HPAKE(-130,temp)

          CALL HBOOK1(-31,'Data Jetshape, 6 < Et < 9 GeV',
     +         9,0.15,1.05,0.)
          CALL HBOOK1(-131,'Data Jetshape, 6 < Et < 9 GeV',
     +         9,0.15,1.05,0.)
          CALL HPAK(-31,jet2)
          CALL HPAKE(-31,jet2_e)
          DO ivec=1,9
            temp(ivec)=sqrt(jet2_e(ivec)**2+jet2_s(ivec)**2)
          ENDDO
          CALL HPAK(-131,jet2)
          CALL HPAKE(-131,temp)

          CALL HBOOK1(-32,'Data Jetshape, 9 < Et < 12 GeV',
     +         9,0.15,1.05,0.)
          CALL HBOOK1(-132,'Data Jetshape, 9 < Et < 12 GeV',
     +         9,0.15,1.05,0.)
          CALL HPAK(-32,jet3)
          CALL HPAKE(-32,jet3_e)
          DO ivec=1,9
            temp(ivec)=sqrt(jet3_e(ivec)**2+jet3_s(ivec)**2)
          ENDDO
          CALL HPAK(-132,jet3)
          CALL HPAKE(-132,temp)

          CALL HBOOK1(-33,'Data Jetshape, 12 < Et <20 GeV',
     +         9,0.15,1.05,0.)
          CALL HBOOK1(-133,'Data Jetshape, 12 < Et < 20 GeV',
     +         9,0.15,1.05,0.)
          CALL HPAK(-33,jet4)
          CALL HPAKE(-33,jet4_e)
          DO ivec=1,9
            temp(ivec)=sqrt(jet4_e(ivec)**2+jet4_s(ivec)**2)
          ENDDO
          CALL HPAK(-133,jet4)
          CALL HPAKE(-133,temp)

          CALL HBOOKB(-34,'Data Jetshape, r = 0.5, Et',4,etbin,0.)
          CALL HBOOKB(-134,'Data Jetshape, r = 0.5, Et',4,etbin,0.)
          CALL HPAK(-34,jet5)
          CALL HPAKE(-34,jet5_e)
          DO ivec=1,4
            temp(ivec)=sqrt(jet5_e(ivec)**2+jet5_s(ivec)**2)
          ENDDO
          CALL HPAK(-134,jet5)
          CALL HPAKE(-134,temp)

          CALL HBOOK1(-35,'Data Jetshape, r = 0.5, eta',4,0.,2.,0.)
          CALL HBOOK1(-135,'Data Jetshape, r = 0.5, eta',4,0.,2.,0.)
          CALL HPAK(-35,jet6)
          CALL HPAKE(-35,jet6_e)
          DO ivec=1,4
            temp(ivec)=sqrt(jet6_e(ivec)**2+jet6_s(ivec)**2)
          ENDDO
          CALL HPAK(-135,jet6)
          CALL HPAKE(-135,temp)

          CALL HBOOK1(-36,'Data Jetshape, xg < 0.8',9,0.15,1.05,0.)
          CALL HBOOK1(-136,'Data Jetshape, xg < 0.8',9,0.15,1.05,0.)
          CALL HPAK(-36,jet7)
          CALL HPAKE(-36,jet7_e)
          DO ivec=1,9
            temp(ivec)=sqrt(jet7_e(ivec)**2+jet7_s(ivec)**2)
          ENDDO
          CALL HPAK(-136,jet7)
          CALL HPAKE(-136,temp)

          CALL HBOOK1(-37,'Data Jetshape, xg > 0.8',9,0.15,1.05,0.)
          CALL HBOOK1(-137,'Data Jetshape, xg > 0.8',9,0.15,1.05,0.)
          CALL HPAK(-37,jet8)
          CALL HPAKE(-37,jet8_e)
          DO ivec=1,9
            temp(ivec)=sqrt(jet8_e(ivec)**2+jet8_s(ivec)**2)
          ENDDO
          CALL HPAK(-137,jet8)
          CALL HPAKE(-137,temp)

          CALL HBOOKB(-39,'Data Transverse energy flow',4,tbin,0.)
          CALL HBOOKB(-139,'Data Transverse energy flow',4,tbin,0.)
          CALL HPAK(-39,trans)
          CALL HPAKE(-39,trans_e)
          CALL HPAK(-139,trans)
          CALL HPAKE(-139,trans_e)


          CALL HBOOK1(1,'MC X-Sec(pb), 2-Resolved',8,0.,0.85,0.)
          CALL HBOOK1(2,'MC X-Sec(pb), Direct',8,0.,0.85,0.)
          CALL HBOOKB(10,'MC X-Sec(pb), |eta|<2',7,xbins,0.)
          CALL HBOOK1(20,'MC X-Sec(pb), Et(jet1)>4, Et(jet2)>3',
     &         5,0.0,2.0,0.)
          CALL HBOOK1(21,'MC X-Sec(pb), 2-resolved',5,0.0,2.0,0.)
          CALL HBOOK1(22,'MC X-Sec(pb), Direct',5,0.0,2.0,0.)
          CALL HBOOK1(23,'MC X-Sec(pb), Et(jet1)>5, Et(jet2)>3',
     &         5,0.0,2.0,0.)
          CALL HBOOK1(24,'MC X-Sec(pb), 2-resolved',5,0.0,2.0,0.)
          CALL HBOOK1(25,'MC X-Sec(pb), Direct',5,0.0,2.0,0.)
          CALL HBOOK1(26,'MC X-Sec(pb), Et(jet)>5',5,0.0,2.0,0.)
          CALL HBOOK1(27,'MC X-Sec(pb), 2-resolved',5,0.0,2.0,0.)
          CALL HBOOK1(28,'MC X-Sec(pb), Direct',5,0.0,2.0,0.)

          CALL HBOOK1(30,'MC Jetshape, 3 < Et < 6 GeV',10,0.05,1.05,0.)
          CALL HBOOK1(31,'MC Jetshape, 6 < Et < 9 GeV',10,0.05,1.05,0.)
          CALL HBOOK1(32,'MC Jetshape, 9 < Et <12 GeV',10,0.05,1.05,0.)
          CALL HBOOK1(33,'MC Jetshape, 12< Et <20 GeV',10,0.05,1.05,0.)

          CALL HBProf(34,'MC Jetshape, psi(0.5), Et',
     +         NETB,XBMIN,XBMAX,0.,1.,' ')
          CALL HBProf(35,'MC Jetshape, psi(0.5), eta',
     +         4,0.,2.,0.,1.,' ')

          CALL HBOOK1(36,'MC Jetshape, xg < 0.8',10,0.05,1.05,0.)
          CALL HBOOK1(37,'MC Jetshape, xg > 0.8',10,0.05,1.05,0.)

          CALL HBOOKB(39,'MC Transverse energy flow',4,tbin,0.)

        ENDIF

        CALL HCDIR('//HISTO/C98113',' ')
        CALL HCDIR('//PAWC/C98113',' ')

        CALL HBOOK1(1+iproc*100,'MC component',8,0.,0.85,0.)
        CALL HBOOK1(2+iproc*100,'MC component',8,0.,0.85,0.)
        CALL HBOOKB(10+iproc*100,'MC component',7,xbins,0.)
        CALL HBOOK1(20+iproc*100,'MC component',5,0.0,2.0,0.)
        CALL HBOOK1(21+iproc*100,'MC component',5,0.0,2.0,0.)
        CALL HBOOK1(22+iproc*100,'MC component',5,0.0,2.0,0.)
        CALL HBOOK1(23+iproc*100,'MC component',5,0.0,2.0,0.)
        CALL HBOOK1(24+iproc*100,'MC component',5,0.0,2.0,0.)
        CALL HBOOK1(25+iproc*100,'MC component',5,0.0,2.0,0.)
        CALL HBOOK1(26+iproc*100,'MC component',5,0.0,2.0,0.)
        CALL HBOOK1(27+iproc*100,'MC component',5,0.0,2.0,0.)
        CALL HBOOK1(28+iproc*100,'MC component',5,0.0,2.0,0.)

        CALL HBOOK1(30+iproc*100,'MC Jetshape',10,0.05,1.05,0.)
        CALL HBOOK1(31+iproc*100,'MC Jetshape',10,0.05,1.05,0.)
        CALL HBOOK1(32+iproc*100,'MC Jetshape',10,0.05,1.05,0.)
        CALL HBOOK1(33+iproc*100,'MC Jetshape',10,0.05,1.05,0.)

        CALL HBProf(34+iproc*100,'MC Jetshape',
     +         NETB,XBMIN,XBMAX,0.,1.,' ')
        CALL HBProf(35+iproc*100,'MC Jetshape',4,0.,2.,0.,1.,' ')

        CALL HBOOK1(36+iproc*100,'MC Jetshape',10,0.05,1.05,0.)
        CALL HBOOK1(37+iproc*100,'MC Jetshape',10,0.05,1.05,0.)

        CALL HBOOKB(39+iproc*100,'MC component',4,tbin,0.)

        CALL HBARX(0)

C     --- standard cone radius is 1.0
        CALL HZJETRAD(2,CONERADIUS)
        IF (CONERADIUS.lt.0.0) THEN
          CONERADIUS=1.0
        ENDIF
        CALL HZJTNAME(chjet,jetf)
        WRITE(6,*)'***********************************************'
        WRITE(6,*)'* HZC98113 called, histograms will be output. *'
        WRITE(6,*)'*     Jet finder selected : ',jetf,'            *'
        WRITE(6,1001)'*        with cone radius : ',CONERADIUS
     +       ,'          *'
        WRITE(6,*)'***********************************************'

 1001   FORMAT(A29,F5.2,A14)

      ELSE IF (intiflag.eq.2) THEN
        angle=1.D0
        iNormMod=0              ! jetshapes normalized with jet pt
        xplus=0.
        xminus=0.
        numflag=0               ! number of jets for filling
        jetflag(1)=0            ! pos. in hzjetcmn of jet 1 (with highest Et)
        jetflag(2)=0            ! pos. in hzjetcmn of jet 2
        Et(1)=0D0               ! Et of jet 1
        Et(2)=0D0               ! Et of jet 2

C     *** Filling runs ***
C     *** Change directory to our graphs ***

        CALL HCDIR('//PAWC/C98113',' ')

        angle=hzeekin(2)
        IF ((angle.ne.-1D0).and. ! anti-tag cut
     +       ((angle.lt.0.033D0).or.(angle.gt.3.1085927D0))) Then
          CALL HzJtFind(chJet,coneRadius,numJets,jets)
          Call HzJetShp(iNormMod,coneRadius,djshpRho,djshpPsi,iErr)

          If (numJets.ge.2) Then
            If (numJets.eq.2) Then ! easy with only two jets
              jetflag(1)=1
              jetflag(2)=2
            Else                ! find the two jets with highest Et
              Do loop=1,numJets
                If (Jets(loop,3).gt.Et(1)) Then
                  Et(2)=Et(1)
                  Et(1)=Jets(loop,3)
                  jetflag(2)=jetflag(1)
                  jetflag(1)=loop
                EndIf
                If ((Jets(loop,3).gt.Et(2)).and.
     +               (Jets(loop,3).ne.Et(1))) Then
                  Et(2)=Jets(loop,3)
                  jetflag(2)=loop
                EndIf
              EndDo
            EndIf
            Do loop=1,2         ! fill jet1/2 data
              IF ((Jets(jetflag(loop),3).ge.3.0).and.
     +             (ABS(Jets(jetflag(loop),1)).le.2.0)) THEN
                numflag=numflag+1
                Et(numflag)=Jets(jetflag(loop),3)
                rap(numflag)=Jets(jetflag(loop),1)
                xplus=xplus+(Jets(jetflag(loop),4)+
     +               Jets(jetflag(loop),7))
                xminus=xminus+(Jets(jetflag(loop),4)-
     +               Jets(jetflag(loop),7))
              EndIf
            EndDo
          EndIf                 ! numJets.ge.2

C     *** Fill our histograms for the two jets ***

          If (numflag.eq.2) Then

C     --- Stuff to separate out resolved & direct events
C     --- Events where one or both scattered electrons are detected are
C     --- vetoed (anti-tagged)
            IF (GEN(1:3).eq.'HRW') THEN
              veto1=1
              veto2=2
            ELSEIF (GEN(1:3).eq.'PYT') THEN
              kbeam= hzeebeam(i1,i2) ! find e- and e+ position
              If ((i1.eq.1).and.(i2.eq.2)) Then
                veto1=3
                veto2=4
              ElseIf ((i1.eq.2).and.(i2.eq.1)) Then
                veto1=4
                veto2=3
              EndIf
            ELSEIF (GEN(1:3).eq.'PHO') THEN
              veto1=3
              veto2=5
            ELSE
              write(6,*)'Unknown generator'
            ENDIF

            xpdenom=0.
            xmdenom=0.
            DO sum=1,NHEP
              IF ((ISTHEP(sum).eq.1).and.
     +             (JMOHEP(1,sum).ne.veto1).and.
     +             (JMOHEP(1,sum).ne.veto2)) THEN
                xpdenom=xpdenom+(PHEP(4,sum)+PHEP(3,sum))
                xmdenom=xmdenom+(PHEP(4,sum)-PHEP(3,sum))
              ENDIF
            ENDDO
            xplus=xplus/xpdenom
            xminus=xminus/xmdenom

            costh=ABS(tanh((rap(1)-rap(2))/2))
            mjj=(Et(1)+Et(2))/sqrt(1-(costh**2))
            etabar=ABS((rap(1)+rap(2))/2)

            IF ((mjj.gt.12.).and.(etabar.lt.1.)) THEN
              IF ((xplus.lt.0.8).and.(xminus.lt.0.8)) THEN
                CALL HFILL(iproc*100+1,REAL(costh),0.,wtx)
              ENDIF
              IF ((xplus.gt.0.8).and.(xminus.gt.0.8)) THEN
                CALL HFILL(iproc*100+2,REAL(costh),0.,wtx)
              ENDIF
            ENDIF

C     --- End of that lot

            CALL HFILL(iproc*100+10,REAL(Et(1)),0.,wtx)
            CALL HFILL(iproc*100+10,REAL(Et(2)),0.,wtx)

C     --- Jetshapes -----

            Etmean=0.5D0*(Et(1)+Et(2))
            Call Hfill(iproc*100+34,Real(EtMean),
     +           Real(djshpPsi(5,jetflag(1))),1.)

c            DO I=1,NETB
c             IF ((Etmean.ge.xbmin+float(i-1)*
c     +          (xbmin-xbmax)/float(netb)).and.
c     +          (Etmean.lt.xbmin+float(i)*
c     +          (xbmin-xbmax)/float(netb)))
c     +          Etc(I)=Etc(I)+Etmean
c            ENDDO

            Call Hfill(iproc*100+35,Real(rap(1)),
     +           Real(djshpPsi(5,jetflag(1))),1.)
            Call Hfill(iproc*100+35,Real(rap(2)),
     +           Real(djshpPsi(5,jetflag(2))),1.)

            If (((Et(1).ge.3).and.(Et(1).le.6)).or.
     +           ((Et(2).ge.3).and.(Et(2).le.6))) Then
              Do i=1,10
                Call HFill(iproc*100+30,Real(i)*0.1,0.,
     +               Real(djshpPsi(i,jetflag(1))))
                Call HFill(iproc*100+30,Real(i)*0.1,0.,
     +               Real(djshpPsi(i,jetflag(2))))
              EndDo
            EndIf

            If (((Et(1).ge.6).and.(Et(1).le.9)).or.
     +           ((Et(2).ge.6).and.(Et(2).le.9))) Then
              Do i=1,10
                Call HFill(iproc*100+31,Real(i)*0.1,0.,
     +               Real(djshpPsi(i,jetflag(1))))
                Call HFill(iproc*100+31,Real(i)*0.1,0.,
     +               Real(djshpPsi(i,jetflag(2))))
              EndDo
            EndIf

            If (((Et(1).ge.9).and.(Et(1).le.12)).or.
     +           ((Et(2).ge.9).and.(Et(2).le.12))) Then
              Do i=1,10
                Call HFill(iproc*100+32,Real(i)*0.1,0.,
     +               Real(djshpPsi(i,jetflag(1))))
                Call HFill(iproc*100+32,Real(i)*0.1,0.,
     +               Real(djshpPsi(i,jetflag(2))))
              EndDo
            EndIf

            If (((Et(1).ge.12).and.(Et(1).le.20)).or.
     +           ((Et(2).ge.12).and.(Et(2).le.20))) Then
              Do i=1,10
                Call HFill(iproc*100+33,Real(i)*0.1,0.,
     +               Real(djshpPsi(i,jetflag(1))))
                Call HFill(iproc*100+33,Real(i)*0.1,0.,
     +               Real(djshpPsi(i,jetflag(2))))
              EndDo
            EndIf

            If ((xminus.le.0.8).and.(xplus.le.0.8)) Then
              Do i=1,10
                Call HFill(iproc*100+36,Real(i)*0.1,0.,
     +               Real(djshpPsi(i,jetflag(1))))
                Call HFill(iproc*100+36,Real(i)*0.1,0.,
     +               Real(djshpPsi(i,jetflag(2))))
              EndDo
            EndIf

            If ((xminus.ge.0.8).and.(xplus.ge.0.8)) Then
              Do i=1,10
                Call HFill(iproc*100+37,Real(i)*0.1,0.,
     +               Real(djshpPsi(i,jetflag(1))))
                Call HFill(iproc*100+37,Real(i)*0.1,0.,
     +               Real(djshpPsi(i,jetflag(2))))
              EndDo
            EndIf

C --- End of Jetshapes -----
C --- Transverse energy flow ---
            Call HFill(iproc*100+39,Real(xplus+xminus),0.,
     +           Real(Et(1)))
            Call HFill(iproc*100+39,Real(xplus+xminus),0.,
     +           Real(Et(2)))

C --- End of Transverse energy flow ---

            IF (Et(1).gt.4.0) THEN
              CALL HFILL(iproc*100+20,REAL(ABS(rap(1))),0.,wtx)
              CALL HFILL(iproc*100+20,REAL(ABS(rap(2))),0.,wtx)
              IF ((xplus.lt.0.8).and.(xminus.lt.0.8)) THEN
                CALL HFILL(iproc*100+21,REAL(ABS(rap(1))),0.,wtx)
                CALL HFILL(iproc*100+21,REAL(ABS(rap(2))),0.,wtx)
              ENDIF
              IF ((xplus.gt.0.8).and.(xminus.gt.0.8)) THEN
                CALL HFILL(iproc*100+22,REAL(ABS(rap(1))),0.,wtx)
                CALL HFILL(iproc*100+22,REAL(ABS(rap(2))),0.,wtx)
              ENDIF
              IF (Et(1).gt.5.) THEN
                CALL HFILL(iproc*100+23,REAL(ABS(rap(1))),0.,wtx)
                CALL HFILL(iproc*100+23,REAL(ABS(rap(2))),0.,wtx)
                IF ((xplus.lt.0.8).and.(xminus.lt.0.8)) THEN
                  CALL HFILL(iproc*100+24,REAL(ABS(rap(1))),0.,wtx)
                  CALL HFILL(iproc*100+24,REAL(ABS(rap(2))),0.,wtx)
                ENDIF
                IF ((xplus.gt.0.8).and.(xminus.gt.0.8)) THEN
                  CALL HFILL(iproc*100+25,REAL(ABS(rap(1))),0.,wtx)
                  CALL HFILL(iproc*100+25,REAL(ABS(rap(2))),0.,wtx)
                ENDIF
                IF (Et(2).gt.5) THEN
                  CALL HFILL(iproc*100+26,REAL(ABS(rap(1))),0.,wtx)
                  CALL HFILL(iproc*100+26,REAL(ABS(rap(2))),0.,wtx)
                  IF ((xplus.lt.0.8).and.(xminus.lt.0.8)) THEN
                    CALL HFILL(iproc*100+27,REAL(ABS(rap(1))),0.,wtx)
                    CALL HFILL(iproc*100+27,REAL(ABS(rap(2))),0.,wtx)
                  ENDIF
                  IF ((xplus.gt.0.8).and.(xminus.gt.0.8)) THEN
                    CALL HFILL(iproc*100+28,REAL(ABS(rap(1))),0.,wtx)
                    CALL HFILL(iproc*100+28,REAL(ABS(rap(2))),0.,wtx)
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
          ENDIF                 ! numflag.eq.2
        ENDIF                   ! angle.lt.0.033

      ELSE IF (intiflag.eq.3) THEN
C     *** Termination run ***
C     *** Change directory ***
        CALL HCDIR('//PAWC/C98113',' ')
C     *** Finish off histograms ***
        IF (Xsec.eq.0) THEN
          PRINT*,'HZC98113: termination called with zero cross section'
          PRINT*,'          cross section graph meaningless'
          PRINT*,'	      in process :',iproc*1000
          Xsec=1
        ENDIF
        IF (Ntot.eq.0) THEN
          PRINT*,'HZC98113: termination called with no total events'
          PRINT*,'          cross section graph meaningless'
          PRINT*,'          in process :',iproc*1000
          Ntot=1
        ENDIF

C     --- store Xsec and Ntot for both direct and resolved events.

        mhXsec(iproc)=1000*Xsec
        mhntot(iproc)=Ntot

C     --- normalise direct/resolved histograms
        norm=0.
        norm=REAL(mhntot(iproc)/mhXsec(iproc))

        CALL HZHINRM(100*iproc+1,0,norm,1)
        CALL HZHINRM(100*iproc+2,0,norm,1)
        CALL HZHINRM(100*iproc+10,0,norm,1)
        CALL HZHINRM(100*iproc+20,0,norm,1)
        CALL HZHINRM(100*iproc+21,0,norm,1)
        CALL HZHINRM(100*iproc+22,0,norm,1)
        CALL HZHINRM(100*iproc+23,0,norm,1)
        CALL HZHINRM(100*iproc+24,0,norm,1)
        CALL HZHINRM(100*iproc+25,0,norm,1)
        CALL HZHINRM(100*iproc+26,0,norm,1)
        CALL HZHINRM(100*iproc+27,0,norm,1)
        CALL HZHINRM(100*iproc+28,0,norm,1)

        Call Hnoent(100*iproc+30,noent)
        Call HzHinrm(100*iproc+30,0,Real(noent),1)
        Call Hnoent(100*iproc+31,noent)
        Call HzHinrm(100*iproc+31,0,Real(noent),1)
        Call Hnoent(100*iproc+32,noent)
        Call HzHinrm(100*iproc+32,0,Real(noent),1)
        Call Hnoent(100*iproc+33,noent)
        Call HzHinrm(100*iproc+33,0,Real(noent),1)
        Call Hnoent(100*iproc+36,noent)
        Call HzHinrm(100*iproc+36,0,Real(noent),1)
        Call Hnoent(100*iproc+37,noent)
        Call HzHinrm(100*iproc+37,0,Real(noent),1)

        IF (iproc.eq.2) THEN
          CALL HOPERA(101,'+e',201,1,1.,1.)
          CALL HOPERA(102,'+e',202,2,1.,1.)
          CALL HOPERA(110,'+e',210,10,1.,1.)
          CALL HOPERA(120,'+e',220,20,1.,1.)
          CALL HOPERA(121,'+e',221,21,1.,1.)
          CALL HOPERA(122,'+e',222,22,1.,1.)
          CALL HOPERA(123,'+e',223,23,1.,1.)
          CALL HOPERA(124,'+e',224,24,1.,1.)
          CALL HOPERA(125,'+e',225,25,1.,1.)
          CALL HOPERA(126,'+e',226,26,1.,1.)
          CALL HOPERA(127,'+e',227,27,1.,1.)
          CALL HOPERA(128,'+e',228,28,1.,1.)

          CALL HOPERA(130,'+e',230,30,1.,1.)
          CALL HOPERA(131,'+e',231,31,1.,1.)
          CALL HOPERA(132,'+e',232,32,1.,1.)
          CALL HOPERA(133,'+e',233,33,1.,1.)
          CALL HOPERA(134,'+e',234,34,1.,1.)
          CALL HOPERA(135,'+e',235,35,1.,1.)
          CALL HOPERA(136,'+e',236,36,1.,1.)
          CALL HOPERA(137,'+e',237,37,1.,1.)
          CALL HOPERA(139,'+e',239,39,1.,1.)

        ENDIF

        IF (iproc.eq.3) THEN
          CALL HOPERA(301,'+e',1,1,1.,1.)
          CALL HOPERA(302,'+e',2,2,1.,1.)
          CALL HOPERA(310,'+e',10,10,1.,1.)
          CALL HOPERA(320,'+e',20,20,1.,1.)
          CALL HOPERA(321,'+e',21,21,1.,1.)
          CALL HOPERA(322,'+e',22,22,1.,1.)
          CALL HOPERA(323,'+e',23,23,1.,1.)
          CALL HOPERA(324,'+e',24,24,1.,1.)
          CALL HOPERA(325,'+e',25,25,1.,1.)
          CALL HOPERA(326,'+e',26,26,1.,1.)
          CALL HOPERA(327,'+e',27,27,1.,1.)
          CALL HOPERA(328,'+e',28,28,1.,1.)

          CALL HOPERA(330,'+e',30,30,1.,1.)
          CALL HOPERA(331,'+e',31,31,1.,1.)
          CALL HOPERA(332,'+e',32,32,1.,1.)
          CALL HOPERA(333,'+e',33,33,1.,1.)
          CALL HOPERA(334,'+e',34,34,1.,1.)
          CALL HOPERA(335,'+e',35,35,1.,1.)
          CALL HOPERA(336,'+e',36,36,1.,1.)
          CALL HOPERA(337,'+e',37,37,1.,1.)
          CALL HOPERA(339,'+e',39,39,1.,1.)

          Call Hnoent(30,noent)
          Call HzHinrm(30,0,Real(noent),1)
          Call Hnoent(31,noent)
          Call HzHinrm(31,0,Real(noent),1)
          Call Hnoent(32,noent)
          Call HzHinrm(32,0,Real(noent),1)
          Call Hnoent(33,noent)
          Call HzHinrm(33,0,Real(noent),1)
          Call Hnoent(36,noent)
          Call HzHinrm(36,0,Real(noent),1)
          Call Hnoent(37,noent)
          Call HzHinrm(37,0,Real(noent),1)

          CALL HZCHISQ(-101,1)
          CALL HZCHISQ(-102,2)
          CALL HZCHISQ(-110,10)
          CALL HZCHISQ(-120,20)
          CALL HZCHISQ(-121,21)
          CALL HZCHISQ(-122,22)
          CALL HZCHISQ(-123,23)
          CALL HZCHISQ(-124,24)
          CALL HZCHISQ(-125,25)
          CALL HZCHISQ(-126,26)
          CALL HZCHISQ(-127,27)
          CALL HZCHISQ(-128,28)

        ENDIF

      ELSE
C     *** End ***
        PRINT*,'HZC98113:Please run with iflag set to 1,2 or 3'
      ENDIF

      RETURN
      END
*CMZ :  2.00/06 02/05/2002  15.07.33  by  Tancredi Carli
*CMZ :  2.00/02 17/01/2000  11.01.28  by  Tancredi Carli
*-- Author :    Tancredi Carli   17/01/2000
      subroutine HZ99091(IFLAG)

**********************************************************************
*Running: Ee=27.6, Ep=820, no polarization
*
*
* Arguments: iflag=1 initialisation
*            iflag=2 filling
*            iflag=3 termination
*
* written by: Carmen Tesch
*             Reimer Selle
*             Dirk Kruecker
*             Guido Nellen (nellen@mail.desy.de)
*********************************************************************
      IMPLICIT NONE
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
* --- subroutine-specific settings
*
      Integer iflag,ihep,i,j,k,l
*     DESY Preprint number
      Character*5 xxxx
      Data xxxx/'99091'/
      save xxxx
      character*60 string

      Real pi,dpi,rd,ee,eb
      Logical evcuthq,evcutahq,lp,evcutbhq,evcutalq,evcutblq
      Integer iel,idum,id
      Parameter (pi=3.1415927,dpi=2.*pi,rd=180./pi,ee=27.6)

* set the debug flag   lp
      Data lp/.false./
*      data lp/.true./

*---  counting variables
      Integer nentry
      Data nentry/0/

* --- kinematic variables
      Real x,y,q2,w2,obf,enel,ptel,thel,efwd,th,rap,pt,et,p
      Real phel,phpa,php,etp
      Real dth

* --- normalization var.
      Real xmi,xma,ymi,yma
      Integer nx,ny,nwt,loc,binahq,binbhq,binalq,binblq

      Character chtitl*80,rout*7
      data rout/'HIQ2ET'/

* --- var. related to cms-boost
      Integer ierr,ibeam,igam
      Double precision pbeam(4),pgam(4),pcm(4),ph(5),phc(4),pcme(4)

* --- Et in central + photo frag. region
      real etcent,etfrag



*********************************************************************
*
*                      data points from H1
*
*********************************************************************

* ---  low Q2 selection a), 17 histograms (bins in x-Q2)
*       etlq: transversal Energy-flow
*	eetlq: stat. E-flow - Error
*	setlq: first only syst. Err., later stat+sys. E-flow-Error
*       etalq: pseudo-rapidity in CMS (x-coordinate binning for histos)

      Real xmin,xmax
      Integer nb,nbin
      Parameter (nb=24,xmin=-6.,xmax=6.,nbin=17)
      Real etlq1(nb),etlq2(nb),etlq3(nb),etlq4(nb),etlq5(nb)
      Real etlq6(nb),etlq7(nb),etlq8(nb),etlq9(nb),etlq10(nb)
      Real etlq11(nb),etlq12(nb),etlq13(nb),etlq14(nb),etlq15(nb)
      Real etlq16(nb),etlq17(nb)
      Real eetlq1(nb),eetlq2(nb),eetlq3(nb),eetlq4(nb),eetlq5(nb)
      Real eetlq6(nb),eetlq7(nb),eetlq8(nb),eetlq9(nb),eetlq10(nb)
      Real eetlq11(nb),eetlq12(nb),eetlq13(nb),eetlq14(nb),eetlq15(nb)
      Real eetlq16(nb),eetlq17(nb)
      Real setlq1(nb),setlq2(nb),setlq3(nb),setlq4(nb),setlq5(nb)
      Real setlq6(nb),setlq7(nb),setlq8(nb),setlq9(nb),setlq10(nb)
      Real setlq11(nb),setlq12(nb),setlq13(nb),setlq14(nb),setlq15(nb)
      Real setlq16(nb),setlq17(nb)

*
*     energy flow data in the 17 bins
*     note: systematic errors are not included
*
      Data  etlq1/0.000,0.000,0.000,0.000,0.000,0.000,0.862,1.111,0.000,
     &     0.000,1.684,1.894,1.999,1.916,1.844,1.858,1.814,2.085,
     &     1.743,1.462,1.080,0.459,0.232,0.033/
      Data eetlq1/0.000,0.000,0.000,0.000,0.000,0.000,0.046,0.057,0.000,
     &     0.000,0.107,0.113,0.119,0.122,0.136,0.166,0.139,0.175,
     &     0.126,0.103,0.087,0.048,0.036,0.008/
      Data  etlq2/0.000,0.000,0.000,0.000,0.000,0.000,0.879,1.032,0.000,
     &     0.000,1.604,1.809,2.027,1.860,1.856,1.874,1.863,1.842,
     &     1.750,1.383,0.873,0.388,0.108 ,0.018/
      Data eetlq2/0.000,0.000,0.000,0.000,0.000,0.000,0.038,0.045,0.000,
     &     0.000,0.089,0.094,0.105,0.102,0.112,0.127,0.122,0.120,
     &     0.105,0.085,0.064,0.037,0.016,0.004/
      Data  etlq3/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.980,1.010,
     &     0.000,1.444,1.728,1.811,2.072,1.893,1.764,1.788,1.574,
     &     1.578,1.072,0.637,0.222,0.078,0.000/
      Data eetlq3/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.058,0.059,
     &     0.000,0.186,0.124,0.129,0.150,0.148,0.148,0.156,0.143,
     &     0.129,0.096,0.069,0.032,0.015,0.000/
      Data  etlq4/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.873,
     &     1.385,0.000,1.525,1.578,1.736,1.741,1.820,1.510,
     &     1.585,1.235,0.821,0.388,0.096,0.036,0.000/
      Data eetlq4/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.072,
     &      0.101,0.000,0.154,0.135,0.151,0.159,0.172,0.155,0.154,
     &      0.116,0.098,0.058,0.019,0.010,0.001/
      Data  etlq5/0.000,0.000,0.000,0.000,0.000,0.000,0.953,1.046,0.000,
     &     0.000,1.675,1.827,2.111,1.822,2.099,1.872,1.837,2.155,
     &     2.084,1.717,0.949,0.455,0.143,0.037/
      Data eetlq5/0.000,0.000,0.000,0.000,0.000,0.000,0.054,0.050,0.000,
     &     0.000,0.120,0.132,0.155,0.141,0.171,0.167,0.164,0.187,
     &     0.175,0.146,0.096,0.063,0.026,0.010/
      Data  etlq6/0.000,0.000,0.000,0.000,0.000,0.000,0.878,1.096,0.000,
     &     0.000,1.604,1.759,1.890,1.814,1.869,2.092,1.958,1.857,
     &     1.946,1.620,0.751,0.335,0.087,0.027/
      Data eetlq6/0.000,0.000,0.000,0.000,0.000,0.000,0.046,0.061,0.000,
     &     0.000,0.104,0.099,0.108,0.110,0.126,0.160,0.141,0.133,
     &     0.131,0.110,0.061,0.039,0.015,0.007/
      Data  etlq7/0.000,0.000,0.000,0.000,0.000,0.000,0.000,1.040,1.098,
     &     0.000,0.000,1.782,1.862,1.838,1.782,1.999,1.998,2.081,
     &     1.636,1.207,0.553,0.174,0.056,0.000/
      Data eetlq7/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.051,0.053,
     &     0.000,0.000,0.109,0.110,0.107,0.111,0.132,0.140,0.142,
     &     0.112,0.091,0.051,0.020,0.010,0.000/
      Data  etlq8/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,1.087,
     &     1.270,0.000,0.000,1.652,1.688,1.788,1.614,1.980,
     &     1.637,1.700,0.783,0.265,0.096,0.027,0.001/
      Data eetlq8/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.068,
     &     0.079,0.000,0.000,0.126,0.134,0.136,0.139,0.185,0.143,
     &     0.148,0.074,0.032,0.017,0.007,0.000/
      Data  etlq9/0.000,0.000,0.000,0.000,0.000,0.000,0.916,1.292,0.000,
     &     0.000,1.858,1.983,2.044,1.949,2.183,2.216,2.277,2.186,
     &     2.130,1.842,1.034,0.438,0.134,0.033/
      Data eetlq9/0.000,0.000,0.000,0.000,0.000,0.000,0.019,0.027,0.000,
     &     0.000,0.039,0.042,0.045,0.048,0.059,0.064,0.068,0.060,
     &     0.054,0.050,0.033,0.017,0.007,0.003 /
      Data  etlq10/0.000,0.000,0.000,0.000,0.000,0.000,0.000,1.085,
     &     1.479,0.000,1.623,1.886,1.925,1.866,2.025,2.072,2.200,2.194,
     &     2.148,1.419,0.698,0.274,0.085,0.021/
      Data eetlq10/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.029,
     &     0.040,0.000,0.044,0.046,0.050,0.050,0.068,0.072,0.077,
     &     0.067,0.062,0.045,0.025,0.014,0.006,0.002/
      Data  etlq11/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.890,
     &     1.282, 0.000,0.000,1.735,1.940,1.900,1.926,2.024,2.079,2.031,
     &     1.847,1.086,0.467,0.160,0.048,0.010/
      Data eetlq11/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.021,
     &     0.028,0.000,0.000,0.041,0.046,0.048,0.054,0.060,0.061,0.058,
     &     0.053,0.033,0.018,0.008,0.004,0.001/
      Data  etlq12/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &     1.056,1.492,0.000,1.474,1.821,1.946,1.838,1.994,2.047,1.859,
     &     1.479,0.716,0.281,0.072,0.017,0.003/
      Data eetlq12/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &     0.037,0.053,0.000,0.052,0.057,0.064,0.064,0.072,0.074,0.065,
     &     0.055,0.029,0.015,0.005,0.002,0.001/
      Data  etlq13/0.000,0.000,0.000,0.000,0.000,0.000,0.925,1.260,
     &     0.000,0.000,1.853,2.062,2.124,2.088,2.387,2.432,2.567,2.569,
     &     2.483,1.583,0.892,0.346,0.099,0.028/
      Data eetlq13/0.000,0.000,0.000,0.000,0.000,0.000,0.018,0.025,
     &     0.000,0.000,0.037,0.043,0.044,0.046,0.059,0.065,0.069,0.063,
     &     0.062,0.039,0.026,0.014,0.006,0.002/
      Data  etlq14/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.976,
     &     1.322,0.000,1.613,1.863,2.055,2.063,2.145,2.347,2.357,
     &     2.337,1.980,1.102,0.473,0.152,0.040,0.011/
      Data eetlq14/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.029,
     &     0.040,0.000,0.049,0.041,0.046,0.049,0.057,0.065,0.068,0.065,
     &     0.052,0.031,0.016,0.007,0.003,0.001/
      Data  etlq15/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &     1.064,1.548,0.000,1.551,1.903,2.125,2.073,2.187,2.250,2.259,
     &     1.334,0.577,0.266,0.071,0.020,0.005/
      Data eetlq15/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,
     &     0.035,0.050,0.000,0.051,0.061,0.065,0.065,0.078,0.078,0.078,
     &     0.046,0.026,0.013,0.006,0.002,0.001/
      Data  etlq16/0.000,0.000,0.000,0.000,0.000,0.000,0.844,1.269,
     &     0.000,1.488,1.777,2.089,2.284,2.277,2.611,2.976,2.813,2.682,
     &     2.335,1.571,0.704,0.336,0.091,0.013/
      Data eetlq16/0.000,0.000,0.000,0.000,0.000,0.000,0.052,0.078,
     &     0.000,0.137,0.111,0.097,0.100,0.113,0.154,0.174,0.179,0.168,
     &     0.128,0.096,0.058,0.027,0.010,0.003/
      Data  etlq17/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.961,
     &     1.233,0.000,1.468,1.818,2.073,2.179,2.401,2.634,2.604,2.278,
     &     1.506,0.812,0.303,0.095,0.024,0.007/
      Data eetlq17/0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.030,
     &     0.039,0.000,0.075,0.057,0.064,0.070,0.087,0.097,0.096,0.079,
     &     0.054,0.033,0.016,0.008,0.003,0.001/


* syst errors %
* plug up-dated to 32%
      Data setlq1/6*0. ,0.32,0.32,0.00,0.00,0.10,0.10,0.10,0.10,0.10
     &     ,0.10,0.10,0.10,0.10,0.17,0.21,0.22,0.22,0.22/
      Data setlq2/6*0. ,0.32,0.32,0.00,0.00,0.10,0.10,0.10,0.10,0.10
     &     ,0.10,0.10,0.10,0.10,0.14,0.18,0.21,0.22,0.22/
      Data setlq3/7*0. ,0.32,0.32,0.00,0.09,0.09,0.09,0.09,0.09,0.09
     &     ,0.09,0.09,0.09,0.11,0.13,0.14,0.16,0.17/
      Data setlq4/8*0. ,0.32,0.32,0.00,0.10,0.10,0.10,0.10,0.10
     &     ,0.10,0.10,0.10,0.11,0.12,0.12,0.12,0.12/
      Data setlq5/6*0. ,0.32,0.32,0.00,0.00,0.10,0.10,0.10,0.10,0.10
     &     ,0.10,0.10,0.10,0.10,0.16,0.21,0.22,0.22,0.22/
       Data setlq6/6*0. ,0.32,0.32,0.00,0.00,0.10,0.10,0.10,0.10,0.10
     &     ,0.10,0.10,0.10,0.10,0.13,0.16,0.19,0.21,0.21/
       Data setlq7/7*0. ,0.32,0.32,0.00,0.00,0.10,0.10,0.10,0.10,0.10
     &      ,0.10,0.10,0.10,0.12,0.13,0.12,0.12,0.12/
       Data setlq8/8*0. ,0.32,0.32,0.00,0.00,0.13,0.13,0.13,0.13
     &      ,0.13,0.13,0.13,0.14,0.13,0.13,0.14,0.13/
       Data setlq9/6*0. ,0.32,0.32,0.00,0.00,0.10,0.10,0.10,0.10,0.10
     &      ,0.10,0.10,0.10,0.11,0.15,0.18,0.20,0.21,0.21/
       Data setlq10/7*0.  ,0.32,0.32,0.00,0.09,0.09,0.09,0.09,0.09,0.09
     &      ,0.09,0.09,0.10,0.13,0.13,0.13,0.13,0.12/
       Data setlq11/7*0.  ,0.32,0.32,0.00,0.00,0.09,0.09,0.09,0.09,0.09
     &      ,0.09,0.09,0.10,0.11,0.09,0.09,0.09,0.09/
       Data setlq12/8*0.  ,0.32,0.32,0.00,0.10,0.10,0.10,0.10,0.10
     &      ,0.10,0.10,0.10,0.10,0.10,0.10,0.10,0.10/
       Data setlq13/6*0.  ,0.32,0.32,0.00,0.00,0.09,0.09,0.09,0.09,0.09
     &      ,0.09,0.09,0.09,0.11,0.13,0.14,0.15,0.16,0.17/
       Data setlq14/7*0.  ,0.32,0.32,0.00,0.09,0.09,0.09,0.09,0.09,0.09
     &      ,0.09,0.09,0.10,0.10,0.09,0.09,0.09,0.11/
       Data setlq15/8*0.  ,0.32,0.32,0.00,0.10,0.10,0.10,0.10,0.10
     &      ,0.10,0.10,0.10,0.10,0.10,0.10,0.10,0.10/
       Data setlq16/6*0.  ,0.32,0.32,0.00,0.09,0.09,0.10,0.09,0.09,0.10
     &      ,0.10,0.09,0.09,0.12,0.11,0.11,0.11,0.11,0.09/
       Data setlq17/7*0.  ,0.32,0.32,0.00,0.10,0.10,0.10,0.10,0.10,0.10
     &      ,0.10,0.10,0.10,0.10,0.10,0.10,0.10,0.10/

*
* low Q2 selection b), 5 histograms (bins in Q2, 0.3<y<0.5)
*	wetlq: transversal Energy-flow
*	weetlq: stat. E-flow - Error
*	wsetlq: stat+sys. E-flow-Error

      Real wxmin,wxmax
      Integer wnb,wnbin
      Parameter (wnb=14,wxmin=-1.,wxmax=6.,wnbin=7)

      Real wetlq2(wnb),wetlq3(wnb),wetlq4(wnb),wetlq5(wnb)
      Real wetlq6(wnb)
      Real weetlq2(wnb),weetlq3(wnb),weetlq4(wnb),weetlq5(wnb)
      Real weetlq6(wnb)
      Real wsetlq2(wnb),wsetlq3(wnb),wsetlq4(wnb),wsetlq5(wnb)
      Real wsetlq6(wnb)

      Data  wetlq2/1.421,1.593,1.752,1.698,1.622,1.805,1.626,1.792,
     &          1.706,1.445,1.001,0.493,0.179,0.029/
      Data weetlq2/0.075,0.081,0.089,0.088,0.098,0.128,0.102,0.118,
     &          0.098,0.082,0.066,0.041,0.022,0.006/
      Data  wetlq3/1.390,1.525,1.755,1.672,1.826,1.720,1.817,1.946,
     &          1.996,1.722,0.955,0.478,0.146,0.050/
      Data weetlq3/0.085,0.095,0.110,0.110,0.130,0.134,0.137,0.145,
     &          0.138,0.118,0.078,0.053,0.021,0.011/
      Data  wetlq4/1.651,1.748,1.862,1.846,2.003,2.075,2.131,2.105,
     &          2.097,1.846,1.029,0.459,0.140,0.040/
      Data weetlq4/0.038,0.040,0.045,0.050,0.060,0.064,0.068,0.061,
     &          0.057,0.052,0.035,0.019,0.008,0.004/
      Data  wetlq5/1.748,1.878,1.963,1.960,2.231,2.326,2.483,2.499,
     &          2.499,1.684,0.908,0.391,0.131,0.039/
      Data weetlq5/0.044,0.051,0.051,0.058,0.071,0.078,0.084,0.077,
     &          0.078,0.052,0.033,0.019,0.010,0.004/
      Data  wetlq6/1.709,1.919,2.194,1.932,2.691,2.843,2.858,2.701,
     &          2.282,1.705,0.769,0.420,0.120,0.016/
      Data weetlq6/0.139,0.121,0.133,0.126,0.215,0.213,0.234,0.238,
     &          0.166,0.142,0.085,0.042,0.018,0.005/

*correct systematic errors fixed W 2-5 in %
      Data wsetlq2/  0.10,0.10,0.10,0.10,0.10,0.10
     &     ,0.10,0.10,0.10,0.10,0.10,0.10,0.10,0.10/
      Data wsetlq3/  0.10,0.10,0.10,0.10,0.10,0.10
     &     ,0.10,0.10,0.10,0.10,0.10,0.10,0.10,0.10/
      Data wsetlq4/  0.10,0.10,0.10,0.10,0.10,0.10
     &     ,0.10,0.10,0.10,0.10,0.10,0.10,0.10,0.10/
      Data wsetlq5/  0.09,0.09,0.09,0.09,0.09,0.09
     &     ,0.09,0.09,0.09,0.09,0.09,0.09,0.09,0.09/
      Data wsetlq6/  0.09,0.09,0.09,0.10,0.09,0.09
     &     ,0.09,0.09,0.09,0.09,0.09,0.10,0.09,0.09/

* mean values of x,q2,W and the origin(breitframe)
* selection a)
      Real lqmx17(17),lqmq217(17),lqmobf17(17)

      Data lqmx17/0.00008,0.00014,0.00026,0.00057,0.00016,0.00027,
     &     0.0005,0.00108,0.00036,0.00063,0.00111,0.00226,0.00093,
     &     0.00207,0.00472,0.00203,0.00704/
      Data lqmq217/3.2,3.8,3.9,4.2,6.3,7.0,7.0,7.3,13.1,14.1,
     &     14.1,14.9,
     &     28.8,31.2,33.2,59.4,70.2/
      data lqmobf17/4.7167,4.43686,4.12728,3.73465,4.37009,4.10841,
     &     3.8002,3.40567,3.96452,3.68458,3.40567,3.03627,3.4897,
     &     3.08186,2.67774,3.1063,2.47741/

* selection b)
      Real lqmq25(5)
      Data lqmq25/3.5,7.,14.,30.,61./


*  Et vs Q2 for the central rap / the photon frag.
*  one histogram each, with 5 bins in Q2

*  etlqce:  transversal Energy-flow,     central rapidity region
*  eetlqce: stat. E-flow - Error,          "        "       "
*  setlqce: stat. + syst. E-flow - Error,  "        "       "
*	etlqfr: transversal Energy-flow,   photon fragmentation region
*	eetlqfr: stat. E-flow - Error,           "        "       "
*	setlqfr: stat. + syst. E-flow - Error,   "        "       "


      real qbinslq(6),etlqce(5),eetlqce(5),setlqce(5)
      real etlqfr(5),eetlqfr(5),setlqfr(5)

      data qbinslq/2.5,5.,10.,20.,50.,100./

      data etlqce/1.6725,1.64,1.805,1.9205,2.0565/
      data eetlqce/0.0601706,0.0736722,0.030104,0.0360624,0.0899027/
      data setlqce/0.177744,0.17938,0.182993,0.176567,0.205764/

      data etlqfr/1.709,1.8815,2.118,2.491,2.7795/
      data eetlqfr/0.0779872,0.0997422,0.0456755,0.0569759,0.166883/
      data setlqfr/0.187853,0.212953,0.216669,0.231317,0.300712/



* ---  high Q2 selection a), 7 histograms (bins in x-Q2)
*       ethq: transversal Energy-flow
*	eethq: stat. E-flow - Error
*	sethq: stat+sys. E-flow-Error
*       etahq: pseudo-rapidity in CMS (x-coordinate binning for histos)

      Real ethq1(13),ethq2(12),ethq3(9),ethq4(10),ethq5(11)
      Real ethq6(9 ),ethq7(9)
	
      Real eethq1(13),eethq2(12),eethq3(9),eethq4(10),eethq5(11)
      Real eethq6(9 ),eethq7(9)

      Real sethq1(13),sethq2(12),sethq3(9),sethq4(10),sethq5(11)
      Real sethq6(9 ),sethq7(9)

      Real etahq1(14),etahq2(13),etahq3(10),etahq4(11),etahq5(12)
      Real etahq6(10),etahq7(10)

*    number of bins for x-Q2-histogram nr. 1: nb1=14
      Data etahq1/-1.75, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0,
     &           3.5,   4.0,  4.75,5.75/	
*    nb2=13
      Data etahq2/-1.75, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0,
     &           3.5, 4.25, 5.25/
*    nb3=10
      Data etahq3/-1.25,-0.5,0.0,0.5,1.0,1.5,2.25,3.25,4.25,5.25/
*    nb4=11
      Data etahq4/-1.5, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.25, 4.25,
     &          5.25/ 	
*    nb5=12
      Data etahq5/-1.75, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.25,
     &           4.25, 5.25/	
*    nb6=10
      Data etahq6/-1.75, -1.0, -0.5, 0.0, 0.5, 1.0, 1.75, 2.75, 3.75,
     &           4.75/
*    nb7=10
      Data etahq7/-2.0, -1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 2.0, 3.0, 4.0/

      Data  ethq1/.000,2.077,2.390,2.444,2.727,3.070,3.603,3.469,3.454,
     &     2.725,1.837, .754, .130/
      Data eethq1/.000, .040, .053, .057, .079, .099, .137, .122, .100,
     &     .075, .058, .027, .008/
      Data  ethq2/ .000,1.879,2.319,2.642,2.814,3.288,3.473,3.589,3.089,
     &     2.221,1.138, .246/
      Data eethq2/.000, .043, .047, .057, .091, .105, .108, .106, .081,
     &     .061, .033, .011/
      Data  ethq3/.000,1.821,2.260,2.681,2.718,3.032,2.289, .744,
     &     .000/
      Data eethq3 /.000, .051, .060, .079, .090, .073, .053, .029,
     &     .000/
      Data  ethq4/2.126,2.569,2.937,3.126,4.224,4.408,3.973,3.935,1.852,
     &     .000/
      Data eethq4/ .094, .119, .163, .255, .412, .354, .304, .220, .102,
     &     .000/
      Data  ethq5/.000,1.937,2.353,2.865,3.100,3.661,4.150,3.873,2.974,
     &     1.182, .000/
      Data eethq5/.000, .075, .078, .106, .130, .173, .196, .164, .098,
     &     .043, .000/
      Data  ethq6/.000, .000,1.861,2.389,2.902,3.231,2.532, .000, .000/
      Data eethq6/.000, .000, .078, .087, .125, .104, .079, .000, .000/
      Data  ethq7/.000, .000,2.062,2.436,2.777,3.472,4.246,3.273,1.497/
      Data eethq7/.000, .000, .156, .115, .140, .228, .178, .129, .084/
      Data sethq1/.000, .299, .232, .190, .228, .257, .300, .333, .265,
     &     .218, .159, .094, .024/
      Data sethq2/.000, .189, .148, .198, .220, .246, .273, .266, .254,
     &     .224, .167, .057/
      Data sethq3/ .000, .188, .154, .231, .276, .277, .322, .214,
     &     .000/
      Data sethq4/ .162, .391, .320, .360, .538, .484, .432, .382, .188,
     &     .000/
      Data sethq5/ .000, .197, .170, .221, .264, .312, .361, .351, .344,
     &           .212, .000/
      Data sethq6/ .000, .000, .219, .209, .345, .386, .440, .000, .000/
      Data sethq7/ .000, .000, .230, .210, .271, .405, .477, .405, .359/


* high Q2 selection b), 3 histograms (bins in Q2, W approx. const.)
*	wethq: transversal Energy-flow
*	weethq: stat. E-flow - Error
*	wsethq: stat+sys. E-flow-Error
*       wetahq: pseudo-rapidity in CMS (x-coordinate binning for histos)

      Real wethq1(13),wethq2(12),wethq3(13)
      Real weethq1(13),weethq2(12),weethq3(13)
      Real wsethq1(13),wsethq2(12),wsethq3(13)
      Real wetahq1(14),wetahq2(13),wetahq3(14)
*
*     energy flow data in the 5 bins
*     note: systematic errors are not included in weethq

      Data  wethq1/0.,1.96144,2.26067,2.39531,2.54628,2.92249,3.42234,
     &     3.48024,3.4375,2.60368,1.76196,0.708719,0./
      Data weethq1/0.,0.0453798,0.0658047,0.0692139,0.118844,0.112638,
     &     0.153131,0.13977,0.113641,0.084296,0.0656442,0.029105,0./
      Data  wethq2/0.,2.13422,2.4708,2.76255,2.95303,3.48934,3.75384,
     &     3.80795,3.16871,2.60493,1.31544,0.307483/
      Data weethq2/0.,0.0669379,0.0795785,0.10199,0.137484,0.200204,
     &     0.211435,0.196098,0.139574,0.112423,0.0584927,0.0201879/
      Data  wethq3/0.,0,2.41631,2.56516,2.96521,3.26279,4.10874,
     &     4.48665,4.10311,3.86765,2.49623,0.,0./
      Data weethq3/0.,0,0.114194,0.103008,0.14824,0.215506,0.288596,
     &     0.266768,0.205114,0.197455,0.109017,0.,0./
      Data wsethq1/0.,0.285369,0.224487,0.194103,0.23986,0.239587,
     &     0.2777,0.281172,0.260204,0.197213,0.156636,0.0873512,0/
      Data wsethq2/0.,0.31699,0.234723,0.223517,0.248444,0.331568,
     &     0.3606,0.326333,0.323294,0.209277,0.118246,0.0427787/
      Data wsethq3/0.,0.,0.229923,0.217818,0.253925,0.311768,0.415278,
     &     0.410218,0.350569,0.367516,0.245055,0.,0./

*    nwb1=14
      Data wetahq1/-1.75, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5,
     &     3.0, 3.5, 4.0, 4.75, 5.75/
*     nwb2=13
      Data wetahq2/-1.75, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0,
     &     2.5, 3.0, 3.5, 4.25, 5.25/
*    nwb3=14
      Data wetahq3/-2., -1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0,
     &     2.5, 3.0, 3.75, 4.75, 5.75/

*  special q2-binning for Et vs Q2 for the central rap / the photon frag.
*  one histogram each, with 3 bins in Q2

*  ethqce:  transversal Energy-flow,     central rapidity region
*  eethqce: stat. E-flow - Error,          "        "       "
*  sethqce: stat. + syst. E-flow - Error,  "        "       "

*  ethqfr: transversal Energy-flow,   photon fragmentation region
*  eethqfr: stat. E-flow - Error,           "        "       "
*  sethqfr: stat. + syst. E-flow - Error,   "        "       "


      real qbinshq(4),ethqce(3),eethqce(3),sethqce(3)
      real ethqfr(3),eethqfr(3),sethqfr(3)

      data qbinshq/100.,220.,400.,90364./

      data ethqce/2.321799,2.61668,2.76518/
      data sethqce/0.203661,0.219599,0.21855/
      data eethqce/0.0477515,0.0646819,0.0902576/

      data ethqfr/3.45887,3.48839,3.98538/
      data sethqfr/0.255431,0.301307,0.329475/
      data eethqfr/0.0900693,0.120349,0.142355/

* mean values of x,q2,W and the origin(breitframe)

      real hqmx7(7),hqmQ27(7),hqmOBF7(7),hqmQ23(3)


* selection a)
      data hqmx7/0.0043,0.01,0.026,0.012,0.026,0.076,0.11/
      data hqmQ27/175.,253.,283.,511.,617.,682.,2200./
      data hqmobf7/2.74,2.34,1.88,2.19,1.84,1.31,1.15/

* selection b)
      data hqmQ23/191.,294.,1103./


*********************************************************************
*
*                      Initialization
*
*********************************************************************

      NENTRY=NENTRY+1
*
      IF (iflag.eq.1) then
*
*
*      Initialisation: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (i) make subdirectory in o/p file

       Call hcdir('//PAWC',' ')
       call hmdir(xxxx,'S')

       Call hcdir('//HISTO',' ')
       call hmdir(xxxx,'S')

*-------------------*
* low Q2 selection *
*-------------------*
* calc total errors out of stat. and syst. errors
       Do i=1,nb
          setlq1(i)=etlq1(i)*setlq1(i)
          setlq1(i)=sqrt(eetlq1(i)**2+setlq1(i)**2)
          setlq2(i)=etlq2(i)*setlq2(i)
          setlq2(i)=sqrt(eetlq2(i)**2+setlq2(i)**2)
          setlq3(i)=etlq3(i)*setlq3(i)
          setlq3(i)=sqrt(eetlq3(i)**2+setlq3(i)**2)
          setlq4(i)=etlq4(i)*setlq4(i)
          setlq4(i)=sqrt(eetlq4(i)**2+setlq4(i)**2)
          setlq5(i)=etlq5(i)*setlq5(i)
          setlq5(i)=sqrt(eetlq5(i)**2+setlq5(i)**2)
          setlq6(i)=etlq6(i)*setlq6(i)
          setlq6(i)=sqrt(eetlq6(i)**2+setlq6(i)**2)
          setlq7(i)=etlq7(i)*setlq7(i)
          setlq7(i)=sqrt(eetlq7(i)**2+setlq7(i)**2)
          setlq8(i)=etlq8(i)*setlq8(i)
          setlq8(i)=sqrt(eetlq8(i)**2+setlq8(i)**2)
          setlq9(i)=etlq9(i)*setlq9(i)
          setlq9(i)=sqrt(eetlq9(i)**2+setlq9(i)**2)
          setlq10(i)=etlq10(i)*setlq10(i)
          setlq10(i)=sqrt(eetlq10(i)**2+setlq10(i)**2)
          setlq11(i)=etlq11(i)*setlq11(i)
          setlq11(i)=sqrt(eetlq11(i)**2+setlq11(i)**2)
          setlq12(i)=etlq12(i)*setlq12(i)
          setlq12(i)=sqrt(eetlq12(i)**2+setlq12(i)**2)
          setlq13(i)=etlq13(i)*setlq13(i)
          setlq13(i)=sqrt(eetlq13(i)**2+setlq13(i)**2)
          setlq14(i)=etlq14(i)*setlq14(i)
          setlq14(i)=sqrt(eetlq14(i)**2+setlq14(i)**2)
          setlq15(i)=etlq15(i)*setlq15(i)
          setlq15(i)=sqrt(eetlq15(i)**2+setlq15(i)**2)
          setlq16(i)=etlq16(i)*setlq16(i)
          setlq16(i)=sqrt(eetlq16(i)**2+setlq16(i)**2)
          setlq17(i)=etlq17(i)*setlq17(i)
          setlq17(i)=sqrt(eetlq17(i)**2+setlq17(i)**2)
       enddo

       Do i=1,wnb
          wsetlq2(i)=wetlq2(i)*wsetlq2(i)
          wsetlq2(i)=sqrt(weetlq2(i)**2+wsetlq2(i)**2)
          wsetlq3(i)=wetlq3(i)*wsetlq3(i)
          wsetlq3(i)=sqrt(weetlq3(i)**2+wsetlq3(i)**2)
          wsetlq4(i)=wetlq4(i)*wsetlq4(i)
          wsetlq4(i)=sqrt(weetlq4(i)**2+wsetlq4(i)**2)
          wsetlq5(i)=wetlq5(i)*wsetlq5(i)
          wsetlq5(i)=sqrt(weetlq5(i)**2+wsetlq5(i)**2)
          wsetlq6(i)=wetlq6(i)*wsetlq6(i)
          wsetlq6(i)=sqrt(weetlq6(i)**2+wsetlq6(i)**2)
       enddo


* booking histos
* selection a)

       Do i=1,nbin
          write(string,'(A,I2)') '1/N dEt/d[c] CMS x-Q2-bin nr. ',i
          call hbook1(-i,string,nb,xmin,xmax, 0.)
          call hbook1(i,string,nb,xmin,xmax, 0.)
          write(string,'(A,I2,A)') '1/N dEt/d[c] CMS x-Q2-bin nr. ',i
     &         ,' stat. err. only'
          call hbook1(-100-i,string,nb,xmin,xmax, 0.)
       enddo

       call hbprof(-31,'mean x vs. x-Q2-bin, no err.',17,0.5,17.5,
     &      -1.E30,1.E30,' ')
       call hbprof( 31,'mean x vs. x-Q2-bin',17,0.5,17.5,
     &      -1.E30,1.E30,' ')
       call hbprof(-32,'mean Q2 vs. x-Q2-bin, no err.',17,0.5,17.5,
     &      -1.E30,1.E30,' ')
       call hbprof( 32,'mean Q2 vs. x-Q2-bin',17,0.5,17.5,
     &      -1.E30,1.E30,' ')
       call hbprof(-33,'mean origin(breitframe) vs. x-Q2-bin, no err.'
     &      ,17,0.5,17.5,-1.E30,1.E30,' ')
       call hbprof( 33,'mean origin(breitframe) vs. x-Q2-bin'
     &      ,17,0.5,17.5,-1.E30,1.E30,' ')	
       call hbook1(35,'number of events vs. x-Q2-bin',17,0.5,17.5, 0.)


       call hbarx(31)
       call hbarx(32)
       call hbarx(33)


* ---- pack data into histograms ; 17 bins
*      histos with full errors
       Call hpak (-1,etlq1)
       Call hpake(-1,setlq1)
       Call hpak (-2,etlq2)
       Call hpake(-2,setlq2)
       Call hpak (-3,etlq3)
       Call hpake(-3,setlq3)
       Call hpak (-4,etlq4)
       Call hpake(-4,setlq4)
       Call hpak (-5,etlq5)
       Call hpake(-5,setlq5)
       Call hpak (-6,etlq6)
       Call hpake(-6,setlq6)
       Call hpak (-7,etlq7)
       Call hpake(-7,setlq7)
       Call hpak (-8,etlq8)
       Call hpake(-8,setlq8)
       Call hpak (-9,etlq9)
       Call hpake(-9,setlq9)
       Call hpak (-10,etlq10)
       Call hpake(-10,setlq10)
       Call hpak (-11,etlq11)
       Call hpake(-11,setlq11)
       Call hpak (-12,etlq12)
       Call hpake(-12,setlq12)
       Call hpak (-13,etlq13)
       Call hpake(-13,setlq13)
       Call hpak (-14,etlq14)
       Call hpake(-14,setlq14)
       Call hpak (-15,etlq15)
       Call hpake(-15,setlq15)
       Call hpak (-16,etlq16)
       Call hpake(-16,setlq16)
       Call hpak (-17,etlq17)
       Call hpake(-17,setlq17)

* ---- histos with stat errors only
       Call hpak (-101,etlq1)
       Call hpake(-101,eetlq1)
       Call hpak (-102,etlq2)
       Call hpake(-102,eetlq2)
       Call hpak (-103,etlq3)
       Call hpake(-103,eetlq3)
       Call hpak (-104,etlq4)
       Call hpake(-104,eetlq4)
       Call hpak (-105,etlq5)
       Call hpake(-105,eetlq5)
       Call hpak (-106,etlq6)
       Call hpake(-106,eetlq6)
       Call hpak (-107,etlq7)
       Call hpake(-107,eetlq7)
       Call hpak (-108,etlq8)
       Call hpake(-108,eetlq8)
       Call hpak (-109,etlq9)
       Call hpake(-109,eetlq9)
       Call hpak (-110,etlq10)
       Call hpake(-110,eetlq10)
       Call hpak (-111,etlq11)
       Call hpake(-111,eetlq11)
       Call hpak (-112,etlq12)
       Call hpake(-112,eetlq12)
       Call hpak (-113,etlq13)
       Call hpake(-113,eetlq13)
       Call hpak (-114,etlq14)
       Call hpake(-114,eetlq14)
       Call hpak (-115,etlq15)
       Call hpake(-115,eetlq15)
       Call hpak (-116,etlq16)
       Call hpake(-116,eetlq16)
       Call hpak (-117,etlq17)
       Call hpake(-117,eetlq17)


* ---- histos with no error
       call hpak (-31,lqmx17)
       call hpak (-32,lqmq217)
       call hpak (-33,lqmobf17)

       call hbarx(31)
       call hbarx(32)
       call hbarx(33)


* selection b)

       Do i=1,5
          write(string,'(A,I2)') '1/N dEt/d[c] CMS Q2-bin nr. ',i
          call hbook1(-i-20,string,wnb,wxmin,wxmax, 0.)
          call hbook1(i+20,string,wnb,wxmin,wxmax, 0.)
          write(string,'(A,I2,A)') '1/N dEt/d[c] CMS Q2-bin nr. '
     &         ,i,' stat. err. only'
          call hbook1(-120-i,string,wnb,wxmin,wxmax, 0.)
       enddo

       string='1/N dEt/d[c] CMS for -0.5"o#[c]"o#0.5 vs Q2'
       call hbookb(-26,string,5,qbinslq,0.)
       call hbookb(26,string,5,qbinslq,0.)
       write(string,'(A,A)') '1/N dEt/d[c] CMS for -0.5"o#[c]"o#0.5',
     &      'vs Q2, stat. err. only'
       call hbookb(-126,string,5,qbinslq,0.)

       string='1/N dEt/d[c] CMS for 2"o#[c]"o#3 vs Q2'
       call hbookb(-27,string,5,qbinslq,0.)
       call hbookb(27,string,5,qbinslq,0.)
       string='1/N dEt/d[c] CMS for 2"o#[c]"o#3 vs Q2, stat. err. only'
       call hbookb(-127,string,5,qbinslq,0.)

       call hbprof(-34,'mean Q2 vs. Q2-bin,no errors',5,0.5,5.5,
     &      -1.E30,1.E30,' ')
       call hbprof( 34,'mean Q2 vs. Q2-bin',5,0.5,5.5,
     &      -1.E30,1.E30,' ')
       call hbook1(36,'number of events vs. Q2-bin',5,0.5,5.5,0.)

       call hbarx(26)
       call hbarx(27)

       call hbarx(34)

* histos with total errors
       Call hpak (-21,wetlq2)
       Call hpake(-21,wsetlq2)
       Call hpak (-22,wetlq3)
       Call hpake(-22,wsetlq3)
       Call hpak (-23,wetlq4)
       Call hpake(-23,wsetlq4)
       Call hpak (-24,wetlq5)
       Call hpake(-24,wsetlq5)
       Call hpak (-25,wetlq6)
       Call hpake(-25,wsetlq6)

       Call hpak (-26,etlqce)
       Call hpake(-26,setlqce)
       Call hpak (-27,etlqfr)
       Call hpake(-27,setlqfr)

* histos with stat. errors only
       Call hpak (-121,wetlq2)
       Call hpake(-121,weetlq2)
       Call hpak (-122,wetlq3)
       Call hpake(-122,weetlq3)
       Call hpak (-123,wetlq4)
       Call hpake(-123,weetlq4)
       Call hpak (-124,wetlq5)
       Call hpake(-124,weetlq5)
       Call hpak (-125,wetlq6)
       Call hpake(-125,weetlq6)

       Call hpak (-126,etlqce)
       Call hpake(-126,eetlqce)
       Call hpak (-127,etlqfr)
       Call hpake(-127,eetlqfr)

* histos with no errors
       call hpak (-34,lqmq25)

*-------------------*
* high Q2 selection *
*-------------------*
* booking the histos for selection a), which uses 7 x-Q2-bins

       string='1/N dEt/d[c] CMS x-Q2-bin nr. 1'
       call hbookb(-41,string,13,etahq1,0.)
       call hbookb(41,string,13,etahq1,0.)
       string='1/N dEt/d[c] CMS x-Q2-bin nr. 1, stat. err. only'
       call hbookb(-141,string,13,etahq1,0.)

       string='1/N dEt/d[c] CMS x-Q2-bin nr. 2'
       call hbookb(-42,string,12,etahq2,0.)
       call hbookb(42,string,12,etahq2,0.)
       string='1/N dEt/d[c] CMS x-Q2-bin nr. 2, stat. err. only'
       call hbookb(-142,string,12,etahq2,0.)

       string='1/N dEt/d[c] CMS x-Q2-bin nr. 3'
       call hbookb(-43,string,9,etahq3,0.)
       call hbookb(43,string,9,etahq3,0.)
       string='1/N dEt/d[c] CMS x-Q2-bin nr. 3, stat. err. only'
       call hbookb(-143,string,9,etahq3,0.)

       string='1/N dEt/d[c] CMS x-Q2-bin nr. 4'
       call hbookb(-44,string,10,etahq4,0.)
       call hbookb(44,string,10,etahq4,0.)
       string='1/N dEt/d[c] CMS x-Q2-bin nr. 4, stat. err. only'
       call hbookb(-144,string,10,etahq4,0.)

       string='1/N dEt/d[c] CMS x-Q2-bin nr. 5'
       call hbookb(-45,string,11,etahq5,0.)
       call hbookb(45,string,11,etahq5,0.)
       string='1/N dEt/d[c] CMS x-Q2-bin nr. 5, stat. err. only'
       call hbookb(-145,string,11,etahq5,0.)

       string='1/N dEt/d[c] CMS x-Q2-bin nr. 6'
       call hbookb(-46,string,9,etahq6,0.)
       call hbookb(46,string,9,etahq6,0.)
       string='1/N dEt/d[c] CMS x-Q2-bin nr. 6, stat. err. only'
       call hbookb(-146,string,9,etahq6,0.)

       string='1/N dEt/d[c] CMS x-Q2-bin nr. 7'
       call hbookb(-47,string,9,etahq7,0.)
       call hbookb(47,string,9,etahq7,0.)
       string='1/N dEt/d[c] CMS x-Q2-bin nr. 7, stat. err. only'
       call hbookb(-147,string,9,etahq7,0.)

       call hbprof(-61,'mean x vs. x-Q2-bin, no err.',7,0.5,7.5,
     &      -1.E30,1.E30,' ')
       call hbprof( 61,'mean x vs. x-Q2-bin',7,0.5,7.5,
     &      -1.E30,1.E30,' ')
       call hbprof(-62,'mean Q2 vs. x-Q2-bin, no err.',7,0.5,7.5,
     &      -1.E30,1.E30,' ')
       call hbprof( 62,'mean Q2 vs. x-Q2-bin',7,0.5,7.5,
     &      -1.E30,1.E30,' ')
       call hbprof(-63,'mean origin(breitframe) vs. x-Q2-bin, no err.'
     &      ,7,0.5,7.5,-1.E30,1.E30,' ')
       call hbprof( 63,'mean origin(breitframe) vs. x-Q2-bin'
     &      ,7,0.5,7.5,-1.E30,1.E30,' ')	
       call hbook1(65,'number of events vs. x-Q2-bin',7,0.5,7.5,0.)

       call hbarx(61)
       call hbarx(62)
       call hbarx(63)


* fill the data histos for selection a)
* histos with full errors
       Call hpak (-41,ethq1)
       Call hpake(-41,sethq1)
       Call hpak (-42,ethq2)
       Call hpake(-42,sethq2)
       Call hpak (-43,ethq3)
       Call hpake(-43,sethq3)
       Call hpak (-44,ethq4)
       Call hpake(-44,sethq4)
       Call hpak (-45,ethq5)
       Call hpake(-45,sethq5)
       Call hpak (-46,ethq6)
       Call hpake(-46,sethq6)
       Call hpak (-47,ethq7)
       Call hpake(-47,sethq7)

* histos with only statistical errors
       Call hpak (-141,ethq1)
       Call hpake(-141,eethq1)
       Call hpak (-142,ethq2)
       Call hpake(-142,eethq2)
       Call hpak (-143,ethq3)
       Call hpake(-143,eethq3)
       Call hpak (-144,ethq4)
       Call hpake(-144,eethq4)
       Call hpak (-145,ethq5)
       Call hpake(-145,eethq5)
       Call hpak (-146,ethq6)
       Call hpake(-146,eethq6)
       Call hpak (-147,ethq7)
       Call hpake(-147,eethq7)

* histos with no errors
       call hpak(-61,hqmx7)
       call hpak(-62,hqmQ27)
       call hpak(-63,hqmobf7)

* booking the histos concerning selection b)
       string='1/N dEt/d[c] CMS Q2-bin nr. 1'
       call hbookb(-51,string,13,wetahq1,0.)
       call hbookb(51,string,13,wetahq1,0.)
       string='1/N dEt/d[c] CMS Q2-bin nr. 1, stat err. only'
       call hbookb(-151,string,13,wetahq1,0.)

       string='1/N dEt/d[c] CMS Q2-bin nr. 2'
       call hbookb(-52,string,12,wetahq2,0.)
       call hbookb(52,string,12,wetahq2,0.)
       string='1/N dEt/d[c] CMS Q2-bin nr. 2, stat err. only'
       call hbookb(-152,string,12,wetahq2,0.)

       string='1/N dEt/d[c] CMS Q2-bin nr. 3'
       call hbookb(-53,string,13,wetahq3,0.)
       call hbookb(53,string,13,wetahq3,0.)
       string='1/N dEt/d[c] CMS Q2-bin nr. 3, stat err. only'
       call hbookb(-153,string,13,wetahq3,0.)

       string='1/N dEt/d[c] CMS for -0.5"o#[c]"o#=0.5 vs Q2'
       call hbookb(-54,string,3,qbinshq,0.)
       call hbookb(54,string,3,qbinshq,0.)
       string='1/N dEt/d[c] CMS for -0.5"0#[c]"o#0.5 vs Q2,
     &      stat. err. only'
       call hbookb(-154,string,3,qbinshq,0.)

       string='1/N dEt/d[c] CMS for 2"o#[c]"o#3 vs Q2'
       call hbookb(-55,string,3,qbinshq,0.)
       call hbookb(55,string,3,qbinshq,0.)
       string='1/N dEt/d[c] CMS for 2"o#[c]"o#3 vs Q2, stat. err. only'
       call hbookb(-155,string,3,qbinshq,0.)

       call hbprof(-64,'mean Q2 vs. Q2-bin,no errors',3,0.5,3.5,
     &      -1.E30,1.E30,' ')
       call hbprof( 64,'mean Q2 vs. Q2-bin',3,0.5,3.5,
     &      -1.E30,1.E30,' ')
       call hbook1(66,'number of events vs. Q2-bin',3,0.5,3.5,0.)

       call hbarx(54)
       call hbarx(55)
       call hbarx(64)


* fill the data histos
* histos with full errors
       Call hpak (-51,wethq1)
       Call hpake(-51,wsethq1)
       Call hpak (-52,wethq2)
       Call hpake(-52,wsethq2)
       Call hpak (-53,wethq3)
       Call hpake(-53,wsethq3)
       Call hpak (-54,ethqce)
       Call hpake(-54,sethqce)
       Call hpak (-55,ethqfr)
       Call hpake(-55,sethqfr)

* histos with only stat. errors
       Call hpak (-151,wethq1)
       Call hpake(-151,weethq1)
       Call hpak (-152,wethq2)
       Call hpake(-152,weethq2)
       Call hpak (-153,wethq3)
       Call hpake(-153,weethq3)
       Call hpak (-154,ethqce)
       Call hpake(-154,eethqce)
       Call hpak (-155,ethqfr)
       Call hpake(-155,eethqfr)

* ---- histos with no errors
       call hpak(-64,hqmQ23)

* ---- book histos that contain crossection/number of gen. events
       call hbook1(71,'gen. crossection',1,0.,1.,0.)
       call hbook1(72,'gen. number of events',1,0.,1.,0.)


* ---- book dummy histgrams, that help in the Et-calculation
       do i=1,17
          call hcopy(i,1000+i,' ')
       enddo
       do i=1,5
          call hcopy(20+i,1020+i,' ')
       enddo
       do i=1,7
          call hcopy(40+i,1040+i,' ')
       enddo
       do i=1,3
          call hcopy(50+i,1050+i,' ')
       enddo


*********************************************************************
*
*                      Event Processing
*
*********************************************************************

      elseif (iflag.eq.2) then


* filling: The following MUST always be done
* (i) move to the correct sub-directory in PAWC
         call hcdir('//PAWC/'//xxxx,' ')



* get kinematic variables
         q2=real(HZDISKIN(1))
         x =real(HZDISKIN(2))
         y =real(HZDISKIN(3))
         w2=real(HZDISKIN(4))
         obf=log(1/x-1)/2

         if (lp) write(6,*) 'Hz'//xxxx, ' x= ',x,
     &       ' Q2 ',q2,' y= ',y,' w2= ',w2,'O(BF)=',obf,' wtx= ',wtx

* ------ get electron variables
         iel=HZIDELEC(idum)
         if (iel.eq.-1) then
            write(6,*) 'Hz'//xxxx,' electron not found '
            goto 9990
         endif
         enel=real(PHEP(4,iel))
         thel=real(HZPHMANG(PHEP(3,iel),
     &        sqrt(PHEP(1,iel)**2+PHEP(2,iel)**2)))*rd

         if (lp) write(6,*) 'Hz'//xxxx,
     &        ' enel= ',enel,'GeV',' thel= ',thel,'Degrees'


* ----- calculate forward energy
         efwd=0.
         Do ihep=1,nhep
            if (isthep(ihep).eq.1.and.ihep.ne.iel) then
               th=real(HZPHMANG(PHEP(3,ihep),
     &              sqrt(PHEP(1,ihep)**2+PHEP(2,ihep)**2)))*rd
               if(th.gt.4.4.and.th.lt.15.) then
                  efwd=real(PHEP(4,ihep))+efwd
               endif
            endif
         enddo

         if (lp) write(6,*) 'Hz'//xxxx,
     &        ' efwd= ',efwd


*------ calc. flag for selection
*        evcutalq = low Q2 selection a)
*        evcutblq = low Q2 selection b)
*        evcutahq = high Q2 selection a)
*        evcutbhq = high Q2 selection b) (w ~185 GeV)

         evcutalq= enel.gt.12.
         evcutalq= (thel.gt.157.).and.(thel.lt.176.0).and. evcutalq
         evcutalq= (w2.ge.4400.).and. evcutalq
         evcutalq = evcutalq.and.(efwd.gt.0.5)

         evcutblq= enel.gt.12.
         evcutblq= y.gt.0.3 .and. y.lt.0.5 .and. evcutblq

         evcutahq= thel.gt.12. .and. thel.lt.150.0
         evcutahq= (y.gt.0.05).and.(y.lt.0.6).and.evcutahq
         evcutahq= w2.ge.4400..and. evcutahq
         evcutahq = evcutahq.and.(efwd.gt.0.5)

         evcutbhq= thel.gt.12. .and. thel.lt.150.0
         evcutbhq= (y.gt.0.05).and.(y.lt.0.6).and.evcutbhq
         evcutbhq= w2.gt.27110. .and. w2.lt.45182. .and. evcutbhq

         if (lp) then
            write(6,*) ' evcutalq= ',evcutalq
            write(6,*) ' evcutblq= ',evcutblq
            write(6,*) ' evcutahq= ',evcutahq
            write(6,*) ' evcutbhq= ',evcutbhq
         endif

* ------ early event skip?
         if (.not.(evcutalq.or.evcutblq.or.evcutahq.or.evcutbhq)) then
            goto 9990
         endif

* ------ find the bin numbers
*        low Q2 selection a), x-Q2 bins
         binalq = 0
         if(q2.gt.2.5.and.q2.le.5.) then
            if(x.gt.0.00005.and.x.le.0.0001) binalq=1
            if(x.gt.0.0001.and.x.le.0.0002) binalq=2
            if(x.gt.0.0002.and.x.le.0.00035) binalq=3
            if(x.gt.0.00035.and.x.le.0.0010) binalq=4
         elseif(q2.gt.5..and.q2.le.10.) then
            if(x.gt.0.0001.and.x.le.0.0002) binalq=5
            if(x.gt.0.0002.and.x.le.0.00035) binalq=6
            if(x.gt.0.00035.and.x.le.0.0007) binalq=7
            if(x.gt.0.0007.and.x.le.0.0020) binalq=8
         elseif(q2.gt.10..and.q2.le.20.) then
            if(x.gt.0.0002.and.x.le.0.0005) binalq=9
            if(x.gt.0.0005.and.x.le.0.0008) binalq=10
            if(x.gt.0.0008.and.x.le.0.0015) binalq=11
            if(x.gt.0.0015.and.x.le.0.040) binalq=12
         elseif(q2.gt.20..and.q2.le.50.) then
            if(x.gt.0.0005.and.x.le.0.0014) binalq=13
            if(x.gt.0.0014.and.x.le.0.0030) binalq=14
            if(x.gt.0.0030.and.x.le.0.0100) binalq=15
         elseif(q2.gt.50..and.q2.le.100.) then
            if(x.gt.0.0008.and.x.le.0.0030) binalq=16
            if(x.gt.0.0030.and.x.le.0.0200) binalq=17
         endif

         if (lp) write(6,*) 'Hz'//xxxx,'binalq=',binalq
         if (binalq.eq.0) then
            evcutalq=.false.
         endif

* ------ low Q2 selection b), Q2 bins
         binblq = 0
         if(q2.gt.2.5.and.q2.le.5.) binblq=1
         if(q2.gt.5..and.q2.le.10.) binblq=2
         if(q2.gt.10..and.q2.le.20.) binblq=3
         if(q2.gt.20..and.q2.le.50.) binblq=4
         if(q2.gt.50..and.q2.le.100.) binblq=5

         if (lp) write(6,*) 'Hz'//xxxx,'binblq=',binblq
         if (binblq.eq.0) then
            evcutblq=.false.
         endif

* ------ high Q2 selection a), x-Q2 bins
         binahq=0
         if (evcutahq) then
            if(q2.gt.100..and.q2.le.400.) then
               if(x.gt.0.00251.and.x.le.0.00631) binahq=1
               if(x.gt.0.00631.and.x.le.0.0158) binahq=2
               if(x.gt.0.0158.and.x.le.0.0398) binahq=3
            elseif(q2.gt.400.and.q2.le.1100.) then
               if(x.gt.0.00631.and.x.le.0.0158) binahq=4
               if(x.gt.0.0158.and.x.le.0.0398) binahq=5
               if(x.gt.0.0398.and.x.le.1.) binahq=6
            elseif(q2.gt.1100..and.q2.le.100000.) then
               if(x.gt.0..and.x.le.1.) binahq=7
            endif
         endif

         if (lp) then
            write(6,*) ' binahq= ',binahq
         endif
         if (binahq.eq.0) then
            evcutahq=.false.
         endif

* ------ high Q2 selection b), Q2 bins
         binbhq=0
         if (evcutbhq) then
            if(q2.gt.100..and.q2.le.220.) then
               binbhq=1
            elseif(q2.gt.220..and.q2.le.400.) then
               binbhq=2
            elseif(q2.gt.400.) then
               binbhq=3
            endif
         endif

         if (lp) then
            write(6,*) ' binbhq= ',binbhq
       endif
       if (binbhq.eq.0) then
          evcutbhq=.false.
       endif

* ------ early event skip?
       if (.not.(evcutalq.or.evcutblq.or.evcutahq.or.evcutbhq)) then
          goto 9990
       endif

* ----- 'pre-check' for generated events
       ierr=HZIBEAM(ibeam,idum)
       if (.not.(ierr.eq.1)) then
          write(6,*) 'HZ'//xxxx,' beams not found ! '
          goto 9990
       else
          Do i=1,4
             pbeam(i)=PHEP(i,IBEAM)
          enddo
       endif

       if (lp) write(6,*) ' pbeam= ',pbeam

       eb=real(PHEP(4,idum))
       if (abs(abs(eb)-ee).gt.0.2) then
          if (nentry.lt.10) then
             write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,'  ! '
          elseif (nentry.eq.10) then
             write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &            ' ...last message ! '
          endif
          goto 9990
       endif

       if (lp) write(6,*) ' eb= ',eb

       ierr=HZIPGAM(ph)
       if (ierr.eq.-1) then
          write(6,*) 'HZ'//xxxx,' boson vector not found ! '
          goto 9990
       else
          Do i=1,4
             pgam(i)=ph(i)
          enddo
       endif

       if (lp) write(6,*) ' pgam= ',pgam

* ----- initialize boost to cms
       call HZHCMINI(pbeam,pgam,ierr)
       if (ierr.eq.-1) then
          write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
          goto 9990
       endif

       if (lp) write(6,*) ' nhep= ',nhep,' iel= ',iel


* ---- reset all quantities needed to calc. Et flow for one event
       etcent=0
       etfrag=0

       if (evcutalq) then
          call hreset(binalq+1000,' ')
       endif
       if (evcutblq) then
          call hreset(binblq+1020,' ')
       endif
       if (evcutahq) then
         call hreset(binahq+1040,' ')
       endif
       if (evcutbhq) then
          call hreset(binbhq+1050,' ')
       endif

* ---- loop over all particles of the haronic final state
       do 2000 ihep=1,nhep

* ------- skip unstable particles (they represent additional information and NOT
*         particles of the hadronic final state) and the scat. el.
          if (isthep(ihep).ne.1.or.ihep.eq.iel) goto 2000

* ------- transform 4vec of particle into CMS (4vec CMS: pcm)
          Do i=1,4
             Phc(i)=PHEP(i,ihep)
          enddo
          call HZHCM(phc,pcm,ierr)
          if (ierr.eq.-1) then
             write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
             goto 9990
          endif

* ------- calc. transverse energy (et) for the particle
          p      = real(sqrt(pcm(1)**2+pcm(2)**2+pcm(3)**2 ))
          pt     = real(sqrt( pcm(1)**2+pcm(2)**2 ))
          if (p.eq.0.) then
             write(6,*) xxxx,' p(',ihep,') = ',p
             goto 2000
          endif
          et     = real(pcm(4)) * pt / p


* ------- calc. pseudorapidity of particle
          th     = (acos(real(pcm(3))/p))
          if (abs(     th*rd).lt.1.e-4 .or.
     &         abs(180.-th*rd).lt.1.e-4 ) then
             goto 2000
          else
             rap    = -log(tan( th/2. ))
          endif

          if (lp) write(6,*) 'Hz'//xxxx,
     &         'lab: et,pt,rap,th ',et,pt,rap,th*rd

* -------- sum Et central rap./photon frag. region
          if (rap.gt.-0.5.and.rap.lt.0.5) then
             etcent=etcent+et
          endif
          if (rap.gt.2.0.and.rap.le.3.0) then
             etfrag=etfrag+et
          endif

* -------- sum Et for low/high Q2 sel. a)/b)
          if (evcutalq) then
             call hf1(1000+binalq, rap, et)
          endif
          if (evcutblq) then
             call hf1(1020+binblq, rap, et)
          endif
          if (evcutahq) then
             call hf1(1040+binahq, rap, et)
          endif
          if (evcutbhq) then
             call hf1(1050+binbhq, rap, et)
          endif

 2000  continue

* --- fill all histogramms concerning the whole event

       if (evcutalq) then
          call h9091fil(binalq,1000+binalq,wtx)
          call hfill(31,real(binalq),x,wtx)
          call hfill(32,real(binalq),q2,wtx)
          call hfill(33,real(binalq),obf,wtx)
          call hf1(35,real(binalq),wtx)
       endif
       if (evcutblq) then
          call h9091fil(20+binblq,1020+binblq,wtx)
          call hzmeanhi(26,dble(q2),dble(etcent),wtx)
          call hzmeanhi(27,dble(q2),dble(etfrag),wtx)
          call hfill(34,real(binblq),q2,wtx)
          call hf1(36,real(binblq),wtx)
       endif
       if (evcutahq) then
          call h9091fil(40+binahq,1040+binahq,wtx)
          call hfill(61,real(binahq),x,wtx)
          call hfill(62,real(binahq),q2,wtx)
          call hfill(63,real(binahq),obf,wtx)
          call hf1(65,real(binahq),wtx)
       endif
       if (evcutbhq) then
          call h9091fil(50+binbhq,1050+binbhq,wtx)
          call hzmeanhi(54,dble(q2),dble(etcent),wtx)
          call hzmeanhi(55,dble(q2),dble(etfrag),wtx)
          call hfill(64,real(binbhq),x,wtx)
          call hf1(66,real(binbhq),wtx)
       endif

9990   continue

*********************************************************************
*
*                      Termination
*
*********************************************************************

      Else if(iflag.eq.3) then

*      Termination: The following MUST always be done
*      (i) Move to the correct PAW subdirectory

         call hcdir('//PAWC/'//xxxx,' ')

         do i=1,17
            call hdelet(1000+i)
            call hzhinrm(i,0,1.,1)
            call hzchisq(-i,i)
         enddo
         do i=21,25
            call hdelet(1000+i)
            call hzhinrm(i,0,1.,1)
            call hzchisq(-i,i)
         enddo
         call hzchisq(-26,26)
         call hzchisq(-27,27)

         do i=41,47
            call hdelet(1000+i)
            call hzhinrm(i,0,1.,1)
            call hzchisq(-i,i)
         enddo
         do i=51,53
            call hdelet(1000+i)
            call hzhinrm(i,0,1.,1)
            call hzchisq(-i,i)
         enddo
         call hzchisq(-54,54)
         call hzchisq(-55,55)

* fill generated crosssection and number of events into histograms
         call hf1(71,0.5,real(xsec))
         call hf1(72,0.5,real(ntot))

      endif

      RETURN
      END
      SUBROUTINE h9091fil(id1,id2,weight)

* --- each channel of histo id1 is filled with the help of HZMEANHI  individually
*     with its content and a specific weight into histo id2
*     for maximum number of bins and histos of the type that HZMEANHI
creates
*     see that subroutine (7.12.99 = HZVERS ...: MAXHISTS=50, MAXBINS=20)

      IMPLICIT NONE

      character*80 ctit
      integer incX1, incX2, incY, inwt, idum
      real Xmin1, Xmax1, Xmin2, Xmax2, Ymin, Ymax, Xleft

      integer i,id1,id2
      real hi,lowx1,highx1,lowx2,highx2,weight

* --- get some histo information
      call hgive(id1,ctit,incX1,Xmin1,Xmax1,incY,Ymin,Ymax,inwt,idum)
      if (incY.ne.0) then
         write(6,*) 'h9091fil: ERROR for hist ID ',id1,
     &        'can only handle 1d-histos !'
         return
      endif
      call hgive(id2,ctit,incX2,Xmin2,Xmax2,incY,Ymin,Ymax,inwt,idum)
      if (incY.ne.0) then
         write(6,*) 'h9091fil: ERROR for hist ID ',id2,
     &        'can only handle 1d-histos !'
         return
      endif

* --- safety check
      if ((incX1.ne.incX2).or.(Xmin1.ne.Xmin2).or.(Xmax1.ne.Xmax2)) then
         write(6,*) 'h9091fil: ERROR, histogram specifications for',
     &        'hist ID ',id1,'and ID ',id2,' differ'
         return
      endif

* --- loop over all channels
      do i=1,incX1
         call hix(id1,i,lowx1)
         call hix(id1,i+1,highx1)
         call hix(id2,i,lowx2)
         call hix(id2,i+1,highx2)
* ------ safety check again
         if ((lowx1.ne.lowx2).or.(highx1.ne.highx2)) then
            write(6,*) 'h9091fil: ERROR, histogram specifications for',
     &           'hist ID ',id1,'and ID ',id2,' differ'
            return
         endif
* ------ main fill
         call hzmeanhi(id1,dble((lowx2+highx2)/2.),dble(hi(id2,i))
     &        ,weight)
      enddo

      return
      end
*
*CMZ :  2.00/06 02/05/2002  15.02.41  by  Tancredi Carli
*CMZ :  2.00/05 01/08/2000  10.32.33  by  Tancredi Carli
*CMZ :  2.00/00 13/08/99  10.06.19  by  Hannes Jung
*-- Author :    Thorsten Wengler   14/04/98
      subroutine HZ99094(IFLAG)
**********************************************************************
* Purpose: histograms for the fwd pi0 x-sections 1996
*
* to normalize histgrams. This routine is included at the end of this
* file.
*
* The Routine is intended to run with the HzTool Package
* Theta is measured wrt the incoming proton direction (=z direction)
*
* DIS Event selection: 2.0<Q2<70.0 GeV2
*                      0.1<y<0.6
*
* pi0 selection: 5 < Theta < 25 degrees (in lab)
*                Pt > 2.5 GeV (in hcms)
*                x_pi=E_pi/E_proton> 0.01 (in lab)
*
**********************************************************************
* Arguments: iflag=1 initialisation
*            iflag=1 filling
*            iflag=3 termination
*
* Output Histograms:
*
*--------------------------------------------------------------------
* Histogram   Description
*--------------------------------------------------------------------
*                        Data Plots
*--------------------------------------------------------------------
*     -114    ds/dq2  [pb/GeV2]
*     -115    ds/dq2  [pb/GeV2] for Pt > 3.5 GeV (in hcms)
*     -116    ds/dx  [pb/GeV2] for Pt > 3.5 GeV (in hcms)
*     -101    ds/dx [nb] 2.0 <q2< 4.5  GeV2
*     -102    ds/dx [nb] 4.5 <q2< 15.0 GeV2
*     -103    ds/dx [nb] 15.0<q2< 70.0 GeV2
*     -131    ds/deta [pb] 2.0 <q2< 4.5  GeV2
*     -132    ds/deta [pb] 4.5 <q2< 15.0 GeV2
*     -133    ds/deta [pb] 15.0<q2< 70.0 GeV2
*     -171    ds/dpt [pb/GeV] 2.0 <q2< 4.5  GeV2
*     -172    ds/dpt [pb/GeV] 4.5 <q2< 15.0 GeV2
*     -173    ds/dpt [pb/GeV] 15.0<q2< 70.0 GeV2
*--------------------------------------------------------------------
*                                              Monte Carlo Histograms
*--------------------------------------------------------------------
*     114    ds/dq2  [pb/GeV2]
*     115    ds/dq2  [pb/GeV2] for Pt > 3.5 GeV (in hcms)
*     116    ds/dx  [pb/GeV2] for Pt > 3.5 GeV (in hcms)
*     101    ds/dx [nb] 2.0 <q2< 4.5  GeV2
*     102    ds/dx [nb] 4.5 <q2< 15.0 GeV2
*     103    ds/dx [nb] 15.0<q2< 70.0 GeV2
*     131    ds/deta [pb] 2.0 <q2< 4.5  GeV2
*     132    ds/deta [pb] 4.5 <q2< 15.0 GeV2
*     133    ds/deta [pb] 15.0<q2< 70.0 GeV2
*     171    ds/dpt [pb/GeV] 2.0 <q2< 4.5  GeV2
*     172    ds/dpt [pb/GeV] 4.5 <q2< 15.0 GeV2
*     173    ds/dpt [pb/GeV] 15.0<q2< 70.0 GeV2
*
* rate histos:  divided by DIS histo
*     -100101    drate/dx [nb] 2.0 <q2< 4.5  GeV2
*     -100102    drate/dx [nb] 4.5 <q2< 15.0 GeV2
*     -100103    drate/dx [nb] 15.0<q2< 70.0 GeV2
*--------------------------------------------------------------------
*
* written by: T.Wengler 01. Sptember 1998
*********************************************************************
      IMPLICIT NONE

*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
      Logical Debug
      Parameter(Debug=.false.)

*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEND.
*Lepto common
      integer LST
      real  CUT,PARL,X,Y,W2,Q2,U
      COMMON /LEPTOU/ CUT(14),LST(40),PARL(30),X,Y,W2,Q2,U

*---PYTHIA common
      real parp
      integer mstp
      COMMON /PYPARS/ MSTP(200),PARP(200)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
*
      Double precision phad,pgam(4),pcm(4),ph(5),plab(5,NMXHEP)
      Double precision plep,eout(4),p(4,1),q(4,1),myxsecdp,myxsdisdp
      Double precision newxs
      real ethcms,myxsec,myxsdis,wtxdis
      integer retc
*
      Integer i,iflag,ihep
      Character*5 xxxx
      Integer nentry
      Data xxxx/'99094'/,NENTRY/0/
      save xxxx
*
      real a(3),b(3),thgg,thmin,enpi
      Real pi,rd,eb
      Integer iel,idum,ipbeam,iebeam
      Parameter (pi=3.1415927,rd=180./pi)
      Real enel,thel,efwd,th,lx,lxj
      real xwght,q2wght,ywght,pdfset,rewghttw
      Integer ibin,nj,ij,naj,naj2,np,np4,np5,j,nsel
*
      Integer ierr
      Integer maxhi,modjet,maxjet
      Parameter (maxhi=100,modjet=2,maxjet=30)
      Real  selj(maxjet,4),help,empz,empzh,xg,empzl,empzhl,xgl
      Integer ipjet(maxjet),l,k
      Real nev(maxhi),lum
      Double precision rcone
      Parameter (rcone=1.)
***********************************
*
* Define bins for histograms
*
* Q2
      INTEGER piq2anb
      PARAMETER (piq2anb=10)
      REAL piq2ab(piq2anb+1)
      DATA piq2ab/2.0, 2.4, 3.0, 3.8, 4.9, 6.5, 9.1,
     +     13.0, 20.0, 32.0, 70.0/
*
* Q2 for higher pt cut of 3.5 GeV
      INTEGER piq3anb
      PARAMETER (piq3anb=5)
      REAL piq3ab(piq3anb+1)
      DATA piq3ab/2.0, 3.0, 4.9, 9.1, 20.0, 70.0/
*
* 3x x_bj
      INTEGER pixbj1nb
      PARAMETER (pixbj1nb=5)
      REAL pixbj1b(pixbj1nb+1)
      DATA pixbj1b/4.2E-5,7.9E-5,1.1E-4,1.7E-4,2.5E-4,4.2E-4/
*
      INTEGER pixbj2nb
      PARAMETER (pixbj2nb=5)
      REAL pixbj2b(pixbj2nb+1)
      DATA pixbj2b/1.1E-4,2.0E-4,2.9E-4,3.9E-4,5.5E-4,1.1E-3/
*
      INTEGER pixbj3nb
      PARAMETER (pixbj3nb=4)
      REAL pixbj3b(pixbj3nb+1)
      DATA pixbj3b/3.9E-4,7.9E-4,1.3E-3,1.9E-3,6.3E-3/
*
* x for higher pt cut of 3.5 GeV
      INTEGER pixbj4nb
      PARAMETER (pixbj4nb=5)
      REAL pixbj4b(pixbj4nb+1)
      DATA pixbj4b/1.0E-4, 1.9E-4, 3.0E-4, 5.0E-4,
     +     1.1E-3, 6.3E-3/
*
*3x eta
      INTEGER pieta1nb
      PARAMETER (pieta1nb=5)
      REAL pieta1b(pieta1nb+1)
      DATA pieta1b/1.5,1.93,2.23,2.56,2.85,3.13/
*
      INTEGER pieta2nb
      PARAMETER (pieta2nb=5)
      REAL pieta2b(pieta2nb+1)
      DATA pieta2b/1.5,1.91,2.22,2.5,2.82,3.13/
*
      INTEGER pieta3nb
      PARAMETER (pieta3nb=4)
      REAL pieta3b(pieta3nb+1)
      DATA pieta3b/1.5,1.93,2.26,2.69,3.13/
*
*3x pt
      INTEGER piet1nb
      PARAMETER (piet1nb=5)
      REAL piet1b(piet1nb+1)
      DATA piet1b/2.5,2.8,3.3,4.0,5.2,8.0/
*
      INTEGER piet2nb
      PARAMETER (piet2nb=5)
      REAL piet2b(piet2nb+1)
      DATA piet2b/2.5,2.8,3.4,4.1,5.2,8.0/
*
      INTEGER piet3nb
      PARAMETER (piet3nb=4)
      REAL piet3b(piet3nb+1)
      DATA piet3b/2.5,2.9,3.5,4.7,8.0/
**********************************************************************
*
* Define Variables
*
* Nevt -> number of events
      real Nevt,Nevtw,Npass
      real npdis
      save Nevt
      save Nevtw
      save Npass
      save npdis
* Ee -> electron energy
* The -> electron theta
* Phe -> electron phi
* xpi ->  pi E/820.
* Thpi -> pi theta
* Phpi -> pi phi
* Ptpi -> pi pt
      real Ee, The, Phe, xpi, Thpi, Phpi, Ptpi, etapi
*
* --- define 3 Q2 regions in which to plot x-Bj dependencies
*
      REAL q2re1lo,q2re2lo,q2re3lo,q2re1hi,q2re2hi,q2re3hi
      PARAMETER (q2re1lo=2.0,q2re1hi=4.5)
      PARAMETER (q2re2lo=4.5,q2re2hi=15.0)
      PARAMETER (q2re3lo=15.0,q2re3hi=70.0)

* define cut parameters (prelim. secenario)
*
      real ylow,yhigh,eelow,thelow,thehigh
      real xpilow,xpihigh,ptpilow,ptpihigh,etapilow,etapihigh
      parameter(ylow=0.1)
      parameter(yhigh=0.6)
      parameter(xpilow=0.01)
      parameter(xpihigh=99.0)
      parameter(ptpilow=2.5)
      parameter(ptpihigh=99.0)
      parameter(etapilow=1.5)
      parameter(etapihigh=3.13)
* --- define higher pt-cut for additional plots
      real addpt
      parameter(addpt=3.5)
*
* define H1 pi0 x-sections
*
* for pt > 2.5 GeV
      real pq2(10),pq2se(10),pq2te(10)
      real px1(5),px1se(5),px1te(5)
      real px2(5),px2se(5),px2te(5)
      real px3(4),px3se(4),px3te(4)
      real peta1(5),peta1se(5),peta1te(5)
      real peta2(5),peta2se(5),peta2te(5)
      real peta3(4),peta3se(4),peta3te(4)
      real ppt1(5),ppt1se(5),ppt1te(5)
      real ppt2(5),ppt2se(5),ppt2te(5)
      real ppt3(4),ppt3se(4),ppt3te(4)
* for pt > 3.5 GeV
      real pq22(5),pq22se(5),pq22te(5)
      real px4(5),px4se(5),px4te(5)

* rel. err. for rates
      real pq2rsy(10),pq3rsy(5)
      real px1rsy(5),px2rsy(5),px3rsy(4),px4rsy(5)

* for pt > 2.5 GeV
      data pq2/139.35,106.168,78.1601,54.4862,35.5119,18.961,
     +     11.5121,7.11915,3.6436,1.08484/
      data pq2se/16.179,10.8842,7.34308,4.75706,3.12018,1.81492,
     +     1.14794,0.681489,0.360846,0.101381/
      data pq2te/29.5678,23.5225,13.3422,10.4635,5.27709,3.61389,
     +     1.81803,1.23043,0.627047,0.219166/
      data px1/1189.4,1260.71,970.313,609.441,159.994/
      data px1se/133.668,142.596,96.4167,75.2521,26.8072/
      data px1te/188.539,253.011,201.361,120.972,52.5223/
      data px2/397.611,366.411,336.702,192.65,63.5073/
      data px2se/42.8972,41.0226,38.9405,21.4877,6.84674/
      data px2te/61.3354,59.0537,64.2526,33.8743,13.7813/
      data px3/72.4478,55.811,43.0783,6.44535/
      data px3se/8.74659,6.25791,5.49562,0.742444/
      data px3te/16.778,12.864,9.80771,1.23017/
      data peta1/141.393,164.624,129.465,107.787,111.024/
      data peta1se/15.7144,20.3144,14.5706,13.0785,15.1506/
      data peta1te/27.9372,31.3005,28.5719,26.0788,26.348/
      data peta2/103.374,144.833,130.951,114.562,89.029/
      data peta2se/11.1443,14.8855,14.305,12.3191,10.2301/
      data peta2te/16.1466,29.1717,21.4435,20.7014,22.1032/
      data peta3/66.1792,93.4857,73.2534,43.6127/
      data peta3se/7.93505,11.2445,8.11797,5.38275/
      data peta3te/14.8967,17.5536,13.527,10.6018/
      data ppt1/186.682,131.718,65.3347,25.1165,6.47844/
      data ppt1se/20.4757,12.7326,7.52587,3.36217,1.23232/
      data ppt1te/91.939,22.0191,17.5243,4.2398,1.85798/
      data ppt2/156.887,93.484,56.8597,16.5697,4.4512/
      data ppt2se/15.3586,7.77076,6.35731,2.39455,0.751803/
      data ppt2te/74.0591,21.7324,9.50821,3.77732,1.18351/
      data ppt3/89.0546,54.0469,19.9416,4.71727/
      data ppt3se/9.53043,5.88907,2.46298,0.717909/
      data ppt3te/34.6819,8.40795,3.91176,0.939199/

* for pt > 3.5 GeV
      data pq22/35.0229,22.543,10.0461,3.199,0.645272/
      data pq22se/4.38384,2.3367,1.02995,0.355149,0.0689242/
      data pq22te/7.65896,3.8773,1.54139,0.554968,0.112668/
      data px4/374.066,249.41,165.41,60.2614,5.89598/
      data px4se/41.5554,31.8851,20.6637,6.48355,0.686599/
      data px4te/69.5626,45.3052,29.9305,10.511,1.50017/

* relative errors +10 % for rates
      data pq2rsy/0.203819,0.220405,0.174108,0.198132,0.156084,
     +     0.192782,0.158102,0.175237,0.172652,0.205137/
      data px1rsy/0.149992,0.193605,0.207826,0.184809,0.299487/
      data px2rsy/0.14885,0.153103,0.18177,0.168751,0.213231/
      data px3rsy/0.221488,0.224843,0.213447,0.182097/
      data pq3rsy/0.205317,0.169818,0.151758,0.166645,0.170522/
      data px4rsy/0.179558,0.163257,0.16473,0.169847,0.247343/

*********************************************************************
*
*                      Initialization
*
*********************************************************************
      NENTRY=NENTRY+1
*
      IF (iflag.eq.1) then
*
         Nevt=0.
         Nevtw=0.
         Npass=0.
         npdis=0.
*
*
* Initialisation: The following MUST always be done
* (i) make subdirectory in PAWC
* - use the name as the xxxxxx in HZxxxxxx subroutine
* (i) make subdirectory in o/p file
*
         Call hcdir('//PAWC',' ')
         call hmdir(xxxx,'S')
         Call hcdir('//HISTO',' ')
         call hmdir(xxxx,'S')
*
* book histograms -------------------
*
* pi0 x-sections
         CALL HBOOKB(101,'[p]^o![:] x?Bj,1!',pixbj1nb,pixbj1b,0.)
         CALL HBOOKB(102,'[p]^o![:] x?Bj,2!',pixbj2nb,pixbj2b,0.)
         CALL HBOOKB(103,'[p]^o![:] x?Bj,3!',pixbj3nb,pixbj3b,0.)
         CALL HBOOKB(131,'[p]^o![:] [c]?1!',pieta1nb,pieta1b,0.)
         CALL HBOOKB(132,'[p]^o![:] [c]?2!',pieta2nb,pieta2b,0.)
         CALL HBOOKB(133,'[p]^o![:] [c]?3!',pieta3nb,pieta3b,0.)
         CALL HBOOKB(171,'[p]^o![:] E?T,1!(hcms)',piet1nb,piet1b,0.)
         CALL HBOOKB(172,'[p]^o![:] E?T,2!(hcms)',piet2nb,piet2b,0.)
         CALL HBOOKB(173,'[p]^o![:] E?T,3!(hcms)',piet3nb,piet3b,0.)
         CALL HBOOKB(114,'[p]^o![:] Q^2!',piq2anb,piq2ab,0.)
         CALL HBOOKB(115,'[p]^o![:] Q^2!',piq3anb,piq3ab,0.)
         CALL HBOOKB(116,'[p]^o![:] Q^2!',pixbj4nb,pixbj4b,0.)
*
* DIS histos for calc. of Rate
         CALL HCOPY(101,110101,' ')
         CALL HCOPY(102,110102,' ')
         CALL HCOPY(103,110103,' ')
*
* DIS histos for calc. of Rate in data
         CALL HCOPY(101,-110101,' ')
         CALL HCOPY(102,-110102,' ')
         CALL HCOPY(103,-110103,' ')
*
* histograms for data (with stat. error, 10000+hid has tot. error)
         CALL HCOPY(114,-114,' ')
         CALL HCOPY(114,-10114,' ')
         CALL HCOPY(115,-115,' ')
         CALL HCOPY(115,-10115,' ')
         CALL HCOPY(116,-116,' ')
         CALL HCOPY(116,-10116,' ')
         CALL HCOPY(101,-101,' ')
         CALL HCOPY(101,-10101,' ')
         CALL HCOPY(102,-102,' ')
         CALL HCOPY(102,-10102,' ')
         CALL HCOPY(103,-103,' ')
         CALL HCOPY(103,-10103,' ')
         CALL HCOPY(131,-131,' ')
         CALL HCOPY(131,-10131,' ')
         CALL HCOPY(132,-132,' ')
         CALL HCOPY(132,-10132,' ')
         CALL HCOPY(133,-133,' ')
         CALL HCOPY(133,-10133,' ')
         CALL HCOPY(171,-171,' ')
         CALL HCOPY(171,-10171,' ')
         CALL HCOPY(172,-172,' ')
         CALL HCOPY(172,-10172,' ')
         CALL HCOPY(173,-173,' ')
         CALL HCOPY(173,-10173,' ')
* reserve space to store errors
         CALL HRESET(0,' ')
         call hbarx(0)

* - fill the data histograms

         call hpak(-114,pq2)
         call hpake(-114,pq2se)
         call hpak(-10114,pq2)
         call hpake(-10114,pq2te)

         call hpak(-101,px1)
         call hpake(-101,px1se)
         call hpak(-10101,px1)
         call hpake(-10101,px1te)
         call hpak(-102,px2)
         call hpake(-102,px2se)
         call hpak(-10102,px2)
         call hpake(-10102,px2te)
         call hpak(-103,px3)
         call hpake(-103,px3se)
         call hpak(-10103,px3)
         call hpake(-10103,px3te)

         call hpak(-131,peta1)
         call hpake(-131,peta1se)
         call hpak(-10131,peta1)
         call hpake(-10131,peta1te)
         call hpak(-132,peta2)
         call hpake(-132,peta2se)
         call hpak(-10132,peta2)
         call hpake(-10132,peta2te)
         call hpak(-133,peta3)
         call hpake(-133,peta3se)
         call hpak(-10133,peta3)
         call hpake(-10133,peta3te)

         call hpak(-171,ppt1)
         call hpake(-171,ppt1se)
         call hpak(-10171,ppt1)
         call hpake(-10171,ppt1te)
         call hpak(-172,ppt2)
         call hpake(-172,ppt2se)
         call hpak(-10172,ppt2)
         call hpake(-10172,ppt2te)
         call hpak(-173,ppt3)
         call hpake(-173,ppt3se)
         call hpak(-10173,ppt3)
         call hpake(-10173,ppt3te)

* for higher pt cut of 3.5 GeV
         call hpak(-115,pq22)
         call hpake(-115,pq22se)
         call hpak(-10115,pq22)
         call hpake(-10115,pq22te)

         call hpak(-116,px4)
         call hpake(-116,px4se)
         call hpak(-10116,px4)
         call hpake(-10116,px4te)
* book histo for stat. of event types
         call HBOOK1(299,'event type',8,0.,7.,0.)
         call hbook1(297,'gg-op-ang',30,0.,30.,0.)
         call hbook1(296,'gg-op-ang',20,0.,20.,0.)
         call hbprof(298,'gg-op-ang',30,0.,30.,0.,25.0,' ')
         CALL HRESET(298,' ')
         call hbar2(298)
*
*********************************************************************
*
*                      Event Processing
*
*********************************************************************
      Else if (iflag.eq.2) then
*
* Filling: The following MUST always be done
* (i) move to the correct sub-directory in PAWC
*
         call hcdir('//PAWC/'//xxxx,' ')

* weight is not used - set to 1.0
         wtx=1.0

* count events
         Nevt = Nevt + wtx
* find beam particles
         ierr=HZIBEAM(ipbeam,iebeam)
         if (.not.(ierr.eq.1)) then
            write(6,*) 'HZ'//xxxx,' beams not found ! '
            return
         else
            phad=DBLE(PHEP(3,IPBEAM))
            plep=DBLE(PHEP(3,IEBEAM))
         endif

* get kinematics
         q2=real(HZDISKIN(1))
         x =real(HZDISKIN(2))
         y =real(HZDISKIN(3))
         xwght=x
         ywght=y
         q2wght=q2
channes         pdfset=MSTP(51)
channes       if(pdfset.gt.9999) pdfset=pdfset-1000000
channes       wtxdis = wtx * REWGHTTW(Xwght,Q2wght,Ywght,pdfset)
         wtxdis = wtx
         Nevtw = Nevtw + wtxdis
*       print *,q2,x,y,wtx,wtxdis

* get electron
         iel=HZIDELEC(idum)
         if (iel.eq.-1) then
            write(*,*) 'Hz'//xxxx,' electron not found '
            return
         endif
*       print *,'e->',PHEP(1,iel),PHEP(2,iel),PHEP(3,iel),
*     +      PHEP(4,iel)
         eout(1)=(PHEP(1,iel))
         eout(2)=(PHEP(2,iel))
         eout(3)=(PHEP(3,iel))
         eout(4)=(PHEP(4,iel))

* select DIS events
         if (y.lt.ylow) return
         if (y.gt.yhigh) return
         if (q2.lt.q2re1lo) return
         if (q2.gt.q2re3hi) return

* count number of events passing the DIS cuts
         Npass=Npass+WTX
         Npdis=Npdis+wtxdis
channes         if (q2.lt.q2re3hi.and.q2.gt.q2re1lo) then
channes            call hf1(110114,q2,wtx)
channes            call hf1(-110114,q2,wtxdis)
channes            call hf1(110115,q2,wtx)
channes            call hf1(-110115,q2,wtxdis)
channes            call hf1(110116,x,wtx)
channes            call hf1(-110116,x,wtxdis)
channes         endif
         if (q2.lt.q2re1hi.and.q2.gt.q2re1lo) then
            call hf1(110101,x,wtx)
            call hf1(-110101,x,wtxdis)
         endif
         if (q2.lt.q2re2hi.and.q2.gt.q2re2lo) then
            call hf1(110102,x,wtx)
            call hf1(-110102,x,wtxdis)
         endif
         if (q2.lt.q2re3hi.and.q2.gt.q2re3lo) then
            call hf1(110103,x,wtx)
            call hf1(-110103,x,wtxdis)
         endif


* find pi0s, boost pt, apply selection, fill histos
         do i=1,nhep
            if (iabs(idhep(i)).eq.111) then
*             print *,PHEP(1,i),PHEP(2,i),PHEP(3,i),PHEP(4,i)
               p(1,1)=DBLE(PHEP(1,i))
               p(2,1)=DBLE(PHEP(2,i))
               p(3,1)=DBLE(PHEP(3,i))
               p(4,1)=DBLE(PHEP(4,i))
               thpi=real(HZPHMANG(PHEP(3,i), sqrt(PHEP(1,i)**2+PHEP(2,
     +         i)**2)))
               etapi=-LOG(TAN(thpi/2))
               xpi=real(PHEP(4,i))/820.0
               CALL KTHADR(0,plep,phad,eout,1,P,Q,*999)
               ethcms=sngl(sqrt(q(1,1)**2+q(2,1)**2))

* calculate opening of two gammas from pi0
               a(1)=sngl(PHEP(1,jdahep(1,i)))
               a(2)=sngl(PHEP(2,jdahep(1,i)))
               a(3)=sngl(PHEP(3,jdahep(1,i)))
               b(1)=sngl(PHEP(1,jdahep(2,i)))
               b(2)=sngl(PHEP(2,jdahep(2,i)))
               b(3)=sngl(PHEP(3,jdahep(2,i)))
               thgg=57.2958*acos( (a(1)*b(1)+a(2)*b(2)+a(3)*b(3))/
     +         (sqrt(a(1)**2+a(2)**2+a(3)**2)* sqrt(b(1)**2+b(2)**2+
     +         b(3)**2)) )
               thmin=57.2958*2*atan(0.13498/PHEP(4,i))
               enpi=sngl(PHEP(4,i))

               call hfill(298,enpi,thgg,wtx)
               call hf1(297,enpi,wtx)
               call hf1(296,thgg,wtx)

*             print *,thpi*57.29578,etapi,xpi,
*     +            sqrt(PHEP(1,i)**2+PHEP(2,i)**2)

               if ((ethcms.gt.ptpilow.and.ethcms.lt.ptpihigh).and.
     +         (etapi.gt.etapilow.and.etapi.lt.etapihigh).and. (xpi.gt.
     +         xpilow.and.xpi.lt.xpihigh) )then
c                print *,'hz99094 ',PHEP(4,i),thgg,thmin,thgg-thmin
                  if (q2.lt.q2re3hi.and.q2.gt.q2re1lo) then
                     call hf1(299,float(lst(24)),wtx)
*                   print *,'hi',lst(24)
                     call hf1(114,q2,wtx)
                     if(ethcms.gt.addpt) then
                        call hf1(115,q2,wtx)
                        call hf1(116,x,wtx)
                     endif
                  endif

                  if (q2.lt.q2re1hi.and.q2.gt.q2re1lo) then
                     call hf1(101,x,wtx)
                     call hf1(131,etapi,wtx)
                     call hf1(171,ethcms,wtx)
                  endif
                  if (q2.lt.q2re2hi.and.q2.gt.q2re2lo) then
                     call hf1(102,x,wtx)
                     call hf1(132,etapi,wtx)
                     call hf1(172,ethcms,wtx)
                  endif
                  if (q2.lt.q2re3hi.and.q2.gt.q2re3lo) then
                     call hf1(103,x,wtx)
                     call hf1(133,etapi,wtx)
                     call hf1(173,ethcms,wtx)
                  endif
               endif
            endif
         enddo
*********************************************************************
*
*                      Termination
*
*********************************************************************

      Else if(iflag.eq.3) then

* Termination: The following MUST always be done
* (i) Move to the correct PAW subdirectory
*
         call hcdir('//PAWC/'//xxxx,' ')
*
c         call pdfsta
         lum=999999999.
         if (xsec.ne.0.) then
            lum=Nevt/real(xsec)
            print *,' HZ99094 '
            print *,'hz',xxxx,' pdfset:',pdfset
            print *,'hz',xxxx,' Number of events procesed:',Nevt
            print *,'hz',xxxx,' Number of wght events procesed:',Nevtw
            print *,'hz',xxxx,' Number of events passing DIS cuts ',
     +      Npass
            print *,'hz',xxxx,' Number of wght events passing DIS cuts '
     +      ,Npdis
            print *,'hz',xxxx,' Total cross section:',xsec
            newxs=xsec*(dble(nevtw)/dble(nevt))
            print *,'hz',xxxx,' New Total cross section:',newxs
            print *,'hz',xxxx,' Equivalent luminosity:',lum
            myxsecdp=dble(npass)/dble(nevt)*(xsec)
            myxsec=real(myxsecdp)
            myxsdisdp=dble(npdis)/dble(nevt)*(xsec)
            myxsdis=real(myxsdisdp)
            write (*,40) 'hz',xxxx,' Total x-sect in my PS:',myxsec
            write (*,40) 'hz',xxxx,' Total x-sect in my PS dis:',
     +      myxsdis
         else
            write(6,*) 'hz',xxxx,' xsec=0 ! '
         endif
   40    FORMAT(A,F15.4)
*
* calc. rate for x and Q2 distr.
channes         call hopera(114,'/E',110114,100114,1.0,1.0)
channes         call hopera(115,'/E',110115,100115,1.0,1.0)
channes         call hopera(116,'/E',110116,100116,1.0,1.0)
         call hopera(101,'/E',110101,100101,1.0,1.0)
         call hopera(102,'/E',110102,100102,1.0,1.0)
         call hopera(103,'/E',110103,100103,1.0,1.0)


*      normalize the histos (also div. xbj plots by 1000. to get nb)
*
         call hzhinrm(114,0,lum,1)
         call hzhinrm(115,0,lum,1)
         call hzhinrm(116,0,lum*1000,1)
         call hzhinrm(101,0,lum*1000.0,1)
         call hzhinrm(102,0,lum*1000.0,1)
         call hzhinrm(103,0,lum*1000.0,1)
         call hzhinrm(131,0,lum,1)
         call hzhinrm(132,0,lum,1)
         call hzhinrm(133,0,lum,1)
         call hzhinrm(171,0,lum,1)
         call hzhinrm(172,0,lum,1)
         call hzhinrm(173,0,lum,1)


* calc. rate for x and Q2 distr. for data with wght distr.
channes         call normal(110114,0,lum,1,1)
channes         call normal(110115,0,lum,1,1)
channes         call normal(110116,0,lum*1000,1,1)
         call hzhinrm(-110101,0,lum*1000.0,1)
         call hzhinrm(-110102,0,lum*1000.0,1)
         call hzhinrm(-110103,0,lum*1000.0,1)
channes         call hopera(-114,'/E',-110114,-100114,1.0,1.0)
channes         call hopera(-115,'/E',-110115,-100115,1.0,1.0)
channes         call hopera(-116,'/E',-110116,-100116,1.0,1.0)
         call hopera(-101,'/E',-110101,-100101,1.0,1.0)
         call hopera(-102,'/E',-110102,-100102,1.0,1.0)
         call hopera(-103,'/E',-110103,-100103,1.0,1.0)

* get histos with tot. error for rates

channes         call seterror(-100114,-111114,pq2rsy)
channes         call seterror(-100115,-111115,pq3rsy)
channes         call seterror(-100116,-111116,px4rsy)
         call seterror(-100101,-111101,px1rsy)
         call seterror(-100102,-111102,px2rsy)
         call seterror(-100103,-111103,px3rsy)

* ds/deta and ds/dpt divided by total x-section in analysis Phase Sp.
* for data with wght total xsection
         call hzhinrm(131,100131,myxsdis,1)
         call hzhinrm(132,100132,myxsdis,1)
         call hzhinrm(133,100133,myxsdis,1)
         call hzhinrm(171,100171,myxsdis,1)
         call hzhinrm(172,100172,myxsdis,1)
         call hzhinrm(173,100173,myxsdis,1)
*
      endif
*
      RETURN
 999  continue
      write(6,*) 'hz',xxxx,' error in KTHADR '
      END
**********************************************************************
      subroutine seterror( iid, iidnew, syserr )
**********************************************************************
* Normalize a given 1-dim histogram with factors 1/nevt and 1/binwidth
* works also for non-equidistant bins (from hzhinrm by M.Kuhlen)
*
* Arguments:
* iid      histogram id to be normalized
* iidnew   new histo id (if 0, old histo is modified)
* revt     normalization factor (usually # events)
* iifl     flag=1: normalize errors too, otherwise they are zeroed
* ibin     divide by bin width 0-no, 1-yes
**********************************************************************
      IMPLICIT NONE
*
      Integer   id, idnew,  ifl, iifl, iid, iidnew,nmax, ibin, iibin
*! max # of bins
      Parameter(nmax=200)
      Real      cont(nmax), err(nmax), zeroes(nmax), revt, rrevt
      Integer nx,ny,ntw,iad,i,idfill
      Real xmin,xmax,ymin,ymax,xleft,xright,binw,hie,hi
      Real Hsum
      Character*80  title,rout*10
      Logical hexist
      real syserr(*)
      Data zeroes / nmax*0. /,rout/'TW:NORMAL:'/
*
*                                         PAW gets confused with types
      id    = iid
      idnew = iidnew
      revt  = rrevt
      ifl   = iifl
      ibin  = iibin
*                                             check existence of histo
      if( .not.hexist(id) ) then
         write(6,*) rout,' non-existent histo id ',id
         goto 9999
      endif
*                                            get title, number of bins
      call hgive(id, title, nx, xmin, xmax, ny, ymin, ymax, ntw, iad)
*
      if( nx .eq. 0 ) then
         write(6,*) rout,' histo with 0 bins, id= ',id
         goto 9999
      elseif( nx .gt. nmax ) then
         write(6,*) rout,' histo with #bins>max, id= ',id,nx,nmax
         goto 9999
      endif
*                                         loop over histogram channels
*                                               careful with last bin!
      do i=1,nx
*                                                    lower edge of bin
         call hix(id,i,xleft)
*                                                    upper edge of bin
         xright=xmax
         if(i.lt.nx) call hix(id,i+1,xright)
*                                                            bin width
         binw = xright-xleft
         if(ibin.eq.0) binw=1.0
*                                                          bin content
         cont(i) = hi(id,i)
*                                                  corresponding error
         err(i)  = hie(id,i)
         err(i) = sqrt((err(i)/cont(i))**2 + syserr(i)**2)*cont(i)

      enddo

      print *,'hz99094',id,idnew
      call hcopy(id,idnew,title)
*                                                   reset target histo
      call hreset(idnew,title)
*
*                                  pack normalized contents into histo
*
      call hpak(idnew,cont)
      call hpake(idnew,err)

*
*
 9999 continue
      return
      end
*
*CMZ :  2.00/03 31/05/2000  15.33.39  by  Klaus Rabbertz
*-- Author : Klaus Rabbertz
      SUBROUTINE HZ99193(IFLAG)
**********************************************************************
* Running: Ee=27.5, Ep=820, no polarization
*
* Purpose: Produce histograms for:
*
*          Event shape variables: Two versions of thrust tau_C = 1-T_C,
*          ---------------------- tau = 1-T, jet broadening B, jet mass rho,
*                                 C parameter, two versions of diff. two-jet
*                                 rate y_kt and y_fJ
*
*          Q-bins: Low Q sample:
*                  1) 7 < Q < 8 GeV
*                  2) 8 < Q < 10 GeV
*                  High Q sample:
*                  3) 14 < Q < 16 GeV
*                  4) 16 < Q < 20 GeV
*                  5) 20 < Q < 30 GeV
*                  6) 30 < Q < 50 GeV
*                  7) 50 < Q < 70 GeV
*                  8) 70 < Q < 100 GeV
*
*          Event selection (phase space cuts only):
*          i)    Energy of scattered lepton:
*                E_e' > 14 GeV (low Q)
*                E_e' > 11 GeV (high Q)
*          ii)   Polar angle of scattered lepton:
*                157 deg < theta_e' < 173 deg (low Q)
*                 30 deg < theta_e' < 150 deg (high Q)
*          iii)  Inelasticity y_e (from lepton) and y_h (from hadr.fin.state):
*                0.05 < y_e < 0.80
*                0.05 < y_h        ( = y_e = y on generator level)
*          iv)   Angle of 'quark' direction as deduced from the scattered
*                lepton in QPM:
*                theta_q > 20 deg
*          v)    Hadronic energy in forward region (polar angle within (4,15)):
*                E_forw > 0.5 GeV
*          vi)   Total hadronic energy in Breit current hemisphere:
*                E_CH > 0.1 * Q (part of the def., NOT for y_kt, y_fJ)
*          vii)  No. of hadronic objects in Breit current hemisphere:
*                N_CH >= 2 (NOT for y_kt, y_fJ)
*          viii) Note:
*                There is a usually ineffective cutoff (s. statistics in
*                log file) of O(10^-5) to stay away from the exact left and
*                right borders of the distributions. For y_kt overflow events
*                may occur. In case of the mean values this cut is NOT
*                active.
*
* Produced histos: Mean values:   ID = 10:          <tau>
*                                 ID = 20:          <B>
*                                 ID = 30:          <tau_C>
*                                 ID = 40:          <rho>
*                                 ID = 50:          <C>
*                                 ID = 60:          <y_fJ>
*                                 ID = 70:          <y_kt>
*
*                  Distributions: (QbinNo = 1..8)
*                                 ID = 10 + QbinNo: 1/N dn/dtau
*                                 ID = 20 + QbinNo: 1/N dn/dB
*                                 ID = 30 + QbinNo: 1/N dn/dtau_C
*                                 ID = 40 + QbinNo: 1/N dn/drho
*                                 ID = 50 + QbinNo: 1/N dn/dC
*                                 ID = 60 + QbinNo: 1/N dn/dy_fJ
*                                 ID = 70 + QbinNo: 1/N dn/dy_kt
*
*                  H1 data histograms have corresponding negative numbers.
*                  Data histos with systematic uncertainties only and total
*                  uncertainties are stored with offset -100 and -200.
*
* Arguments: IFLAG = 1: Initialization
*            IFLAG = 2: Filling
*            IFLAG = 3: Termination
*
* Called subroutines and functions:
*            From HBOOK lib:  HCDIR,HMDIR,HBOOK1,HBOOKB,
*                             HFILL,HPAK,HPAKE,HBARX
*            From HzTool lib: DEVSHP
*                             HzDiskin,HzIdelec,HzIpgam,HzIbeam,
*                             HzBrtini,HzBrt,HzHinrm,HzHinfo,HzChisq
*
* Adapted by: Klaus Rabbertz
*
* Reference: Eur. Phys. J. C 14 (2000) 255, DESY 99-193.
*
**********************************************************************

      IMPLICIT NONE

**********************************************************************
*
*                      Declarations
*
**********************************************************************

*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.

*
*---Subroutine-specific settings
*-------------------------------
*---Constants:
      INTEGER NB,NQ,NE
      PARAMETER (NB = 10, NQ = 8, NE = 7)
      REAL PI,RD,EE
      PARAMETER (PI = 3.1415927, RD = 180./PI, EE = 27.5)

*---General variables:
*---DESY Preprint number
      CHARACTER*6 XXXX
      DATA XXXX/'99193'/

      LOGICAL LP
      DATA LP /.TRUE./
      SAVE LP

*---Histo variables:
      CHARACTER*80 CHMEAN(7),CHDIST(7)
      DATA CHMEAN/'<tau>','<B>','<tau_C>','<rho>','<C>',
     &     '<y_fJ>','<y_kt>'/
      DATA CHDIST/'1/N dn/d(tau)','1/N dn/dB',
     &     '1/N dn/d(tau_C)','1/N dn/d(rho)',
     &     '1/N dn/dC','1/N dn/d(y_fJ)','1/N dn/d(y_kt)'/

*---Kinematic variables:
      LOGICAL LOWQ,HIGHQ
      REAL Q2,Q,X,Y
      REAL COSTHETA,THETAE,THETAH,TEMP
      REAL FTQ,BTQ,CTQ,THQ
      DOUBLE PRECISION EHADFWD,ECQ
      DOUBLE PRECISION PLAB (4)
      DOUBLE PRECISION PBRT (4)
      DOUBLE PRECISION PHAD (4,NMXHEP)
      DOUBLE PRECISION PBEAM(4),PGAM(4),P5(5)

*---Event shape variables:
      REAL QL8(NQ),QDT8(NQ),QR8(NQ)
      REAL DM(0:NB,NQ,NE),DDMST(0:NB,NQ,NE)
      REAL DDMSYP(0:NB,NQ,NE),DDMSYM(0:NB,NQ,NE)
      REAL FBLD(NB,NE),FBCD(NB,NE),FBRD(NB,NE)
      REAL DMTMP(NB),DDMTMP(NB)
      REAL QBINNING(10)
      DATA QBINNING/7.0,8.0,10.0,14.0,16.0,20.0,30.0,50.0,70.0,100.0/

*---For MC calculation:
      REAL ESMEAN(7,8)
      REAL ESMEANE(7,8)
      REAL ESMTMP(9)
      REAL ESMETMP(9)

      DOUBLE PRECISION NL
      PARAMETER (NL=5.D-5)
      DOUBLE PRECISION DLIM(7)
      DATA DLIM/0.D05,0.D025,0.D025,0.D0125,0.D05,0.D03,0.D025/
      SAVE DLIM

      DOUBLE PRECISION LOLIMIT (7)
      DOUBLE PRECISION HILIMIT (7)
      DOUBLE PRECISION EVSHPMC (7)
      DOUBLE PRECISION EVSHPSR (13)
      DOUBLE PRECISION ESSUM (7,8)
      DOUBLE PRECISION ESSQSUM (7,8)
      SAVE ESSUM
      SAVE ESSQSUM

*---Counting, index and errorcode variables:
      INTEGER I,IB,IQ,IE
      INTEGER ID,IH,IM
      INTEGER IHEP,IEL,IBEAM,IGAM
      INTEGER IDUM,IERR,IFLAG
      INTEGER ICHN,CURQBIN
      INTEGER IHAD,ICOMP
      INTEGER NCURR
      REAL NEVT(7,8)
      REAL LOCUT(7,8)
      REAL HICUT(7,8)
      DOUBLE PRECISION DDUM
      SAVE NEVT

*********************************************************************
*
*                      Initialization
*
*********************************************************************
      IF (IFLAG.EQ.1) THEN

*---Initialization: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (ii) make subdirectory in o/p file
         CALL HCDIR('//PAWC',' ')
         CALL HMDIR(XXXX,'S')
         CALL HCDIR('//HISTO',' ')
         CALL HMDIR(XXXX,'S')

*---Hello world!
	 WRITE(6,*)'***************************************************'
	 WRITE(6,*)'HZ'//xxxx//' called'
         WRITE(6,*)'***************************************************'

*---Read H1 Data
         OPEN (UNIT=20,FILE='hz99193mean.dat',
     &        STATUS='OLD',FORM='FORMATTED')
 1001    FORMAT(2X,3(F6.1,5X),3(F7.4,4X),F7.4)
         IB = 0
         DO IE=1,NE
            DO I=1,3
               READ(20,*)
            ENDDO
            DO IQ=1,NQ
               READ(20,1001)QL8(IQ),QDT8(IQ),QR8(IQ),
     &              DM(IB,IQ,IE),DDMST(IB,IQ,IE),
     &              DDMSYP(IB,IQ,IE),DDMSYM(IB,IQ,IE)
            ENDDO
            READ(20,*)
         ENDDO
         CLOSE(20)
         OPEN (UNIT=20,FILE='hz99193dist.dat',
     &        STATUS='OLD',FORM='FORMATTED')
 1002    FORMAT(2X,3(F6.3,5X),3(G10.3,1X),G10.3)
         DO IE=1,NE
            READ(20,*)
            DO IQ=1,NQ
               DO I=1,6
                  READ(20,*)
               ENDDO
               DO IB=1,NB
                  READ(20,1002)FBLD(IB,IE),FBCD(IB,IE),FBRD(IB,IE),
     &                 DM(IB,IQ,IE),DDMST(IB,IQ,IE),
     &                 DDMSYP(IB,IQ,IE),DDMSYM(IB,IQ,IE)
               ENDDO
            ENDDO
            READ(20,*)
         ENDDO

*---Book histograms, fill data histograms
*---Reminder: HistoID's:  ID > 0  : MC, stat. uncertainty
*                         ID < 0  : H1 data, stat. uncertainty
*                         ID <-100: H1 data, syst. uncertainty (symm. overlay)
*                         ID <-200: H1 data, tot. uncertainty (symm. overlay)
         DO IE=1,NE
            IM = 10*IE
            CALL HBOOKB(IM,CHMEAN(IE),NQ+1,QBINNING,0.)
            CALL HBARX(IM)
            DO IH=0,2
               ID = -(100*IH+10*IE)
               CALL HBOOKB(ID,CHMEAN(IE),NQ+1,QBINNING,0.)
               IF (IH.EQ.0) THEN
                  DO IQ=1,2
                     DMTMP(IQ)  = DM(0,IQ,IE)
                     DDMTMP(IQ) = DDMST(0,IQ,IE)
                  ENDDO
                  DMTMP(3)  = 0.
                  DDMTMP(3) = 0.
                  DO IQ=3,8
                     DMTMP(IQ+1)  = DM(0,IQ,IE)
                     DDMTMP(IQ+1) = DDMST(0,IQ,IE)
                  ENDDO
               ELSEIF (IH.EQ.1) THEN
                  DO IQ=1,2
                     DMTMP(IQ)  = DM(0,IQ,IE) + 0.5 *
     &                    (DDMSYP(0,IQ,IE)+DDMSYM(0,IQ,IE))
                     DDMTMP(IQ) = 0.5 *
     &                    (DDMSYP(0,IQ,IE)-DDMSYM(0,IQ,IE))
                  ENDDO
                  DMTMP(3)  = 0.
                  DDMTMP(3) = 0.
                  DO IQ=3,8
                     DMTMP(IQ+1)  = DM(0,IQ,IE) + 0.5 *
     &                    (DDMSYP(0,IQ,IE)+DDMSYM(0,IQ,IE))
                     DDMTMP(IQ+1) = 0.5 *
     &                    (DDMSYP(0,IQ,IE)-DDMSYM(0,IQ,IE))
                  ENDDO
               ELSE
                  DO IQ=1,2
                     DMTMP(IQ)  = DM(0,IQ,IE) + 0.5 *
     &                    (SQRT(DDMST(0,IQ,IE)**2.+DDMSYP(0,IQ,IE)**2.)-
     &                    SQRT(DDMST(0,IQ,IE)**2.+DDMSYM(0,IQ,IE)**2.))
                     DDMTMP(IQ) = 0.5 *
     &                    (SQRT(DDMST(0,IQ,IE)**2.+DDMSYP(0,IQ,IE)**2.)+
     &                    SQRT(DDMST(0,IQ,IE)**2.+DDMSYM(0,IQ,IE)**2.))
                  ENDDO
                  DMTMP(3)  = 0.
                  DDMTMP(3) = 0.
                  DO IQ=3,8
                     DMTMP(IQ+1)  = DM(0,IQ,IE) + 0.5 *
     &                    (SQRT(DDMST(0,IQ,IE)**2.+DDMSYP(0,IQ,IE)**2.)-
     &                    SQRT(DDMST(0,IQ,IE)**2.+DDMSYM(0,IQ,IE)**2.))
                     DDMTMP(IQ+1) = 0.5 *
     &                    (SQRT(DDMST(0,IQ,IE)**2.+DDMSYP(0,IQ,IE)**2.)+
     &                    SQRT(DDMST(0,IQ,IE)**2.+DDMSYM(0,IQ,IE)**2.))
                  ENDDO
               ENDIF
               CALL HPAK(ID,DMTMP)
               CALL HPAKE(ID,DDMTMP)
            ENDDO
            DO IQ=1,NQ
               IM = 10*IE+IQ
               CALL HBOOK1(IM,CHDIST(IE),
     &              NB,FBLD(1,IE),FBRD(NB,IE),0.)
               CALL HBARX(IM)
               DO IH=0,2
                  ID = -(100*IH+10*IE+IQ)
                  CALL HBOOK1(ID,CHDIST(IE),
     &                 NB,FBLD(1,IE),FBRD(NB,IE),0.)
                  IF (IH.EQ.0) THEN
                     DO IB=1,NB
                        DMTMP(IB)  = DM(IB,IQ,IE)
                        DDMTMP(IB) = DDMST(IB,IQ,IE)
                     ENDDO
                  ELSEIF (IH.EQ.1) THEN
                     DO IB=1,NB
                        DMTMP(IB)  = DM(IB,IQ,IE) + 0.5 *
     &                       (DDMSYP(IB,IQ,IE)+DDMSYM(IB,IQ,IE))
                        DDMTMP(IB) = 0.5 *
     &                       (DDMSYP(IB,IQ,IE)-DDMSYM(IB,IQ,IE))
                     ENDDO
                  ELSE
                     DO IB=1,NB
                        DMTMP(IB)  = DM(IB,IQ,IE) + 0.5 *
     &                       (SQRT(DDMST(IB,IQ,IE)**2. +
     &                       DDMSYP(IB,IQ,IE)**2.) -
     &                       SQRT(DDMST(IB,IQ,IE)**2. +
     &                       DDMSYM(IB,IQ,IE)**2.))
                        DDMTMP(IB) = 0.5 *
     &                       (SQRT(DDMST(IB,IQ,IE)**2. +
     &                       DDMSYP(IB,IQ,IE)**2.)+
     &                       SQRT(DDMST(IB,IQ,IE)**2. +
     &                       DDMSYM(IB,IQ,IE)**2.))
                     ENDDO
                  ENDIF
                  CALL HPAK(ID,DMTMP)
                  CALL HPAKE(ID,DDMTMP)
               ENDDO
            ENDDO
         ENDDO

*---Initialize counter variables
         DO IE=1,NE
            DO IQ=1,NQ
               ESSUM(IE,IQ) = 0.D0
               ESSQSUM(IE,IQ) = 0.D0
               NEVT(IE,IQ) = 0.
               LOCUT(IE,IQ) = 0.
               HICUT(IE,IQ) = 0.
            ENDDO
         ENDDO

*---Initialize exclusive limits for event shapes in MC calculation
         DO IE=1,NE
            LOLIMIT(IE) = DBLE(FBLD(1,IE))  + 1.D-3*DLIM(IE)
            HILIMIT(IE) = DBLE(FBRD(NB,IE)) - 1.D-3*DLIM(IE)
         ENDDO

*********************************************************************
*
*                      Event Processing
*
*********************************************************************

      ELSEIF (IFLAG.EQ.2) THEN


*---Filling: The following MUST always be done
*   (i) move to the correct sub-directory in PAWC
*
         CALL HCDIR('//PAWC/'//XXXX,' ')

*----------------
* Event selection
*----------------

*---Get Q2
         Q2 = REAL(HZDISKIN(1))

*---Get Q
         IF (Q2.LE.0.) THEN
            WRITE(6,*) 'Hz'//xxxx,' ERROR: Q2 less or equal zero !!!'
            GOTO 9990
         ELSE
            Q = SQRT(Q2)
ckr            CALL HFILL(1,Q,0.,WTX)
         ENDIF

*---Q-binning: Q has to be within [7 GeV, 10 GeV] (low Q) or
*------------              within [14 GeV, 100 GeV] (high Q)

         LOWQ  = .FALSE.
         HIGHQ = .FALSE.
         IF (7..LE.Q.AND.Q.LE.10.) THEN
            LOWQ = .TRUE.
            IF (Q.LT.8.)  THEN
               CURQBIN = 1
            ELSE
               CURQBIN = 2
            ENDIF
         ELSEIF (14..LE.Q.AND.Q.LE.100.) THEN
            HIGHQ = .TRUE.
            IF (Q.LT.16.) THEN
               CURQBIN = 3
            ELSEIF (Q.LT.20.) THEN
               CURQBIN = 4
            ELSEIF (Q.LT.30.) THEN
               CURQBIN = 5
            ELSEIF (Q.LT.50.) THEN
               CURQBIN = 6
            ELSEIF (Q.LT.70.) THEN
               CURQBIN = 7
            ELSE
               CURQBIN = 8
            ENDIF
         ELSE
            GOTO 9990
         ENDIF

*---Detect lepton
         IEL = HZIDELEC(IDUM)
         IF ( (IEL.EQ.-1).OR.
     &        (IEL.LT.1).OR.(IEL.GT.NMXHEP) ) THEN
            WRITE(6,*) 'Hz'//xxxx,' ERROR: lepton not found !!!'
            GOTO 9990
         ENDIF

*---CUT (i): energy of scattered lepton
*----------
         IF (LOWQ.AND.PHEP(4,IEL).LE.14.D0) GOTO 9990
         IF (HIGHQ.AND.PHEP(4,IEL).LE.11.D0) GOTO 9990

*---Get polar angle of scattered lepton
         COSTHETA =  REAL(PHEP(3,IEL)) /
     &        SQRT( REAL(PHEP(1,IEL))**2 + REAL(PHEP(2,IEL))**2
     &        + REAL(PHEP(3,IEL))**2 )
         IF (ABS(COSTHETA).GT.1.) THEN
            WRITE(6,*) 'Hz'//xxxx,' ERROR: abs(cos(thetae)) > 1 !!!'
            GOTO 9990
         ENDIF
         THETAE = RD * ACOS(COSTHETA)

*---CUT (ii): polar angle of scattered lepton
*-----------
         IF (LOWQ) THEN
            IF (THETAE.LE.157..OR.THETAE.GE.173.) THEN
               GOTO 9990
            ENDIF
         ELSEIF (HIGHQ) THEN
            IF (THETAE.LE.30..OR.THETAE.GE.150.) THEN
               GOTO 9990
            ENDIF
         ENDIF

*---Get y
         Y = REAL(HZDISKIN(3))

*---CUT (iii): inelasticity y
*------------
         IF (Y.LE.0.05.OR.Y.GE.0.80) GOTO 9990

*---Get theta_q
         FTQ = Q2*(1.-Y)
         BTQ = 4.*Y**2*EE**2
         CTQ = (FTQ-BTQ)/(FTQ+BTQ)
         THQ = 0.
         IF (ABS(CTQ).LE.1.) THEN
            THQ = RD*ACOS(CTQ)
         ELSEIF (CTQ.LT.-1.) THEN
            THQ = 180.
         ENDIF

*---CUT (iv): angle of 'quark' direction
*-----------
         IF (THQ.LE.20.) GOTO 9990

*---Init boost to Breit frame
         IERR = HZIBEAM(IBEAM,IDUM)
         IF ( (IERR.NE.1).OR.
     &        (IBEAM.LT.1).OR.(IBEAM.GT.NMXHEP).OR.
     &        (IDUM.LT.1).OR.(IDUM.GT.NMXHEP)       ) THEN
            WRITE(6,*) 'HZ'//xxxx,' ERROR: beams not found !!!'
            GOTO 9990
         ELSE
            DO ICOMP = 1,4
               PBEAM(ICOMP)=PHEP(ICOMP,IBEAM)
            ENDDO
         ENDIF

         IERR = HZIPGAM(P5)
         IF (IERR.EQ.-1) THEN
            WRITE(6,*) 'HZ'//xxxx,' ERROR: boson vector not found !!!'
            GOTO 9990
         ELSE
            DO ICOMP = 1,4
               PGAM(ICOMP) = P5(ICOMP)
            ENDDO
         ENDIF

         CALL HZBRTINI (PBEAM,PGAM,IERR)
         IF (IERR.EQ.-1) THEN
            WRITE(6,*)
     &           'HZ'//xxxx,' problem with boost to Breit frame !'
            GOTO 9990
         ENDIF

*---Loop over HEP common
*-----------------------
         IHAD = 0
         EHADFWD = 0.D0
         DO 5000 IHEP = 1,NHEP
*---Skip lepton and unstable particles
            IF ((ISTHEP(IHEP).NE.1).OR.(IHEP.EQ.IEL))  GOTO 5000

*---Get polar angle of hadron
            TEMP =  SQRT( REAL(PHEP(1,IHEP))**2 + REAL(PHEP(2,IHEP))**2
     &           + REAL(PHEP(3,IHEP))**2 )
            IF (TEMP.NE.0.) THEN
               COSTHETA =  REAL(PHEP(3,IHEP)) / TEMP
               IF (ABS(COSTHETA).GT.1.) THEN
                  WRITE(6,*) 'Hz'//xxxx,'ERROR: abs(cos(thetah))>1 !!!'
                  GOTO 9990
               ENDIF
               THETAH = RD * ACOS(COSTHETA)
            ELSE
               THETAH = 0.
            ENDIF

*---Sum up hadronic energy in forward direction
            IF ((THETAH.GT.4.).AND.(THETAH.LT.15.))  THEN
               EHADFWD = EHADFWD + PHEP(4,IHEP)
            ENDIF

*---Perform boost to Breit frame
            DO ICOMP = 1,4
               PLAB(ICOMP) = PHEP(ICOMP,IHEP)
            ENDDO
            CALL HZBRT(PLAB,PBRT,IERR)
            IF (IERR.EQ.-1) THEN
               WRITE(6,*) 'HZ'//xxxx,
     &              ' problem with boost to Breit frame !'
               GOTO 9990
            ENDIF

*---Copy to array suitable for subroutine devshp
            IHAD = IHAD + 1
            PHAD(1,IHAD) = PBRT(4)
            PHAD(2,IHAD) = PBRT(1)
            PHAD(3,IHAD) = PBRT(2)
            PHAD(4,IHAD) = PBRT(3)

 5000    CONTINUE

*---CUT (v): hadronic energy in forward region
*----------
         IF (REAL(EHADFWD).LE.0.5) GOTO 9990


*-------------------------------------
* Calculation of event shape variables
*-------------------------------------

*---Get event shape variables
         CALL DEVSHP(PHAD,IHAD,DBLE(Q2),EVSHPSR,NCURR,ECQ)

*---Copy into internal array
         EVSHPMC(1) = EVSHPSR(3)
         EVSHPMC(2) = EVSHPSR(5)
         EVSHPMC(3) = EVSHPSR(1)
         EVSHPMC(4) = EVSHPSR(7)
         EVSHPMC(5) = EVSHPSR(9)
         EVSHPMC(6) = EVSHPSR(12)
         EVSHPMC(7) = EVSHPSR(10)

*--------------
* Histo filling
*--------------

*---Fill histos and increase counters for number of accepted events
         DO IE=1,NE
            IF (IE.LE.5) THEN
*---CUT (vi): total hadronic energy in Breit current hemisphere
*-----------
               IF (REAL(ECQ).LE.0.1) GOTO 999
*---CUT (vii): no. of hadronic objects in Breit current hemisphere
*------------
               IF (NCURR.LT.2) GOTO 999
            ENDIF
*---Calculate sums for mean values and their standard deviations
            ESSUM(IE,CURQBIN) = ESSUM(IE,CURQBIN)
     &           + DBLE(WTX)*EVSHPMC(IE)
            ESSQSUM(IE,CURQBIN) = ESSQSUM(IE,CURQBIN)
     &           + DBLE(WTX)*(EVSHPMC(IE)**2.)
*---CUT (viii): values of evt.shp.var. in allowed regions (s.a.)
*-------------
            IF (EVSHPMC(IE).GT.LOLIMIT(IE).AND.
     &           EVSHPMC(IE).LT.HILIMIT(IE)) THEN
               CALL HFILL(IE*10+CURQBIN,
     &              REAL(EVSHPMC(IE)),0.,WTX)
               NEVT(IE,CURQBIN) = NEVT(IE,CURQBIN) + WTX
            ELSEIF (EVSHPMC(IE).LE.LOLIMIT(IE)) THEN
               LOCUT(IE,CURQBIN) = LOCUT(IE,CURQBIN) + WTX
            ELSEIF (EVSHPMC(IE).GE.HILIMIT(IE)) THEN
               HICUT(IE,CURQBIN) = HICUT(IE,CURQBIN) + WTX
            ENDIF
 999     ENDDO

 9990    CONTINUE

*********************************************************************
*
*                      Termination
*
*********************************************************************

      ELSEIF (IFLAG.EQ.3) THEN

*---Termination: The following MUST always be done
*   (i) Move to the correct PAW subdirectory
*
         CALL HCDIR('//PAWC/'//XXXX,' ')

*---Write out number of accepted events to histos
         DO IE=1,NE
            DO IQ=1,NQ
               IF (NEVT(IE,IQ).GT.0.) THEN
                  CALL HZHINRM(IE*10+IQ,0,NEVT(IE,IQ),1)
               ENDIF
               CALL HZHINFO(IE*10+IQ,NEVT(IE,IQ))
            ENDDO
         ENDDO

*---Get mean values and errors of event shape variables
         DO IE=1,NE
            DO IQ=1,NQ
               IF (NEVT(IE,IQ).LE.0.) THEN
                  ESMEAN(IE,IQ) = 0.
                  ESMEANE(IE,IQ) = 0.
               ELSE
                  ESMEAN(IE,IQ) = REAL(ESSUM(IE,IQ))
     &                 / NEVT(IE,IQ)
                  IF (NEVT(IE,IQ).GE.2.) THEN
                     ESMEANE(IE,IQ) =
     &                    SQRT(  ( REAL(ESSQSUM(IE,IQ)) -
     &                    REAL(ESSUM(IE,IQ)**2)
     &                    / NEVT(IE,IQ) )
     &                    /((NEVT(IE,IQ)-1)*NEVT(IE,IQ)))
                  ELSE
                     ESMEANE(IE,IQ) = 0.
                     WRITE(6,*)
     &                    'Hz'//xxxx,' only one event in Q-bin No.:',IQ
                  ENDIF
               ENDIF
            ENDDO
         ENDDO

*---Fill mean histos
*---(3rd channel contains zeros)
         DO IE=1,NE
            DO ICHN = 1,2
               ESMTMP(ICHN) = ESMEAN(IE,ICHN)
               ESMETMP(ICHN) = ESMEANE(IE,ICHN)
            ENDDO
            ESMTMP(3) = 0.
            ESMETMP(3) = 0.
            DO ICHN = 4,9
               ESMTMP(ICHN) = ESMEAN(IE,ICHN-1)
               ESMETMP(ICHN) = ESMEANE(IE,ICHN-1)
            ENDDO
            CALL HPAK(IE*10,ESMTMP)
            CALL HPAKE(IE*10,ESMETMP)
         ENDDO

*---Get chi-squares and write them to n-tuple
         DO IE=1,NE
            DO IQ=0,NQ
               CALL HZCHISQ(-(IE*10+IQ),IE*10+IQ)
            ENDDO
         ENDDO

*---Write out statistics
         IF (LP) THEN
            WRITE(6,*)' '
            WRITE(6,*)'Hz'//xxxx,'statistics:'
            WRITE(6,*)'-------------------'
            DO IE=1,NE
               WRITE(6,*) '----- for event shape variable',IE
               DO IQ=1,NQ
                  IF (NEVT(IE,IQ).NE.0.) THEN
                     TEMP = (HICUT(IE,IQ)+LOCUT(IE,IQ))/
     &                    NEVT(IE,IQ)
                  ELSE
                     TEMP = 0.
                  ENDIF
                  WRITE(6,*)'Q bin:',IQ,'   # accepted:',NEVT(IE,IQ)
                  WRITE(6,*)'  # hicut:',HICUT(IE,IQ),
     &                 '   # locut:',LOCUT(IE,IQ),
     &                 '   (# hicut + # locut) / # total :',TEMP
               ENDDO
            ENDDO
         ENDIF
      ENDIF

      RETURN
      END
*CMZ :  2.00/05 31/07/2000  21.43.33  by  Tancredi Carli
*CMZ :  2.00/03 06/06/2000  20.53.32  by  Tancredi Carli
*CMZ :  1.02/06 27/03/99  16.07.57  by  Tancredi Carli
*-- Author :
        SUBROUTINE HZ00035(IFLAG)
****************************************************************************
*
* Purpose: Produces histograms for the differential di-jet cross
*          section in photoproduction, as a function of the momentum
*          fraction of the parton in the photon as reconstructed from the
*          two highest transverse energy final state jets.
*
*
*          d sigma(ep->2 jets + X)/(dx_gamma)
*
*          Event selection cuts : Q2 < 0.01 GeV^2
*          (cut scenario 1)       0.5 < y <0.7
*                                 -0.5 < eta1,eta2 < 2.5
*                                 |eta1-eta2| < 1
*                                 ET1,ET2 > 4 GeV
*                                 M_2Jet > 12 GeV
*
*          Event selection cuts : Q2 < 0.01 GeV^2
*          (cut scenario 2)       0.5 < y <0.7
*                                 -0.5 < eta1,eta2 < 2.5
*                                 |eta1-eta2| < 1
*                                 ET1,ET2 > 6 GeV after Pedestalsubtraction
*                                 eta1,eta2 > -0.9 - ln(x_gamma)
*
*          Definition Pedestal:
*                              ET_Ped= 1/A * Sum (ET)
*
*                        Sum = -1<eta-eta1<1,-pi<phi-phi1<pi
*                          A = Area for which the sum of Et is taken,
*                              outside of jets
*
*           with:   Q2 = photon virtuality
*                   y  = E(photon)/E(beam) = normalized photon energy
*            eta1,eta2 = pseudorapidities of the two highest transverse energy
*                        jets in HERA laboratory frame
*            ET1,ET2   = transverse energies of these two jets
*             M_2Jet   = invariant mass of these two jets
*            x_gamma   = (ET1*exp(-eta1)+ET2*exp(-eta2))/(2*E_photon)
*
*
* Reference : O.Kaufmann, Phd-thesis, Uni Heidelberg
*             H1 Collab, DESY00035, subm. Phys.Lett.
*
* Arguments:  iflag=1 initialisation/booking of histograms
*             iflag=2 event processing/filling of MC histograms
*             iflag=3 termination/final normalisation
*                     (the variables Xsec (total cross section) and
*                      Ntot (total number of events) have to be set before
*                      calling the termination routine in order to get a
*                      correct normalisation for the MC histograms)
*
*             This photoproduction routine has to be run twice with the
*             following code additions:
* 	              +1000 for the DIRECT component run.
*	              +2000 for the RESOLVED component run.
*             for all three phases (iflag=1,2,3)
*
* written by: Oliver Kaufmann (Kaufmann@slac.stanford.edu) on 26/08/99
*     modified for split resolved and direct components by Russell Taylor
****************************************************************************
*
* Output graphs:
*---------------
* DATA
*
* histograms -1,-2 contain the measured di-jet cross section data,
* d sigma/(dx_gamma)
* errors are statistical + uncorrelated systematic
* -1        cut scenario 1
* -2        cut scenario 2
*
*
* Monte-Carlo
* d sigma/(dx_gamma)
*  1        cut scenario 1
*  2        cut scenario 2
*               These graphs will be
*               meaningless unless Xsec and Ntot are set before
*               calling the termination routine.
*               (Xsec - total cross section returned by MC)
*               (Ntot - number of events passed to this routine)
* 201: dsigma/dxgamma scenario 1 Mjj>12
* 202: dsigma/dxgamma scenario 2
*****************************************************************************
        IMPLICIT NONE
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZJETCMN.
*
*     MAXHZJETS: maxmial number of jet allowed
*     NUMJETS: number of jets from jet algo
*     NSEL  : number of selected jets
*     IPJET : pointer to selected jets
*     JETS  : Jet variables (eta,phi,et,e,px,py,pz,m) in choosen frame
*     IJETNO: pointer which objects in PHEP common belong to jets
*
      INTEGER MAXHZJETS
      PARAMETER (MAXHZJETS=50)
      INTEGER NSEL,NUMJETS,IPJET(MAXHZJETS),IJETNO(NMXHEP)
      DOUBLE PRECISION JETS(MAXHZJETS,8)
*
      COMMON /HZJETCMN/JETS,NUMJETS,NSEL,IPJET,IJETNO
*
*
*KEND.
*
      Character xxxx*6
      Data xxxx/'00035'/
*
C --- PXCONE stuff ---
      INTEGER  ITKDM,MXTRK
      PARAMETER  (ITKDM=4,MXTRK=500)
      INTEGER  MXJET, MXTRAK, MXPROT
      PARAMETER  (MXJET=50,MXTRAK=500,MXPROT=500)
      INTEGER  IPASS (MXTRAK),IJMUL (MXJET)
      INTEGER  NTRAK,injet,IERR,MODE
      DOUBLE PRECISION  PTRAK (ITKDM,MXTRK),PJET (5,MXJET)
      DOUBLE PRECISION  CONER, EPSLON, OVLIM
*
      DOUBLE PRECISION phi,px,py,pz,pt,ptsq,ppsq
      DOUBLE PRECISION eta,rap,Et,theta
      INTEGER ref(NMXHEP)
*
      Real nev,nfill1,nfill2,nfill3,nfill4,nfill5,nfill6
      Save nev,nfill1,nfill2,nfill3,nfill4,nfill5,nfill6
      INTEGER NPTBIN,NXGBIN,CUTSCE
      Real IJ,JK
      PARAMETER (NPTBIN=1,NXGBIN=7,CUTSCE=2)
*
      REAL XBIN(NXGBIN+1),PTBIN(NPTBIN+1)
      REAL XSDI1(NXGBIN),XERR1(NXGBIN)
      REAL XSDI2(NXGBIN),XERR2(NXGBIN)
      REAL ETPED(6)	
*
      Integer count,loop
      INTEGER I,J,k,IP,IL,NJET1
      INTEGER IFLAG,IFFLAG,INTIFLAG,IPROC
      REAL TMP(10),TMPE(10)
      REAL EBEAM,Q2,Y,ETA1,ETA2,ET1,ET2,ETPED1,ETPED2
      REAL ETJET,M2JET,PH1,PH2
      REAL ET2LOG,XGAMMA,XGAMPED,WBIN,WBINPED,ANORM(2)
      REAL help,XGAMPED1,XGAMMA1
*
      Logical lp
      Data lp/.false./
      Save lp
*
      Double precision RCONE
      parameter (rcone=0.7)
      INTEGER ID,IDMC,IMODE
      CHARACTER*5 JETNAM
*
*      binning definition
*
C     DATA XBIN /0.04,0.07,0.126,0.2,0.316,0.5,0.794,1.09/
      DATA XBIN /-1.4,-1.15,-0.9,-0.7,-0.5,-0.3,-0.1,0.04/
      Save xbin
*
*     di-jet cross section data
*
      DATA XSDI1/0.49,0.88,0.92,0.83,0.85,0.78,0.54/
      Data XSDI2/0.06,0.17,0.17,0.21,0.29,0.54,0.47/
      Save xsdi1,xsdi2
*
*     di-jet cross section errors
*
      DATA XERR1/0.14,0.22,0.24,0.14,0.17,0.14,0.12/
      Data Xerr2/0.03,0.06,0.06,0.06,0.09,0.14,0.12/
*
*     Pedestal Energy as measured in Data
*
      DATA ETPED /0.44,0.53,0.81,1.14,1.415,1.345/
      Save ETPED
*
* --- choose direct/resolved
* --- recommend 1 - DIRECT, 2 - RESOLVED
      IF (iflag.gt.1000) THEN
       iproc=INT(iflag/1000)
       intiflag=MOD(iflag,1000)
      ENDIF
*
      IF ((iproc.gt.2).or.(iproc.lt.1)) THEN
       PRINT*,'hz',xxxx,' Badly called routine'
       PRINT*,'          please set intiflag +1000 or +2000'
      ENDIF
*
      IF (intiflag.eq.1) THEN
* *** Initialisation run ***
*
       nev=0.
       nfill1=0.
       nfill2=0.
       nfill3=0.
       nfill4=0.
       nfill5=0.
       nfill6=0.
*
       CALL HCDIR('//PAWC',' ')
       CALL HMDIR(xxxx,'S')
       CALL HCDIR('//HISTO',' ')
       CALL HMDIR(xxxx,'S')
*
       ID=1+100*iproc
       CALL HBOOKB(ID,' d[s]/dx?[g]! scen1 ',NXGBIN,XBIN,0.)
       CALL  HBARX(ID)
       CALL HBOOKB(-ID,' d[s]/dx?[g]! scen1 ',NXGBIN,XBIN,0.)
       CALL HPAK(-ID, XSDI1)
       CALL HPAKE(-ID,XERR1)
*
       ID=2+100*iproc
       CALL HBOOKB(id,' d[s]/dlog(x?[g]!) scen2 ',NXGBIN,XBIN,0.)
       CALL  HBARX(id)
       CALL HBOOKB(-id,' d[s]/dlog(x?[g]!) scen2 ',NXGBIN,XBIN,0.)
       CALL HPAK(-id, XSDI2)
       CALL HPAKE(-id,XERR2)
*
C==================================================================
*
      ELSE IF (intiflag.EQ.2) THEN
* ***  Event loop, fill MC histograms ***
*
       CALL HCDIR('//PAWC/'//xxxx,' ')
*
       nev=nev+wtx
*
*      test kinematic range
*
       Q2=REAL(HZPHOKIN(1))
       Y=REAL(HZPHOKIN(3))
*
       IF (Q2.GT.0.01) GOTO 65
       IF (Y.LT.0.5.OR.Y.GT.0.7) GOTO 65
*
*      find electron beam energy
*
       IFFLAG=HZIBEAM(IP,IL)
       IF (IFFLAG.EQ.0.OR.IFFLAG.EQ.1) THEN
        EBEAM=PHEP(4,IL)
        IF (ABS(EBEAM-27.55).GT.0.5) THEN
         PRINT *,'HZ',xxxx,' Warning: wrong electron beam energy'
        END IF
       ELSE
        EBEAM=27.55
       END IF
*
       if (lp) then
        write(6,*) ' Q2= ',real(q2),' y= ',real(y),' Eb= ',ebeam
       endif
*
       numjets=0
*
* --- prepare pxcone call
       MODE=2
       EPSLON=4.D0
       OVLIM=7.5D-1
*
C       if (lp) call hzlihep(2)
*
       Do i=1,4
        do j=1,mxtrk
         ptrak(i,j)=0.
        enddo
       enddo
*
       count=0
       DO loop=1,NHEP
*      skip unstable particles and scattered lepton
        IF (ISTHEP(loop).eq.1 .and.abs(idhep(loop)).ne.11) THEN
         IF (count.eq.MXTRK) THEN
          write(6,*) 'Hz',xxxx,'Too many particles for PXCONE',count
          GOTO 165
         ELSE
          count=count+1
          PTRAK(1,count)=PHEP(1,loop)
          PTRAK(2,count)=PHEP(2,loop)
          PTRAK(3,count)=PHEP(3,loop)
          PTRAK(4,count)=PHEP(4,loop)
          ref(count)=loop
         ENDIF
        ENDIF
       ENDDO
 165   CONTINUE
       if (lp) then
        write(6,*) ' count= ',count
       endif
       NTRAK=count
* --- do pxcone call
       CALL PXCONE (MODE,NTRAK,ITKDM,PTRAK,RCONE,EPSLON,OVLIM,
     &          MXJET,injet,PJET,IPASS,IJMUL,IERR)
*
C       if (lp) then
C        write(6,*) ' injet= ',injet,' Pjet= ',pjet
C       endif
*
       IF (IERR.ne.0) THEN
        write(6,*) 'Hz',xxxx, ' PXCONE returns error'
       ENDIF
       IF (injet.gt.MXJET) THEN
        write(6,*) 'Hz',xxxx, 'Too many jets, increase MXJET',injet
       ENDIF
*
* --- get output
*
       IF (injet.gt.MAXHZJETS) THEN
        NUMJETS=MAXHZJETS
       ELSE
        NUMJETS=injet
       ENDIF
*
       DO loop=1,NUMJETS
        px=PJET(1,loop)
        py=PJET(2,loop)
        pz=PJET(3,loop)
        ptsq=px**2+py**2
        ppsq=(SQRT(ptsq+pz**2)+ABS(pz))**2
        IF (ptsq.le.4.25E-18*ppsq) THEN
         eta=20.D0
        ELSE
         eta=0.5*LOG(ppsq/ptsq)
        ENDIF
        eta=SIGN(eta,pz)
        IF (ptsq.EQ.0.D0) THEN
         phi=0.D0
        ELSE
         phi=ATAN2(py,px)
        ENDIF
*
        Et=PJET(4,loop)*SQRT(ptsq/(ptsq+pz**2))
        Jets(loop,1)=eta  ! eta
        Jets(loop,2)=phi  ! phi
        Jets(loop,3)=Et   ! Et
        Jets(loop,4)=PJET(4,loop)  ! E
        Jets(loop,5)=PJET(1,loop)  ! px
        Jets(loop,6)=PJET(2,loop)  ! py
        Jets(loop,7)=PJET(3,loop)  ! pz
        Jets(loop,8)=0             ! m
       Enddo
*
C       DO loop=1,ntrak
C        iJetNo(ref(loop))=IPASS(loop)
C       ENDDO
*
       if (lp) call hzlijet(numjets,jets)
*
*      at least two jets required
       IF (Numjets.LT.2) GOTO 65
*
*      pseudorapidity range of jets
       ETA1=jets(1,1)
       ETA2=jets(2,1)
*
       if (lp) then
        write(6,*) ' eta1= ',eta1,' eta2= ',eta2,ABS(ETA1-ETA2)
       endif
*
       IF (ABS(ETA1-ETA2).GT.1.) GOTO 65

*
       IF (ETA1.gt.2.5.or.eta2.gt.2.5.or.eta1.lt.-0.5
     +	              .or.eta2.lt.-0.5) GOTO 65
*
        if (lp) write(6,*) ' ...passed eta cuts '
*
*      pedestal energy (as measured in data)
*
       do i=1,6
	jk=-1.+(0.5*i)
        ij=-0.5+(0.5*i)
        if (lp) then
         write(6,*) ' ik= ',jk,' ij= ',ij
        endif
	if(eta1.gt.jk.and.eta1.lt.ij)then
         ETPED1=JETS(1,3)-ETPED(I)
	endif
*
        if(eta2.gt.jk.and.eta2.lt.ij)then
         ETPED2=JETS(2,3)-ETPED(I)
        endif
       end do
*
       if (lp) then
        write(6,*) ' ETPED1= ',ETPED1,' ETPED2= ',ETPED2
       endif
*
*      jet transverse energies
*
       ET1=JETS(1,3)
       ET2=JETS(2,3)
       PH1=JETS(1,2)
       PH2=JETS(2,2)
*
       M2JET=sqrt((2*ET1*ET2*(cosh(ETA1-ETA2)-cos(abs(PH1-PH2)))))
*
       XGAMMA1=(ET1*EXP(-ETA1)+ET2*EXP(-ETA2))/(2.*Y*EBEAM)
       if (xgamma1.gt.0.) then
        XGAMMA=log10(xgamma1)
       else
        write(6,*) ' xgamma1= ',xgamma1,' ?? '
       endif
*
       XGAMPED1=(ETPED1*EXP(-ETA1)+ETPED2*EXP(-ETA2))/(2.*Y*EBEAM)
       if (xgamped1.gt.0.) then
        XGAMPED=log10(XGAMPED1)
       else
        write(6,*) ' xgamped= ',xgamped1,' ?? '
       endif
*
       if (lp) then
        write(6,*) ' Et1= ',et1,' et2= ',et2
        write(6,*) ' Phi1= ',ph1,' Phi2= ',ph2,abs(PH1-PH2)
        write(6,*) ' M2JET= ',M2JET
        write(6,*) ' XGAMMA= ',XGAMMA,' XGAMPED= ',XGAMPED
       endif
*
*      cut scenario 1
*
       IF (I.GT.NXGBIN) GOTO 65
*
       nfill1=nfill1+wtx
       if (lp) then
        write(6,*) 1+100*iproc,' FILLING: '
        write(6,*) ' xgamma= ',xgamma,' nfill1= ',nfill1
       endif
       CALL HFILL (1+100*iproc,XGAMMA,0.,WTX)   	
*
*      cut scenario 2
*
       if (lp) write(6,*) '  et1,  et2= ',ET1,ET2
       if (lp) write(6,*) ' eta1, eta2= ',ETA1,ETA2
       if (lp) write(6,*) ' log= ',log(XGAMMA1)
*
       IF(ET1.gt.6..and.ET2.gt.6..and.
     +	 (ETA1.gt.(-0.9 - log(XGAMMA1))).and.
     +   (ETA2.gt.(-0.9 - log(XGAMMA1))))THEN
*
C     +	 (ETA1.gt.(-0.9 - log(XGAMPED1))).and.
C     +  (ETA2.gt.(-0.9 - log(XGAMPED1))))THEN
*
         nfill2=nfill2+wtx
         if (lp) then
          write(6,*) ' xgamma= ',xgamma,' nfill2= ',nfill2
         endif
        CALL HFILL (2+100*iproc,XGAMMA,0.,WTX)
*
       ENDIF	
*
65     CONTINUE
*
      ELSE IF (intiflag.eq.3) THEN
C *** Termination, fix normalisation of MC histograms ***
*
       CALL HCDIR('//PAWC/'//xxxx,' ')
*
       IF (Xsec.eq.0) THEN
	PRINT*,'HZ',xxxx,': termination called with zero cross section'
	PRINT*,'          cross section graph meaningless'
	PRINT*,'	      in process :',iproc*1000
	Xsec=1
       ENDIF
       IF (Nev.eq.0) THEN
	PRINT*,'HZ',xxxx,' no total events'
	PRINT*,'          cross section graph meaningless'
        PRINT*,'	    in process :',iproc*1000
	Ntot=1
*
        ANORM(iproc)=0.
       ELSE
*       convert pb -> nb
        if (xsec.ne.1) then
         ANORM(iproc)=NEV/(XSEC/1000.)
        else
         ANORM(iproc)=1000.
        endif
*
       ENDIF
*
       write(6,*) ' iproc= ',iproc
       write(6,*) 'HZ',xxxx,': nev= ', nev,' xsec (pb)= ',xsec
       write(6,*) ' scenario1: ',nfill1,' sec: ',nfill1/ANORM(iproc)
       write(6,*) ' scenario2: ',nfill2,' sec: ',nfill2/ANORM(iproc)
*
*
C      IF (iproc.eq.2) THEN
        DO I=1,2
         ID=I+100*iproc
         write(6,*) 'Hz',xxxx,' norm id= ',id
         call hzhinrm(ID,0,anorm(iproc),1)
         if (i.le.2) CALL HZCHISQ(ID,-ID)
        END DO
C      ENDIF
*
      ELSE
       WRITE(6,*) 'HZ',xxxx,' Unknown flag',iflag
      ENDIF
      RETURN
      END
*CMZ :  2.00/04 31/07/2000  21.05.56  by  Tancredi Carli
*CMZ :  2.00/03 10/05/2000  19.43.37  by  Tancredi Carli
*-- Author :    Tancredi Carli   10/05/2000
      Subroutine hz00040(iflag)
************************************************************************
*                                                                      *
* Author: Nick Brook (n.brook@bristol.ac.uk)                           *
*                                                                      *
* This routine plots the phi distbns                                   *
* in the hadronic centre of mass frame.                                *
* The distbn are corrected for particles coming from K0s and Lambdas   *
*                                                                      *
*                                                                      *
* Reference:                                                           *
*            DESY 00-040                                               *
*                                                                      *
************************************************************************
*
* HERA tuning defined commons
*
      Implicit Double Precision(A-H,O-Z)
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEND.
*
      COMMON/QUEST/IQUEST(100)
*
* Set up local variables
*
      Integer idum,ierr,nentry
      Character xxxx*5
      Real eb,ee
      Parameter (ee=27.5)
      Character*80 chtitl
      Character*2 cid
      Dimension plab(4), phcm(4), pbeam(4), pgam(4), pgam5(5)
      Real dazi(10,4), dazie(10,4)
      Real cosm(8),cose(8),cosls(8),cosus(8)
      Real cos2m(8),cos2e(8),cos2ls(8),cos2us(8)
      Real cosmc(8),cos2mc(8)
      Real cosmcsq(8),cos2mcsq(8)
      Real cosmce(8),cos2mce(8)
      Real pi, events
      Integer ntrk(8)
      Dimension pcut(8)
*
      Data nentry/0/
      Data xxxx/'00040'/
*
* Data points from plots
*
      Data pcut/.25,.5,.75,1.,1.25,1.5,1.75,2./
      data cosm/-.078,-.078,-.086,-.080,-.067,-.065,-.048,-.030/
      data cose/.012,.012,.013,.014,.015,.017,.018,.020/
      data cosls/.021,.021,.024,.022,.028,.025,.031,.040/
      data cosus/.019,.017,.019,.020,.018,.024,.023,.021/
      data cos2m/.016,.021,.033,.047,.068,.080,.091,.091/
      data cos2e/.014,.014,.015,.016,.017,.018,.019,.021/
      data cos2ls/.024,.023,.027,.030,.034,.042,.044,.042/
      data cos2us/.019,.020,.021,.021,.022,.024,.024,.026/
      data dazi/.0817,.0743,.0779,.0657,.0695,
     +          .0693,.0605,.0766,.0828,.0874,
     2          .0546,.0485,.0502,.0406,.0452,
     +          .0493,.0373,.0469,.0549,.0602,
     3          .0373,.0314,.0311,.0263,.0339,
     +          .0348,.0270,.0307,.0363,.0438,
     4          .0249,.0221,.0216,.0193,.0258,
     +          .0265,.0185,.0198,.0251,.0290/
      data dazie/.0038,.0034,.0035,.0032,.0034,
     +           .0034,.0029,.0034,.0038,.0040,
     2           .0032,.0028,.0028,.0024,.0027,
     +           .0029,.0023,.0026,.0031,.0034,
     3           .0027,.0022,.0022,.0019,.0025,
     +           .0025,.0020,.0021,.0026,.0031,
     4           .0022,.0019,.0018,.0017,.0022,
     +           .0022,.0016,.0017,.0021,.0025/
*
      If(iflag.eq.1) then
*
* Initialisation: The following MUST always be done
* (i) make subdirectory in PAWC
*      - use the name as the xxxxxx in HZxxxxxx subroutine
* (i) make subdirectory in o/p file
*
        Call hcdir('//PAWC',' ')
        call hmdir('00040','S')
        Call hcdir('//HISTO',' ')
        call hmdir('00040','S')
*
* book your histograms
*
        pi = acos(-1.)
        Call Hbook1(10,' pc = 0.5',10,-pi,pi,0.)
        Call Hbook1(20,' pc = 1.0',10,-pi,pi,0.)
        Call Hbook1(30,' pc = 1.5',10,-pi,pi,0.)
        Call Hbook1(40,' pc = 2.0',10,-pi,pi,0.)
        Call Hbook1(100,' cos(phi)',8,0.25,2.25,0.)
        Call Hbook1(200,' cos(2phi)',8,0.25,2.25,0.)
        Call Hbook1(-10,' pc = 0.5',10,-pi,pi,0.)
        Call Hbook1(-20,' pc = 1.0',10,-pi,pi,0.)
        Call Hbook1(-30,' pc = 1.5',10,-pi,pi,0.)
        Call Hbook1(-40,' pc = 2.0',10,-pi,pi,0.)
        Call Hbook1(-100,' cos(phi)',8,0.25,2.25,0.)
        Call Hbook1(-200,' cos(2phi)',8,0.25,2.25,0.)
        Call Hbook1(-1100,' cos(phi)',8,0.25,2.25,0.)
        Call Hbook1(-1200,' cos(2phi)',8,0.25,2.25,0.)
        Call Hbook1(-1101,' cos(phi)',8,0.25,2.25,0.)
        Call Hbook1(-1201,' cos(2phi)',8,0.25,2.25,0.)
*
* set your plot/paper specific cuts
*
        xlcut = 0.01
        xhcut = 0.1
        ylcut = 0.2
        yhcut = 0.8
        zhcut = 0.2
*
* Initialisation
*
        Call Vzero(cosmc,8)
        Call Vzero(cos2mc,8)
        Call Vzero(cosmcsq,8)
        Call Vzero(cos2mcsq,8)
        do i=1,8
         ntrk(i)=0
        enddo
        nentry = 0
        events = 0.
*
      Else if(iflag.eq.2) then
* Filling: The following MUST always be done
* (i) move to the correct sub-directory in PAWC
*
        call hcdir('//PAWC/00040',' ')
        qsq = hzdiskin(1)
        xbj = hzdiskin(2)
        ybj  = hzdiskin(3)
        If(ybj.ge.ylcut.and.ybj.lt.yhcut.and.
     +     xbj.ge.xlcut.and.xbj.lt.xhcut) then
        Else
           Return
        Endif
*
* Fill your histograms
*
          jel = hzidelec(idum)
          if(jel.lt.0) Return
          if(hzipgam(pgam5).lt.0) Return
          if(hzibeam(ip,il).ne.1) Return
* check on electron beam energy
          nentry=nentry+1
          ierr=HZIBEAM(ibeam,idum)
          if (.not.(ierr.eq.1)) then
           write(6,*) 'HZ'//xxxx,' beams not found ! '
           return
          endif
*
          eb=real(PHEP(4,idum))
          if (abs(abs(eb)-ee).gt.0.3) then
           if (nentry.lt.10) then
            write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,'  ! '
           elseif (nentry.eq.10) then
            write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,
     &      ' ...last message ! '
           endif
           return
          endif

          do ivec = 1, 4
            pbeam(ivec) = phep(ivec,ip)
            pgam(ivec) = pgam5(ivec)
          enddo
          Call hzhcmini(pbeam,pgam,ierr)
          Nentry = Nentry + 1
          events = events + wtx
          do 30 ihep = 1, nhep
            If(isthep(ihep).eq.1.and.ihchrg(ihep).ne.0
     +         .and.ihep.ne.jel) then
             idpart=abs(idhep(jmohep(1,ihep)))
             If(idpart.eq.310.or.idpart.eq.3122) goto 30
             do ivec=1,4
               plab(ivec) = phep(ivec,ihep)
             enddo
             zh = 2.*xbj/qsq*(pbeam(4)*plab(4)-pbeam(3)*plab(3))
             if(zh.lt.zhcut) goto 30
             Call hzhcm(plab,phcm,ierr)
             azi = hzphmang(phcm(1),phcm(2))
             csazi = cos(azi)
             cs2azi = cos(2.*azi)
             pt = sqrt(phcm(1)**2+phcm(2)**2)
             Do ibin = 1, 8
               if(pt.gt.pcut(ibin)) then
                 ntrk(ibin) = ntrk(ibin) + 1
                 cosmc(ibin) = cosmc(ibin) + csazi
                 cos2mc(ibin) = cos2mc(ibin) + cs2azi
                 cosmcsq(ibin) = cosmcsq(ibin) + csazi**2
                 cos2mcsq(ibin) = cos2mcsq(ibin) + cs2azi**2
                 if(ibin.eq.2) then
                   Call hfill(10,sngl(azi),0.,wtx)
                 else if(ibin.eq.4) then
                   Call hfill(20,sngl(azi),0.,wtx)
                 else if(ibin.eq.6) then
                   Call hfill(30,sngl(azi),0.,wtx)
                 else if(ibin.eq.8) then
                   Call hfill(40,sngl(azi),0.,wtx)
                 endif
               endif
             Enddo
            endif
 30       continue
*
      Else if(iflag.eq.3) then
* Termination: The following MUST always be done
* (i) Move to the correct PAW subdirectory
*
        call hcdir('//PAWC/00040',' ')
*
* Histo manipulation
* Deal with data plots
*
          Call hzhinrm(10,0,events,1)
          Call hzhinrm(20,0,events,1)
          Call hzhinrm(30,0,events,1)
          Call hzhinrm(40,0,events,1)
          Do ibin = 1, 8
           cosmc(ibin) = cosmc(ibin)/ntrk(ibin)
           cos2mc(ibin) = cos2mc(ibin)/ntrk(ibin)
           cosmcsq(ibin) = cosmcsq(ibin)/ntrk(ibin)
           cos2mcsq(ibin) = cos2mcsq(ibin)/ntrk(ibin)
           cosmce(ibin) = sqrt((cosmcsq(ibin)-cosmc(ibin)**2)
     +                     /ntrk(ibin))
           cos2mce(ibin) = sqrt((cos2mcsq(ibin)-cos2mc(ibin)**2)
     +                     /ntrk(ibin))
          Enddo

          Call hpak(100,cosmc)
          Call hpake(100,cosmce)
          Call hpak(200,cos2mc)
          Call hpake(200,cos2mce)
          Call hpak(-10,dazi(1,1))
          Call hpake(-10,dazie(1,1))
          Call hpak(-20,dazi(1,2))
          Call hpake(-20,dazie(1,2))
          Call hpak(-30,dazi(1,3))
          Call hpake(-30,dazie(1,3))
          Call hpak(-40,dazi(1,4))
          Call hpake(-40,dazie(1,4))
          Call hpak(-100,cosm)
          Call hpake(-100,cose)
          Call hpak(-200,cos2m)
          Call hpake(-200,cos2e)
          Call hpak(-1100,cosm)
          Call hpake(-1100,cosus)
          Call hpak(-1200,cos2m)
          Call hpake(-1200,cos2us)
          Call hpak(-1101,cosm)
          Call hpake(-1101,cosls)
          Call hpak(-1201,cos2m)
          Call hpake(-1201,cos2ls)
          Call hzchisqa(-1100,-1101,100)
          Call hzchisqa(-1200,-1201,200)
          Call hzchisq(-100,100)
          Call hzchisq(-200,200)
          Call hzchisq(-10,10)
          Call hzchisq(-20,20)
          Call hzchisq(-30,30)
          Call hzchisq(-40,40)

      Endif
*
      Return
 1001 Format(/,1X,' bin # ',I2,' Mean Q = ',F4.1)
 1002 Format(A,F4.2,A,F4.2)
 1003 Format(A,F4.2,A,F4.2,A,F4.2)
      End
*CMZ :  2.00/06 02/05/2002  14.23.52  by  Tancredi Carli
*-- Author :
*
*CMZ :  2.00/05 24/04/2001  13.48.34  by  Frank-Peter Schilling
*-- Author : F.-P.Schilling

      SUBROUTINE HZ00174 (IFLAG)

*******************************************************************************
* H1 Collaboration
* Diffractive Jet Production in Deep-Inelastic e+p Collisions at HERA
* DESY 00-174, hep-ex/0012051, accepted by Eur.Phys.J. C
*
* Analysis by Frank-Peter Schilling, Univ. Heidelberg (Germany)
* This code (C) 2001 by Frank-Peter Schilling (fpschill@mail.desy.de)
*
*******************************************************************************
*
* Event selection: Q2 = 4 ... 80 GeV2 , y = 0.1 ... 0.7
*                  xpom < 0.05 , My < 1.6 GeV , |t| < 1.0 GeV2
*                  N>=2 CDFCONE Jets in HCMS with pt > 4 GeV
*                  eta-jet= -3 ... 0 (in HCMS)
*
* Arguments: iflag=1 initialisation
*            iflag=1 filling
*            iflag=3 termination
*
*******************************************************************************

      IMPLICIT NONE

*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZJETCMN.
*
*     MAXHZJETS: maxmial number of jet allowed
*     NUMJETS: number of jets from jet algo
*     NSEL  : number of selected jets
*     IPJET : pointer to selected jets
*     JETS  : Jet variables (eta,phi,et,e,px,py,pz,m) in choosen frame
*     IJETNO: pointer which objects in PHEP common belong to jets
*
      INTEGER MAXHZJETS
      PARAMETER (MAXHZJETS=50)
      INTEGER NSEL,NUMJETS,IPJET(MAXHZJETS),IJETNO(NMXHEP)
      DOUBLE PRECISION JETS(MAXHZJETS,8)
*
      COMMON /HZJETCMN/JETS,NUMJETS,NSEL,IPJET,IJETNO
*
*
*KEND.

* *** Variable declarations ***************************************************

      integer nentry,iflag
      data nentry /0/

c     name of HZTOOL routine
      Character*5 xxxx
      save xxxx
      Data xxxx/'00174'/

c     Print debug flag
      logical lp
      Data lp/.false./

*     common that gives the position of particles in X and Y system (hzhadgap)
      integer nxobj,nyobj,nxgag,nygag
      double precision pom
      common /diffhad/pom(5),nxobj(5000),nyobj(5000),nxgag,nygag

*     Jets
      Integer numjet,nj
      Parameter (numjet=50)
      Double precision pj(numjet,8)
      integer ipjet2(numjet)

*     all the rest

      real xw,nall,nall2,nall3,n2,lum,n3
      integer i,ij,idum,ierr,iy,ihep,ierr1,ierr2
      integer ibeam,ielec,iel,nsel2,hid

      Double precision pelec(4),pscat(4),pbeam(4),pgam(4)
      Double precision ph(5),plab(5,NMXHEP),pcm(4)
      Double precision hjet1(4),hjet2(4),ljet1(4),ljet2(4)

      real q2,x,yy,x_pom,xmas,ymas,t,mx2,ww,beta
      real ptj2,pj1,pj2,pt_had,p_sh(4),shat,xgluon,q2pt2
      real th1,th2,rap1,rap2,eta_lab,eta1,eta2
      real pj3,m3,shat3,z3,eta3
      real etot,pztot,empztot,empz1,empz2,xgam,egamma,ptpomeron

      double precision pbeam2(4),pgamma(4),ppom(4)

      logical disjet,difjet

* *** Cross section definitions ***********************************************

*     q**2
      integer nbi01
      data    nbi01 /9/
      real    bin01(10)
      data    bin01 / 4., 6., 10., 15., 20., 30., 40., 50., 60., 80./
*     pt
      integer nbi02
      data    nbi02 /6/
      real    bin02(7)
      data    bin02 / 4., 5., 6., 7.5, 9., 11., 14./
*     eta-lab
      integer nbi03
      data    nbi03 /7/
      real    bin03(8)
      data    bin03 / -1., -0.66, -0.33,  0., 0.33, 0.66, 1., 1.5/
*     mx
      integer nbi04
      data    nbi04 /5/
      real    bin04(6)
      data    bin04 / 8., 14., 20., 30., 40., 60./
*     W
      integer nbi05
      data    nbi05 /7/
      real    bin05(8)
      data    bin05 / 90., 115., 140., 165., 190., 215., 240., 260./
*     log(xpom)
      integer nbi06
      data    nbi06 /6/
      real    bin06(7)
      data    bin06 / -2.5, -2.3, -2.1, -1.9, -1.7, -1.5, -1.3/
*     log(beta)
      integer nbi07
      data    nbi07 /8/
      real    bin07(9)
      data    bin07 / -2.8, -2.5,-2.2,-1.9,-1.6,-1.3,-1.1,-0.8,-0.5/
*     zpom
      integer nbi08
      data    nbi08 /8/
      real    bin08(9)
      data    bin08 / 0., 0.125, 0.25, 0.375, 0.5, 0.625, 0.75,0.875,1./
*     xgamma
      integer nbi09
      data    nbi09 /5/
      real    bin09(6)
      data    bin09 / 0.0, 0.2, 0.4, 0.6, 0.8, 1.0/
*     e gamma-hem.
      integer nbi10
      data    nbi10 /4/
      real    bin10(5)
      data    bin10 / 0., 4., 8., 12.,  20./

*     z in xpom bins ----------------------------------------------------------

      real zxpsplit(5)
      data zxpsplit / -1.3, -1.5, -1.75, -2.0, -3.0/
*     z1 xpom=-1.3...-1.5
      integer nbi11
      data    nbi11 /5/
      real    bin11(6)
      data    bin11 / 0., .15, .3, .5, .7, 1. /
*     z2 xpom=-1.5...-1.75
      integer nbi12
      data    nbi12 /5/
      real    bin12(6)
      data    bin12 / 0., .2, .4, .6, .8, 1./
*     z3 xpom=-1.75...-2.00
      integer nbi13
      data    nbi13 /5/
      real    bin13(6)
      data    bin13 / 0., .3, .45, .6, .8, 1./
*     z4 xpom=-2...-3
      integer nbi14
      data    nbi14 /5/
      real    bin14(6)
      data    bin14 / 0., .3, .45, .6, .8, 1./

*     z in q2pt2 bins ---------------------------------------------------------

      real zqpsplit(3)
      data zqpsplit / 35., 45., 60./
*     q2+pt2 = 20 .. 35
      integer nbi15
      data    nbi15 /5/
      real    bin15(6)
      data    bin15 / 0., .2, .4, .6,  .8, 1./
*     q2+pt2 = 35 .. 45
      integer nbi16
      data    nbi16 /5/
      real    bin16(6)
      data    bin16 / 0., .2, .4, .6,  .8, 1./
*     q2+pt2 = 45 .. 60
      integer nbi17
      data    nbi17 /5/
      real    bin17(6)
      data    bin17 / 0., .2, .4, .6,  .8, 1./
*     q2+pt2 = 60 ..
      integer nbi18
      data    nbi18 /5/
      real    bin18(6)
      data    bin18 / 0., .2, .4, .6,  .8, 1./

*     xpom <0.01 --------------------------------------------------------------

*     q2
      integer nbi19
      data    nbi19 /4/
      real    bin19(5)
      data    bin19 / 4.,  10.,  20.,  40.,  80./
*     pt
      integer nbi20
      data    nbi20 /4/
      real    bin20(5)
      data    bin20 / 4., 5., 6., 7.5,  9./
*     zpom
      integer nbi21
      data    nbi21 /5/
      real    bin21(6)
      data    bin21 / 0., .3, .45, .6, .8, 1./
*     pt pomeron-hem.
      integer nbi22
      data    nbi22 /3/
      real    bin22(4)
      data    bin22 / 0., .5,  1.,  3./

*     3jet --------------------------------------------------------------------

*     m-123 (3 jets)
      integer nbi23
      data    nbi23 /3/
      real    bin23(4)
      data    bin23 / 12., 20., 30.,  40. /
*     z3 (3 jets)
      integer nbi24
      data    nbi24 /3/
      real    bin24(4)
      data    bin24 / .2, .4, .6, .8 /

* *** Data points *************************************************************

      real dat01(9),sta01(9),tot01(9)
      data dat01 /21.44,12.95, 6.25, 4.07, 2.33, 1.22, 0.75, 0.72, 0.39/
      data sta01 / 0.96, 0.52, 0.30, 0.25, 0.13, 0.10, 0.08, 0.09, 0.05/
      data tot01 / 3.64, 2.15, 1.10, 0.72, 0.41, 0.22, 0.17, 0.19, 0.13/

      real dat02(6),sta02(6),tot02(6)
      data dat02 / 74.87, 59.50, 28.76,  9.89,  3.35,  0.92/
      data sta02 /  3.00,  1.96,  1.13,  0.69,  0.37,  0.17/
      data tot02 / 13.69,  9.98,  5.10,  1.90,  0.70,  0.24/

      real dat03(7),sta03(7),tot03(7)
      data dat03 / 22.36, 68.85,112.78,131.61,127.86, 85.33, 16.38/
      data sta03 /  3.02,  4.31,  5.28,  5.53,  5.44,  4.38,  1.12/
      data tot03 /  8.24, 12.93, 18.52, 21.43, 23.00, 15.52,  4.35/

      real dat04(5),sta04(5),tot04(5)
      data dat04 /  1.90,  7.54,  7.29,  4.47,  1.21/
      data sta04 /  0.19,  0.33,  0.23,  0.18,  0.07/
      data tot04 /  0.42,  1.18,  1.25,  0.82,  0.34/

      real dat05(7),sta05(7),tot05(7)
      data dat05 /  1.08,  1.40,  1.68,  1.34,  1.13,  0.93,  0.46/
      data sta05 /  0.07,  0.07,  0.07,  0.06,  0.05,  0.05,  0.05/
      data tot05 /  0.23,  0.27,  0.31,  0.25,  0.21,  0.17,  0.14/

      real dat06(6),sta06(6),tot06(6)
      data dat06 /  7.32, 35.44, 88.23,171.24,269.26,440.73/
      data sta06 /  1.60,  3.84,  6.00,  8.07,  9.82, 14.08/
      data tot06 /  2.64,  9.71, 16.56, 29.11, 45.07, 83.01/

      real dat07(8),sta07(8),tot07(8)
      data dat07 /24.90,88.28,129.88,152.69,145.92, 85.03, 53.40, 13.54/
      data sta07 / 2.82, 4.94,  5.65,  6.03,  6.30,  5.95,  4.16,  2.39/
      data tot07 / 7.15,16.77, 22.40, 27.27, 25.30, 15.99, 10.16,  4.69/

      real dat08(8),sta08(8),tot08(8)
      data dat08 /269.40,493.90,331.28,233.17,174.15, 94.01,39.76,29.97/
      data sta08 / 15.74, 18.88, 14.01, 11.42, 10.23,  7.58, 4.65, 4.99/
      data tot08 / 65.82, 92.93, 63.24, 44.66, 29.88, 17.13, 7.97, 8.89/

      real dat09(5),sta09(5),tot09(5)
      data dat09 / 25.37,104.76,153.78,331.54,428.29/
      data sta09 /  3.62,  6.80,  7.64, 11.85, 13.34/
      data tot09 /  9.63, 19.79, 28.88, 60.71, 72.79/

      real dat10(4),sta10(4),tot10(4)
      data dat10 / 38.14,  9.02,  3.99,  2.02/
      data sta10 /  0.94,  0.42,  0.27,  0.16/
      data tot10 /  6.61,  1.64,  1.05,  0.80/

      real dat11(5),sta11(5),tot11(5)
      data dat11 /232.85,209.38, 85.36, 30.91,  3.36/
      data sta11 / 13.97, 11.13,  5.46,  3.22,  0.97/
      data tot11 / 70.53, 51.84, 18.58,  6.64,  1.85/

      real dat12(5),sta12(5),tot12(5)
      data dat12 / 97.08,134.30, 63.43, 21.77,  8.55/
      data sta12 /  6.21,  7.06,  4.47,  2.74,  2.21/
      data tot12 / 21.14, 26.46, 11.25,  4.54,  3.68/

      real dat13(5),sta13(5),tot13(5)
      data dat13 / 37.76, 59.74, 49.07, 33.84,  9.02/
      data sta13 /  3.15,  5.52,  5.49,  3.69,  1.97/
      data tot13 /  9.39, 12.20, 10.97,  7.43,  2.98/

      real dat14(5),sta14(5),tot14(5)
      data dat14 /  5.17, 25.78, 27.97, 24.80, 11.88/
      data sta14 /  1.56,  4.18,  3.88,  3.18,  2.07/
      data tot14 /  4.67,  9.14,  7.12,  5.67,  3.33/

      real dat15(5),sta15(5),tot15(5)
      data dat15 /150.55,109.03, 45.16, 18.72,  5.86/
      data sta15 / 10.04,  7.91,  4.87,  3.04,  1.85/
      data tot15 / 49.84, 30.10, 13.90,  6.65,  3.69/

      real dat16(5),sta16(5),tot16(5)
      data dat16 / 89.72, 71.75, 39.25, 16.94,  4.25/
      data sta16 /  6.36,  4.94,  3.52,  2.45,  1.18/
      data tot16 / 23.49, 16.40, 10.82,  5.07,  1.62/

      real dat17(5),sta17(5),tot17(5)
      data dat17 / 74.64, 78.00, 43.17, 14.74,  5.51/
      data sta17 /  5.78,  5.21,  3.72,  2.17,  1.30/
      data tot17 / 19.24, 19.83,  8.86,  3.68,  2.05/

      real dat18(5),sta18(5),tot18(5)
      data dat18 / 58.66,114.63, 73.39, 45.30, 14.44/
      data sta18 /  5.38,  6.69,  5.01,  4.24,  2.64/
      data tot18 / 15.76, 21.05, 12.47,  8.14,  4.16/

      real dat19(4),sta19(4),tot19(4)
      data dat19 /  1.5750,  0.4045,  0.1154,  0.0143/
      data sta19 /  0.1530,  0.0561,  0.0204,  0.0064/
      data tot19 /  0.3297,  0.0932,  0.0394,  0.0105/

      real dat20(4),sta20(4),tot20(4)
      data dat20 /  8.3167,  4.6510,  2.0343,  0.2935/
      data sta20 /  0.9940,  0.5136,  0.3257,  0.1468/
      data tot20 /  2.2257,  1.1162,  0.5070,  0.1939/

      real dat21(5),sta21(5),tot21(5)
      data dat21 /  5.1740, 25.7836, 27.9743, 24.7987, 11.8816/
      data sta21 /  1.5600,  4.1827,  3.8793,  3.1751,  2.0683/
      data tot21 /  4.6747,  9.1375,  7.1212,  5.6711,  3.3307/

      real dat22(3),sta22(3),tot22(3)
      data dat22 / 24.4935, 11.2122,  1.2875/
      data sta22 /  2.5263,  1.4239,  0.2062/
      data tot22 /  7.0444,  3.1236,  0.7763/

      real dat23(3),sta23(3),tot23(3)
      data dat23 /  0.4821,  0.4336,  0.0562/
      data sta23 /  0.0696,  0.0504,  0.0199/
      data tot23 /  0.1738,  0.1116,  0.0302/

      real dat24(3),sta24(3),tot24(3)
      data dat24 / 13.1448, 13.8502, 10.4796/
      data sta24 /  2.1324,  1.9207,  1.9460/
      data tot24 /  6.1423,  3.4237,  3.0623/

*******************************************************************************
*
*     Initialization
*
*******************************************************************************

      NENTRY=NENTRY+1

      IF (iflag.eq.1) then

        nall = 0.
        nall2= 0.
        nall3= 0.
        n2   = 0.
        n3   = 0.

*       Initialisation: The following MUST always be done
*       (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*       (i) make subdirectory in o/p file

        call hcdir('//PAWC',' ')
        call hmdir(xxxx,'S')
        call hcdir('//HISTO',' ')
        call hmdir(xxxx,'S')

        write(6,*) 'HZ'//xxxx

c       book control histos for all events

        call hbook1(211,'y'        ,100,0.0,0.8,0.)
        call hbook1(212,'Q^2!'     ,100,0.,90.,0.)
        call hbook1(213,'log x?IP!',100,-5.,0.,0.)
        call hbook1(214,'"b#t"b#'  ,100,0.,2.,0.)
        call hbook1(215,'M?X!'     ,100,0.,80.,0.)
        call hbook1(216,'M?Y!'     ,100,0.,5.,0.)

c       book control histos for inclusive DIS

        call hbook1(221,'y'        ,100,0.0,0.8,0.)
        call hbook1(222,'Q^2!'     ,100,0.,90.,0.)
        call hbook1(223,'log x?IP!',100,-5.,0.,0.)
        call hbook1(224,'"b#t"b#'  ,100,0.,2.,0.)
        call hbook1(225,'M?X!'     ,100,0.,80.,0.)
        call hbook1(226,'M?Y!'     ,100,0.,5.,0.)

c       book control histos for incl. diffr. DIS

        call hbook1(231,'y'        ,100,0.0,0.8,0.)
        call hbook1(232,'Q^2!'     ,100,0.,90.,0.)
        call hbook1(233,'log x?IP!',100,-5.,0.,0.)
        call hbook1(234,'"b#t"b#'  ,100,0.,2.,0.)
        call hbook1(235,'M?X!'     ,100,0.,80.,0.)
        call hbook1(236,'M?Y!'     ,100,0.,5.,0.)

c       cross section histograms for mc

        call hbookb(1010,'q2  (MC)'               ,nbi01,bin01,0.)
        call hbookb(1020,'pt  (MC)'               ,nbi02,bin02,0.)
        call hbookb(1030,'eta-lab (MC)'           ,nbi03,bin03,0.)
        call hbookb(1040,'mx  (MC)'               ,nbi04,bin04,0.)
        call hbookb(1050,'W (MC)'                 ,nbi05,bin05,0.)
        call hbookb(1060,'log(xpom) (MC)'         ,nbi06,bin06,0.)
        call hbookb(1070,'log beta (MC)'          ,nbi07,bin07,0.)
        call hbookb(1080,'z (MC)'                 ,nbi08,bin08,0.)
        call hbookb(1090,'x-gamma (MC)'           ,nbi09,bin09,0.)
        call hbookb(1100,'e gamma-hem. (MC)'      ,nbi10,bin10,0.)
        call hbookb(1110,'z1 (MC)'                ,nbi11,bin11,0.)
        call hbookb(1120,'z2 (MC)'                ,nbi12,bin12,0.)
        call hbookb(1130,'z3 (MC)'                ,nbi13,bin13,0.)
        call hbookb(1140,'z4 (MC)'                ,nbi14,bin14,0.)
        call hbookb(1150,'z-q2pt2-1 (MC)'         ,nbi15,bin15,0.)
        call hbookb(1160,'z-q2pt2-2 (MC)'         ,nbi16,bin16,0.)
        call hbookb(1170,'z-q2pt2-3 (MC)'         ,nbi17,bin17,0.)
        call hbookb(1180,'z-q2pt2-4 (MC)'         ,nbi18,bin18,0.)
        call hbookb(1190,'q2 (xpom.lt.0.01) (MC)' ,nbi19,bin19,0.)
        call hbookb(1200,'pt (xpom.lt.0.01) (MC)' ,nbi20,bin20,0.)
        call hbookb(1210,'z (xpom.lt.0.01) (MC)'  ,nbi21,bin21,0.)
        call hbookb(1220,'pt pom.-hem. xplow (MC)',nbi22,bin22,0.)
        call hbookb(1230,'m3 (MC)'                ,nbi23,bin23,0.)
        call hbookb(1240,'z3 (MC)'                ,nbi24,bin24,0.)

c       cross section histograms for data

        call hbookb(1011,'Q2 (Data, sta)'  ,nbi01,bin01,0.)
        call hbookb(1012,'Q2 (Data, tot)'  ,nbi01,bin01,0.)
        call hbookb(1021,'pt (Data, sta)'  ,nbi02,bin02,0.)
        call hbookb(1022,'pt (Data, tot)'  ,nbi02,bin02,0.)
        call hbookb(1031,'eta (Data, sta)' ,nbi03,bin03,0.)
        call hbookb(1032,'eta (Data, tot)' ,nbi03,bin03,0.)
        call hbookb(1041,'mx (Data, sta)'  ,nbi04,bin04,0.)
        call hbookb(1042,'mx (Data, tot)'  ,nbi04,bin04,0.)
        call hbookb(1051,'W (Data, sta)'   ,nbi05,bin05,0.)
        call hbookb(1052,'W (Data, tot)'   ,nbi05,bin05,0.)
        call hbookb(1061,'xpom (Data, sta)',nbi06,bin06,0.)
        call hbookb(1062,'xpom (Data, tot)',nbi06,bin06,0.)
        call hbookb(1071,'beta (Data, sta)',nbi07,bin07,0.)
        call hbookb(1072,'beta (Data, tot)',nbi07,bin07,0.)
        call hbookb(1081,'z (Data, sta)'   ,nbi08,bin08,0.)
        call hbookb(1082,'z (Data, tot)'   ,nbi08,bin08,0.)
        call hbookb(1091,'xgam (Data, sta)',nbi09,bin09,0.)
        call hbookb(1092,'xgam (Data, tot)',nbi09,bin09,0.)
        call hbookb(1101,'egam (Data, sta)',nbi10,bin10,0.)
        call hbookb(1102,'egam (Data, tot)',nbi10,bin10,0.)
        call hbookb(1111,'z1 (Data, sta)'  ,nbi11,bin11,0.)
        call hbookb(1112,'z1 (Data, tot)'  ,nbi11,bin11,0.)
        call hbookb(1121,'z2 (Data, sta)'  ,nbi12,bin12,0.)
        call hbookb(1122,'z2 (Data, tot)'  ,nbi12,bin12,0.)
        call hbookb(1131,'z3 (Data, sta)'  ,nbi13,bin13,0.)
        call hbookb(1132,'z3 (Data, tot)'  ,nbi13,bin13,0.)
        call hbookb(1141,'z4 (Data, sta)'  ,nbi14,bin14,0.)
        call hbookb(1142,'z4 (Data, tot)'  ,nbi14,bin14,0.)
        call hbookb(1151,'z11 (Data, sta)' ,nbi15,bin15,0.)
        call hbookb(1152,'z11 (Data, tot)' ,nbi15,bin15,0.)
        call hbookb(1161,'z12 (Data, sta)' ,nbi16,bin16,0.)
        call hbookb(1162,'z12 (Data, tot)' ,nbi16,bin16,0.)
        call hbookb(1171,'z13 (Data, sta)' ,nbi17,bin17,0.)
        call hbookb(1172,'z13 (Data, tot)' ,nbi17,bin17,0.)
        call hbookb(1181,'z14 (Data, sta)' ,nbi18,bin18,0.)
        call hbookb(1182,'z14 (Data, tot)' ,nbi18,bin18,0.)
        call hbookb(1191,'q2 (xp.lt.0.01) (Data, sta)'  ,nbi19,bin19,0.)
        call hbookb(1192,'q2 (xp.lt.0.01) (Data, tot)'  ,nbi19,bin19,0.)
        call hbookb(1201,'pt (xp.lt.0.01) (Data, sta)'  ,nbi20,bin20,0.)
        call hbookb(1202,'pt (xp.lt.0.01) (Data, tot)'  ,nbi20,bin20,0.)
        call hbookb(1211,'z  (xp.lt.0.01)(Data, sta)'   ,nbi21,bin21,0.)
        call hbookb(1212,'z (xp.lt.0.01) (Data, tot)'   ,nbi21,bin21,0.)
        call hbookb(1221,'ptpr (xp.lt.0.01) (Data, sta)',nbi22,bin22,0.)
        call hbookb(1222,'ptpr (xp.lt.0.01)(Data, tot)' ,nbi22,bin22,0.)
        call hbookb(1231,'m-123 (3 jets) (Data, sta)'   ,nbi23,bin23,0.)
        call hbookb(1232,'m-123 (3 jets) (Data, tot)'   ,nbi23,bin23,0.)
        call hbookb(1241,'z-123 (3 jets) (Data, sta)'   ,nbi24,bin24,0.)
        call hbookb(1242,'z-123 (3 jets) (Data, tot)'   ,nbi24,bin24,0.)

*       pack data into histograms

        Call hpak (1011,dat01)
        Call hpake(1011,sta01)
        Call hpak (1012,dat01)
        Call hpake(1012,tot01)

        Call hpak (1021,dat02)
        Call hpake(1021,sta02)
        Call hpak (1022,dat02)
        Call hpake(1022,tot02)

        Call hpak (1031,dat03)
        Call hpake(1031,sta03)
        Call hpak (1032,dat03)
        Call hpake(1032,tot03)

        Call hpak (1041,dat04)
        Call hpake(1041,sta04)
        Call hpak (1042,dat04)
        Call hpake(1042,tot04)

        Call hpak (1051,dat05)
        Call hpake(1051,sta05)
        Call hpak (1052,dat05)
        Call hpake(1052,tot05)

        Call hpak (1061,dat06)
        Call hpake(1061,sta06)
        Call hpak (1062,dat06)
        Call hpake(1062,tot06)

        Call hpak (1071,dat07)
        Call hpake(1071,sta07)
        Call hpak (1072,dat07)
        Call hpake(1072,tot07)

        Call hpak (1081,dat08)
        Call hpake(1081,sta08)
        Call hpak (1082,dat08)
        Call hpake(1082,tot08)

        Call hpak (1091,dat09)
        Call hpake(1091,sta09)
        Call hpak (1092,dat09)
        Call hpake(1092,tot09)

        Call hpak (1101,dat10)
        Call hpake(1101,sta10)
        Call hpak (1102,dat10)
        Call hpake(1102,tot10)

        Call hpak (1111,dat11)
        Call hpake(1111,sta11)
        Call hpak (1112,dat11)
        Call hpake(1112,tot11)

        Call hpak (1121,dat12)
        Call hpake(1121,sta12)
        Call hpak (1122,dat12)
        Call hpake(1122,tot12)

        Call hpak (1131,dat13)
        Call hpake(1131,sta13)
        Call hpak (1132,dat13)
        Call hpake(1132,tot13)

        Call hpak (1141,dat14)
        Call hpake(1141,sta14)
        Call hpak (1142,dat14)
        Call hpake(1142,tot14)

        Call hpak (1151,dat15)
        Call hpake(1151,sta15)
        Call hpak (1152,dat15)
        Call hpake(1152,tot15)

        Call hpak (1161,dat16)
        Call hpake(1161,sta16)
        Call hpak (1162,dat16)
        Call hpake(1162,tot16)

        Call hpak (1171,dat17)
        Call hpake(1171,sta17)
        Call hpak (1172,dat17)
        Call hpake(1172,tot17)

        Call hpak (1181,dat18)
        Call hpake(1181,sta18)
        Call hpak (1182,dat18)
        Call hpake(1182,tot18)

        Call hpak (1191,dat19)
        Call hpake(1191,sta19)
        Call hpak (1192,dat19)
        Call hpake(1192,tot19)

        Call hpak (1201,dat20)
        Call hpake(1201,sta20)
        Call hpak (1202,dat20)
        Call hpake(1202,tot20)

        Call hpak (1211,dat21)
        Call hpake(1211,sta21)
        Call hpak (1212,dat21)
        Call hpake(1212,tot21)

        Call hpak (1221,dat22)
        Call hpake(1221,sta22)
        Call hpak (1222,dat22)
        Call hpake(1222,tot22)

        Call hpak (1231,dat23)
        Call hpake(1231,sta23)
        Call hpak (1232,dat23)
        Call hpake(1232,tot23)

        Call hpak (1241,dat24)
        Call hpake(1241,sta24)
        Call hpak (1242,dat24)
        Call hpake(1242,tot24)

*******************************************************************************
*
*     Event Processing
*
*******************************************************************************

      Else if (iflag.eq.2) then

*       Filling: The following MUST always be done
*       (i) move to the correct sub-directory in PAWC

        call hcdir('//PAWC/'//xxxx,' ')

c       count event (weighted)

        xw=wtx
        nall=nall+xw

*       get beams, boson and sc.electron vectors

        ierr=HZIBEAM(ibeam,ielec)
        if (.not.(ierr.eq.1)) then
          write(6,*) 'HZ'//xxxx,' beams not found ! '
          return
        else
          Do i=1,4
            pbeam(i)=PHEP(i,ibeam)
            pelec(i)=PHEP(i,ielec)
          enddo
        endif

        if (abs(abs(real(PHEP(4,ielec)))-27.5).gt.0.2) then
          write(6,*) 'HZ'//xxxx,' Electrons not at 27.5 GeV!'
          return
        endif
        if (abs(abs(real(PHEP(4,ibeam)))-820.0).gt.0.2) then
          write(6,*) 'HZ'//xxxx,' Protons not at 820.0 GeV!'
          return
        endif

        ierr=HZIPGAM(ph)
        if (ierr.eq.-1) then
          write(6,*) 'HZ'//xxxx,' Boson vector not found!'
C        call VZERO(ph,5)
         Do i=1,5
          ph(i)=0.
         enddo
        else
          Do i=1,4
            pgam(i)=ph(i)
          enddo
        endif

        iel=HZIDELEC(idum)
        if (iel.eq.-1) then
           write(*,*) 'Hz'//xxxx,' Sc.electron not found!'
           return
        endif
        Do i=1,4
           pscat(i)=PHEP(i,iel)
        enddo

*       get DIS kinematics

        q2 = abs(real(HZDISKIN(1)))
        x  = real(HZDISKIN(2))
        yy = real(HZDISKIN(3))

        if (lp) write(*,*) 'Hz'//xxxx,' x y q2=',x,yy,q2

*       get diffractive kinematics

        call hzhadgap(xmas,ymas,x_pom,t)

        if (.not.(( x_pom.le.1.).and.(x_pom.ge.x))) then
          write (6,*)'Hz'//xxxx,' xpom out of range: xpom,x: ;',x_pom,x
          return
        endif

        if (lp) then
          write(6,*) 'Hz'//xxxx,' xpom= ',x_pom,' m_y= ',ymas,' t=',t
        endif

*       fill histos for inclusive events

        call hfill(211,yy,0.,xw)
        call hfill(212,q2,0.,xw)
        call hfill(213,log10(max(0.,x_pom)),0.,xw)
        call hfill(214,abs(t),0.,xw)
        call hfill(215,xmas,0.,xw)
        call hfill(216,ymas,0.,xw)

*       select diffractive DIS events

        disjet=.true.
        difjet=.true.

        if (yy.lt.0.1) disjet=.false.
        if (yy.gt.0.7) disjet=.false.
        if (q2.lt.4.)  disjet=.false.
        if (q2.gt.80.) disjet=.false.

        if (x_pom.gt.0.05) difjet=.false.
        if (ymas.gt.1.6)   difjet=.false.
        if (abs(t).gt.1.0) difjet=.false.

        if (disjet) then

          nall2=nall2+xw

*         fill histos for inclusive DIS events

          call hfill(221,yy,0.,xw)
          call hfill(222,q2,0.,xw)
          call hfill(223,log10(max(0.,x_pom)),0.,xw)
          call hfill(224,abs(t),0.,xw)
          call hfill(225,xmas,0.,xw)
          call hfill(226,ymas,0.,xw)

          if (difjet) then

            nall3=nall3+xw

*           fill histos for diffractive DIS events

            call hfill(231,yy,0.,xw)
            call hfill(232,q2,0.,xw)
            call hfill(233,log10(max(0.,x_pom)),0.,xw)
            call hfill(234,abs(t),0.,xw)
            call hfill(235,xmas,0.,xw)
            call hfill(236,ymas,0.,xw)

*           loop and boost

            etot=0.
            pztot=0.

            do ihep=1,nhep
              Do i=1,4
                Ph(i)=PHEP(i,ihep)
                Plab(i,ihep)=PHEP(i,ihep)
                phep(i,ihep)=0.0
              enddo
*             do not count decayed partices
              IF(isthep(ihep).ne.1) GOTO 20
*             do not count scattered electron
              if(ihep.eq.iel) goto 20
*             do not count particles assigned to Y system
              do iy=1,nygag
                if(ihep.eq.nyobj(iy)) goto 20
              enddo

              CALL HZHCMTOL(0,PELEC,PBEAM,PSCAT,ph,pcm,ierr)

              if (ierr.eq.1) then
                write(6,*) 'HZ'//xxxx,' problem with boost to cms ! '
                return
              endif

c             store boosted vectors in PHEP
              Do i=1,4
                PHEP(i,ihep)=Pcm(i)
              enddo

c             sum up e-pz
              etot=etot+real(pcm(4))
              pztot=pztot+real(pcm(3))

   20         continue
            enddo

*           get total E-Pz
            empztot=etot-pztot

*           run jet algorithm (8 = pxcone, pt mode)
            call hzjtfind(8,1.0d0,nj,pj)

            if (nj.gt.numjet) then
               write(6,*) 'Hz'//xxxx,' too many jets found!'
               return
            endif
            if (lp) write(6,*) 'number of jets: ',nj

*           select dijet events
            nsel2 = 0
            do ij=1,nj
               ptj2=real(pj(ij,3))
               if (ptj2.gt. 4.0 ) then
*                      pt > 4.0 GeV
                  nsel2 = nsel2 + 1
                  ipjet2(nsel2)=ij
               endif
            enddo

c           diffr. dijets

            if (nsel2.ge.2) then

             eta1=real(pj(ipjet2(1),1))
             eta2=real(pj(ipjet2(2),1))

             if ((eta1.gt.-3.0.and.eta1.lt.0.0).and.
     &           (eta2.gt.-3.0.and.eta2.lt.0.0)) then

              n2=n2+xw

              pj1=real(pj(ipjet2(1),3))
              pj2=real(pj(ipjet2(2),3))
              pt_had=0.5*(pj1+pj2)
              do i=1,4
                p_sh(i)=real(pj(ipjet2(1),3+i)+pj(ipjet2(2),3+i))
              enddo
              shat=p_sh(1)**2 - p_sh(2)**2 - p_sh(3)**2 - p_sh(4)**2
              mx2=xmas**2
              xgluon=max(0.0001,min(0.9999,(q2 + shat)/(q2 + mx2)))
              q2pt2=q2+pt_had**2
              ww=sqrt(max(0.000001,yy*90180.-q2))
              beta=q2/(q2+mx2)
              empz1=real(pj(ipjet2(1),4)-pj(ipjet2(1),4+3))
              empz2=real(pj(ipjet2(2),4)-pj(ipjet2(2),4+3))
              xgam=(empz1+empz2)/empztot

c             boost jets back to lab

              do i=1,3
                hjet1(i)=pj(ipjet2(1),4+i)
                hjet2(i)=pj(ipjet2(2),4+i)
              enddo
              hjet1(4)=pj(ipjet2(1),4)
              hjet2(4)=pj(ipjet2(2),4)
              CALL HZHCMTOL(1,PELEC,PBEAM,PSCAT,hjet1,ljet1,ierr1)
              CALL HZHCMTOL(1,PELEC,PBEAM,PSCAT,hjet2,ljet2,ierr2)

              if (ierr1.eq.1 .or. ierr2.eq.1) then
                write(6,*) 'HZ'//xxxx,' problem with boost to lab!'
              endif

c             calc. eta-lab

              th1=real(HZPHMANG(ljet1(3),
     &                 sqrt(ljet1(1)**2+ljet1(2)**2)))
              th2=real(HZPHMANG(ljet2(3),
     &                 sqrt(ljet2(1)**2+ljet2(2)**2)))
              rap1=-log(tan(th1/2.))
              rap2=-log(tan(th2/2.))
              eta_lab = 0.5*(rap1+rap2)

              if (lp) then
                write(6,*) ' '
                write(6,*) 'pt1*,pt2*: ',pj1,pj2
                write(6,*) 'eta1*,eta2*:',
     &                     real(pj(ipjet2(1),1)),real(pj(ipjet2(2),1))
                write(6,*) 'phi1*,phi2*:',
     &                     real(pj(ipjet2(1),2)),real(pj(ipjet2(2),2))
                write(6,*) 'mean pt: ',pt_had
                write(6,*) 'shat,q2,mx2,z: ',shat,q2,mx2,xgluon
                write(6,*) 'etalab1,etalab2,etalab: ',rap1,rap2,eta_lab
              endif

*             fill cross sections

              call hfill(1010,q2,0.,xw)
              call hfill(1020,pt_had,0.,xw)
              call hfill(1030,eta_lab,0.,xw)
              call hfill(1040,xmas,0.,xw)
              call hfill(1050,ww,0.,xw)
              call hfill(1060,log10(x_pom),0.,xw)
              call hfill(1070,log10(beta),0.,xw)
              call hfill(1080,xgluon,0.,xw)
              call hfill(1090,xgam,0.,xw)

c             z in xpom bins

              if ((log10(x_pom).lt.zxpsplit(1)).and.
     &            (log10(x_pom).ge.zxpsplit(2))) then
                call hfill(1110,xgluon,0.,xw)
              else if ((log10(x_pom).lt.zxpsplit(2)).and.
     &            (log10(x_pom).ge.zxpsplit(3))) then
                call hfill(1120,xgluon,0.,xw)
              else if ((log10(x_pom).lt.zxpsplit(3)).and.
     &            (log10(x_pom).ge.zxpsplit(4))) then
                call hfill(1130,xgluon,0.,xw)
              else if ((log10(x_pom).lt.zxpsplit(4)).and.
     &            (log10(x_pom).ge.zxpsplit(5))) then
                call hfill(1140,xgluon,0.,xw)
              else
                continue
              endif

c             z in q2pt2 bins

              if (q2pt2.lt.zqpsplit(1)) then
                call hfill(1150,xgluon,0.,xw)
              else if ((q2pt2.ge.zqpsplit(1)).and.
     &            (q2pt2.lt.zqpsplit(2))) then
                call hfill(1160,xgluon,0.,xw)
              else if ((q2pt2.ge.zqpsplit(2)).and.
     &            (q2pt2.lt.zqpsplit(3))) then
                call hfill(1170,xgluon,0.,xw)
              else if (q2pt2.ge.zqpsplit(3)) then
                call hfill(1180,xgluon,0.,xw)
              else
                continue
              endif

c             xpom .lt.0.01

              if (x_pom.lt.0.01) then
                call hfill(1190,q2,0.,xw)
                call hfill(1200,pt_had,0.,xw)
                call hfill(1210,xgluon,0.,xw)
              endif

c             three-jets

              if (nsel2.eq.3) then

               eta3=real(pj(ipjet2(3),1))

               if (eta3.gt.-3.0.and.eta3.lt.0.0) then

                n3=n3+xw

                pj3=real(pj(ipjet2(3),3))
                do i=1,4
                  p_sh(i)=real(pj(ipjet2(1),3+i)+pj(ipjet2(2),3+i)
     &                      +pj(ipjet2(3),3+i))
                enddo
                shat3=p_sh(1)**2 - p_sh(2)**2 - p_sh(3)**2 - p_sh(4)**2
                m3=sqrt(max(0.,shat3))
                z3=max(0.0001,min(0.9999,(q2 + shat3)/(q2 + mx2)))

                call hfill(1230,m3,0.,xw)
                call hfill(1240,z3,0.,xw)

               endif
              endif

c             end 3-jets ------------------------------------------------------
c             now the remnant stuff -------------------------------------------

c             xpom*p vector
              do i=1,4
                 pbeam2(i)=pbeam(i)*dble(x_pom)
                 pgamma(i)=0.d0
                 ppom(i)=0.d0
              enddo

              do ihep=1,nhep
                if ((ijetno(ihep).ne.1).and.(ijetno(ihep).ne.2)) then
                  Do i=1,4
                    Pcm(i)=PHEP(i,ihep)
                  enddo
c                 boost back to lab
                  CALL HZHCMTOL(1,PELEC,PBEAM,PSCAT,pcm,plab,ierr1)
c                 boost from lab to gamma-pom CMS
                  CALL HZHCMTOL(0,PELEC,PBEAM2,PSCAT,plab,pcm,ierr2)

                  if (ierr1.ne.0.or.ierr2.ne.0) then
                     print *,'HZ00174: Boost error!'
                  endif

c                 gamma-hemisphere
                  if (pcm(3).lt.0.d0) then
                    do i=1,4
                      pgamma(i)=pgamma(i)+pcm(i)
                    enddo
c                 pomeron-hemisphere
                  else
                    do i=1,4
                      ppom(i)=ppom(i)+pcm(i)
                    enddo
                  endif
                endif
              enddo

              egamma=real(pgamma(4))
              ptpomeron=real(sqrt(ppom(1)**2+ppom(2)**2))

              call hfill(1100,egamma,0.,xw)
              if(x_pom.lt.0.01) then
                call hfill(1220,ptpomeron,0.,xw)
              endif

c             end of remnant stuff

             endif
            endif

*           end diffr. dijets

*           restore hep common

            do ihep=1,nhep
              Do i=1,4
                PHEP(i,ihep)= Plab(i,ihep)
              enddo
            enddo

*           end incl. diffr. and dis inclusive

          endif
        endif

*******************************************************************************
*
*     Termination
*
*******************************************************************************

      Else if (iflag.eq.3) then

*       Termination: The following MUST always be done
*       (i) Move to the correct PAW subdirectory

        call hcdir('//PAWC/'//xxxx,' ')

c       calc lumi

        lum=999999999.
        if (xsec.ne.0.) then
          lum=real(nall)/real(xsec)
        else
          write(6,*) 'hz',xxxx,' xsec=0 ! '
        endif

        write(6,*) ' '
        write(6,*) '--------------------------------------------------'
        write(6,*) 'Hz'//xxxx,': Total Cross Section (pb): ',real(xsec)
        write(6,*) 'Hz'//xxxx,': Generated events:         ',nall
        write(6,*) 'Hz'//xxxx,': Lumi (1/pb):              ',real(lum)
        write(6,*) 'Hz'//xxxx,': Inclusive DIS events:     ',nall2
        write(6,*) 'Hz'//xxxx,': Diffr. DIS events:        ',nall3
        write(6,*) 'Hz'//xxxx,': Diffr. DIS Dijet events:  ',n2
        write(6,*) 'Hz'//xxxx,': Diffr. DIS 3-jet events:  ',n3
        write(6,*) '--------------------------------------------------'
        write(6,*) ' '

        if(n2.gt.1.) then

c         divide by lumi and binwidth

          do hid=1010,1240,10
            call hopera (hid,'+E',hid,hid,1./lum,0.)
            call hzhinrm(hid, 0, 1., 1 )
          enddo

        endif

*******************************************************************************

      endif

 999  RETURN
      END
*CMZ :  0.00/01 05/01/96  14.08.20  by  HZtool
*-- Author :
      FUNCTION HZPHMANG(X,Y)
C#*****************************************************************
C#  HZPHMANG : Returns an angle between -pi and +pi
C#  PURPOSE : Returns an angle between -pi and +pi
C#                                                               *
C# Returns an angle between -pi and +pi                          *
C#                                                               *
C# Theta: getang(z,sqrt(x**2+y**2))   0. < theta < pi            *
C# Phi  : getang(x,y)                -pi <  phi  < pi            *
C#                                                               *
C# Author: ULANGL in JETSET (modified by N Brook)                *
C#                                                               *
C#*****************************************************************
      Implicit DOUBLE PRECISION(A-H,O-Z)
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*
      data pi /3.141592654/
      HZPHMANG=0.
C...RECONSTRUCT THE ANGLE FROM X AND Y COORDINATES
      R=SQRT(X**2+Y**2)
      IF(R.LT.1E-20) RETURN
      IF(ABS(X)/R.LT.0.8) THEN
        HZPHMANG=SIGN(ACOS(X/R),Y)
      ELSE
        HZPHMANG=ASIN(Y/R)
      IF(X.LT.0..AND.HZPHMANG.GE.0.) THEN
        HZPHMANG=PI-HZPHMANG
      ELSEIF(X.LT.0.) THEN
        HZPHMANG=-PI-HZPHMANG
      ENDIF
      ENDIF
      RETURN
      END
*CMZ :  1.00/02 12/03/96  18.14.49  by  Tancredi Carli
*CMZ :  0.00/01 03/01/96  12.05.22  by  HZtool
*-- Author :
       Subroutine Hzboost(dbex,dbey,dbez,p,pnew)
C#*****************************************************************
C#
C#  HZBOOST : Performs Lorentz boosts of given 4-momentum-vector
C#
C#  PURPOSE : Performs Lorentz boosts of given 4-momentum-vector
C#
C# INPUT :
C#   BEX, BEY, BEZ  =
C#        gives the direction and size, beta, of a
C#         Lorentz boost, such that a particle initially at rest
C#       will  have p/E = beta afterwards
C#
C#    P             =  is the vector to be acted upon
C#
C#  OUTPUT :
C#   PNEW           =  is the boosted vector
C#
C# Author: LUROBO in JETSET (modified by N Brook)
C#
C#*****************************************************************
       Implicit Double Precision (A-H,O-Z)
       Dimension dp(4), p(4), pnew(4)
       do ivec = 1, 4
          pnew(ivec) = p(ivec)
       enddo
       IF(dBEX**2+dBEY**2+dBEZ**2.GT.1d-20) THEN
C...LORENTZ BOOST (TYPICALLY FROM REST TO MOMENTUM/ENERGY=BETA)
        DGA=1D0/SQRT(1D0-DBEX**2-DBEY**2-DBEZ**2)
        DBEP=DBEX*P(1)+DBEY*P(2)+DBEZ*P(3)
        DGABEP=DGA*(DGA*DBEP/(1D0+DGA)+P(4))
        PNEW(1)=P(1)+DGABEP*DBEX
        PNEW(2)=P(2)+DGABEP*DBEY
        PNEW(3)=P(3)+DGABEP*DBEZ
        PNEW(4)=DGA*(P(4)+DBEP)
      ENDIF
      RETURN
      END
*CMZ :  1.00/02 12/03/96  19.08.32  by  Tancredi Carli
*CMZU:  0.00/04 26/01/96  11.59.05  by  Tancredi Carli
*CMZ :  0.00/01 05/01/96  18.26.42  by  HZtool
*-- Author :
      Subroutine HZBRTINI(pbeam,pgam,Ierr)
C#*****************************************************************
C#      Subroutine HZBRTINI(pbeam,pgam,Ierr)
C#      Entry HZBRT(p,pnew,Ierr)
C#
C# HZBRTINI/HZBRT (entry point) : Lorentz boost to Breit frame
C# PURPOSE : Lorentz boost to Breit frame
C#
C# INPUT :
C#   PBEAM    =  the 4 vector of the proton beam
C#   PGAM     =  the 4 vector of the virtual exchanged boson
C#   P        =   the vector to be acted upon
C# OUTPUT :
C#   PNEW     =  the boosted vector
C#   IERR     =  an error flag (1 = failed)
C#
C# HZBRTINI - called once an event to set up boost and rotation
C#          variables
C# HZBRT  - perform the actual boost of particles
C#
C# Author: N Brook
C#
C#*****************************************************************
*
      Implicit Double Precision (A-H,O-Z)
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*
      Dimension pbeam(4), pgam(4)
      Dimension p(4), phcm(4), pnew(4),phcm3(3)
      Dimension Robo(3)
      Logical Lboost
      Parameter(pi=3.141592654)
*
      Ierr = 1
      gammas = pgam(4)**2 - pgam(3)**2 - pgam(2)**2 - pgam(1)**2
      if(gammas.ge.0.0) Return
      xb = -gammas/2./(pgam(4)*pbeam(4)-pgam(3)*pbeam(3))
      if(xb.gt.1.0.or.xb.lt.0.0) Return
* set up boost parameters
      do 5 ivec = 1, 3
 5    robo(ivec) = (pgam(ivec)+2.*xb*pbeam(ivec))/
     &             (pgam(4)+2.*xb*pbeam(4))
*
*     chksq = vdot(robo,robo,3)
*     If(chksq.gt.1.) Return
* ... and necessary rotation angles
      call hzboost(-robo(1),-robo(2),-robo(3),pgam,phcm)
      theta = HZPHMANG(phcm(3),sqrt(phcm(2)**2+phcm(1)**2))
      phi   = HZPHMANG(phcm(1),phcm(2))
*
      Ierr = 0
      Return
*
      Entry HZBRT(p,pnew,Ierr)
*
      Ierr = 1
* boost and rotate particle to Breit frame
      call hzboost(-robo(1),-robo(2),-robo(3),p,phcm)
      Do 6 ivec=1,3
 6    phcm3(ivec)=phcm(ivec)
      call hzphmrot(-phi,0.d0,phcm3,phcm3)
      call hzphmrot(0.d0,pi-theta,phcm3,phcm3)
      Do 7 ivec=1,3
 7    phcm(ivec)=phcm3(ivec)
      Do ivec = 1, 4
         pnew(ivec) = phcm(ivec)
      enddo
*
      Ierr = 0
      Return
      End
*CMZ :  1.01/07 15/10/97  17.46.40  by  Tancredi Carli
*CMZ :  1.01/05 22/08/96  20.58.04  by   Tancredi Carli
*CMZ :  0.00/08 14/02/96  10.17.48  by  Tancredi Carli
*-- Author :
      Subroutine HzChisq(iddat,idmc)
*********************************************************************
*                                                                   *
* HzChisq                                                           *
* =======                                                           *
* Author: N Brook                                                   *
*                                                                   *
* Input arguments:                                                  *
* Iddat - histogram ID of data                                      *
* Idmc  - Histogram ID of Monte Carlo                               *
*                                                                   *
* Output arguments:                                                 *
* none                                                              *
*                                                                   *
* Routine calculates Chi-sq between Iddat and Idmc and stores       *
* the Iddat, Chi-sq and NdoF in Ntuple 999 in each subdirectory     *
* If ID=999 doesn't exist this routine creates it                   *
*                                                                   *
* Limitations:  The number of bins and range of histograms Iddat    *
*               and idmc have to be an identical                    *
*                                                                   *
*********************************************************************
*
      Implicit None
*
      Integer Ndatpts
      Parameter(Ndatpts=1000)
      Real xdum(Ndatpts),exdum(Ndatpts),ydat(Ndatpts),eydat(Ndatpts)
      Real ymc(Ndatpts), eymc(Ndatpts)
      Real xmi,xma,ymi,yma
      Real xmj,xmb,ymj,ymb,chi
      Integer iddat, idmc, loc, nwt, ndof
      Integer nx, ny, nx1, ny1, ierr, Ichi, ndat
      Double Precision chi2
      Character*80 chtit
      Logical Hexist,lp
      Character*4 tags(3)
      Character rout*10
      Real evt(3)
      Data Tags/'id','chi2','ndof'/,rout/'hzchisq'/,lp/.false./
*
      If(.not.Hexist(999)) then
       Call Hbookn(999,' Chi sqaures',3,' ',100,Tags)
       if (lp) write(6,*) rout,' book ntuple 9999 '
      endif
*
      Call Hgive(iddat,chtit,nx,xmi,xma,ny,ymi,yma,nwt,loc)
      Call Hgive(idmc,chtit,nx1,xmj,xmb,ny1,ymj,ymb,nwt,loc)
*
      Ierr=1
      If(nx1.ne.nx.or.
     +   xmi.ne.xmj.or.
     1   xma.ne.xmb) Then
        Write(6,*) rout,' Histos:',iddat,
     +             ' and ',idmc,' are different ! '
        Return
      Endif
      Ierr = 0
*
      Call Hrebin(iddat,xdum,ydat,exdum,eydat,nx,1,nx)
      Call Hrebin(idmc,xdum,ymc,exdum,eymc,nx,1,nx)
*     Call Hunpak(idmc,ymc,' ',0)
*
      chi = 0.0
      ndat = 0
      Do Ichi = 1, Nx
        If(eydat(ichi).gt.0.0) Then
          if (eymc(ichi)**2+eydat(ichi)**2.gt.0.) then
           chi = chi + (ymc(ichi)-ydat(ichi))**2/
     1        (eymc(ichi)**2+eydat(ichi)**2)
          else
           chi=-999.
          endif
          ndat = ndat + 1
        Endif
      Enddo
      chi2 = dble(chi)
      evt(1) = real(iddat)
      evt(2) = chi
      evt(3) = real(ndat)
      if (lp) then
       write(6,*) rout,' filling 999 = ',evt
      endif
      Call hfn(999,evt)
*
      Return
      End
*CMZ :  1.01/05 20/08/96  10.38.59  by   Tancredi Carli
*CMZU:  0.00/04 26/01/96  12.00.37  by  Tancredi Carli
*CMZ :  0.00/01 05/01/96  14.11.56  by  HZtool
*-- Author :
      Function Hzdiskin(Itype)
**********************************************************
* Purpose:
* Return DIS kinem. variables
* Input:
* If Itype = 1 -> Q2
*    itype = 2 -> xbj
*    itype = 3 -> ybj
*    itype = 4 -> W2
* Author: N. Brook
**********************************************************
*
      Implicit Double Precision (A-H,O-Z)
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      Dimension pgam(5), pbeam(5)
      Integer iel,idum
*
      hzdiskin = -1.
*
      Jgam = hzipgam(pgam)
      if(jgam.ne.1) Then
       Write(6,*) 'HZDISKIN: No record of virt. photon found'
       Return
      endif
*
      kbeam = hzibeam(ip,il)
      If(kbeam.ne.1) Then
        Write(6,*) 'HZDISKIN: No record of beam particles'
        Return
      Endif
*
*
      q2 = -(pgam(4)**2-pgam(3)**2-pgam(2)**2-pgam(1)**2)
      xbj = q2/2./
     +      (phep(4,ip)*pgam(4) - phep(3,ip)*pgam(3)
     1        -phep(2,ip)*pgam(2) - phep(1,ip)*pgam(1))
      cms = (phep(4,ip)+phep(4,il))**2
     +      - ((phep(3,ip)+phep(3,il))**2
     1         +(phep(2,ip)+phep(2,il))**2
     2         +(phep(1,ip)+phep(1,il))**2)
*
C      write(6,*) ' beam= ',phep(4,ip),phep(3,ip),phep(2,ip),phep(1,ip)
C      write(6,*) ' pgam= ',pgam
C      write(6,*) ' denom= ',
C     +      (phep(4,ip)*pgam(4) - phep(3,ip)*pgam(3)
C     1        -phep(2,ip)*pgam(2) - phep(1,ip)*pgam(1))
C       write(6,*) ' 4= ',phep(4,ip)*pgam(4)
C       write(6,*) ' 3= ',phep(3,ip)*pgam(3)
C       write(6,*) ' 2= ',phep(2,ip)*pgam(2)
C       write(6,*) ' 1= ',phep(1,ip)*pgam(1)C
C
*
C      write(6,*) ' q2= ',q2,' xbj= ',xbj,' cms= ',cms
*
      If(itype.eq.1) Then
        hzdiskin = q2
      else if(itype.eq.2) then
        hzdiskin =xbj
      else if(itype.eq.3) then
        hzdiskin = q2/xbj/cms
      else if(itype.eq.4) then
        hzdiskin = q2*(1.-xbj)/xbj + phep(5,ip)**2
      else
        write(6,*) ' HZDISKIN: itype should be in range 1-4'
      endif
*
      return
      end
*CMZ :  2.00/04 31/07/2000  20.47.17  by  Tancredi Carli
*CMZ :  1.02/06 03/03/99  18.23.34  by  Tancredi Carli
*CMZ :  1.02/01 12/10/98  08.10.10  by  Hannes Jung
*CMZ :  1.01/13 19/03/98  08.49.53  by  Hannes Jung
*CMZ :  1.01/07 13/10/97  16.30.16  by  Tancredi Carli
*CMZ :  1.01/06 18/07/97  13.59.03  by  Tancredi Carli
*CMZ :  1.01/05 27/06/97  19.12.17  by  Tancredi Carli
*CMZ :  1.01/04 13/08/96  18.02.58  by   Tancredi Carli
*CMZ :  1.01/01 25/03/96  14.52.48  by  Tancredi Carli
*CMZ :  1.01/00 15/03/96  20.01.06  by  Tancredi Carli
*CMZU:  1.00/03 08/03/96  16.57.09  by  Mark Hayes
*CMZU:  0.00/05 24/01/96  15.29.41  by  Mark Hayes
*CMZ :  0.00/03 09/01/96  17.39.29  by  HZtool
*CMZ :  0.00/01 03/01/96  12.05.22  by  HZtool
*-- Author :
      Subroutine Hzfilhep
************************************************************************
* Purpose:
* Transfer data to HERACMN and HEPEVTP
* Input: none
* Output: none
* Author: N. Brook
* Modified :
* M. Hayes (for 'PHO')
* N. Pavel introduce POMPYT 8.5.96
* H. Jung (RAPGAP with PYTHIA6)
* A. Solano (interface RIDI - 15.12.98)
* G. Grindhammer (allow for HERWIG+PYTHIA/JETSET -> PYTHRW and for
*                 QCDINS+HERWIG+PYTHIA/JETSET -> PYTINS, 10.06.1999)
************************************************************************
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      Double Precision EVWGT,AVWGT,WGTMAX,WGTSUM,WSQSUM,WBIGST,GAMWT,
     &                 TLOUT
      COMMON/HWEVNT/EVWGT,AVWGT,WGTMAX,WGTSUM,WSQSUM,WBIGST,GAMWT,TLOUT,
     & NRN(2),MAXER,NUMER,NUMERU,MAXPR,LWEVT,ISTAT,IERROR,NOWGT,NWGTS,
     & IDHW(NMXHEP),GENSOF
*
      COMMON /LEPTOU/ CUT(14),LST(40),PARL(30),X,Y,W2,Q2,U
C     Common/Pyint5/Ngen(0:200,3),Xxsec(0:200,3)
      Integer NGENPD, Ngen
      double precision Xxsec
      Common/Pyint5/NGENPD,Ngen(0:500,3),Xxsec(0:500,3)

*

      COMMON/POMSIG/NEVT,SIGTOT
*
      COMMON /RESULT/ S1,S2,S3,S4
      logical lp
      Data lp/.false./
* RAPGAP COMMON for xsec
      DOUBLE PRECISION AVGI,SD
      COMMON/EFFIC/AVGI,SD,NING,NOUTG
* RIDI commons
      logical duejet,trejet,fragm,wei,two,longit,transv,user
      logical lightf,thlim,charm,strange,checkout,onlych
      COMMON/LOGICA/duejet,trejet,fragm,wei,two,longit,transv,user,
     +              lightf,thlim,charm,strange,checkout,onlych
      Integer nevent2,itoteve2,itwoev2,iwei2,nmass
      Real fk_2,weimax2,
     +            sig2t,sig2l,weit2,weil2,twint2,twinte2,
     +            cs2,cst2,csl2,tcs2,tcse2,
     +            tcst2,tcste2,tcsl2,tcsle2,
     +            tcsb2,tcsbe2,tcsi2,tcsie2,tcsa2,tcsae2,tcsf2,tcsfe2
      COMMON/WEI2/nevent2,itoteve2,itwoev2,iwei2,nmass,fk_2,weimax2,
     +            sig2t,sig2l,weit2,weil2,twint2(7),twinte2(7),
     +            cs2(2),cst2(2),csl2(2),tcs2(2),tcse2(2),
     +            tcst2(2),tcste2(2),tcsl2(2),tcsle2(2),
     +            tcsb2,tcsbe2,tcsi2,tcsie2,tcsa2,tcsae2,tcsf2,tcsfe2
      Integer nevent3,ITOTEVE3,itwoev3,IWEI3,nskip
      Real fk_3,weimax3,
     +            weit3,weil3,TWINT3,TWINTE3,
     +            cs3,cst3,csl3,tcs3,tcse3,
     +            tcst3,tcste3,tcsl3,tcsle3,
     +            tcsb3,tcsbe3,tcsi3,tcsie3,tcsa3,tcsae3,tcsf3,tcsfe3
      COMMON/WEI3/nevent3,ITOTEVE3,itwoev3,IWEI3,nskip,fk_3,weimax3,
     +            weit3,weil3,TWINT3(7),TWINTE3(7),
     +            cs3(2),cst3(2),csl3(2),tcs3(2),tcse3(2),
     +            tcst3(2),tcste3(2),tcsl3(2),tcsle3(2),
     +            tcsb3,tcsbe3,tcsi3,tcsie3,tcsa3,tcsae3,tcsf3,tcsfe3
      logical radcor,radcor_i,radcor_f,radcor_a
      common/radlog/radcor,radcor_i,radcor_f,radcor_a
*
* include LUJETS common
      COMMON/LUJETS/N,K(4000,5),P(4000,5),V(4000,5)
* include pythia6 pyjets common
      double precision PP,VP
      COMMON/PYJETS/NP,NPAD,KP(4000,5),PP(4000,5),VP(4000,5)
      Data Ncnt /0/
*
      Ncnt = Ncnt + 1
      Ntot = Ncnt
*
      if (lp) then
       write(6,*) ' ncnt= ',ncnt,' gen= ',gen
      endif
*
      if(gen(1:3).eq.'PYT'.or.gen(1:3).eq.'LEP'.or.gen(1:3).eq.'ARI'
     & .or.gen(1:3).eq.'LEG'.or.gen(1:3).eq.'RAP'.or.gen(1:3).eq.'RID'
     & ) Then
c
        if(gen(1:3).eq.'RID') then
          if(radcor) then
c
c   Born cross section: run without radiative corrections
c
	    write(6,*) ' Please run RIDI without QED rad. correction '
            write(6,*) ' Program stopped '
	    STOP
          elseif(wei) then
c
c   Run without weights to avoid errors in using them
c
            write(6,*) ' Please run RIDI without weights '
            write(6,*) ' Program stopped '
            STOP
          endif
c
c   Get virtual photon four-vector
c
	  DO J = 1,4
            P(N+1,J) = P(1,J)-P(3,J)
	  ENDDO
          P(N+1,5) =
     &      P(N+1,4)**2-P(N+1,1)**2-P(N+1,2)**2-P(N+1,3)**2
	  P(N+1,5) = -SQRT(ABS(P(N+1,5)))
	  K(N+1,1) = 21
	  K(N+1,2) = 22
	  K(N+1,3) = 1
	  N = N+1
        endif
c
c       write(6,*) ' check on LUJETS or PYJETS common '
        IF(N.GT.0) THEN
c         write(6,*) '  LUJETS common found '
          Call HzLuhepc(1)
          Call HzLuncop
	ELSEIF(NP.GT.0) THEN
c         write(6,*) '  PYJETS common found'
	  Call Hzpyhepc(1)
	ELSE
	  write(6,*) ' cannot determine LUJETS or PYJETS common '
	ENDIF
        If(gen(1:3).eq.'PYT' .and.
     &     gen(1:6).ne.'PYTHRW' .and. gen(1:6).ne.'PYTINS') Then
C         xsec = dble(Xxsec(0,3))
          xsec = Xxsec(0,3)*1d9
        Else if (gen(1:6).eq.'PYTHRW') Then
          xsec = avwgt
          call HZPYTCOP
        Else if (gen(1:6).eq.'PYTINS') Then
          xsec = avwgt
          call HZPYTCOP
        Else if (gen(1:3).eq.'LEG') Then
          xsec = dble(s1)
        Elseif(gen(1:3).eq.'RAP') Then
          xsec = AVGI*1000.
        else
          xsec = dble(parl(24))
        Endif
        if (lp) write(6,*) ' xsec= ',xsec
*
      ELSE IF((GEN(1:3).EQ.'DJA')) THEN
         CALL HZDJHEPC(1)
         if (lp) write(6,*) ' ...calling hzluncop '
         CALL HZLUNCOP
         XSEC = DBLE(PARL(24))
        if (lp) write(6,*) ' xsec= ',xsec
*
      else if(gen(1:3).eq.'HRW') Then
        Call Hzhrwcop
        xsec = avwgt
      else if(gen(1:3).eq.'PHO') Then
        Call Hzphocop
C please note the cross section is not filled here. This is left to the
C user, due to the design of PHOJET.
* --> NPA 8.5.96
      else if(gen(1:3).eq.'POM') Then
        call hzgamad
c        write(6,*) ' check on LUJETS or PYJETS common '
        IF(N.GT.0) THEN
c        write(6,*) '  LUJETS common found '
        Call HzLuhepc(1)
        Call HzLuncop
	  ELSEIF(NP.GT.0) THEN
c        write(6,*) '  PYJETS common found'
	  Call Hzpyhepc(1)
	  ELSE
	  write(6,*) ' cannot determine LUJETS or PYJETS common '
	  ENDIF
c from mb --> pb	
        xsec = sigtot*1.e9
        call hzdifkin
* --> end NPA 8.5.96
      else if(gen(1:3).eq.'INS') Then
        Call Hzhrwcop
        xsec = avwgt
      Else
         Write(6,*) ' HZFILHEP: UNKNOWN GENERATOR'
      Endif
*
      wtx=1.
*
      Return
      End
*CMZ :  1.01/15 15/05/98  22.31.33  by  Tancredi Carli
*CMZ :  1.00/03 14/03/96  10.18.09  by  Tancredi Carli
*CMZ :  1.00/02 12/03/96  19.17.13  by  Tancredi Carli
*CMZU:  0.00/04 26/01/96  11.57.51  by  Tancredi Carli
*CMZ :  0.00/01 05/01/96  18.26.05  by  HZtool
*-- Author :
      Subroutine HZHCMINI(pbeam,pgam,Ierr)
C#*****************************************************************
C#      Subroutine HZHCMINI(pbeam,pgam,Ierr)
C#      Entry HZHCM(p,pnew,Ierr)
C#
C# HZHCMINI/HZHCM (entry point) : Lorentz boost to hadronic centre of mass
C# PURPOSE : Lorentz boost to hadronic centre of mass
C#
C# INPUT :
C#   PBEAM    =  the 4 vector of the proton beam
C#   PGAM     =  the 4 vector of the virtual exchanged boson
C#   P        =   the vector to be acted upon
C# OUTPUT :
C#   PNEW     =  the boosted vector
C#   IERR     =  an error flag (1 = failed)
C#
C# HZHCMINI - called once an event to set up boost and rotation
C#          variables
C# HZHCM  - perform the actual boost of particles
C#
C# Author: N Brook
C# Modified: introduce SAVE T. Carli May 1998
C#*****************************************************************
*
      Implicit Double Precision (A-H,O-Z)
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*
      Dimension pbeam(4), pgam(4)
      Dimension p(4), phcm(4), pnew(4),phcm3(3)
      Dimension Robo(3)
      Logical Lboost
      Save
*
      Ierr = 1
* set up boost parameters
      do 5 ivec = 1, 3
 5    robo(ivec) = (pbeam(ivec)+pgam(ivec))/(pbeam(4)+pgam(4))
*
      chksq = robo(1)**2+robo(2)**2+robo(3)**2
      If(chksq.gt.1.) Return
* ... and necessary rotation angles
      call hzboost(-robo(1),-robo(2),-robo(3),pgam,phcm)
      phi = HZPHMANG(phcm(1),phcm(2))
      Do 6 ivec=1,3
 6    phcm3(ivec)=phcm(ivec)
      call hzphmrot(-phi,0.d0,phcm3,phcm3)
      Do 7 ivec=1,3
 7    phcm(ivec)=phcm3(ivec)
      theta = HZPHMANG(phcm(3),sqrt(phcm(2)**2+phcm(1)**2))
*
      Ierr = 0
      Return
*
      Entry HZHCM(p,pnew,Ierr)
*
      Ierr = 1
* boost and rotate particle to HZHCM
      call hzboost(-robo(1),-robo(2),-robo(3),p,phcm)
      Do 8 ivec=1,3
 8    phcm3(ivec)=phcm(ivec)
      call hzphmrot(-phi,  0.d0,phcm3,phcm3)
      call hzphmrot(0.d0,-theta,phcm3,phcm3)
      Do ivec = 1, 3
       pnew(ivec)=phcm3(ivec)
      enddo
      pnew(4) = phcm(4)
*
      Ierr = 0
      Return
      End
*CMZ :  1.01/07 08/10/97  17.29.04  by  Tancredi Carli
*CMZ :  0.00/10 16/02/96  18.04.15  by  Tancredi Carli
*CMZ :  0.00/08 15/02/96  11.25.51  by  Tancredi Carli
*-- Author :    Tancredi Carli   12/02/96
            subroutine hzhinrm( iid, iidnew, nevt, iifl )
****************************************************************************
* Purpose:
* Normalize a given 1-dim histogram with factors 1/nevt and 1/binwidth
* works also for non-equidistant bins
*
* Arguments:
* iid      histogram id to be normalized
* iidnew   new histo id (if 0, old histo is modified)
* nevt     normalization factor (usually # events)
* iifl     flag=1: normalize errors too, otherwise they are zeroed
*
* written by: Michel Kuhlen on 12/02/96
* Changed: T. Carli nevt is now real to allow for weighted histogram
****************************************************************************
      IMPLICIT NONE
*
      Integer   id, idnew,  ifl, iifl, iid, iidnew,nmax
      Real  nevt
      Parameter(nmax=200)               ! max # of bins
      Real      cont(nmax), err(nmax), zeroes(nmax), revt
      Integer nx,ny,ntw,iad,i,idfill
      Real xmin,xmax,ymin,ymax,xleft,xright,binw,hie,hi
      Character*80  title,rout*10
      Logical hexist
      Data zeroes / nmax*0. /,rout/'**hzhinrm '/
*
*                                       PAW gets confused with types
      id    = iid
      idnew = iidnew
      revt  = nevt
      ifl   = iifl
*
C       write(6,*) ' norm ',id,' nevt= ',nevt
*                                       check normalization
      if( revt.le.0. ) then
        write(6,*) rout,' normalization is 0! or <0 id,revt: ',id,revt
        goto 9999
      endif
*                                       check existence of histo
      if( .not.hexist(id) ) then
        write(6,*) rout,' non-existent histo id ',id
        goto 9999
      endif
*                                       get title, number of bins
*
      call hgive( id, title, nx, xmin, xmax, ny, ymin, ymax, ntw, iad )
*
      if( nx .eq. 0 ) then
        write(6,*) rout,' histo with 0 bins, id= ',id
        goto 9999
      elseif( nx .gt. nmax ) then
        write(6,*) rout,' histo with #bins>max, id= ',id,nx,nmax
        goto 9999
      endif
*                                           loop over histogram channels
*                                           careful with last bin!
      do i=1,nx
*                                           lower edge of bin
       call hix(id,i,xleft)
*                                           upper edge of bin
       xright=xmax
       if(i.lt.nx) call hix(id,i+1,xright)
*                                           bin width
       binw = xright-xleft
*                                           bin content
       cont(i) = hi(id,i)
*      write(6,*) '  bin #, xl,xr, cont ', i,xleft,xright,cont(i)
*                                           normalized contents
       cont(i) = cont(i)  /(revt*binw)
*                                           corresponding error
       err(i)  = hie(id,i)/(revt*binw)
      enddo
*
*                                           determine where to put the contents
      if(idnew.gt.0) then
       title = 'norm - '//title
       call hcopy(id,idnew,title)
       idfill = idnew
      else
       idfill = id
      endif
*                                           reset target histo
      call hreset(idfill,title)
*
*                                            pack normalized contents into histo
*
      call hpak(idfill,cont)
      if(ifl.eq.1) then
       call hpake(idfill,err)
      else
       call hpake(idfill,zeroes)
      endif
*
 9999 continue
      return
      end
*CMZ :          02/05/2002  15.18.23  by  Tancredi Carli
*CMZ :  1.02/06 25/03/99  18.11.33  by  Tancredi Carli
*CMZ :  1.01/13 23/03/98  18.30.16  by  Tancredi Carli
*CMZ :  1.01/06 18/07/97  13.54.35  by  Tancredi Carli
*CMZ :  1.01/05 27/06/97  19.14.52  by  Tancredi Carli
*CMZ :  1.01/01 25/03/96  17.03.00  by  Tancredi Carli
*CMZ :  1.00/03 15/03/96  16.21.50  by  Tancredi Carli
*CMZU:  0.00/05 26/01/96  12.18.03  by  Mark Hayes
*CMZ :  0.00/01 05/01/96  14.12.28  by  HZtool
*-- Author :
      Function Hzibeam(ip,il)
*******************************************************
* Purpose:
* Find posn of proton and lepton beam
* returns
* If find both beams Hzibeam = 1
* if find only lepton beam Hzibeam = 0
* if find only proton beam Hzibeam = -1
* Input: none
* Output: ip pointer to proton
*         il pointer to lepton
*
* Author; N. Brook
* PHOJET mods : M. Hayes
* Gen="POM" added by H. Jung
* Gen='RID' added by A. Solano
*******************************************************
      Implicit Double Precision (A-H,O-Z)
      Logical  llep,lprot,lp
      Data lp/.false./
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*
      hzibeam = -2
      llep  = .false.
      lprot = .false.
      ip=-1
      il=-1
      If(gen(1:3).eq.'PYT'.or.gen(1:3).eq.'LEP'.or.gen(1:3).eq.'ARI'
     & .or.gen(1:3).eq.'LEG' .or.gen(1:3).eq.'RAP'.or.gen(1:3).eq.'RID'
     & .or.gen(1:3).eq.'DSN'.or.gen(1:3).eq.'HVQ'
     &  )Then
       Do Ihep = 1,Nhep
C*TC
c         write(6,*) ' ihep = ',ihep,' ist= ',Isthep(ihep),
c     &   ' id= ',idhep(ihep)

         If(Isthep(ihep).eq.3
     +      .and.idhep(ihep).eq.2212) Then
           ip = ihep
           hzibeam = hzibeam + 1
         Else if(Isthep(ihep).eq.3
     +           .and.abs(idhep(ihep)).eq.11) Then
           il = ihep
           hzibeam = hzibeam + 2
         Endif
         If(hzibeam.eq.1) then
c            write(*,*) 'il:ip',il,ip
            Return
         Endif
       Enddo
CTW-120697->
      else if(gen(1:3).eq.'DJA') then
****** e+/- should be particle 1, the proton part. 2
         if (idhep(2).eq.2212) then
            ip = 2
            hzibeam = hzibeam + 1
         endif
         if (abs(idhep(1)).eq.11) then
            il = 1
            hzibeam = hzibeam + 2
         endif
         if(hzibeam.eq.1) return
CTW<-120697-
      Else If(gen(1:3).eq.'HRW' .or.gen(1:3).eq.'INS' ) Then
       Do Ihep = Nhep,1,-1
         if (lp) then
          write(6,'(A,4F9.3,a,i4,a,i4)') '**hzibeam: HRW= ',
     +    (PHEP(i,ihep),i=1,4),' ist= ',
     +    Isthep(ihep),' idhep= ',idhep(ihep)
         endif
         If((Isthep(ihep).eq.101.or.Isthep(ihep).eq.102)
     +      .and.idhep(ihep).eq.2212) Then
           ip = ihep
           hzibeam = hzibeam + 1
         else If((Isthep(ihep).eq.101.or.Isthep(ihep).eq.102)
     +      .and.abs(idhep(ihep)).eq.11) Then
           il = ihep
           hzibeam = hzibeam + 2
         Endif
         If(hzibeam.eq.1) Return
       Enddo
      Else If(gen(1:3).eq.'PHO') Then
* Trivial since the Proton should be particle 1, e+/- part. 2
	IF (idhep(1).eq.2212) Then
           ip = 1
           hzibeam = hzibeam + 1
         Endif
        If (abs(idhep(2)).eq.11) Then
           il = 2
           hzibeam = hzibeam + 2
         Endif
         If(hzibeam.eq.1) Return
      Else If(gen(1:3).eq.'POM') Then
* Trivial since the Proton should be particle 1, e+/- part. 2
	IF (idhep(1).eq.2212) Then
           ip = 1
           hzibeam = hzibeam + 1
         Endif
        If (abs(idhep(2)).eq.11) Then
           il = 2
           hzibeam = hzibeam + 2
         Endif
         If(hzibeam.eq.1) Return
      Else
       write(6,*) '**hzibeam: generator not found gen=',gen
      Endif
*
      Return
      End
*CMZ :          02/05/2002  15.25.49  by  Tancredi Carli
*CMZ :  1.02/06 25/03/99  18.10.54  by  Tancredi Carli
*CMZ :  1.01/06 18/07/97  13.55.11  by  Tancredi Carli
*CMZ :  1.01/05 27/06/97  19.16.33  by  Tancredi Carli
*CMZ :  1.01/04 13/08/96  18.06.01  by   Tancredi Carli
*CMZU:  1.00/03 01/03/96  13.36.23  by  Mark Hayes
*CMZU:  0.00/05 27/01/96  12.21.54  by  Mark Hayes
*CMZ :  0.00/01 05/01/96  14.10.16  by  HZtool
*-- Author :
      Function Hzidelec(idum)
**********************************************************
* Purpose:
* hzidelec return the position of the scatt. e-/+
*
* For LEPTO, ARIADNE and HERWIG the first stable particle is
* the scatt. lepton
* & in PYTHIA & in PHOJET (MEH'96)
* & in RIDI (AS '98)
* if no stable particle found hzidelec < 0
* Input: idum only a dummy
*
* Author: N. Brook
***********************************************************
      Implicit Double Precision (A-H,O-Z)
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*
      hzidelec = -1
      if(gen(1:3).eq.'LEP'.or.gen(1:3).eq.'ARI'.or.
     +   gen(1:3).eq.'HRW'.or.gen(1:3).eq.'PYT'.or.
     +   gen(1:3).eq.'POM'.or.gen(1:3).eq.'DJA'.or.
     +	 gen(1:3).eq.'PHO'.or.gen(1:3).eq.'RAP'.or.
     +   gen(1:3).eq.'RID'.or.gen(1:3).eq.'DSN'.or.
     +   gen(1:3).eq.'HVQ'
     + ) then
        Do Ihep = 1, Nhep
         if(Isthep(Ihep).eq.1.and.abs(idhep(ihep)).eq.11) then
           hzidelec = ihep
           Return
         Endif
        Enddo
      Elseif (gen(1:3).eq.'INS') then
        Do Ihep = 1, Nhep
         if(  Isthep(Ihep).eq.1
     +       .and.(abs(idhep(ihep)).eq.11))then
           hzidelec = ihep
           Return
         Endif
        Enddo
      Elseif (gen(1:3).eq.'LEG') then
        Do Ihep = 1, Nhep
         if(  Isthep(Ihep).eq.1
     +       .and.(abs(idhep(ihep)).eq.11))then
           hzidelec = ihep
           Return
         Endif
        Enddo
      Else
        Write(6,*) ' HZIDELEC: UNKNOWN GENERATOR'
      Endif
*
      return
      end
*CMZ :  0.00/02 14/05/97  18.59.56  by  Tancredi Carli
*CMZU:  1.00/03 10/03/96  18.28.05  by  Mark Hayes
*CMZ :  0.00/01 05/01/96  14.11.37  by  HZtool
*-- Author :
      Function Hzipgam(pgam)
*********************************************************
* Purpose:
* Hzipgam flags whether a virtual photon is found or not
* Input: none
* Output:
* If found it's 5vec (px,py,px,e,m) are passed back
* via an argument
*
* Author: N. Brook
*********************************************************
      Implicit Double Precision (A-H,O-Z)
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*
      Dimension Pgam(5)
*
      Hzipgam = -1
CRP***Correction to find the virtual boson independent of the
CRP***used generator. Due to the agreement in the Particle Pata
CRP***Group the virtual gamma has the particle ID 23

      DO 10 ILHEP = 1,NHEP

         IF(ISTHEP(ILHEP).EQ.3) THEN


            IF(IDHEP(ILHEP).EQ.23) THEN
               HZIPGAM = 1
               IVIRT = ILHEP
               goto 11
CRP               PRINT*,'IVIRT=', IVIRT
CRP               WRITE(*,*) ' LUCK ! VIRTUAL GAMMA FOUND'
            ENDIF

            IF(IDHEP(ILHEP).EQ.22) THEN
               HZIPGAM = 1
               IVIRT  = ILHEP
               goto 11
CRP               PRINT*,'IVIRT=', IVIRT
CRP               WRITE(*,*) ' LUCK ! VIRTUAL GAMMA FOUND'
            ENDIF

         ENDIF


 10   CONTINUE
 11   continue

      IF(HZIPGAM.EQ.-1) THEN
            WRITE(*,*) 'VIRTUAL GAMMA NOT FOUND. CHECK
     &                  GENERATOR'
      ENDIF



CRP      if(gen(1:3).eq.'LEP'.or.gen(1:3).eq.'ARI') Then
CRP        ivirt = 3
CRP      else if(gen(1:3).eq.'HRW') then
CRP        ivirt = 9
CRP     to test herwig direct
CRP           ivirt = 10
CRP      else if(gen(1:3).eq.'PHO') Then
CRP        ivirt=4
CRP      else
CRP        hzipgam = -1
CRP        Write(6,*) ' HZIPGAM: UNKNOWN GENERATOR'
CRP        Return
CRP      endif
*
      pgam(1) = phep(1,ivirt)
      pgam(2) = phep(2,ivirt)
      pgam(3) = phep(3,ivirt)
      pgam(4) = phep(4,ivirt)
      pgam(5) = phep(5,ivirt)
CRP      PRINT*,'GAMMAMASS,IDHEP=', PGAM(5),IDHEP(IVIRT)


*
      Return
      End

*CMZ :  2.00/06 02/05/2002  14.54.18  by  Tancredi Carli
*CMZ :  0.00/03 08/01/96  16.56.39  by  HZtool
*CMZ :  0.00/01 05/01/96  14.14.22  by  HZtool
*-- Author :
      FUNCTION HZLCHGE(KF)
******************************************************************
*Purpose: to give three times the charge for a particle/parton.
* Input: KF particle code
*Output:
*Author: N. Brook
******************************************************************
*KEEP,HZDAT.
      Integer KCHG
      COMMON/HZDAT/KCHG(500,3)
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*
      Integer Loca(500,3)
      Logical Init,lp
      Data Init /.true./,lp/.false./
      DATA (LOCA(I,1),I=   1, 500)/-1,2,-1,2,-1,2,-1,2,2*0,-3,0,-3,0,
     &-3,0,-3,6*0,3,9*0,3,2*0,3,0,-1,44*0,2,-1,2,-1,2,3,11*0,3,0,2*3,0,
     &3,0,3,0,3,10*0,3,0,2*3,0,3,0,3,0,3,10*0,3,0,2*3,0,3,0,3,0,3,10*0,
     &3,0,2*3,0,3,0,3,0,3,10*0,3,0,2*3,0,3,0,3,0,3,10*0,3,0,2*3,0,3,0,
     &3,0,3,70*0,3,0,3,28*0,3,2*0,3,8*0,-3,8*0,3,0,-3,0,3,-3,3*0,3,6,0,
     &3,5*0,-3,0,3,-3,0,-3,4*0,-3,0,3,6,-3,0,3,-3,0,-3,0,3,6,0,3,5*0,
     &-3,0,3,-3,0,-3,114*0/
      DATA (LOCA(I,2),I=   1, 500)/8*1,12*0,2,16*0,2,1,50*0,-1,410*0/
      DATA (LOCA(I,3),I=   1, 500)/8*1,2*0,8*1,5*0,1,9*0,1,2*0,1,0,2*1,
     &41*0,1,0,7*1,10*0,10*1,10*0,10*1,10*0,10*1,10*0,10*1,10*0,10*1,
     &10*0,10*1,70*0,3*1,22*0,1,5*0,1,0,2*1,6*0,1,0,2*1,6*0,2*1,0,5*1,
     &0,6*1,4*0,6*1,4*0,16*1,4*0,6*1,114*0/
*
      If(Init) Then
        Init = .false.
C        Call Ucopy(loca,kchg,1500)
         Do i=1,500
          kchg(i,1)=loca(i,1)
          kchg(i,2)=loca(i,2)
          kchg(i,3)=loca(i,3)
         enddo
      Endif
C...Initial values. Simple case of direct readout.
      HZLCHGE=0
      KFA=IABS(KF)
      KC=HZLCOMP(KFA)
*
      if (lp) then
       write(6,*) ' kfa = ',kfa,' kc= ',kc
      endif
*
      IF(KC.EQ.0) THEN
      ELSEIF(KFA.LE.100.OR.KC.LE.80.OR.KC.GT.100) THEN
        HZLCHGE=KCHG(KC,1)

C...Construction from quark content for heavy meson, diquark, baryon.
      ELSEIF(MOD(KFA/1000,10).EQ.0) THEN
        HZLCHGE=(KCHG(MOD(KFA/100,10),1)-KCHG(MOD(KFA/10,10),1))*
     &  (-1)**MOD(KFA/100,10)
      ELSEIF(MOD(KFA/10,10).EQ.0) THEN
        HZLCHGE=KCHG(MOD(KFA/1000,10),1)+KCHG(MOD(KFA/100,10),1)
      ELSE
        HZLCHGE=KCHG(MOD(KFA/1000,10),1)+KCHG(MOD(KFA/100,10),1)+
     &  KCHG(MOD(KFA/10,10),1)
      ENDIF

C...Add on correct sign.
      HZLCHGE=HZLCHGE*ISIGN(1,KF)
      if (lp) then
       write(6,*) ' kf= ',kf,' hzlchge= ',HZLCHGE
      endif
      RETURN
      END
*CMZ :  1.02/06 03/03/99  18.02.14  by  Tancredi Carli
*CMZ :  1.01/13 23/03/98  18.27.38  by  Tancredi Carli
*CMZ :  1.00/02 12/03/96  18.22.08  by  Tancredi Carli
*CMZ :  0.00/03 08/01/96  16.55.31  by  HZtool
*CMZ :  0.00/01 03/01/96  12.05.22  by  HZtool
*-- Author :
      FUNCTION HZLCOMP(KF)
******************************************************************
* Purpose: to compress the standard KF codes for use in mass and decay
*...arrays; also to check whether a given code actually is defined.
* 0: means not defined
* Input: KF particle code
*Output:
*Author: N. Brook
******************************************************************
*KEEP,HZDAT.
      Integer KCHG
      COMMON/HZDAT/KCHG(500,3)
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*
* A. Solano 15.12.98
* The first time the program enters this function ( from hzluhepc(1)
* called by hzfilhep ) COMMON/HZDAT/KCHG(500,3) is still empty, since
* is filled at the first call of function HZLCHGE ( called by hzluncop,
* called by hzfilhep right after hzluhepc(1) ).
* Fill KCHG here copying from HZLCHGE
*      SAVE /LUDAT2/
      DIMENSION KFTAB(25),KCTAB(25)
      logical lp
      DATA KFTAB/211,111,221,311,321,130,310,213,113,223,
     &313,323,2112,2212,210,2110,2210,110,220,330,440,30443,30553,0,0/
      DATA KCTAB/101,111,112,102,103,221,222,121,131,132,
     &122,123,332,333,281,282,283,284,285,286,287,231,235,0,0/
*
      data lp/.false./
*
      Integer i,Loca(500,3)
      Logical Init
      Data Init /.true./
      DATA (LOCA(I,1),I=   1, 500)/-1,2,-1,2,-1,2,-1,2,2*0,-3,0,-3,0,
     &-3,0,-3,6*0,3,9*0,3,2*0,3,0,-1,44*0,2,-1,2,-1,2,3,11*0,3,0,2*3,0,
     &3,0,3,0,3,10*0,3,0,2*3,0,3,0,3,0,3,10*0,3,0,2*3,0,3,0,3,0,3,10*0,
     &3,0,2*3,0,3,0,3,0,3,10*0,3,0,2*3,0,3,0,3,0,3,10*0,3,0,2*3,0,3,0,
     &3,0,3,70*0,3,0,3,28*0,3,2*0,3,8*0,-3,8*0,3,0,-3,0,3,-3,3*0,3,6,0,
     &3,5*0,-3,0,3,-3,0,-3,4*0,-3,0,3,6,-3,0,3,-3,0,-3,0,3,6,0,3,5*0,
     &-3,0,3,-3,0,-3,114*0/
      DATA (LOCA(I,2),I=   1, 500)/8*1,12*0,2,16*0,2,1,50*0,-1,410*0/
      DATA (LOCA(I,3),I=   1, 500)/8*1,2*0,8*1,5*0,1,9*0,1,2*0,1,0,2*1,
     &41*0,1,0,7*1,10*0,10*1,10*0,10*1,10*0,10*1,10*0,10*1,10*0,10*1,
     &10*0,10*1,70*0,3*1,22*0,1,5*0,1,0,2*1,6*0,1,0,2*1,6*0,2*1,0,5*1,
     &0,6*1,4*0,6*1,4*0,16*1,4*0,6*1,114*0/
*
      If(Init) Then
        Init = .false.
C*TC>
        do i=1,500
         kchg(i,1)=loca(i,1)
         kchg(i,2)=loca(i,2)
         kchg(i,3)=loca(i,3)
        enddo
C       Call Ucopy(loca,kchg,1500)
C*TC<
      Endif
*
C...Starting values.
      HZLCOMP=0
      KFA=IABS(KF)
*
      if (lp) then
       write(6,*) ' KF= ',KF,' KFA= ',KFA
      endif
C...Simple cases: direct translation or table.
      IF(KFA.EQ.0.OR.KFA.GE.100000) THEN
        RETURN
      ELSEIF(KFA.LE.100) THEN
        HZLCOMP=KFA
        IF(KF.LT.0.AND.KCHG(KFA,3).EQ.0) HZLCOMP=0
        if (lp) write(6,*) 'kfa<100: HZLCOMP= ',HZLCOMP,KCHG(KFA,3)
        RETURN
      ELSE
        DO 100 IKF=1,23
        IF(KFA.EQ.KFTAB(IKF)) THEN
          HZLCOMP=KCTAB(IKF)
          IF(KF.LT.0.AND.KCHG(HZLCOMP,3).EQ.0) HZLCOMP=0
          if (lp) write(6,*) 'else HZLCOMP= ',HZLCOMP
          RETURN
        ENDIF
  100   CONTINUE
      ENDIF

C...Subdivide KF code into constituent pieces.
      KFLA=MOD(KFA/1000,10)
      KFLB=MOD(KFA/100,10)
      KFLC=MOD(KFA/10,10)
      KFLS=MOD(KFA,10)
      KFLR=MOD(KFA/10000,10)

C...Mesons.
      IF(KFA-10000*KFLR.LT.1000) THEN
        IF(KFLB.EQ.0.OR.KFLB.EQ.9.OR.KFLC.EQ.0.OR.KFLC.EQ.9) THEN
        ELSEIF(KFLB.LT.KFLC) THEN
        ELSEIF(KF.LT.0.AND.KFLB.EQ.KFLC) THEN
        ELSEIF(KFLB.EQ.KFLC) THEN
          IF(KFLR.EQ.0.AND.KFLS.EQ.1) THEN
            HZLCOMP=110+KFLB
          ELSEIF(KFLR.EQ.0.AND.KFLS.EQ.3) THEN
            HZLCOMP=130+KFLB
          ELSEIF(KFLR.EQ.1.AND.KFLS.EQ.3) THEN
            HZLCOMP=150+KFLB
          ELSEIF(KFLR.EQ.1.AND.KFLS.EQ.1) THEN
            HZLCOMP=170+KFLB
          ELSEIF(KFLR.EQ.2.AND.KFLS.EQ.3) THEN
            HZLCOMP=190+KFLB
          ELSEIF(KFLR.EQ.0.AND.KFLS.EQ.5) THEN
            HZLCOMP=210+KFLB
          ENDIF
        ELSEIF(KFLB.LE.5) THEN
          IF(KFLR.EQ.0.AND.KFLS.EQ.1) THEN
            HZLCOMP=100+((KFLB-1)*(KFLB-2))/2+KFLC
          ELSEIF(KFLR.EQ.0.AND.KFLS.EQ.3) THEN
            HZLCOMP=120+((KFLB-1)*(KFLB-2))/2+KFLC
          ELSEIF(KFLR.EQ.1.AND.KFLS.EQ.3) THEN
            HZLCOMP=140+((KFLB-1)*(KFLB-2))/2+KFLC
          ELSEIF(KFLR.EQ.1.AND.KFLS.EQ.1) THEN
            HZLCOMP=160+((KFLB-1)*(KFLB-2))/2+KFLC
          ELSEIF(KFLR.EQ.2.AND.KFLS.EQ.3) THEN
            HZLCOMP=180+((KFLB-1)*(KFLB-2))/2+KFLC
          ELSEIF(KFLR.EQ.0.AND.KFLS.EQ.5) THEN
            HZLCOMP=200+((KFLB-1)*(KFLB-2))/2+KFLC
          ENDIF
        ELSEIF((KFLS.EQ.1.AND.KFLR.LE.1).OR.(KFLS.EQ.3.AND.KFLR.LE.2)
     &  .OR.(KFLS.EQ.5.AND.KFLR.EQ.0)) THEN
          HZLCOMP=80+KFLB
        ENDIF

C...Diquarks.
      ELSEIF((KFLR.EQ.0.OR.KFLR.EQ.1).AND.KFLC.EQ.0) THEN
        IF(KFLS.NE.1.AND.KFLS.NE.3) THEN
        ELSEIF(KFLA.EQ.9.OR.KFLB.EQ.0.OR.KFLB.EQ.9) THEN
        ELSEIF(KFLA.LT.KFLB) THEN
        ELSEIF(KFLS.EQ.1.AND.KFLA.EQ.KFLB) THEN
        ELSE
          HZLCOMP=90
        ENDIF

C...Spin 1/2 baryons.
      ELSEIF(KFLR.EQ.0.AND.KFLS.EQ.2) THEN
        IF(KFLA.EQ.9.OR.KFLB.EQ.0.OR.KFLB.EQ.9.OR.KFLC.EQ.9) THEN
        ELSEIF(KFLA.LE.KFLC.OR.KFLA.LT.KFLB) THEN
        ELSEIF(KFLA.GE.6.OR.KFLB.GE.4.OR.KFLC.GE.4) THEN
          HZLCOMP=80+KFLA
        ELSEIF(KFLB.LT.KFLC) THEN
          HZLCOMP=300+((KFLA+1)*KFLA*(KFLA-1))/6+(KFLC*(KFLC-1))/2+KFLB
        ELSE
          HZLCOMP=330+((KFLA+1)*KFLA*(KFLA-1))/6+(KFLB*(KFLB-1))/2+KFLC
        ENDIF

C...Spin 3/2 baryons.
      ELSEIF(KFLR.EQ.0.AND.KFLS.EQ.4) THEN
        IF(KFLA.EQ.9.OR.KFLB.EQ.0.OR.KFLB.EQ.9.OR.KFLC.EQ.9) THEN
        ELSEIF(KFLA.LT.KFLB.OR.KFLB.LT.KFLC) THEN
        ELSEIF(KFLA.GE.6.OR.KFLB.GE.4) THEN
          HZLCOMP=80+KFLA
        ELSE
          HZLCOMP=360+((KFLA+1)*KFLA*(KFLA-1))/6+(KFLB*(KFLB-1))/2+KFLC
        ENDIF
      ENDIF

      RETURN
      END
*CMZ :  1.01/14 25/03/98  18.47.52  by  Tancredi Carli
*CMZU:  0.00/05 29/01/96  16.52.30  by  Mark Hayes
      Function Hzphokin(Itype)
**********************************************************
* Purpose:
* Return DIS kinem. variables
* Input:
* If Itype = 1 -> Q2
*    itype = 2 -> xbj
*    itype = 3 -> ybj
*    itype = 4 -> W2
* Photoproduction Author : M. Hayes
* Original Author: N. Brook
**********************************************************

      IMPLICIT NONE

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.

      INTEGER itype
      DOUBLE PRECISION q2,ybj,pgam(5),pbeam(5),cms
      INTEGER il,ip,jgam,kbeam
*
      hzphokin = -1.0d0
C      Jgam = hzipgamn(pgam)
      if(jgam.ne.1) Then
       Write(6,*) 'HZPHOKIN: No record of virt. photon found'
       Return
      endif
      kbeam = hzibeam(ip,il)
      If(kbeam.ne.1) Then
        Write(6,*) 'HZPHOKIN: No record of beam particles'
        Return
      Endif

      q2 = -(pgam(4)**2-pgam(3)**2-pgam(2)**2-pgam(1)**2)
      cms = (phep(4,ip)+phep(4,il))**2
     +      - ((phep(3,ip)+phep(3,il))**2
     1         +(phep(2,ip)+phep(2,il))**2
     2         +(phep(1,ip)+phep(1,il))**2)
      ybj=(phep(4,ip)*pgam(4) - phep(3,ip)*pgam(3)
     +        -phep(2,ip)*pgam(2) - phep(1,ip)*pgam(1))/
     1    (phep(4,ip)*phep(4,il) - phep(3,ip)*phep(3,il)
     2        -phep(2,ip)*phep(2,il) - phep(1,ip)*phep(1,il))
      If(itype.eq.1) Then
        hzphokin = q2
      else if(itype.eq.2) then
	PRINT*,'HZPHOKIN : current version has no x_proton calculation'
      else if(itype.eq.3) then
	hzphokin = ybj
      else if(itype.eq.4) then
	PRINT*,'HZPHOKIN : current version has no W2 calculation'
      else
        write(6,*) ' HZPHOKIN: itype should be in range 1-4'
      endif
*
      return
      end
*CMZ :  0.00/01 05/01/96  21.29.22  by  HZtool
*-- Author :
       Subroutine Hzphmrot(phi,the,p,pnew)
C#*****************************************************************
C#       Subroutine hzphmrot(phi,the,p,pnew)
C#
C#  HZPHMROT : Performs rotations in space
C#
C#  PURPOSE :  Performs rotations in space
C#
C# INPUT :
C#  PHI, THE =
C#       are standard polar coords. ,phi and theta, giving
C#       the direction of a momentum vector initially along the
C#       +ve z axis.
C#
C#   P       =  is the vector to be acted upon
C# OUTPUT :
C#   PNEW    =  is the rotated vector
C#
C# Author: LUROBO in JETSET (modified by N Brook)
C#
C#****************************************************************
       Implicit DOUBLE PRECISION(A-H,O-Z)
       Dimension rot(3,3), p(3), pnew(3), ptmp(3)
*
       do Ivec = 1, 3
         pnew(ivec) = p(ivec)
         ptmp(ivec) = p(ivec)
       enddo
       IF(THE**2+PHI**2.GT.1E-20) THEN
C...ROTATE (TYPICALLY FROM Z AXIS TO DIRECTION THETA,PHI)
         ROT(1,1)=COS(THE)*COS(PHI)
         ROT(1,2)=-SIN(PHI)
         ROT(1,3)=SIN(THE)*COS(PHI)
         ROT(2,1)=COS(THE)*SIN(PHI)
         ROT(2,2)=COS(PHI)
         ROT(2,3)=SIN(THE)*SIN(PHI)
         ROT(3,1)=-SIN(THE)
         ROT(3,2)=0.
         ROT(3,3)=COS(THE)
         DO 110 J=1,3
 110     PNEW(J)=ROT(J,1)*PTMP(1)+ROT(J,2)*PTMP(2)+ROT(J,3)*PTMP(3)
       ENDIF
       RETURN
       END
*CMZ :  1.01/15 22/06/98  15.35.32  by  Tancredi Carli
*CMZ :  1.01/10 11/11/97  17.30.21  by  Tancredi Carli
*CMZ :  0.00/10 19/02/96  10.09.59  by  Tancredi Carli
*CMZ :  0.00/08 13/02/96  18.43.56  by  Tancredi Carli
*-- Author :
      Subroutine Hzterm
********************************************************************
*                                                                  *
* Hzterm                                                           *
* ======                                                           *
* Authour: Nick Brook.                                             *
*                                                                  *
* Scans through sub-directories and prints out the Chi-sq, Ndof    *
* for each histogram in a nice little table                        *
*                                                                  *
********************************************************************

      Implicit None
*
      Integer Maxdir
      Parameter(Maxdir=40)
      Character*8 chdir(maxdir)
      Integer Ndir, Idir, Ievt, Nevt,idn,ierr
      Real evt(3)
      Logical Hexist
      Character rout*10
      Data rout/'hzterm '/
*
      Call hcdir('//PAWC',' ')
      Call Hrdir(maxdir,chdir,ndir)
      If(ndir.gt.maxdir) Write(6,*) rout,' Number of directories > ',
     +  maxdir, ' only first ',maxdir, ' outputted'
*
       Do Idir = 1, min(ndir,maxdir)
         call hcdir(chdir(idir),' ')
         Write(6,*) ' Subdirectory: ',chdir(idir)
         Write(6,*) ' ======================'
         Write(6,*) ' '
         if(hexist(999)) Then
           Write(6,1000)
           Call Hgnpar(999,'HZTERM')
           Call Hnoent(999,nevt)
           Do Ievt = 1, Nevt
             Call Hgnf(999,ievt,evt,ierr)
             Write(6,1001) int(evt(1)),evt(2),int(evt(3))
           Enddo
           Write(6,1002)
         Endif
         Call hcdir(' \ ',' ')
       Enddo
*
       Return
*
 1000  Format(10X,30('*')/10x,'*',10x,'*',10x,'*',6x,'*'/
     1        10x,'* HISTO ID *   chi-2  *  NdF *'/
     +        10x,'*',10x,'*',10x,'*',6x,'*'/10X,30('*')/
     2        10x,'*',10x,'*',10x,'*',6x,'*')
 1001  Format(10X,'* ',I8,' * ',F8.2,' * ',I4,' *')
 1002  Format(10x,'*',10x,'*',10x,'*',6x,'*'/10X,30('*')/' ')
       End
*CMZ :  0.00/01 05/01/96  14.49.59  by  HZtool
*-- Author :    HZtool   05/01/96
      subroutine HZVERS
****************************************************************************
* Purpose: write out hztoo version used
*
* by written: Tancredi Carli on 05/01/96
****************************************************************************
      IMPLICIT NONE
*
      CHARACTER*8     VERSQQ
      INTEGER         IEV,IVERSQ,IDATQQ,ITIMQQ
*
*KEEP,VERSQQ.
      VERSQQ = ' 2.00/06'
      IVERSQ =  20006
*KEEP,DATEQQ.
      IDATQQ = 20020502
*KEEP,TIMEQQ.
      ITIMQQ =   1525
*KEND.
*
       WRITE(6,1000) IDATQQ,ITIMQQ
 1000  FORMAT(
     &'1*********************************************************'/
     &' ******   ',
*KEEP,QFTITLE,N=40.
     + 40H2.00/06  02/05/2002  15.10.39           
*KEND.
     &,' ******'/
     &' ****** compiled at date ',I6,'  and time ',I4,'    ******'/
     &' *********************************************************'/)
*
      RETURN
*
      END
*
*CMZ :  1.01/15 04/06/98  23
*-- Author :
*****************************************************************************
	Subroutine HZjtname(chjet,jetf)
*****************************************************************************
*	Routine returns 6 letter mnemonic for a jet finder
*	INPUT  : chjet = jet finder number
*	OUTPUT : jetf = 6 character string for jet finder
*	Author : M.Hayes
*****************************************************************************

      INTEGER chjet
      CHARACTER*6 jetf

      IF (chjet.eq.1) THEN
	jetf='EUCELL'	
      ELSEIF (chjet.eq.2) THEN
	jetf='PXCONE'
      ELSEIF (chjet.eq.3) THEN
	jetf='KTCLUS'
      ELSEIF (chjet.eq.4) THEN
	jetf='GPCONE'
      ELSEIF (chjet.eq.5) THEN
	jetf='JCLUST'
      ELSEIF (chjet.eq.6) THEN
	jetf='JCLUST'
      ELSEIF (chjet.eq.7) THEN
	jetf='PUCELL'
      ELSE
	jetf='00USER'
      ENDIF

      Return
      End
*CMZ :  1.00/03 13/03/96  17.24.58  by  Mark Hayes
*-- Author :
      SUBROUTINE hzjetrad(iflag,radi)
***********************************************************************
* Purpose: To set jet finder radii & find out the radius
*
* To set radius
*	INPUT   iflag=1
*		radi=radius to be set (in radians)
*	OUTPUT  radi=-1 everything OK!
* To read the radius
*	INPUT   iflag=2
*	OUTPUT  radi=returns radius (in radians)
*			or negative if cone radius not set by user
* Author: M. Hayes
***********************************************************************
      Implicit None

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.

      INTEGER iflag
      DOUBLE PRECISION radi,radius
      DATA radius/-1.0/
      SAVE radius

      IF (iflag.eq.1) THEN
C --- set radius
	IF ((radi.gt.0).and.(radi.lt.3.14)) THEN
	  radius=radi
	ELSE
	  radi=-1
	  PRINT*,'HZJETRAD : silly cone radius set'
	ENDIF
      ELSEIF (iflag.eq.2) THEN
C --- read radius
	radi=radius
      ELSE
      	radi=-1
      	PRINT*,'HZJETRAD : badly set iflag'
      ENDIF

      Return
      End
*CMZ :  1.01/11 20/11/97  14.00.47  by  Tancredi Carli
*CMZ :  1.01/03 30/04/96  17.09.55  by  Mark Hayes
*-- Author :    Mark Hayes   30/04/96
      SUBROUTINE HZEVENT
*****************************************************************
*	Prints out current event in ASCII format
*   Author : Mark Hayes
*****************************************************************
      IMPLICIT NONE
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
      INTEGER loop
*
      WRITE(6,*) '-Event----------------------------------'
*
          DO loop=1,NHEP
             WRITE(6,1000) loop,'.is ',IDHEP(loop),' ('
     &          ,ISTHEP(loop),') [',PHEP(4,loop),'; ',PHEP(1,loop)
     &          ,', ',PHEP(2,loop),', ',PHEP(3,loop),']'
     &          ,' m ',JMOHEP(1,loop),' d1 ',JDAHEP(1,loop)
     &	        ,' d2 ',JDAHEP(2,loop)
 1000        FORMAT(I3,A,I4,A,I4,A,F8.2,A,F8.2,A,
     &               F8.2,A,F8.2,A,A,I3,A,I3,A,I3)
          ENDDO
*
      RETURN
      END
*CMZ :  1.01/04 13/08/96  18.17.43  by   Tancredi Carli
*CMZ :          13/08/96  18.16.00  by   Tancredi Carli
      SUBROUTINE HZDIFKIN
*  ---- get event kinematik for diffractive events (Mx,xpom etc..)
*  MODIFICATION log
* ---------------------------------------------------------
*   8.5.96 |  NPA |  start with POMPYT
* ---------------------------------------------------------
* --- for POMPYT :
       implicit none
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZDIFEV.
      REAL             MXGEN, XPOMGEN, TGEN, PTPGEN, PDFSCA
      COMMON /HZDIFEV/ MXGEN, XPOMGEN, TGEN, PTPGEN, PDFSCA(4)
*
*KEND.
      COMMON/POMEVT/KIN(4,5),PIN(4,5),ROOTS,XMASS,XF,XPOM,T,PT,WHAD
      integer KIN
      real PIN, ROOTS,XMASS,XF,XPOM,T,PT,WHAD
      integer j
*
      if(gen.eq.'POM') then
        mxgen = xmass
        xpomgen = xpom
        tgen = t
        ptpgen = pt
        do j=1,4
          pdfsca(j) = pin(3,j)
        enddo
      endif

      return
      end
*
*CMZ :  1.01/04 13/08/96  18.20.38  by   Tancredi Carli
*-- Author :     Tancredi Carli   13/08/96
      SUBROUTINE HZFPOMP
      implicit none
*
* ---- insert 4-mom of scat. ele , virt. photon in lund buffer at
*        postion 3,4
*  MODIFICATION log
* ---------------------------------------------------------
*   8.5.96 |  NPA |  start version
* ---------------------------------------------------------
      COMMON/POMEVT/KIN(4,5),PIN(4,5),ROOTS,XMASS,XF,XPOM,T,PT,WHAD
      integer KIN
      real PIN, ROOTS,XMASS,XF,XPOM,T,PT,WHAD
      COMMON/LUJETS/N,K(4000,5),P(4000,5),V(4000,5)
      integer N,K
      real P,V
      real p1
      integer i,j, k1

      do i=n,2,-1
        do j=1,5
          k(i+2,j) = k(i,j)
          p(i+2,j) = p(i,j)
        enddo
      enddo
      do j=1,5
        k(4,j) = kin(3,j)
        p(4,j) = pin(3,j)
        p(3,j) = p(1,j) - pin(3,j)
      enddo
      k(3,1) = 21
      k(3,2) = 23
      k(3,3) = 1
      k(3,4) = 0
      k(3,5) = 0
* swap beams such that lepton first
      do j=1,5
        k1=k(1,j)
        k(1,j) = k(2,j)
        k(2,j) = k1
        p1=k(1,j)
        p(1,j) = p(2,j)
        p(2,j) = p1
      enddo
      return
      end
*
*CMZ :  1.01/11 20/11/97  13.58.19  by  Tancredi Carli
*CMZ :  1.01/07 08/10/97  17.27.54  by  Tancredi Carli
*CMZ :  1.01/05 03/09/96  16.37.58  by  Tancredi Carli
*-- Author :
      Subroutine HzHInfo(idmc,nbin)
*********************************************************************
*                                                                   *
* Fills some information in an ntuple                               *
*
* Author: Tancredi Carli                                            *
*                                                                   *
* Input arguments:                                                  *
* Idmc  - Histogram ID of Monte Carlo                               *
*                                                                   *
* Output arguments:                                                 *
* none                                                              *
*                                                                   *
*********************************************************************
*
      Implicit None
*
      Integer Ndatpts
      Parameter(Ndatpts=1000)
      Integer idmc
      Real nbin
      Logical Hexist,lp
      Character rout*10
      Integer ntag,ntid
      Parameter (ntag=2,ntid=998)
      Real evt(ntag)
      Character*4 tags(ntag)
      Data Tags/'id','Norm'/
      Data lp/.false./
*
      If(.not.Hexist(ntid)) then
       Call Hbookn(ntid,' Histo info',ntag,' ',100,Tags)
       if (lp) write(6,*) rout,' book ntuple ',ntid
      endif
*
      evt(1) = real(idmc)
      evt(2) = nbin
*
      if (lp) then
       write(6,*) rout,ntid,' filling = ',evt
      endif
*
      Call hfn(ntid,evt)
*
      Return
      End
*CMZ :  1.01/15 12/08/98  20.14.07  by  Tancredi Carli
*CMZ :  1.01/11 29/12/97  11.26.36  by  Tancredi Carli
*-- Author :
      Subroutine Hzterm2
********************************************************************
*                                                                  *
* Hzterm2                                                          *
* ======                                                           *
* Author: Tancredi Carli                                           *
*                                                                  *
* Prints number of events in histogram                             *
*        total cross-section and total number of events            *
*                                                                  *
********************************************************************

      Implicit None
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      Integer Maxdir
      Parameter(Maxdir=40)
      Character*8 chdir(maxdir)
      Integer Ndir, Idir, Ievt, Nevt,idn,ierr
      Real evt(2)
      Logical Hexist
      Character rout*10
      Data rout/'hzterm2 '/
*
      Call hcdir('//PAWC',' ')
*
*
      Call Hrdir(maxdir,chdir,ndir)
      If(ndir.gt.maxdir) Write(6,*) rout,' Number of directories > ',
     +  maxdir, ' only first ',maxdir, ' outputted'
*
       Do Idir = 1, min(ndir,maxdir)
         call hcdir(chdir(idir),' ')
         Write(6,*) rout,' Subdirectory: ',chdir(idir)
         Write(6,*) ' ======================'
         Write(6,*) ' '
         if(hexist(998)) Then
C           Write(6,1000)
           Call Hgnpar(998,'HZTERM')
           Call Hnoent(998,nevt)
           Do Ievt = 1, Nevt
             Call Hgnf(998,ievt,evt,ierr)
C             Write(6,*) rout,int(evt(1)),int(evt(2))
           Enddo
C           Write(6,1002)
         Endif
         Call hcdir('\',' ')
       Enddo
*
      Call hcdir('//PAWC',' ')
      Call hcdir('//HISTO',' ')
      call hbook1(997,' SigmaTOT + NTOT ',2,0.,3.,0.)
      call hfill(997,1.,0.,real(xsec))
      call hfill(997,2.,0.,real(ntot))
*
      write(6,*) rout,' Total cross-section: ',real(xsec)
      write(6,*) rout,' Total number of event generated: ',ntot
*
*
       Return
*
C 1000  Format(10X,20('*')/10x,'*',10x,'*',6x,'*'/
C     1        10x,'* HISTO ID * Nbin     *,
C     +        10x,'*',10x,'*',10x,'*',6x,'*'/10X,20('*')/
C     2        10x,'*',10x,'*',6x,'*')
C 1001  Format(10X,'* ',I8,' * ',I8,' * ')
C 1002  Format(10x,'*',10x,'*',6x,'*'/10X,20('*')/' ')
       End
*CMZ :  2.00/05 23/04/2001  22.48.47  by  Frank-Peter Schilling
*CMZ :  2.00/00 13/08/99  18.34.44  by  Tancredi Carli
*CMZ :  1.02/01 09/10/98  11.36.14  by  Tancredi Carli
*CMZ :  1.01/15 04/06/98  23.30.54  by  Tancredi Carli
*CMZ :  1.01/13 13/02/98  14.58.37  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98  12.08.06  by  Tancredi Carli
*CMZ :  1.01/11 05/01/98  18.51.27  by  Tancredi Carli
*CMZ :  1.01/05 11/02/97  10.08.45  by  Tancredi Carli
*CMZ :  1.01/03 15/05/96  18.13.10  by  Mark Hayes
*CMZ :  1.01/02 09/04/96  16.46.07  by  Tancredi Carli
*CMZ :  1.00/03 13/03/96  17.26.59  by  Mark Hayes
*-- Author :
      SUBROUTINE hzjtfind(ijetf,radius,iArgNJts,ArgJets)
***********************************************************************
* Purpose: Generic jet finder caller.
*	   runs on HEPEVTP table of particles.
* Associated routine : HZJTNAME returns mnemonic of jet finder
*
* INPUT:  ijetf = chosen jetfinder, installed so far
*		    1=EUCELL, 2=PXCONE (Et mode), 3=KTCLUS, 4=GPCONE,
*		    5=JCLUST(DIS), 6=JCLUST(photoprod.)
*                   7=PUCELL 8=PXCONE (Pt mode)
*         radius = radius of jet to find
*	            (-1 to get from HZJETRAD, but this slows down the
*			     program since HZJETRAD will be called every event)
*
* OUTPUT : numjets = Number of jets found (max. 50)
*	   Jets(50,x) = information about jets found
*	   	x= 1,2  rapidity, phi  of jet axis
*		   3    Et  of jet
*		   4-8  (E,px,py,pz,m) of jet axis
*          note: for PXCONE(ijetf=2), KTCLUS:
*                jet momentum components are scaled by E/p
*
*          iJetNo(NMXHEP) =
*                    case >= 1 :  number of jet particle is associated with
*                    case <  1 :  particle doesn't belong to any jet
*                   (only for follwing jet algorithms: PXCONE, KTCLUS)
*
* Author: M. Hayes
***********************************************************************
      Implicit None
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZJETCMN.
*
*     MAXHZJETS: maxmial number of jet allowed
*     NUMJETS: number of jets from jet algo
*     NSEL  : number of selected jets
*     IPJET : pointer to selected jets
*     JETS  : Jet variables (eta,phi,et,e,px,py,pz,m) in choosen frame
*     IJETNO: pointer which objects in PHEP common belong to jets
*
      INTEGER MAXHZJETS
      PARAMETER (MAXHZJETS=50)
      INTEGER NSEL,NUMJETS,IPJET(MAXHZJETS),IJETNO(NMXHEP)
      DOUBLE PRECISION JETS(MAXHZJETS,8)
*
      COMMON /HZJETCMN/JETS,NUMJETS,NSEL,IPJET,IJETNO
*
*
*KEND.
*
C --- PXCONE stuff ---
      INTEGER  ITKDM,MXTRK
      PARAMETER  (ITKDM=4,MXTRK=500)
      INTEGER  MXJET, MXTRAK, MXPROT
      PARAMETER  (MXJET=50,MXTRAK=500,MXPROT=500)
      INTEGER  IPASS (MXTRAK),IJMUL (MXJET)
      INTEGER  NTRAK,injet,IERR,MODE
      DOUBLE PRECISION  PTRAK (ITKDM,MXTRK),PJET (5,MXJET)
      DOUBLE PRECISION  CONER, EPSLON, OVLIM
*
C --- KTCLUS stuff ---
      integer IKTPMX
      parameter (IKTPMX=512)
      double precision ppp(4,IKTPMX),ktpjet(4,IKTPMX)
      integer          i,j,k,ktmode,ktreco,npjets
      integer          invmap(IKTPMX),map(IKTPMX)
      double precision etjeti,etjetj,help
      real             yy(IKTPMX),ecut
      integer          parttojet(IKTPMX)
*
C --- EUCELL stuff ---
      INTEGER ncusmx,KJ,NCUSE,KCUSE,NJET
      REAL PJ,ETEMC0,ETHAC0,EEMC0,EHAC0,PCUSE
      Parameter (ncusmx=500)
      COMMON/EUJETS/ NJET,KJ(50,5),PJ(50,12),ETEMC0,ETHAC0,EEMC0,EHAC0
     &,NCUSE,KCUSE(ncusmx,5),PCUSE(ncusmx,10)
*
C --- GPCONE stuff ---
      REAL JET1(10,3)
      REAL ETALM,ETINI,ETBIN,ETMIN,ETMAX,helpGP
      INTEGER NETA,NPHI
*
C---- JADE Stuff
      Real EVIS,XJCUT,ee,ep
      Integer JMODE,NPI,NP,ip,il,iel
      REAL PI(4,nmxhep),P(5,nmxhep)
      DOUBLE PRECISION DPI(4,nmxhep),DP(4,nmxhep)
*
c --- PUCELL stuff ---
      real pucellP
      COMMON/MORSUB/pucellP(10,1000)
       integer njet1
       real vtx(3),EnergyCuts(10),Operation(10)
       real PGJET1
       COMMON/GENJET1/NJET1,PGJET1(20,15)
       INTEGER NRclus
*
c --- arguments
      INTEGER ijetf, iArgNJts
      DOUBLE PRECISION radius, ArgJets(MAXHZJETS,8)
*
c --- general stuff ---
      character*9 cxxxx
      data cxxxx /'HZJTFIND'/

      INTEGER loop,loop2,count,myil,jetf
      DOUBLE PRECISION phi,px,py,pz,pt,ptsq,ppsq,energy,mass
      DOUBLE PRECISION eta,rap,Et,theta,drad
      INTEGER ref(NMXHEP)
      INTEGER hziflag,hzflag
      integer npart

      LOGICAL photoprod,lp
      data lp/.false./
*	




**********************************************
*     GENERAL SETTINGS
**********************************************

      jetf=ijetf
*
C --- This determines if we call JCLUST(6) or not
      IF (jetf.eq.6) THEN
       jetf=5
       photoprod=.TRUE.
      ELSE
       photoprod=.FALSE.
      ENDIF

C --- initializations
      do loop=1,NMXHEP
         IJETNO(loop)=0
      enddo
      do i=1,MAXHZJETS
       do j=1,8
        Jets(i,j)=0.D0
        ArgJets(i,j)=0.D0
       enddo
      enddo
      NUMJETS = 0

C ----standard cone radius is 1.0
      If (radius.lt.0.D0) THEN
       CALL HZJETRAD(2,CONER)
       IF (CONER.lt.0.D0) THEN
        CONER=1.D0
       ENDIF
      Else
       CONER=radius
      Endif
*
C --- make sure we disable electron from jet finding
      myil=HZIDELEC(hzflag)
      if (lp) write(6,*) cxxxx,'myil= ',myil
      IF (myil.ge.0) Then
*     status of lepton is changed to 999 and changed back at the end
         ISTHEP(myil)=999
      ENDIF
*

C --- avoid invalid array-access
      if ((NHEP.lt.1).or.(NHEP.gt.NMXHEP)) then
         write(6,*) cxxxx,'invalid number of particles !',NHEP
      endif


**********************************************
*     CHOOSE JETFINDER
**********************************************


***********************************************************************
      IF (jetf.eq.1) THEN
C ------------------ start EUCELL stuff - find jets
C ---                EUCELL has implicit cuts for rapidity (5,-5)
C --- 		     minimum seed jet energy of 2 GeV
C ---                can not fill the iJetNo array

       ETEMC0=0.
       ETHAC0=0.
       EEMC0=0.
       EHAC0=0.
*
       CALL EUHEPC
       CALL EUCELL(4.0, -4.0, 2.0, 2.0, REAL(CONER))
       IF (NJET.gt.MAXHZJETS) THEN
        NUMJETS=MAXHZJETS
       ELSE
        NUMJETS=NJET
       ENDIF
*	
       DO loop=1,NUMJETS
        Jets(loop,1)=dble(PJ(loop,1))  ! eta
       	Jets(loop,2)=dble(PJ(loop,2))  ! phi
      	Jets(loop,3)=dble(PJ(loop,5))  ! Et
      	Jets(loop,4)=dble(PJ(loop,9))  ! E
      	Jets(loop,5)=dble(PJ(loop,6))  ! px
      	Jets(loop,6)=dble(PJ(loop,7))  ! py
      	Jets(loop,7)=dble(PJ(loop,8))  ! pz
      	Jets(loop,8)=dble(PJ(loop,10)) ! m
       ENDDO
C ---------------- end EUCELL stuff - find jets
***********************************************************************
      ELSEIF (jetf.eq.2) THEN
C -----------------PXCONE stuff - find jets
C ---              PXCONE minimum seed jet energy of 2 GeV

c --- prepare pxcone call
       MODE=2
       EPSLON=2.D0
C      EPSLON=5.0
C      OVLIM=0.1
       OVLIM=7.5D-1
*
       count=0
       DO loop=1,NHEP
*     skip unstable particles and scattered lepton
	IF (ISTHEP(loop).eq.1) THEN
           drad = sqrt( PHEP(1,loop)**2+PHEP(2,loop)**2
     &                 +PHEP(3,loop)**2 )
           if( drad.le.0.D0 ) then
              if (lp) write(6,*) cxxxx, 'drad = ',drad
           else
              IF (count.eq.MXTRK) THEN
                 write(6,*) cxxxx,'Too many particles for PXCONE',count
                 GOTO 65
              ELSE
                 count=count+1
*     following 'trick' is used to force PXCONE calculating with Et
*     rather than pt
                 PTRAK(1,count)=PHEP(1,loop)*PHEP(4,loop)/drad
                 PTRAK(2,count)=PHEP(2,loop)*PHEP(4,loop)/drad
                 PTRAK(3,count)=PHEP(3,loop)*PHEP(4,loop)/drad
                 PTRAK(4,count)=PHEP(4,loop)
                 ref(count)=loop
              ENDIF
           endif
	ENDIF
       ENDDO
 65    CONTINUE
       NTRAK=count
*
       do loop = 1, MXTRAK
          ipass(loop) = 0
       enddo

c --- do pxcone call
       CALL PXCONE (MODE,NTRAK,ITKDM,PTRAK,CONER,EPSLON,OVLIM,
     &		MXJET,injet,PJET,IPASS,IJMUL,IERR)
       IF (IERR.ne.0) THEN
	write(6,*) cxxxx, 'PXCONE returns error'
       ENDIF
       IF (injet.gt.MXJET) THEN
        write(6,*) cxxxx, 'Too many jets found, increase MXJET',injet
       ENDIF

c --- get output

       IF (injet.gt.MAXHZJETS) THEN
        NUMJETS=MAXHZJETS
       ELSE
        NUMJETS=injet
       ENDIF
*
       DO loop=1,NUMJETS
	px=PJET(1,loop)
	py=PJET(2,loop)
	pz=PJET(3,loop)
        ptsq=px**2+py**2
        ppsq=(SQRT(ptsq+pz**2)+ABS(pz))**2
        IF (ptsq.le.4.25E-18*ppsq) THEN
         eta=20.D0
        ELSE
         eta=0.5*LOG(ppsq/ptsq)
        ENDIF
        eta=SIGN(eta,pz)
        IF (ptsq.EQ.0.D0) THEN
         phi=0.D0
        ELSE
         phi=ATAN2(py,px)
        ENDIF
*
	Et=PJET(4,loop)*SQRT(ptsq/(ptsq+pz**2))
      	Jets(loop,1)=eta  ! eta
       	Jets(loop,2)=phi  ! phi
      	Jets(loop,3)=Et   ! Et
      	Jets(loop,4)=PJET(4,loop)  ! E
      	Jets(loop,5)=PJET(1,loop)  ! px
      	Jets(loop,6)=PJET(2,loop)  ! py
      	Jets(loop,7)=PJET(3,loop)  ! pz
      	Jets(loop,8)=0             ! m
       Enddo
*
       DO loop=1,ntrak
          iJetNo(ref(loop))=IPASS(loop)
       ENDDO


C ---  end PXCONE stuff - find jets
***********************************************************************
      ELSEIF (jetf.eq.3) THEN
C     ---  start KTCLUS stuff - find jets
C     ---  KTCLUS ignores the radius parameter
         
c     --- prepare KTCLUS call
C     !!!!!!
c     ktreco=2
C     ktreco=1
C     ktmode=3212
C     !!!!!
C     ktmode=3210+ktreco
         ktreco=1
         ktmode=3210+ktreco
C     !!!!! ecut=0.
         ecut   = 1.
         count=0
       DO loop=1,NHEP
*     skip unstable particles and scattered lepton
         IF (ISTHEP(loop).eq.1) THEN
            drad = sqrt( PHEP(1,loop)**2+PHEP(2,loop)**2
     &                   +PHEP(3,loop)**2 )
            if( drad.le.0.D0 ) then
               if (lp) write(6,*) cxxxx, 'drad = ',drad
            else
               IF (count.eq.IKTPMX) THEN
                  write(6,*) cxxxx,'Too many particles for KTCLUS',count
                  GOTO 85
               ELSE
                  count=count+1
*     following 'trick' is used to force KTCLUS calculating with Et
*     rather than pt
*                 ppp(1,count) = PHEP(1,loop)*PHEP(4,loop)/drad
*                 ppp(2,count) = PHEP(2,loop)*PHEP(4,loop)/drad
*                 ppp(3,count) = PHEP(3,loop)*PHEP(4,loop)/drad
*                 ppp(4,count) = PHEP(4,loop)
* TC take vectors as they are
                  ppp(1,count) = PHEP(1,loop)
                  ppp(2,count) = PHEP(2,loop)
                  ppp(3,count) = PHEP(3,loop)
                  ppp(4,count) = PHEP(4,loop)
*                  write(6,*) ' p= ',(real(ppp(j,count)),j=1,4)
                  ref(count)=loop
*                  write(6,*)'****************************'
*                  write(6,*) 'part:',loop,PHEP(1,loop),PHEP(2,loop)
*     &                 ,PHEP(3,loop),PHEP(4,loop)
               ENDIF
            endif
         ENDIF
       EndDo
 85    CONTINUE
*
       NPART=count

c --- do KTCLUS call
       call KTCLUS(ktmode,ppp,npart,ecut,yy,*89)
       call KTINCL(ktreco,ppp,npart,ktpjet,parttojet,NJET,*89)

       if (NJET.gt.IKTPMX) goto 89


c --- sort jets in Et
       Do loop=1,NJET
          map(loop)=loop
       ENDDO

       do i = 1, NJET
        etjeti = sqrt( ktpjet(1,i)**2 + ktpjet(2,i)**2 )
        do j = (i+1), NJET
         etjetj = sqrt( ktpjet(1,j)**2 + ktpjet(2,j)**2 )
         if( etjetj.gt.etjeti )then
          do k = 1, 4
           help      = ktpjet(k,i)
           ktpjet(k,i) = ktpjet(k,j)
           ktpjet(k,j) = help
          enddo
          k=map(i)
          map(i)=map(j)
          map(j)=k
         endif
        enddo ! j
       enddo ! i
       DO loop=1,NJET
         invmap(map(loop))=loop
       ENDDO

c --- get output
       IF (NJET.gt.MAXHZJETS) THEN
	NUMJETS=MAXHZJETS
       ELSE
	NUMJETS=NJET
       ENDIF
*
       DO loop=1,NUMJETS
	px=ktPJET(1,loop)
	py=ktPJET(2,loop)
	pz=ktPJET(3,loop)
C        write(6,*) ' jet: ',(real(ktPJET(j,loop)),j=1,4)
        ptsq=px**2+py**2
        ppsq=(SQRT(ptsq+pz**2)+ABS(pz))**2
        IF (ptsq.le.4.25E-18*ppsq) THEN
         eta=20.
        ELSE
         eta=0.5*LOG(ppsq/ptsq)
        ENDIF
        eta=SIGN(eta,pz)
        IF (ptsq.EQ.0) THEN
         phi=0.
        ELSE
         phi=ATAN2(py,px)
        ENDIF
	Et=ktPJET(4,loop)*SQRT(ptsq/(ptsq+pz**2))
      	Jets(loop,1)=eta  ! eta
       	Jets(loop,2)=phi  ! phi
      	Jets(loop,3)=Et   ! Et
      	Jets(loop,4)=ktPJET(4,loop)  ! E
      	Jets(loop,5)=ktPJET(1,loop)  ! px
      	Jets(loop,6)=ktPJET(2,loop)  ! py
      	Jets(loop,7)=ktPJET(3,loop)  ! pz
        Jets(loop,8)=-ktPJET(1,loop)**2-ktPJET(2,loop)**2
     &               -ktPJET(3,loop)**2+ktPJET(4,loop)**2
*        write(6,*)'****************************'
*        write(6,*) 'part:',loop,PHEP(1,loop),PHEP(2,loop)
*     &       ,PHEP(3,loop),PHEP(4,loop)
        if (Jets(loop,8).gt.0.) Jets(loop,8)=sqrt(Jets(loop,8))
       Enddo

       Do loop=1,npart
          if ((parttojet(loop).ge.1).and.(parttojet(loop).le.NJET)) then
             iJetNo(ref(loop))=invmap(parttojet(loop))
          else
             iJetNo(ref(loop))=0
          endif
       ENDDO

       goto 90
 89    CONTINUE
       write(6,*) cxxxx,'Error in KTCLUS !'
       call hzlihep(2)

 90    continue
C --- end KTCLUS stuff - find jets
***********************************************************************
      ELSEIF (jetf.eq.4) THEN
C ---    start GPCONE stuff - find jets
C        minimum Et of jet is 2 GeV
C        doesn't return HZJETCMN
         ETALM = 3.0
         NETA = 30
         NPHI = 24
         ETINI = 0.1
         ETBIN = 2.
         ETMIN = 2.0
         ETMAX=49.
         call vzero(jet1,30)
         njet=0
         CALL H1GPCONE(ETALM,NETA,NPHI,ETINI,ETMIN,ETBIN,ETMAX,
     +                 REAL(CONER), NJET,JET1)
*
 	 IF (NJET.gt.1) Then ! sort the jets in Et
          do i = 1, NJET
           do j = (i+1), NJET
            if( JET1(j,1).gt.JET1(i,1) )then
             do k = 1, 3
              helpGP      = JET1(i,k)
              JET1(i,k) = JET1(j,k)
              JET1(j,k) = helpGP
             enddo
            endif
           enddo ! j
          enddo ! i
         ENDIF ! jets sorted.
*
	 IF (NJET.gt.MAXHZJETS) THEN
	  NUMJETS=MAXHZJETS
	 ELSE
	  NUMJETS=NJET
	 ENDIF
*	
	 DO loop=1,NUMJETS
      	  Jets(loop,1)=dble(JET1(loop,2))  ! eta
       	  Jets(loop,2)=dble(JET1(loop,3))  ! phi
      	  Jets(loop,3)=dble(JET1(loop,1))  ! Et
          theta=2*datan(exp(-1*Jets(loop,1)))
      	  Jets(loop,4)= Jets(loop,3)/dcos(theta)  ! E
      	  Jets(loop,5)= Jets(loop,4)*sin(theta)*cos(phi)  ! px
          Jets(loop,6)= Jets(loop,4)*sin(theta)*sin(phi) ! py
          Jets(loop,7)= Jets(loop,4)*cos(theta) ! pz
          Jets(loop,8)= 0.d0 ! m
	 ENDDO
C ---   end GPCONE stuff
	ELSEIF (jetf.eq.5) THEN
C ---   start JADE stuff
*       Doesn't return HZJETCMN
*       This is both the code for JCLUST(DIS) and JCLUST(photoprod.)
*       Please use with care.
*
*       evis: visible energy in event
*       xjcut: unscale e fraction x=xjcut/w**2
*       jmode: ?
*       iel: pointer to electron
*
        evis=0.
*
        call VZERO(PI,4*nmxhep)
        npi=0
        DO loop=1,NHEP
	 IF (ISTHEP(loop).eq.1) THEN
          npi=npi+1
          PI(1,npi)=PHEP(1,loop)
          PI(2,npi)=PHEP(2,loop)
          PI(3,npi)=PHEP(3,loop)
          PI(4,npi)=PHEP(4,loop)
          evis=evis+PHEP(4,loop)
         endif
*
        enddo
*
        jmode=1
        xjcut=real(radius)
*
        IF (.NOT.photoprod) THEN
C        IF (myil.ge.0) Then
C         ISTHEP(myil)=1 ! turn on the electron !
C        ENDIF
         evis=real(HZDISKIN(4))
         mass=HZDISKIN(4)
         if (evis.ne.0.) evis=sqrt(evis)
        ENDIF
*
C       call VZERO(P,5*nmxhep)
        do i=1,nmxhep
         p(1,i)=0.
         p(2,i)=0.
         p(3,i)=0.
         p(4,i)=0.
        enddo
*
        if (lp) then
         write(6,*) ' calling jade evis= ',evis
         write(6,*) ' xjcut= ',xjcut,' jmode= ',jmode
        endif
*
        call jclust(evis,xjcut,jmode,npi,Pi,Np,P)
C       call jadejet(dpi,npi,radius,mass,1,1,np,dp)
*
        if (lp) then
         do i=1,np
          write(6,'(i3,a,4f9.3)') i,' e,px,py,pz= ',
     &    real(p(4,i)),real(p(1,i)),real(p(2,i)),real(p(3,i))
         enddo
        endif
*
*       sort jets in Et
*
        do i = 1, np
         do j = (i+1), np
          etjeti = sqrt( p(1,i)**2 + p(2,i)**2 )
          etjetj = sqrt( p(1,j)**2 + p(2,j)**2 )
          if( etjetj.gt.etjeti )then
           do k = 1, 4
            help   = p(k,i)
            p(k,i) = p(k,j)
            p(k,j) = help
           enddo
          endif
         enddo ! j
        enddo ! i
*
	DO loop=1,np
  	 px=dble(P(1,loop))
  	 py=dble(P(2,loop))
  	 pz=dble(P(3,loop))
         ptsq=px**2+py**2
         ppsq=(SQRT(ptsq+pz**2)+ABS(pz))**2
         IF (ptsq.le.4.25E-18*ppsq) THEN
          rap=20.
         ELSE
          rap=0.5*LOG(ppsq/ptsq)
         ENDIF
         rap=SIGN(rap,pz)
         IF (ptsq.EQ.0.) THEN
          phi=0.
         ELSE
          phi=ATAN2(py,px)
         ENDIF
	 Et=P(4,loop)*SQRT(ptsq/(ptsq+pz**2))
         Jets(loop,1)=rap
         Jets(loop,2)=phi
         Jets(loop,3)=et
         Jets(loop,4)= dble(P(4,loop))
         Jets(loop,5)= dble(P(1,loop))
         Jets(loop,6)= dble(P(2,loop))
         Jets(loop,7)= dble(P(3,loop))
         Jets(loop,8)= dble(P(5,loop))
C        write(6,*) loop,' Jets= ',Jets(loop,4),Jets(loop,3),
C     &                                Jets(loop,2),Jets(loop,1)
	ENDDO
        NUMJETS=np
*
C ---   end JADE stuff
       ELSEIF (jetf.eq.6) THEN
C ---   start stuff
*	do not use this space as it is referenced by JCLUST(photoprod.)
C ---   end stuff
          ELSEIF (jetf.eq.7) THEN
c --- start PUCELL stuff
           npi=0
           DO loop=1,NHEP
            IF (ISTHEP(loop).eq.1) THEN
             npi=npi+1
             PucellP(1,npi+100)=PHEP(1,loop)
             PucellP(2,npi+100)=PHEP(2,loop)
             PucellP(3,npi+100)=PHEP(3,loop)
             PucellP(4,npi+100)=PHEP(4,loop)
            endif
           enddo
           Operation(1)=0.9     ! Et
           Operation(2)=REAL(CONER)   ! cone
           Operation(3)=REAL(CONER)   ! cone
           Operation(4)=20      ! Number of iterations
           Operation(5)=0.75    ! fraction energy to merge
           EnergyCuts(1)=0.05   !
           EnergyCuts(2)=0.10   !
           ENERGYCUTS(3)=0.50   ! (Seed)
           CALL Had_to_HCM(npi)
           call pacellgp(Operation,EnergyCuts,NrClus,
     +     IErr,npi)
           IF (Ierr.gt.0) PRINT*,'HZJTFIND : PUCELL error ',Ierr
           IF (NJET1.gt.MAXHZJETS) THEN
              NUMJETS=MAXHZJETS
            ELSE
              NUMJETS=NJET1
            ENDIF
             DO loop=1,NUMJETS
             Jets(loop,1)=dble(PGJET1(loop,6))  ! eta
             Jets(loop,2)=dble(PGJET1(loop,11))  ! phi
             Jets(loop,3)=dble(PGJET1(loop,10))  ! Et
             Jets(loop,4)=dble(PGJET1(loop,4))  ! E
             Jets(loop,5)=dble(PGJET1(loop,1))  ! px
             Jets(loop,6)=dble(PGJET1(loop,2))  ! py
             Jets(loop,7)=dble(PGJET1(loop,3))  ! pz
             Jets(loop,8)=dble(0.0) ! m
            ENDDO
c --- end PUCELL stuff
c --- start PXCONE (pt mode)

       ELSEIF (jetf.eq.8) THEN

c --- prepare pxcone call
       MODE=2
       EPSLON=4.0D0
       OVLIM=7.5D-1
*
       count=0
       DO loop=1,NHEP
*     skip unstable particles and scattered lepton
	IF (ISTHEP(loop).eq.1) THEN
c           drad = sqrt( PHEP(1,loop)**2+PHEP(2,loop)**2
c     &                 +PHEP(3,loop)**2 )
c           if( drad.le.0.D0 ) then
c              if (lp) write(6,*) cxxxx, 'drad = ',drad
c           else
              IF (count.eq.MXTRK) THEN
                 write(6,*) cxxxx,'Too many particles for PXCONE',count
                 GOTO 165
              ELSE
                 count=count+1
                 PTRAK(1,count)=PHEP(1,loop)
                 PTRAK(2,count)=PHEP(2,loop)
                 PTRAK(3,count)=PHEP(3,loop)
                 PTRAK(4,count)=PHEP(4,loop)
                 ref(count)=loop
              ENDIF
c           endif
	ENDIF
       ENDDO
 165    CONTINUE
       NTRAK=count
*
       do loop = 1, MXTRAK
          ipass(loop) = 0
       enddo

c --- do pxcone call
       CALL PXCONE (MODE,NTRAK,ITKDM,PTRAK,CONER,EPSLON,OVLIM,
     &		MXJET,injet,PJET,IPASS,IJMUL,IERR)
       IF (IERR.ne.0) THEN
	write(6,*) cxxxx, 'PXCONE returns error'
       ENDIF
       IF (injet.gt.MXJET) THEN
        write(6,*) cxxxx, 'Too many jets found, increase MXJET',njet
       ENDIF

c --- get output

       IF (injet.gt.MAXHZJETS) THEN
        NUMJETS=MAXHZJETS
       ELSE
        NUMJETS=injet
       ENDIF
*
       DO loop=1,NUMJETS
	px=PJET(1,loop)
	py=PJET(2,loop)
	pz=PJET(3,loop)

        ptsq=px**2+py**2

        ppsq=(SQRT(ptsq+pz**2)+ABS(pz))**2
        IF (ptsq.le.4.25E-18*ppsq) THEN
         eta=20.D0
        ELSE
         eta=0.5*LOG(ppsq/ptsq)
        ENDIF
        eta=SIGN(eta,pz)

        IF (ptsq.EQ.0.D0) THEN
         phi=0.D0
        ELSE
         phi=ATAN2(py,px)
        ENDIF
*
*	Et=PJET(4,loop)*SQRT(ptsq/(ptsq+pz**2))
	Et=SQRT(ptsq)
      	Jets(loop,1)=eta  ! eta
       	Jets(loop,2)=phi  ! phi
      	Jets(loop,3)=Et   ! Et
      	Jets(loop,4)=PJET(4,loop)  ! E
      	Jets(loop,5)=PJET(1,loop)  ! px
      	Jets(loop,6)=PJET(2,loop)  ! py
      	Jets(loop,7)=PJET(3,loop)  ! pz
      	Jets(loop,8)=0             ! m
       Enddo
*
       DO loop=1,ntrak
          iJetNo(ref(loop))=IPASS(loop)
       ENDDO

c --- copy common variables to argument variables
      iArgNJts=NUMJETS
      do loop=1,NUMJETS
         do loop2=1,8
            ArgJets(loop,loop2)=JETS(loop,loop2)
         enddo
      enddo

c END of pxcone (pt mode)

       ELSE
C ---   user jet finders
C ---   comments for user additions:
C ---   1. use tracks from HEPEVTP
C ---   2. return jets in highest Energy first order.
C ---   3. update HZJTNAME
	PRINT*,'HZJTFIND : User jet finder called but not defined'
C ---   end user jet finders
      ENDIF


c --- copy common variables to argument variables
      iArgNJts=NUMJETS
      do loop=1,NUMJETS
         do loop2=1,8
            ArgJets(loop,loop2)=JETS(loop,loop2)
         enddo
      enddo


C --- finish off HZJETCMN

C --- turn the electron on again so that we haven't modified anything
*
      if (lp) write(6,*) '**hzjtfind: end myil= ',myil
*
      IF (myil.ge.0) Then
       ISTHEP(myil)=1
      ENDIF

      Return
      End
*CMZ :  1.01/07 10/10/97  19.47.29  by  Tancredi Carli
*-- Author :
      subroutine HZPARTON(npart,plist)
****************************************************************************
*
*
* purpose: this routine returns a list of the partons (plist)
*          in the HEP-common and their number (npart).
*
* Lepto uses the string hadronisation model (with soft colour interactions).
* Regarded as Partons are the mothers of strings and clusters and
* stable particles of the proton remnant (including resonances).
*
* If Lepto is run in the ARIADNE-modus it uses colour dipole for parton
* showers.
* A list of possible mothers for mothers of clusters and strings is created.
* The daughters of these particles (the string/cluster mothers!) and
* stable particles of the proton remnant are included in the partonlist.
*
* HERWIG: uses cluster hadronization. A list of partons in the
* parton showering is provided.
* It is instructive to have a look at a typical event bank-printout and
* perhaps the HERWIG-manual!
*
* the routine asks for generator type(logical:lepto,ariadne,herwig).
* If other generators are used and if parameters are changed it has to be
* adjusted to the applied generator and hadronisation sequence
* (strings,cluster) and the steering card!
*
* written by: Reimer Selle (rselle@rec06.desy.de)
*
****************************************************************************
      IMPLICIT NONE
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZHBOOK.
*
* Function declarations for Hbook functions
*
          Real HSTATI,HMAX,HMIN,HSUM,HI,HIJ,HX,HXY
          Real HIE,HXE,HIF
          Logical HEXIST
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      Integer plist(nmxhep),npart,imot,motlist(nmxhep)
      Integer zero,start
      Integer iflag,ihep,i,j,k,l
      Integer iel,idum,ierr,ibeam,ee,eb
      Parameter (ee=27.6)
*     DESY Preprint number
      Character*6 xxxx
      Data xxxx/'parton'/

*
      Real pi,dpi,rd
      Logical lp
      Data lp/.false./
      Parameter (pi=3.1415927,dpi=2.*pi,rd=180./pi)
*

       Logical lepto,ariadne,herwig
       Integer moth1,moth2
       Integer istring,icluster
*
*********************************************************************
*
*
*
*                                      'pre-check' for generated events
       iel=HZIDELEC(idum)
       if (iel.eq.-1) then
        write(6,*) 'Hz'//xxxx,' electron not found '
        goto 9990
       endif


*
       ierr=HZIBEAM(ibeam,idum)
       if (.not.(ierr.eq.1)) then
        write(6,*) 'HZ'//xxxx,' beams not found ! '
        goto 9990
       endif
*
       eb=real(PHEP(4,idum))
       if (abs(abs(eb)-ee).gt.0.2) then
        write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,'  ! '
        goto 9990
       endif

*                                    all initial values set to 0
       moth1=0
       moth2=0
       icluster=0
       istring=0
       npart=0
C*TC>
C      call vzero(plist,nmxhep)
       do i=1,nmxhep
        plist(i)=0
       enddo
C*TC<
*                                    LEPTO-sequence
      if (GEN(1:3).eq.'LEP') then
       lepto=.true.
      endif

      IF (lepto) then

       Do 2000 ihep=1,nhep
*                               find mothers of strings and clusters

       if ((IDHEP(ihep).eq.91).or.(IDHEP(ihep).eq.92)) then
         moth1= JMOHEP(1,ihep)
         moth2= JMOHEP(2,ihep)

         if (IDHEP(ihep).eq.92) istring=ihep
         if (IDHEP(ihep).eq.91) icluster=ihep

         if (moth2.lt.moth1) then
          write(*,*)'Hzparton: moth2<moth1!'
          goto 2000
         endif
*                                 put partons in plist

          do k=moth1,moth2
*                                 avoid fake-mothers!
*
          if (JDAHEP(1,k).eq.istring.or.JDAHEP(1,k).eq.icluster) then
           npart=npart+1
           plist(npart)= k
           if (lp) write(*,*)'plistnpart',plist(npart)
          endif
          enddo
           if(lp) write(*,*)'npart:',npart
        endif

*                                    put undecayed particles with mother=2
*                                    (proton) in plist

         if (JMOHEP(1,ihep).eq.2.and.ISTHEP(ihep).eq.1) then
          npart=npart+1
          plist(npart)=ihep
         endif

*                                    add resonances
*               --> particles coming from beam proton, decaying (at least
*                   partially)into stable particles
*                   e.g. Delta+ -->p+ + pi0
         if (JMOHEP(1,ihep).eq.2.and.ISTHEP(ihep).eq.2) then
*                                    skip gammas,gluons
          if (IDHEP(ihep).eq.21.or.IDHEP(ihep).eq.22) goto 2000
*                                    skip quarks,diquarks
          j=abs(IDHEP(ihep))
          if (j.le.6.and.j.ne.0) goto 2000
          if (j.eq.2203.or.j.eq.1103.or.j.eq.2101.or.j.eq.3201.or.
     &        j.eq.3203.or.j.eq.3103.or.j.eq.3101) goto 2000

           npart=npart+1
           plist(npart)=ihep
         endif

2000     continue
*                                   Terminate lepto-seq.
      ENDIF
*                                    ARIADNE-Sequence
       if (GEN(1:3).eq.'ARI') then
        ariadne=.true.
       endif

       if (ariadne) then
C*TC>
        imot=0
C        call vzero(motlist,nmxhep)
        do i=1,nmxhep
         motlist(i)=0
        enddo
C*TC<
        do 3000 ihep=1,nhep
*                                    skip documentation,beam particles
        if (ISTHEP(ihep).ne.3.and.ISTHEP(ihep).ne.201)then

*                                    Find particles without mother
*                                    or coming from beam proton and put
*                                    them in motlist

         if (JMOHEP(1,ihep).eq.0.or.JMOHEP(1,ihep).eq.2) then
          imot=imot+1
          motlist(imot)=ihep
         endif

*                                    put undecayed particles with mother=2
*                                    (proton) in plist

         if (JMOHEP(1,ihep).eq.2.and.ISTHEP(ihep).eq.1) then
          npart=npart+1
          plist(npart)=ihep
         endif
        endif
*                                    no partons in hep-common after
*                                    first string

         if (IDHEP(ihep).eq.92) istring=ihep
         if (istring.ne.0) goto 3100
3000     continue
3100     continue

          if (lp) then
           do i=1,imot
            write(*,*) i,'**motlist',motlist(i)
           enddo
          endif
*                                add particles with mother in motlist
        if (imot.ne.0) then
         do ihep=1,nhep
          do i=1,imot
          if (JMOHEP(1,ihep).eq.motlist(i)) then
           npart=npart+1
           plist(npart)=ihep
          endif
          enddo
         enddo
        endif
*                                      Terminate Ariadne-seq.
      ENDIF

*                                      Begin HERWIG-SEQUENCE
      if (GEN(1:3).eq.'HRW') then
       herwig=.true.
      endif

      IF (herwig) then
*                                      set initial values to 0
       npart=0
C*TC>
C      call vzero(plist,nmxhep)
       do i=1, nmxhep
        plist(i)=0
       enddo
C*TC<
       do 4000 ihep=4,nhep
*                                      start at 4 according to actual
*                                      particle listing in herwig.
*                                      (ihep=1-3:initial state)
*                                      for the meanings of the different
*                                      ISTHEPs -->herwig-manual!

*                                      no partons after parton shower
        if (ISTHEP(ihep).gt.144) goto 4100
*                                      get partons!
         if (ISTHEP(ihep).eq.2) then
          npart=npart+1
          plist(npart)=ihep
         endif
 4000    continue
 4100    continue

*                                Terminate HERWIG
       ENDIF


       if(lp) Write(*,*)'npartfin=',npart

*                                 check on correct hadronisation
        if(lp) Write(*,*)'istring=',istring
       if (GEN(1:3).eq.'LEP') then
        if (lp.and.istring.eq.0) write(*,*)'No string found in event'
       endif
9990  continue

      RETURN
      END
*CMZ :  2.00/02 08/10/99  12.32.15  by  Tancredi Carli
*CMZ :  1.01/11 31/12/97  14.45.54  by  Tancredi Carli
*CMZ :  1.01/07 02/10/97  17.09.02  by  Tancredi Carli
*-- Author :
	Subroutine HZHEPTOP
*****************************************************************************
*
* This routine replaces the HEP-Common with the partons within(also
* including beams,scattered lepton and docu-Z0).
*
* For HERWIG some other particles are also included because of the different
* event history, but they are irrelevant for further processing.
*
* The purpose is to calculate quantities on the partonic level.
* To avoid difficulties in the use within other routines (which usually
* access the stable hadrons in the HEP-Common) the status of the partons
* is switched from 2(unstable/decayed) to 1(undecayed).
*
* The used partonlist is produced by Hzparton(npart,plist), which can be
* tested with hzpscon(iflag) on conservation of transversal momentum and
* s.
*
*  written by: Reimer Selle (rselle@rec06.desy.de)
*****************************************************************************
*
*
	IMPLICIT NONE
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*

*                                          subroutine-related var.
*                                          -----------------------
      Integer plist(nmxhep)
      Integer ihep,i,j,k,l,npart,lastp
      Integer iel,idum
*                                          test-variable
      Logical lp,part
      Data lp/.false./
      Logical first
      Data first/.true./

*********************************************************************
*
       if (first) then
        first=.false.
        write(6,*) '**hzheptop: run on partons only ! '
       endif
*
       lastp=0
*                                      get partonlist
       call hzparton(npart,plist)
       if (lp) write(*,*)'HEPP npart:',npart
*                                      find last parton in hep-common
       do i=1,npart
        if (plist(i).gt.lastp) then
         lastp=plist(i)
        endif
       enddo

       if (lp) write(*,*)'last parton:',lastp
       if (lp) then
        do i=1,npart
         write(*,*)'plist:',plist(i)
        enddo
       endif

       NEVHEP=0
*                                      erase informations after partons
       do 1000 ihep=lastp+1,nhep
        ISTHEP(ihep)=0
        IDHEP(ihep)=0
        JMOHEP(1,ihep)=0
        JMOHEP(2,ihep)=0
        JDAHEP(1,ihep)=0
        JDAHEP(2,ihep)=0

        do j=1,5
         PHEP(j,ihep)=0.
        enddo
        do k=1,4
         VHEP(k,ihep)=0.
        enddo
 1000	continue

*                                      find scattered electron
       iel=HZIDELEC(idum)

*                                      find remaining non-partons and
*                                      erase them!
        do 2000 ihep=iel+1,lastp
         part=.false.
         do j=1,npart
          if (ihep.eq.plist(j)) then
           part=.true.
           goto 2000
          endif
         enddo

         if (.not.part) then

          ISTHEP(ihep)=0
          IDHEP(ihep)=0
          JMOHEP(1,ihep)=0
          JMOHEP(2,ihep)=0
          JDAHEP(1,ihep)=0
          JDAHEP(2,ihep)=0
*
          do j=1,5
           PHEP(j,ihep)=0.
          enddo
          do k=1,4
           VHEP(k,ihep)=0.
          enddo
         endif
 2000	continue
*                                compress COMMON

        nhep=lastp

3000    continue

        do i=iel+1,lastp
         if (IDHEP(i).eq.0) then
          nhep=nhep-1
          do k=i,lastp-1
           ISTHEP(k)=ISTHEP(k+1)
           IDHEP(k)=IDHEP(k+1)
           JMOHEP(1,k)=JMOHEP(1,k+1)
           JMOHEP(2,k)=JMOHEP(2,k+1)
           JDAHEP(1,k)=JDAHEP(1,k+1)
           JDAHEP(2,k)=JDAHEP(2,k+1)
           do j=1,5
            PHEP(j,k)=PHEP(j,k+1)
           enddo
           do j=1,4
            VHEP(j,k)=VHEP(j,k+1)
           enddo
          enddo
         endif
        enddo
*
        do i=iel+1,nhep
         if (IDHEP(i).eq.0) goto 3000
        enddo
*
*                                 stabilize partons
*                                 the partons should be the only decayed
*                                 particles left in the Common!
        do k=1,nhep
         if (ISTHEP(k).eq.2) then
          ISTHEP(k)=1
         endif
        enddo

        if (lp) write(*,*)'final nhep:',nhep
       END
*CMZ :  1.01/15 15/05/98  09.57.45  by  Tancredi Carli
*CMZ :  1.01/11 20/11/97  13.57.45  by  Tancredi Carli
*CMZ :  1.01/10 03/11/97  16.49.01  by  Tancredi Carli
*CMZ :  1.01/07 10/10/97  19.51.17  by  Tancredi Carli
*-- Author :
	Subroutine HZpscon(iflag)
*****************************************************************************
*
* This routine checks transversal momentum and s(cmsen) conservation
* in generated events on the parton level.
*
* produced histogramms: 10 relative error of calc. cmsen to actual s
*                       11 relative error of x-momentum
*                       12 relative error of y-momentum
*
* Arguments: iflag=1 initialisation
*            iflag=2 filling
*            iflag=3 termination
*
*
*  written by: Reimer Selle (rselle@rec06.desy.de)
*****************************************************************************
*
*
	IMPLICIT NONE
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*

*                                          subroutine-related var.
*                                          -----------------------
      Integer plist(nmxhep)
      Integer iflag,ihep,i,j,k,l,npart,entry
      Data entry/0/
*     DESY Preprint number
      Character*4 xxxx
      Data xxxx/'psco'/
      character*40 string
      Integer iel,idum,ierr,ibeam,ee,eb
      Parameter (ee=27.6)
*                                          kinetic variables and
*                                          errors
      Double precision px,py,pz,en,cmsen,mass2
      real ser,perx,pery
*                                          normalization-var.
      Integer nev
      Real rnev,norm
*                                          test-variable
      Logical lp,test
      Data lp/.false./
      Data test/.true./

*********************************************************************
*
*                      Initialization
*
*********************************************************************
*
      IF (iflag.eq.1) then
*
*
*      Initialisation: The following MUST always be done
*      (i) make subdirectory in PAWC
*       - use the name as the xxxxxx in HZxxxxxx subroutine
*      (i) make subdirectory in o/p file
*
       Call hcdir('//PAWC',' ')
       call hmdir(xxxx,'S')
       Call hcdir('//HISTO',' ')
       call hmdir(xxxx,'S')

*                                         book generator histos

       call hbook1(10,'rel. error in s(cmsen) in %',40,-1.,1.,0.)
       call hbook1(11,'rel. error in px in %',40,-1.,1.,0.)
       call hbook1(12,'rel. error in py in %',40,-1.,1.,0.)
*
*********************************************************************
*
*                      Event Processing
*
*********************************************************************

       ELSE IF(iflag.eq.2) then

*      Filling: The following MUST always be done
*      (i) move to the correct sub-directory in PAWC
*
       call hcdir('//PAWC/'//xxxx,' ')

*                                      center-of-mass energy for 1993/94
*                                      HERA-runnings
       cmsen=4.*ee*820.
*
       entry=entry+1
*

       iel=HZIDELEC(idum)
       if (iel.eq.-1) then
        write(6,*) 'Hz'//xxxx,' electron not found '
        goto 9990
       endif

*                                      'pre-check' for generated events
*
       ierr=HZIBEAM(ibeam,idum)
       if (.not.(ierr.eq.1)) then
        write(6,*) 'HZ'//xxxx,' beams not found ! '
        goto 9990
       endif
*
       eb=real(PHEP(4,idum))
       if (abs(abs(eb)-ee).gt.0.2) then
        write(6,*) 'HZ'//xxxx,' Electron beam not at ',ee,'  ! '
        goto 9990
       endif


       call hzparton(npart,plist)
        px=0.
        py=0.
        pz=0.
        en=0.
        mass2=0.

*                                     get total parton 4-vector
       do ihep=1,npart
         px= PHEP(1,plist(ihep))+ px
         py= PHEP(2,plist(ihep))+ py
         pz= PHEP(3,plist(ihep))+ pz
         en= PHEP(4,plist(ihep))+ en
        enddo

*                                   check transversal momentum conservation
        perx=((-abs(PHEP(1,iel))+abs(px))/abs(PHEP(1,iel)))*100
        pery=((-abs(PHEP(2,iel))+abs(py))/abs(PHEP(2,iel)))*100

       call hf1(11,perx,1.)
       call hf1(12,pery,1.)
*                                    add lepton contribution 4-vector
         px= PHEP(1,iel)+ px
         py= PHEP(2,iel)+ py
         pz= PHEP(3,iel)+ pz
         en= PHEP(4,iel)+ en
*                                     compare with cmsen
        mass2=en**2-px**2-py**2-pz**2

       if (lp) write(6,*) 'Hz'//xxxx,': s=',cmsen
*                                     calculate relative error (ser)
       ser=((mass2-cmsen)/cmsen)*100
       call hf1(10,ser,1.)
       nev= nev+1
      if (test) then
       if (entry.le.10.or.abs(perx).gt.0.2.or.abs(pery).gt.0.2) then
        write(6,*)'*********ENTRY*********',entry
        write(6,*)'px/part =',px -PHEP(1,iel)
        write(6,*)'pxel=',PHEP(1,iel)
        write(6,*)'py/part =',py -PHEP(2,iel)
        write(6,*)'pyel=',PHEP(2,iel)
        write(6,*)'perx =',perx
        write(6,*)'pery =',pery
        write(6,*)'masse =',mass2
        write(6,*)'s-error =',ser
        do i=1,npart
         print*,i,'**plist:',plist(i)
        enddo
       endif
      endif
9990   continue	
*
*********************************************************************
*
*                      Termination
*
*********************************************************************

      Else if(iflag.eq.3) then

*      Termination: The following MUST always be done
*      (i) Move to the correct PAW subdirectory
*
       call hcdir('//PAWC/'//xxxx,' ')
*                                              Normalization
       if (lp) write(6,*)'events',nev
       rnev=real(nev)
       norm= 1/rnev

       call hopera (10,'+E',10,10,norm,0.)
       call hopera (11,'+E',11,11,norm,0.)
       call hopera (12,'+E',12,12,norm,0.)

       ENDIF

       RETURN

       END

*CMZ :  1.01/15 12/08/98  19.33.39  by  Tancredi Carli
*-- Author :
      Subroutine HzChisqa(iddatu,iddatl,idmc)
*********************************************************************
*                                                                   *
* HzChisqa                                                          *
* ========                                                          *
* Author: N Brook                                                   *
*                                                                   *
* Input arguments:                                                  *
* Iddatu - histogram ID of data (with upper syst error)             *
* Iddatl - Histogram ID of data (with lower syst error)             *
* Idmc   - Histogram ID of Monte Carlo                              *
*                                                                   *
* Output arguments:                                                 *
* none                                                              *
*                                                                   *
* Routine calculates Chi-sq between Iddat and Idmc and stores       *
* the Iddat, Chi-sq and NdoF in Ntuple 999 in each subdirectory     *
* If ID=999 doesn't exist this routine creates it                   *
*                                                                   *
* Limitations:  The number of bins and range of histograms Iddat    *
*               and idmc have to be an identical                    *
*                                                                   *
*********************************************************************
*
      Implicit None
*
      Integer Ndatpts
      Parameter(Ndatpts=1000)
      Real xdum(Ndatpts),exdum(Ndatpts),ydat(Ndatpts),eydat(Ndatpts)
      Real ymc(Ndatpts), eymc(Ndatpts)
      Real eydatu(Ndatpts), eydatl(Ndatpts)
      Real xmi,xma,ymi,yma
      Real xmj,xmb,ymj,ymb,chi
      Integer iddatu, iddatl, idmc, loc, nwt, ndof
      Integer nx, ny, nx1, ny1, ierr, Ichi, ndat
      Double Precision chi2
      Character*80 chtit
      Logical Hexist,lp
      Character*4 tags(3)
      Character rout*10
      Real evt(3)
      Data Tags/'id','chi2','ndof'/,rout/'hzchisq'/,lp/.false./
*
      If(.not.Hexist(999)) then
       Call Hbookn(999,' Chi sqaures',3,' ',100,Tags)
       if (lp) write(6,*) rout,' book ntuple 9999 '
      endif
*
      Call Hgive(iddatu,chtit,nx,xmi,xma,ny,ymi,yma,nwt,loc)
      Call Hgive(idmc,chtit,nx1,xmj,xmb,ny1,ymj,ymb,nwt,loc)
*
      Ierr=1
      If(nx1.ne.nx.or.
     +   xmi.ne.xmj.or.
     1   xma.ne.xmb) Then
        Write(6,*) rout,' Histos:',iddatu,
     +             ' and ',idmc,' are different ! '
        Return
      Endif
      Call Hgive(iddatl,chtit,nx,xmi,xma,ny,ymi,yma,nwt,loc)
*
      If(nx1.ne.nx.or.
     +   xmi.ne.xmj.or.
     1   xma.ne.xmb) Then
        Write(6,*) rout,' Histos:',iddatl,
     +             ' and ',idmc,' are different ! '
        Return
      Endif
      Ierr = 0
*
      Call Hrebin(iddatu,xdum,ydat,exdum,eydatu,nx,1,nx)
      Call Hrebin(iddatl,xdum,ymc,exdum,eydatl,nx,1,nx)
      Call Hrebin(idmc,xdum,ymc,exdum,eymc,nx,1,nx)
*     Call Hunpak(idmc,ymc,' ',0)
*
      chi = 0.0
      ndat = 0
      Do Ichi = 1, Nx
        eydat(ichi) = eydatu(ichi)
        If(ymc(ichi).lt.ydat(ichi)) eydat(ichi) = eydatl(ichi)
        If(eydat(ichi).gt.0.0) Then
          if (eymc(ichi)**2+eydat(ichi)**2.ne.0.) then
           chi = chi + (ymc(ichi)-ydat(ichi))**2/
     1        (eymc(ichi)**2+eydat(ichi)**2)
          else
           chi=-999.
          endif
          ndat = ndat + 1
        Endif
      Enddo
      chi2 = dble(chi)
      evt(1) = real(iddatu)
      evt(2) = chi
      evt(3) = real(ndat)
      if (lp) then
       write(6,*) rout,' filling 999 = ',evt
      endif
      Call hfn(999,evt)
*
      Return
      End
*CMZ :  1.01/13 19/03/98  08.27.21  by  Hannes Jung
*-- Author :    Hannes Jung   19/03/98
      subroutine HZGAMAD
****************************************************************************
* Purpose: to add virtual gamma to event record for PYTHIA and POMPYT
* written by: Hannes Jung on 19/03/98
****************************************************************************
      IMPLICIT DOUBLE PRECISION(A-H, O-Z)
      INTEGER PYK,PYCHGE,PYCOMP
C...Commonblocks.
      COMMON/PYJETS/N,NPAD,K(4000,5),P(4000,5),V(4000,5)
      COMMON/PYDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
      COMMON/PYDAT2/KCHG(500,4),PMAS(500,4),PARF(2000),VCKM(4,4)
      SAVE /PYJETS/,/PYDAT1/,/PYDAT2/
*
      ISCAT = -999
* find scattered electron
      DO I=1,N
      IF(K(I,1).eq.1.and.abs(K(I,2)).eq.11) then
         iscat = I
	  endif
      ENDDO
      IF(ISCAT.GT.0) THEN
        DO J = 1,4
        P(N+1,J) = P(2,J) - P(ISCAT,J)
	 ENDDO
	 P(N+1,5) = P(N+1,4)**2 - P(N+1,1)**2 - P(N+1,2)**2 - P(N+1,3)**2
	 P(N+1,5) = -DSQRT(DABS(P(N+1,5)))
	 K(N+1,1) = 21
	 K(N+1,2) = 23
	 K(N+1,3) = 1
	 N = N+1
	 ENDIF
      RETURN
*
      END
*CMZ :  1.01/13 19/03/98  09.44.28  by  Hannes Jung
*-- Author :
C*********************************************************************

C...PYCOMP
C...Compress the standard KF codes for use in mass and decay arrays;
C...also checks whether a given code actually is defined.

      FUNCTION HZPYCOMP(KF)

C...Double precision and integer declarations.
      IMPLICIT DOUBLE PRECISION(A-H, O-Z)
      INTEGER HZPYCOMP
C...Commonblocks.
      COMMON/PYDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
      COMMON/PYDAT2/KCHG(500,4),PMAS(500,4),PARF(2000),VCKM(4,4)
      SAVE /PYDAT1/,/PYDAT2/
C...Local arrays and saved data.
      DIMENSION KFORD(100:500),KCORD(101:500)
      SAVE KFORD,KCORD,NFORD,KFLAST,KCLAST

C...Whenever necessary reorder codes for faster search.
      IF(MSTU(20).EQ.0) THEN
        NFORD=100
        KFORD(100)=0
        DO 120 I=101,500
          KFA=KCHG(I,4)
          IF(KFA.LE.100) GOTO 120
          NFORD=NFORD+1
          DO 100 I1=NFORD-1,0,-1
            IF(KFA.GE.KFORD(I1)) GOTO 110
            KFORD(I1+1)=KFORD(I1)
            KCORD(I1+1)=KCORD(I1)
  100     CONTINUE
  110     KFORD(I1+1)=KFA
          KCORD(I1+1)=I
  120   CONTINUE
        MSTU(20)=1
        KFLAST=0
        KCLAST=0
      ENDIF

C...Fast action if same code as in latest call.
      IF(KF.EQ.KFLAST) THEN
        HZPYCOMP=KCLAST
        RETURN
      ENDIF

C...Starting values.
      HZPYCOMP=0
      KFA=IABS(KF)

C...Simple cases: direct translation.
      IF(KFA.GT.KFORD(NFORD)) THEN
      ELSEIF(KFA.LE.100) THEN
        HZPYCOMP=KFA

C...Else binary search.
      ELSE
        IMIN=100
        IMAX=NFORD+1
  130   IAVG=(IMIN+IMAX)/2
        IF(KFORD(IAVG).GT.KFA) THEN
          IMAX=IAVG
          IF(IMAX.GT.IMIN+1) GOTO 130
        ELSEIF(KFORD(IAVG).LT.KFA) THEN
          IMIN=IAVG
          IF(IMAX.GT.IMIN+1) GOTO 130
        ELSE
          HZPYCOMP=KCORD(IAVG)
        ENDIF
      ENDIF

C...Check if antiparticle allowed.
      IF(HZPYCOMP.NE.0.AND.KF.LT.0) THEN
        IF(KCHG(HZPYCOMP,3).EQ.0) HZPYCOMP=0
      ENDIF

C...Save codes for possible future fast action.
      KFLAST=KF
      KCLAST=HZPYCOMP

      RETURN
      END
*CMZ :  1.01/15 02/09/98  14.06.34  by  Tancredi Carli
*-- Author :
      SUBROUTINE HZHADGAP(xmas,ymas,xpom,t)
      IMPLICIT NONE
* Reconstruct the hadronic final state at the
* (generated)  hadron level following the H1 definition of diffraction
* presented at  Eilat 1995. In this scheme the hadronaic final state is
* separated into two systems ep--->eXY where X (the diffractive system) and
* Y (the proton dissociation system) are separated by the largest gap in
* rapidity in the event. This definition works for all processes and
* diffractive and non-diffractive.
* GAP NOW FOUND IN GAMMA PROTON CMS SYSTEM
*
* New ! Two systems X and Y are collected into two 4-vectors
* PMX and IPMY
*   GAGOBJ = 1 if object in X
*   GAGOBJ = 2 if object in Y
*   GAGOBJ = 0 Problem !
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
      Double precision pbeam(4),pgam(4),pcm(5),ph(5),pboost(5,NMXHEP)
      Double precision pmx(5),pmy(5),pstore(5,nmxhep)
*
      Integer i,ihep
      Real pi,rd,eb,ee
      Parameter (ee=27.5)
      Integer iel,idum,ip,ie
      Parameter (pi=3.1415927,rd=180./pi)
* Also Complete 4-vector of hadronic final state is given
* maximum number of objects in event
      REAL DUM,GAPTEST
      LOGICAL FLAG
      Integer max_nobj,max_gobj,iobj,ibobj,ierr,iog,ii,k,iround
      Integer nogag,npgag,nngag
      real gagobj,etamx,etamy,rapgug,rapglg,grapg,gapg
      real etamyg,etamxg,eyg,pxyg,pyyg,pzyg,pxxg,pyxg,pzxg,exg
      real smygag,smxgag,fac,ptchk,small
      Parameter (small=1.e-3)
      Real x,y,q2
      Double precision ehg,pxhg,pyhg,pzhg
      PARAMETER(MAX_GOBJ=5000)
      PARAMETER(MAX_NOBJ=5000)
      DIMENSION IOBJ(MAX_NOBJ),IBOBJ(MAX_NOBJ),GAGOBJ(MAX_NOBJ)
      REAL ARR(4)
      DOUBLE PRECISION EXGD,PXXGD,PYXGD,PZXGD
      DOUBLE PRECISION EYGD,PXYGD,PYYGD,PZYGD
      DOUBLE PRECISION EHGD,PXHGD,PYHGD,PZHGD
*
      Real xmas,ymas,t,xpom
      Real mxgag,mygag
*
      double precision qp,qx,qy,qz,qe,qm,qch,qth,qrap
      Integer ki
      double precision qpb,qxb,qyb,qzb,qeb,qmb,qthb,qrapb
* common that gives the position of particles in X and Y system
      integer nxobj,nyobj,nxgag,nygag
      double precision pom
      common /diffhad/pom(5),nxobj(5000),nyobj(5000),nxgag,nygag

      QP  (KI)=PHEP(4,KI)
      QX  (KI)=PHEP(1,KI)
      QY  (KI)=PHEP(2,KI)
      QZ  (KI)=PHEP(3,KI)
      QE  (KI)=PHEP(4,KI)
      QM  (KI)=PHEP(5,KI)
      QCH (KI)=Ihchrg(KI)
      QPB  (KI)=Pboost(4,KI)
      QXB  (KI)=Pboost(1,KI)
      QYB  (KI)=Pboost(2,KI)
      QZB  (KI)=Pboost(3,KI)
      QEB  (KI)=Pboost(4,KI)
      QMB  (KI)=Pboost(5,KI)

      QTH(KI)=DACOS(QZ(KI)/DMAX1(QP(KI),DABS(QZ(KI))))
      QRAP(KI)=0.5D0*(DLOG(DMAX1(0.0000001D0,QE(KI)+QZ(KI))) -
     +              DLOG(DMAX1(0.0000001D0,QE(KI)-QZ(KI))))
      QTHB(KI)=DACOS(QZB(KI)/DMAX1(QPB(KI),DABS(QZB(KI))))
      QRAPB(KI)=0.5D0*(DLOG(DMAX1(0.0000001D0,QEB(KI)+QZB(KI))) -
     +              DLOG(DMAX1(0.0000001D0,QEB(KI)-QZB(KI))))
      do i=1,nhep
         do k=1,5
            pstore(k,i)=phep(k,i)
         enddo
      enddo
      MXGAG=0.0
      MYGAG=0.0
      T=0.0
      EHGD=0.0D0
      PXHGD=0.0D0
      PYHGD=0.0D0
      PZHGD=0.0D0
      EHG=0.0D0
      PXHG=0.0D0
      PYHG=0.0D0
      PZHG=0.0D0
      IOG =0
      do i=1,5
         pmx(i)=0.
         pmy(i)=0.
      enddo
      ierr=HZIBEAM(ip,ie)
      if (.not.(ierr.eq.1)) then
         write(6,*) 'HZHADGAP beams not found ! '
         return
      else
         Do i=1,4
            pbeam(i)=PHEP(i,ip)
         enddo
      endif
      ierr=HZIPGAM(ph)
      if (ierr.eq.-1) then
         write(6,*) 'HZHADGAP boson vector not found ! '
C        call VZERO(ph,5)
        Do i=1,5
         ph(i)=0.
        enddo
      else
         Do i=1,4
            pgam(i)=ph(i)
         enddo
      endif
*
      iel=HZIDELEC(idum)
      if (iel.eq.-1) then
         write(*,*) 'Hz electron not found '
         return
      endif
*
      call HZHCMINI(pbeam,pgam,ierr)
      if (ierr.eq.1) then
         write(6,*) 'HZHADGAP problem with boost to cms ! '
         return
      endif
*      call hzlulist(1)
      DO I=1,Nhep
*     Reject if not stable...
         IF(isthep(i).ne.1) GOTO 10
         if(iel.eq.i) goto 10
         if(ip.eq.i) goto 10
         if(ie.eq.i) goto 10
* fill an array with phan vetors of the hadronic final state
*   (used subsequently for sorting)
* do not select scattered electron
* JPP - 23/04/96 - Do not include Electron or Photon
         IF(IOG.LT.MAX_GOBJ)THEN
* Make 4-vector of hadronic final state
* Make complete hadronic final state 4 vector
            EHGD=EHGD+PHEP(4,I)
            PXHGD=PXHGD+PHEP(1,I)
            PYHGD=PYHGD+PHEP(2,I)
            PZHGD=PZHGD+PHEP(3,I)
* Boost vector into gamma*-proton cms
            Do ii=1,4
               Ph(ii)=PHEP(ii,i)
            enddo
            call HZHCM(ph,pcm,ierr)
            if (ierr.eq.1) then
               write(6,*) 'HZHADGAP problem with boost to cms ! '
               return
            endif
            Do ii=1,4
               pboost(ii,i)=pcm(ii)
            enddo
c revert z axis to coincide with rapidity definition
            pboost(3,i)=-pcm(3)
            IOG=IOG+1
            IOBJ(IOG)=I
            IBOBJ(IOG)=I
         ENDIF
   10    CONTINUE
      ENDDO
*      write(6,*) ' IOG ',IOG,(IOBJ(I),I=1,IOG)
      EHG=SNGL(EHGD)
      PXHG=SNGL(PXHGD)
      PYHG=SNGL(PYHGD)
      PZHG=SNGL(PZHGD)
      IROUND=0
   20 FLAG=.FALSE.
      IROUND=IROUND+1
      DO I=1,IOG-1
         IF(QRAPB(IBOBJ(I+1)).LT.QRAPB(IBOBJ(I))) THEN
* add a small piece to rapgug to avoid precision problems
*         IF(QRAPB(IBOBJ(I+1)).LT.(QRAPB(IBOBJ(I))+SMALL)) THEN
            DUM=IOBJ(I+1)
            IOBJ(I+1)=IOBJ(I)
            IOBJ(I)=DUM

            DUM=IBOBJ(I+1)
            IBOBJ(I+1)=IBOBJ(I)
            IBOBJ(I)=DUM

            FLAG=.TRUE.

         ENDIF
      ENDDO
      IF(IROUND.GE.10000) then
         WRITE(6,*) ' hzhadgap: Something wrong with eta sorting'
         write(6,*) ' hzhadgap: IOG = ',IOG
         write(6,*) ' hzhadgap: IOBJ = ',(IOBJ(i),i=1,iog)
         write(6,*) ' hzhadgap: QRAPB = ',(QRAPB(IOBJ(i)),i=1,iog)

*        call hzlulist(1)
      endif
      IF(FLAG.AND.IROUND.LE.10001) GOTO 20
* Find largest gap
      GAPG=0.0
      RAPGLG=-8.0
      RAPGUG=-8.0
      DO I=1,IOG-1
         GAPTEST=QRAPB(IBOBJ(I+1))-QRAPB(IBOBJ(I))
*        write(6,*) ' gaptest',gaptest,gapg,ibobj(i)
         IF(GAPTEST.GT.GAPG)THEN
            GAPG=GAPTEST
            RAPGLG=QRAPB(IBOBJ(I))
            RAPGUG=QRAPB(IBOBJ(I+1))
*          write(6,*) 'rapgug ',rapgug,ibobj(i)
            ETAMXG=-LOG(TAN(QTH(IOBJ(I))/2))
            ETAMYG=-LOG(TAN(QTH(IOBJ(I+1))/2))
            IF(ETAMYG.GT.99.0) ETAMYG=99.0
            IF(ETAMXG.GT.99.0) ETAMXG=99.0
            IF(ETAMYG.LT.-99.0) ETAMYG=-99.0
            IF(ETAMXG.LT.-99.0) ETAMXG=-99.0
         ENDIF
      ENDDO
* Make hadronic final state considering only those particles with ETA<ETAGL
* JPP - Make 4-vectors from these two systems for external use
*     pmx
*     pmy
      EXG=0.0
      PXXG=0.0
      PYXG=0.0
      PZXG=0.0

      NOGAG=0

      EYG=0.0
      PXYG=0.0
      PYYG=0.0
      PZYG=0.0

      NYGAG=0
      NXGAG=0
      SMXGAG=0.0
      SMYGAG=0.0

* JPP Double precision for construction of X and Y
      EXGD=0.D0
      PXXGD=0.D0
      PYXGD=0.D0
      PZXGD=0.D0
      EYGD=0.D0
      PXYGD=0.D0
      PYYGD=0.D0
      PZYGD=0.D0
* subtract a small piece to rapgug to avoid precision problems
      RAPGUG=RAPGUG-SMALL
*      write(6,*) 'rapgug ',rapgug
      DO I=1,IOG
*        write(6,*) ' qrapb,rapgug',QRAPB(IBOBJ(I)),RAPGUG,IBOBJ(I)
         IF(QRAPB(IBOBJ(I)).LT.RAPGUG)THEN
            DO K=1,5
               PMX(K)=PMX(K)+phep(K,IOBJ(I))
            ENDDO
            GAGOBJ(I) = 1
C Now double precision
            EXGD=EXGD+phep(4,IOBJ(I))
            PXXGD=PXXGD+phep(1,IOBJ(I))
            PYXGD=PYXGD+phep(2,IOBJ(I))
            PZXGD=PZXGD+phep(3,IOBJ(I))
* Total charges of tracks
            IF(QCH(IOBJ(I)).EQ.0) NOGAG=NOGAG+1
            IF(QCH(IOBJ(I)).GT.0) NPGAG=NPGAG+1
            IF(QCH(IOBJ(I)).LT.0) NNGAG=NNGAG+1
            NXGAG = NXGAG + 1
            nxobj(nxgag)=IOBJ(I)
* Workout invariant mass in a method that is less sensitive to rounding
* errors. It unfortunately requires going through the particles twice
            SMXGAG=SMXGAG+phep(5,IOBJ(I))**2
*           write(6,*) ' check mx ',iobj(I)
            DO II=1,IOG
               IF(QRAPB(IBOBJ(II)).LT.RAPGUG.AND.II.NE.I)THEN
                  SMXGAG=SMXGAG+ PHEP(4,IOBJ(I))*phep(4,IOBJ(II))-
     +            PHEP(3,IOBJ(I))*phep(3,IOBJ(II))- PHEP(2,IOBJ(I))*
     +            phep(2,IOBJ(II))- PHEP(1,IOBJ(I))*phep(1,IOBJ(II)
     +            )
               ENDIF
            ENDDO
         ELSE
            DO K=1,5
               PMY(K)=PMY(K)+phep(K,IOBJ(I))
            ENDDO
            GAGOBJ(I) = 2
* Now double precision
            EYGD=EYGD+phep(4,IOBJ(I))
            PXYGD=PXYGD+phep(1,IOBJ(I))
            PYYGD=PYYGD+phep(2,IOBJ(I))
            PZYGD=PZYGD+phep(3,IOBJ(I))
            NYGAG=NYGAG+1
            nyobj(nygag)=IOBJ(I)
* Workout invariant mass in a method that is less sensitive to rounding
* errors. It unfortunately requires going through the particles twice
*          SMYGAG=SMYGAG+phep(5,IOBJ(I))**2
*           write(6,*) ' check my ',iobj(I)
            DO II=1,IOG
               IF(QRAPB(IBOBJ(II)).GT.RAPGLG.AND.II.NE.I)THEN
                  SMYGAG=SMYGAG+ PHEP(4,IOBJ(I))*phep(4,IOBJ(II))-
     +            PHEP(3,IOBJ(I))*phep(3,IOBJ(II))- PHEP(2,IOBJ(I))*
     +            phep(2,IOBJ(II))- PHEP(1,IOBJ(I))*phep(1,IOBJ(II)
     +            )
               ENDIF
            ENDDO
         ENDIF
      ENDDO
* Make invariant masses of X and Y systems
      IF(SMXGAG.GT.0)THEN
         MXGAG = SQRT(SMXGAG)
      ELSE
         MXGAG = 0.0
      ENDIF
      IF(SMYGAG.GT.0)THEN
         MYGAG = SQRT(SMYGAG)
      ELSE
         MYGAG = 0.0
      ENDIF
*      write(6,*) ' mx',pmx(4)**2-pmx(1)**2-pmx(2)**2-pmx(3)**2
*      write(6,*) 'mxgag ',mxgag**2
*      write(6,*) ' my',pmy(4)**2-pmy(1)**2-pmy(2)**2-pmy(3)**2
*      write(6,*) 'mygag ',mygag**2

* Check masses
      IF(NYGAG.EQ.1) THEN
         DO I=1,IOG
            IF(GAGOBJ(I).EQ.2) THEN
               MYGAG = QM(IOBJ(I))
            ENDIF
         ENDDO
         IF(MYGAG.LT.0.1) MYGAG=0.1
      ENDIF
      IF(NXGAG.EQ.1) THEN
         DO I=1,IOG
            IF(GAGOBJ(I).EQ.1) THEN
               MXGAG = QM(IOBJ(I))
            ENDIF
         ENDDO
         IF(MXGAG.LT.0.1) MXGAG=0.1
      ENDIF
      PMX(5)=MXGAG
      PMY(5)=MYGAG
      ymas = mygag
      xmas = mxgag

* Get squared momentum transfer at proton vertex
      IF(ip.NE.0) THEN
         t =(phep(4,ip)-PMY(4))**2 -(phep(1,ip)-PMY(1))**2 -
     +   (phep(2,ip)-PMY(2))**2 -(phep(3,ip)-PMY(3))**2
*         t =phep(5,ip)**2 -
*     &    2.d0*(phep(4,ip)*PMY(4) - phep(1,ip)*PMY(1) -
*     &    phep(2,ip)*PMY(2) - phep(3,ip)*PMY(3)) + PMY(5)**2
      ELSE
         WRITE(6,*) 'No hadron beam particle'
         t = 0.0
      ENDIF


* Boost objects into gamma*-pom centre of mass system now that
* kinematics known
      q2=real(HZDISKIN(1))
      y =real(HZDISKIN(3))
      FAC = 4.*real(phep(4,ie))*real(phep(4,ip))*Y
      IF(FAC.GT.0.) THEN
* Create pseudo-pomeron = proton 4-vector * xpgag
* Create vector for "pomeron" = p - Y
         Do I=1,4
            pom(i) = phep(i,ip) - pmy(i)
         enddo

         xpom = (Q2+MXGAG**2-T)/FAC

      ENDIF
      if(xpom.lt.0.0.or.xpom.gt.1.) then
c       write(6,*) ' hzhadgap: xpom=',xpom,' t = ',t,' m_x=',xmas,ymas
c       write(6,*) ' hzhadgap: y=',y
c       write(6,*) ' hzhadgap: e-beam',real(phep(4,ie))
c       write(6,*) ' hzhadgap: p-beam',real(phep(4,ip))
         xpom=1.

      endif
*      write(6,*) ' hzhadgap: xpom=',xpom,' t = ',t,' m_x=',xmas,ymas
*      call hzlulist(1)
* Check PT
      PTCHK = SQRT((PXXG+PXYG)**2+(PYXG+PYYG)**2)
      do i=1,nhep
         do k=1,5
            phep(k,i)=pstore(k,i)
         enddo
      enddo
      RETURN
      END
*CMZ :  1.02/01 22/10/98  16.25.20  by  Tancredi Carli
*CMZ :  1.01/15 24/04/98  14.23.19  by  Tancredi Carli
*-- Author :
      subroutine hzbrtola(njets,jetsin,jetsout)
****************************************************
*                                                  *
* boost jets from Breit to Lab                     *
* Input: numjets number of jets                    *
* jetsin:  Jets in Breit frame                     *
* jetsout: jets in lab frame                       *
*                                                  *
* see ttjtfind for def of jets( , )                *
*                                                  *
* This routines assumes that the boost to the      *
* Breit frame has been done according to the       *
* convention in HZBRT not in KTBREI                *
* otherwise the component below have to be         *
* switched again                                   *
*                                                  *
****************************************************
      Implicit none
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZJETCMN.
*
*     MAXHZJETS: maxmial number of jet allowed
*     NUMJETS: number of jets from jet algo
*     NSEL  : number of selected jets
*     IPJET : pointer to selected jets
*     JETS  : Jet variables (eta,phi,et,e,px,py,pz,m) in choosen frame
*     IJETNO: pointer which objects in PHEP common belong to jets
*
      INTEGER MAXHZJETS
      PARAMETER (MAXHZJETS=50)
      INTEGER NSEL,NUMJETS,IPJET(MAXHZJETS),IJETNO(NMXHEP)
      DOUBLE PRECISION JETS(MAXHZJETS,8)
*
      COMMON /HZJETCMN/JETS,NUMJETS,NSEL,IPJET,IJETNO
*
*
*KEND.
*
      Integer i,j,k,ioff
      Logical lp
      Data lp/.false./
      DOUBLE PRECISION Jetsin(maxhzjets,8),Jetsout(maxhzjets,8)
      Character rout*13
      Data rout/'**hzbrtola'/
      Integer iel,idum,ierr,ibeam,njets
      DOUBLE PRECISION PLEP,PHAD,PEL(4),P(4,nmxhep)
      DOUBLE PRECISION empz,en,px,py,pz,rap,phi,pt
      DOUBLE PRECISION ETAMAX,EPS
      DATA ETAMAX,EPS/10,1E-6/
*
      if (lp) then
       write(6,*) rout,' njets= ',njets
      endif
*                     reset
      do i=1,nmxhep
       do j=1,4
        p(j,i)=0.
       enddo
      enddo
*
*     get electron and beams
*
      iel=HZIDELEC(idum)
      if (iel.eq.-1) then
       write(6,*) rout,' electron not found '
       return
      endif
*
      ierr=HZIBEAM(ibeam,idum)
      if (.not.(ierr.eq.1)) then
       write(6,*) rout,' beams not found ! '
       return
      endif
      Do i=1,4
       pel(i)=PHEP(i,iel)
      enddo
*
      ioff=0
*
      PHAD=PHEP(3,IBEAM)
      PLEP=PHEP(3,IDUM)
*
      if (PHAD.lt.800.) then
       write(6,*) ' Proton energy below 800 GeV'
       write(6,*) ' Please, make sure that you did not boost '
       write(6,*) ' the beam particles ! '
       write(6,*) ' -> The boost to the lab wil be wrong ! '
      endif
*
*     Now  boost beam and electron from lab to Breit
*     for test purposes only
      if (ioff.ne.0) then
       Do i=1,4
        p(i,1)=PHEP(i,IBEAM)
        p(i,2)=PHEP(i,IDUM)
        P(i,3)=PHEP(i,iel)
       enddo
       call KTBREI(2,plep,phad,pel,ioff,P,P,*99)
      endif
*
*     Now  boost jets from Breit to lab

      Do i=1,njets
       P(4,i+ioff)=jetsin(i,4)
C       P(1,i+ioff)=jetsin(i,5)
C       P(2,i+ioff)=jetsin(i,6)
       P(3,i+ioff)=jetsin(i,7)
       P(1,i+ioff)=-jetsin(i,5)
       P(2,i+ioff)=-jetsin(i,6)
      enddo
*
      if (lp) then
       write(6,'(a,4f9.3)') ' Pel= ',pel
       write(6,'(2(a,f9.3))') ' plep= ',plep,' phad= ',phad
       do j=1,njets+ioff
        write(6,'(i3,a,4f9.3)') j,' p= ',(p(i,j),i=1,4)
       enddo
      endif
*
      call KTBREI(3,plep,phad,pel,njets+ioff,P,P,*99)
*
C      if (lp) then
C       do j=1,njets+ioff
C        write(6,'(i3,a,4f9.3)') j,' q= ',(p(i,j),i=1,4)
C       enddo
C      endif
*
      do i=1,njets
       px=p(1,i+ioff)
       py=p(2,i+ioff)
       pz=p(3,i+ioff)
       en=p(4,i+ioff)
       pt=px**2+py**2
       empz=en**2-pz**2
*                 convert to eta a la KTCLUS (see ktmerg)
       IF (empz.LE.EPS*en**2) empz=pt
       IF (empz.GT.0.) THEN
        empz=0.5*LOG((en+ABS(pz))**2/empz)
        IF (empz.GT.ETAMAX) empz=ETAMAX+2.
       ELSE
        empz=ETAMAX+2.
       ENDIF
       rap=SIGN(empz,P(3,I+ioff))
       IF (px.NE.0.AND.py.NE.0) THEN
        phi=ATAN2(px,py)
       ELSE
        phi=0.
       ENDIF
*
       if (pt.gt.0) pt=sqrt(pt)
       Jetsout(i,1)=rap          ! eta
       Jetsout(i,2)=phi          ! phi
       Jetsout(i,3)=pt           ! Et
       Jetsout(i,4)=en           ! E
       Jetsout(i,5)=px           ! px
       Jetsout(i,6)=py           ! py
       Jetsout(i,7)=pz           ! pz
       Jetsout(i,8)=en**2-px**2-py**2-pz**2 ! m
       if (Jetsout(i,8).gt.0.) Jetsout(i,8)=sqrt(Jetsout(i,8))
*
      enddo
*
      if (lp) then
       do i=1,njets
        write(6,'(a,7(1x,f9.3))') 'jetsout= ',(jetsout(i,j),j=1,7)
       enddo
      endif
*
      return
 99   continue
      write(6,*) rout,' error on KTBREI ! '
      return
      end
*CMZ :  1.02/01 11/10/98  19.44.38  by  Hannes Jung
*-- Author :
C*********************************************************************

C...HZPCOMP
C...Compress the standard KF codes for use in mass and decay arrays;
C...also checks whether a given code actually is defined.

      FUNCTION HZPCOMP(KF)

C...Double precision and integer declarations.
      IMPLICIT DOUBLE PRECISION(A-H, O-Z)
      INTEGER HZPCOMP
C...Commonblocks.
      COMMON/PYDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
      COMMON/PYDAT2/KCHG(500,4),PMAS(500,4),PARF(2000),VCKM(4,4)
      SAVE /PYDAT1/,/PYDAT2/
C...Local arrays and saved data.
      DIMENSION KFORD(100:500),KCORD(101:500)
      SAVE KFORD,KCORD,NFORD,KFLAST,KCLAST
	DATA MSTU20/0/
C...Whenever necessary reorder codes for faster search.
      IF(MSTU20.EQ.0) THEN
        NFORD=100
        KFORD(100)=0
        DO 120 I=101,500
          KFA=KCHG(I,4)
          IF(KFA.LE.100) GOTO 120
          NFORD=NFORD+1
          DO 100 I1=NFORD-1,0,-1
            IF(KFA.GE.KFORD(I1)) GOTO 110
            KFORD(I1+1)=KFORD(I1)
            KCORD(I1+1)=KCORD(I1)
  100     CONTINUE
  110     KFORD(I1+1)=KFA
          KCORD(I1+1)=I
  120   CONTINUE
        MSTU20=1
        KFLAST=0
        KCLAST=0
      ENDIF

C...Fast action if same code as in latest call.
      IF(KF.EQ.KFLAST) THEN
        HZPCOMP=KCLAST
        RETURN
      ENDIF

C...Starting values.
      HZPCOMP=0
      KFA=IABS(KF)

C...Simple cases: direct translation.
      IF(KFA.GT.KFORD(NFORD)) THEN
      ELSEIF(KFA.LE.100) THEN
        HZPCOMP=KFA

C...Else binary search.
      ELSE
        IMIN=100
        IMAX=NFORD+1
  130   IAVG=(IMIN+IMAX)/2
        IF(KFORD(IAVG).GT.KFA) THEN
          IMAX=IAVG
          IF(IMAX.GT.IMIN+1) GOTO 130
        ELSEIF(KFORD(IAVG).LT.KFA) THEN
          IMIN=IAVG
          IF(IMAX.GT.IMIN+1) GOTO 130
        ELSE
          HZPCOMP=KCORD(IAVG)
        ENDIF
      ENDIF
C...Check if antiparticle allowed.
      IF(HZPCOMP.NE.0.AND.KF.LT.0) THEN
        IF(KCHG(HZPCOMP,3).EQ.0) HZPCOMP=0
      ENDIF

C...Save codes for possible future fast action.
      KFLAST=KF
      KCLAST=HZPCOMP

      RETURN
      END
*CMZ :  1.02/02 23/10/98  16.02.12  by  Tancredi Carli
*-- Author :
      SUBROUTINE HzJetshp
     .(iNormMod, dconeRad, djshpRho, djshpPsi, ierr)
* ---------------------------------------------------------------------------
*     purpose:   this subroutine calculates jetshape variables:
*                differential jetshape rho, integrated jetshape psi
*                in standard bins of r/R: 0.0,0.1,0.2,...,1.0
*
*     usage:     1. call HzJtfind for jet finding
*                2. call this routine
*
*                input arguments for this routine:
*                   iNormMod     : normalization mode
*                             = 0: jetshapes will be normalized with
*                                  jet Et
*                             = 1: jetshapes will be normlized with
*                                  summed Et of all particles belonging
*                                  to jet AND lying inside a cone of
*                                  radius dconeR (with cone axis=jet axis)
*
*                   dconeRad     : cone radius R
*                                  (if dconeR <= 0.D0, cone radius returned
*                                   by HzJtfind is used)
*
*                output arguments for this routine:
*                   djshpRho(i,j): differential jetshape rho of jet no.j
*                                  in r/R bin no.i
*
*                   djshpPsi(i,j): integrated jetshape rho of jet no.j
*                                  in r/R bin no.i
*
*                   ierr         : error flag
*                             = 0: everything o.k.
*                             =-1: an error occured
*
*     structure: this subroutine will only work correctly, if the
*                common block HZJETCMN has been filled before
*                (by HzJtfind) !!!
*                this subroutine calls the following subroutine/functions:
*                from HzTool lib: HzEta, HzPhi, HzEt
*                from PXCONE lib: PXMDPI
*
*     written by: Andreas von Manteuffel
*
* ---------------------------------------------------------------------------

      IMPLICIT NONE


*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZJETCMN.
*
*     MAXHZJETS: maxmial number of jet allowed
*     NUMJETS: number of jets from jet algo
*     NSEL  : number of selected jets
*     IPJET : pointer to selected jets
*     JETS  : Jet variables (eta,phi,et,e,px,py,pz,m) in choosen frame
*     IJETNO: pointer which objects in PHEP common belong to jets
*
      INTEGER MAXHZJETS
      PARAMETER (MAXHZJETS=50)
      INTEGER NSEL,NUMJETS,IPJET(MAXHZJETS),IJETNO(NMXHEP)
      DOUBLE PRECISION JETS(MAXHZJETS,8)
*
      COMMON /HZJETCMN/JETS,NUMJETS,NSEL,IPJET,IJETNO
*
*
*KEND.

c --- pxcone function for shifting phi into the interval (-pi,+pi)
      Double Precision pxmdpi

c --- arguments
c --- input:
      Integer iNormMod
      Double Precision dconeRad
c --- output:
      Double Precision djshpRho(10,MAXHZJETS)
      Double Precision djshpPsi(10,MAXHZJETS)
      Integer ierr

      Character*8 cName
      Data cName /'HzJetshp'/
      save cName
      Integer iNmess, INMXMESS
      Parameter (INMXMESS=10) ! limit for printed messages
      Data iNmess /0/
      Save iNmess
      Integer ijt, ihad, ir, idum
      Double Precision dcRadius
      Double Precision dEtJet, detaJet, dphiJet
      Double Precision dEtpart, detapart, dphipart
      Double Precision dphiDlta, detaDlta, drtoR
      Double Precision drtoRbin(11)
      Data drtoRbin / 0.0D0, 0.1D0, 0.2D0, 0.3D0, 0.4D0, 0.5D0,
     .                0.6D0, 0.7D0, 0.8D0, 0.9D0, 1.0D0 /
      save drtoRbin


c --- initializations
c -------------------

* initialize errorflag
      ierr = 0

* check if number of jets valid
      if (NUMJETS.gt.MAXHZJETS) then
         ierr = -1
         if (iNmess.lt.INMXMESS) then
            write(6,*) cName, ' ERROR: number of jets too big !!!'
            iNmess = iNmess + 1
         endif
         goto 9999
      endif

* initialize arrays
      do ijt = 1, MAXHZJETS
         do ir = 1, 10
            djshpRho(ir,ijt) = 0.D0
            djshpPsi(ir,ijt) = 0.D0
         enddo
      enddo

* check cone radius
      if (dconeRad.lt.1.D-18) then
*     get cone radius from HzJetrad
         call HzJetrad(2,dcRadius)
         if (dcRadius.lt.1.D-18) then
            ierr = -1
            if (iNmess.lt.INMXMESS) then
               write(6,*) cName,' ERROR: invalid cone radius !'
               iNmess = iNmess + 1
            endif
            goto 9999
         endif
      else
         dcRadius = dconeRad
      endif

* anything to do ?
      if (NUMJETS.lt.1) goto 9999


c --- calculation
c ---------------


* loop over all jets found	
      do 1000 ijt = 1, NUMJETS

*     get kinematic variables of current jet
         detaJet = JETS(ijt,1)
         dphiJet = JETS(ijt,2)
         dEtJet  = JETS(ijt,3)

         if (dEtJet.lt.0.) then
            ierr = -1
            if (iNmess.lt.INMXMESS) then
               write(6,*) cName,' ERROR: jet Et less than 0 !'
               iNmess = iNmess + 1
            endif
            goto 9999
         elseif (dEtJet.eq.0.) then
            goto 1000
         endif

*     loop over all particles
         do 2000 ihad = 1, NHEP

*     does particle belong to jet ?
            if (iJetNo(ihad).ne.ijt) goto 2000
*     note: unstable particles and lepton should never be associated to
*           any jet (this is implemented in HzJtfind)

*     get eta, phi and Et of particle
            detapart = HzEta(ihad)
            dphipart = HzPhi(ihad)
            dEtpart = HzEt(ihad)

*     get (r/R)**2 for current particle
            dphiDlta = pxmdpi(dphiJet-dphipart)
            detaDlta = detaJet-detapart
            drtoR = SQRT((detaDlta**2+dphiDlta**2)/(dcRadius**2))
            do ir = 1, 10
               if (drtoR.lt.drtoRbin(ir+1)) then
                  djshpPsi(ir,ijt) = djshpPsi(ir,ijt) + dEtpart
		  if (drtoR.ge.drtoRbin(ir)) then
                     djshpRho(ir,ijt) = djshpRho(ir,ijt) + dEtpart
		  endif         ! contribution to rho ?
               endif            ! contribution to psi ?
            enddo               ! next r/R step

 2000    continue               ! next hadron

*     normalize jetshapes to jet Et
*     note: factor 10. is for binwith normalization of rho
         do ir = 1, 10
           if (iNormMod.eq.0) then
             djshpRho(ir,ijt) = 10.D0*djshpRho(ir,ijt)/dEtJet
             djshpPsi(ir,ijt) = djshpPsi(ir,ijt)/dEtJet
           elseif (iNormMod.eq.1) then
             djshpRho(ir,ijt) = 10.D0*djshpRho(ir,ijt)/djshpPsi(10,ijt)
             djshpPsi(ir,ijt) = djshpPsi(ir,ijt)/djshpPsi(10,ijt)
           endif
         enddo
 1000 continue                  ! next jet

 9999 continue

      RETURN
      END
*CMZ :  2.00/03 17/01/2000  12.06.37  by  Tancredi Carli
*CMZ :  2.00/02 17/01/2000  10.26.04  by  Tancredi Carli
*CMZ :  1.02/02 06/11/98  11.46.52  by  Tancredi Carli
*-- Author :
      SUBROUTINE HzMeanHi(iid,dX,dY,wtx)
* ---------------------------------------------------------------------------
*     purpose: this subroutine calculates weighted mean values of
*              a variable in different bins, their errors and stores
*              them in a hbook histogram
*
*              the produced histograms are similiar to hbprof-histos,
*              but this routine allows you to use non-aequidistant bins
*
*
*     usage:   1. initialization step:
*                 book histogram with hbook1 or hbookb
*
*              2. filling step:
*                 call this routine
*
*              3. termination step:
*                 nothing to do
*
*              input arguments for this routine:
*                 iid = histo id in hbook context
*                      (that one used for booking the histo in step 1)
*                 dX  = current value of binned variable (Abszissa)
*                 dY  = current value of variable, whose mean value
*                       is of interest (Ordinate)
*                 wtx = event weight
*                 (note: dX, dY declared double precision !)
*
*     structure:  this subroutine calls the following subroutine/functions
*                 (only the ones not included in this file are listed):
*                 hexist,hgive,hi,hie,hix,hpak,hpake (all from hbook-lib)
*
*
*     written by: Andreas von Manteuffel
*
*     reference:  the formula for the error is taken from:
*                 Michael Kuhlen (H1-01/95-418)
* ---------------------------------------------------------------------------

      IMPLICIT NONE


c --- input arguments
      integer iid,j
      double precision dX, dY
      real wtx

c --- internal limits
      integer MAXHISTS, MAXBINS, ARRSIZE
      parameter (MAXHISTS=150, MAXBINS=40)
      parameter (ARRSIZE=MAXHISTS*MAXBINS)

c --- hbook functions
      logical hexist
      real hi
      real hie

c --- argument variables for hbook subrouines
      character*80 ctit
      integer incX, incY, inwt, idum
      real Xmin, Xmax, Ymin, Ymax, Xleft
      real Ycont(MAXBINS), Yerr(MAXBINS)
      real testcont, testerr

c --- other internal stuff
      logical lfound ! indicates if histo is already in internal list
      integer ibin, ihist  ! counting variables for loops
      integer icbin ! current X-bin number in filling step
      integer icHi  ! current internal histo index
      integer iNhistos ! last internal histo index (see comment in code)
      integer iIDlist(MAXHISTS) ! list of hbook histo IDs
      integer iNbins(MAXHISTS) ! number of X-bins for histo
      double precision dmeanY, dNeff, dtemp
      double precision dwtx(MAXHISTS,MAXBINS)
      double precision dwtx2(MAXHISTS,MAXBINS)
      double precision dwtxY(MAXHISTS,MAXBINS)
      double precision dwtxY2(MAXHISTS,MAXBINS)
      double precision dbins(MAXHISTS,MAXBINS+1)
      logical lp
      Data lp/.false./
      data iNhistos /0/
      data iIDlist /MAXHISTS*0/
      save iNhistos, iIDlist, iNbins
      save dwtx,dwtx2,dwtxY,dwtxY2,dbins
      character*80 errMsgTxt
      character rout*10
      Data rout/'**hzmeanhi'/
      save rout

c --------------------------------------------------------------------------
c     look up histo
c --------------------------------------------------------------------------
c --- look up if histo already initialized in this routine
c     and get internal histo index
      lfound = .false.
      do ihist = 1, iNhistos
         if (iIDlist(ihist).eq.iid) then
            lfound = .true.
            icHi = ihist
            goto 100
         endif
      enddo
 100  continue


         if (.not.lfound) then
c --------------------------------------------------------------------------
c --- prepare new histo
c --------------------------------------------------------------------------

c --- CHECKS
c ----------
c --- check if histo ID already in use in hbook
            if (.not.hexist(iid)) then
               write(6,*) rout,' histo must be booked in hbook first !'
               goto 9999
c --- check last histo index currently used
c     this is identical with total number of histos used, before the
c     first histo is removed (see termination step)
            elseif (iNhistos.eq.MAXHISTS) then
               write(6,*) rout,'too many histos requested !'
               goto 9999
            endif
c --- get histo features
            call hgive(iid,ctit,incX,Xmin,Xmax,incY,Ymin,Ymax,inwt,idum)
c --- check if 1dimensional histo
            if (incY.ne.0) then
               write(6,*) rout,'can only handle 1d-histos !'
               goto 9999
c --- check number of channels
            elseif (incX.gt.MAXBINS) then
               write(6,*) rout,'too many channels !'
               goto 9999
            elseif (incX.lt.1) then
               write(6,*) rout,'invalid number of channels !'
               goto 9999
            endif
c --- check if histo is empty
            do ibin = 1, incX
               testcont = hi(iid,ibin)
               testerr = hie(iid,ibin)
               if ((testcont.ne.0.).or.(testerr.ne.0.)) then
                  write(6,*) rout,
     .             'histogram is not empty (contents will be ignored) !'
                  goto 200
               endif
            enddo
 200        continue

c --- INITIALIZATIONS
c -------------------
            iNhistos = iNhistos + 1
            icHi = iNhistos
            do ibin = 1, incX
               dwtx(icHi,ibin) = 0.D0
               dwtx2(icHi,ibin) = 0.D0
               dwtxY(icHi,ibin) = 0.D0
               dwtxY2(icHi,ibin) = 0.D0
*     get binning info
               call hix(iid,ibin,Xleft)
               dbins(icHi,ibin) = dble(Xleft)
            enddo
            dbins(icHi,incX+1) = dble(Xmax)
            iNbins(icHi) = incX
            iIDlist(icHi) = iid
         endif

c --------------------------------------------------------------------------
c     internal filling
c --------------------------------------------------------------------------
*     get bin number
         do ibin = 0, iNbins(icHi)
            if (dX.le.dbins(icHi,ibin+1)) goto 500
         enddo
 500     continue
         icbin = ibin
         if ((icbin.ge.1).and.(icbin.le.iNbins(icHi))) then
            dwtx(icHi,icbin) = dwtx(icHi,icbin)+dble(wtx)
            dwtx2(icHi,icbin) = dwtx2(icHi,icbin)+dble(wtx)**2
            dwtxY(icHi,icbin) = dwtxY(icHi,icbin)+dble(wtx)*dY
            dwtxY2(icHi,icbin) = dwtxY2(icHi,icbin)+dble(wtx)*(dY)**2
         endif

c --------------------------------------------------------------------------
c     calculation of current means and their errors
c --------------------------------------------------------------------------
         do ibin = 1, iNbins(icHi)
           if (dwtx(icHi,ibin).eq.0.D0) then
             Ycont(ibin) = 0.
             Yerr(ibin) = 0.
           else
             dmeanY = dwtxY(icHi,ibin)/dwtx(icHi,ibin)
             Ycont(ibin) = real(dmeanY)
             Yerr(ibin) = 0.
             if (dwtx2(icHi,ibin).le.0.D0) then
               write(6,*) rout,'numerical problems with calculation !'
             else
               dNeff = dwtx(icHi,ibin)**2/dwtx2(icHi,ibin)
               if (dNeff.gt.1.D0) then
                 dtemp=dwtxY2(icHi,ibin)/dwtx(icHi,ibin) - dmeanY**2
                 Yerr(ibin)=sqrt(real(dtemp*(1.D0/(dNeff-1.D0))))
               endif
             endif
           endif
         enddo
c --------------------------------------------------------------------------
c     histo filling
c --------------------------------------------------------------------------
         if (lp) write(6,*) rout,iid,' ibin= ',iNbins(icHi),
     &   ' cont= ',(ycont(j),j=1,iNbins(icHi))
*
         call hpak(iid,Ycont)
         call hpake(iid,Yerr)


 9999 continue
      RETURN
      END
*CMZ :  1.02/02 23/10/98  11.02.43  by  Tancredi Carli
*-- Author :
      FUNCTION HzTheta (ipart)
************************************************************************
*     input:  ipart:        index of particle in HEP common
*     output: return value: polar angle of particle
*     no other subroutines are called
*     written by: Andreas von Manteuffel
************************************************************************

      IMPLICIT NONE

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEND.

      Double Precision HzTheta
      Integer ipart
      Double Precision dpx, dpy, dpz, dp, dcosthta, dtheta

c --- check particle index
      if ((ipart.lt.1).or.(ipart.gt.NHEP)) then
         dtheta = 0.D0
      else

c --- get particle momentum components
         dpx = PHEP(1,ipart)
         dpy = PHEP(2,ipart)
         dpz = PHEP(3,ipart)
         dp = SQRT(dpx**2+dpy**2+dpz**2)

c --- check if calculation is possible
         if (dp.eq.0.D0) then
            dtheta = 0.D0
         else

c --- get polar angle of particle
            dcosthta = dpz/dp
            if (abs(dcosthta).gt.1.D0) then
               if (dcosthta.gt.0.D0) then
                  dtheta = 0.D0
               else
                  dtheta = 180.D0
               endif
            else
               dtheta = ACOS(dcosthta)
            endif
         endif
      endif

      HzTheta = dtheta

      RETURN
      END
*CMZ :  1.02/02 23/10/98  11.02.43  by  Tancredi Carli
*-- Author :
      FUNCTION HzPt (ipart)
************************************************************************
*     input:  ipart:        index of particle in HEP common
*     output: return value: transverse momentum of particle
*     no other subroutines are called
*     written by: Andreas von Manteuffel
************************************************************************

      IMPLICIT NONE

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEND.

      Double Precision HzPt
      Integer ipart
      Double Precision dpx, dpy, dpt

c --- check particle index
      if ((ipart.lt.1).or.(ipart.gt.NHEP)) then
         dpt = 0.D0
      else

c --- get particle pt
         dpx = PHEP(1,ipart)
         dpy = PHEP(2,ipart)
         dpt = SQRT(dpx**2+dpy**2)

      endif

      HzPt = dpt

      RETURN
      END
*CMZ :  1.02/02 23/10/98  11.02.43  by  Tancredi Carli
*-- Author :
      FUNCTION HzEt (ipart)
************************************************************************
*     input:  ipart:        index of particle in HEP common
*     output: return value: transverse energy of particle
*     no other subroutines are called
*     written by: Andreas von Manteuffel
************************************************************************

      IMPLICIT NONE

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEND.

      Double Precision HzEt
      Integer ipart
      Double Precision dpx, dpy, dpz, dp, dpt2, dE, dEt

c --- check particle index
      if ((ipart.lt.1).or.(ipart.gt.NHEP)) then
         dEt = 0.D0
      else

c --- get particle momentum components
         dpx = PHEP(1,ipart)
         dpy = PHEP(2,ipart)
         dpz = PHEP(3,ipart)
         dE = PHEP(4,ipart)
         dpt2 = dpx**2+dpy**2
         dp = SQRT(dpt2+dpz**2)

c --- check if calculation is possible
         if (dp.eq.0.D0) then
            dEt = 0.D0
         else

c --- get Et
            dEt = dE*sqrt(dpt2)/dp
         endif
      endif

      HzEt = dEt

      RETURN
      END
*CMZ :  1.02/02 23/10/98  11.02.43  by  Tancredi Carli
*-- Author :
      FUNCTION HzPhi (ipart)
************************************************************************
*     input:  ipart:        index of particle in HEP common
*     output: return value: azimutal angle (phi) of particle,
*                           or 0.D0 if calculation not possible
*     no other subroutines are called
*     written by: Andreas von Manteuffel
************************************************************************
      IMPLICIT NONE

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEND.

      Double Precision HzPhi
      Integer ipart
      Double Precision dpx, dpy, dpz, dpt2, dphi

c --- check particle index
      if ((ipart.lt.1).or.(ipart.gt.NHEP)) then
         dphi = 0.D0
      else

c --- get particle momentum components
         dpx = PHEP(1,ipart)
         dpy = PHEP(2,ipart)
         dpz = PHEP(3,ipart)
         dpt2 = dpx**2+dpy**2

c --- check if calculation is possible
         if (dpt2.EQ.0.D0) THEN
            dphi=0.
         else

c --- get azimutal angle (phi)
            dphi=ATAN2(dpy,dpx)
         endif
      endif

      HzPhi = dphi

      RETURN
      END
*CMZ :  1.02/02 23/10/98  11.02.43  by  Tancredi Carli
*-- Author :
      FUNCTION HzEta (ipart)
************************************************************************
*     input:  ipart:        index of particle in HEP common
*     output: return value: pseudo-rapidity of particle,
*                           or +/-20.D0 if calculation not possible
*     no other subroutines are called
*     written by: Andreas von Manteuffel
************************************************************************
      IMPLICIT NONE

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEND.

      Double Precision HzEta
      Integer ipart
      Double Precision dpx, dpy, dpz, dpt2, dtemp, deta

c --- check particle index
      if ((ipart.lt.1).or.(ipart.gt.NHEP)) then
        deta = 20.D0
      else

c --- get particle momentum components
         dpx = PHEP(1,ipart)
         dpy = PHEP(2,ipart)
         dpz = PHEP(3,ipart)
         dpt2 = dpx**2+dpy**2
         dtemp = (SQRT(dpt2+dpz**2)+ABS(dpz))**2

c --- check if calculation is possible
         if (dpt2.le.4.25E-18*dtemp) then
            deta = 20.D0
         else

c --- get amount of pseudo-rapidity
            deta = 0.5D0*LOG(dtemp/dpt2)
         endif
         deta=SIGN(deta,dpz)

      endif

c --- assign pseudo-rapidity with correct sign to return variable
      HzEta=deta
      RETURN
      END
*CMZ :  1.02/03 28/11/98  13.37.06  by  Tancredi Carli
*-- Author :
      FUNCTION HzIdntro (idum)
************************************************************************
*  purpose:
*     HzIdntro returns index of first neutrino in HEP common
*     (for CC events)
*
*     note: current version will only work with LEPTO !
*
*  input:
*     currently only dummy variable
*  output:
*     returned value: id of neutrino in HEP common (if found)
*                     -1 if neutrino finding was not successful
*  structure:
*     no other subroutines are called
*  written by:
*     Andreas von Manteuffel (Oct.98)
*  modified:
*
************************************************************************
      IMPLICIT NONE
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEND.
*
c --- input argument (dummy variable)
      Integer idum
c --- returned value (id of neutrino in HEP common, -1 for error)
      Integer HzIdntro
*
c --- internal stuff
      Integer iNmess, INMXMESS
      Parameter (INMXMESS=10)
      Data iNmess /0/
      save iNmess
      Integer ihep, ineutrin
*
c --- return -1 if neutrino finding not successful
      ineutrin = -1
*
c --- in current version neutrino finding is only implemented
c     for LEPTO; for other generators the scheme will propably
c     be similiar (see HzIdelec)
*
      if (gen(1:3).eq.'LEP') then
         do ihep = 1, NHEP
            if ((Isthep(ihep).eq.1).and.(abs(Idhep(ihep)).eq.12)) then
               ineutrin = ihep
               goto 200
            endif
         enddo
      else
         if (iNmess.le.INMXMESS) then
            write(6,*)'HzIdntro: unknown generator !'
            iNmess = iNmess + 1
         endif
      endif
*
 200  continue
      HzIdntro = ineutrin
*
      RETURN
      END
*CMZ :  0.00/03 29/10/98  11.16.17  by  Tancredi Carli
*-- Author :
      SUBROUTINE HzSubjm(iflag, ijet, inycut, ycut, isubjm, ierr)
***********************************************************************
*
* purpose:
*     This subroutine is an HzTool interface for the calculation
*     of SUBJET MULTICPLITIES using the KTCLUS package.
*
* usage:
*     1. jet finding: call HzJtfind with jetfinder selection KTCLUS
*     2. preparation of subjet multiplicity calculation:
*        call this subroutine HzSubjm with iflag = 1
*     3. calculation of subjet multiplicities:
*        call this subroutine HzSubjm with iflag = 2 (for each jet)
*     note: the commons HEPEVTP and HZJETCMN should not be changed
*           (directly or for example through HzJtfind) between the
*           steps mentioned above !!!
*
*     input arguments:
*        iflag  = mode flag (=1: initialization step)
*                           (=2: subjet multiplicity calculation step)
*        ijet   = HzTool number of jet to be analysed
*        inycut = number of ycuts
*        ycut   = ycut values
*     output arguments:
*        isubjm = subjet multiplicities for different ycut values
*        ierr   = errorflag (=0: no error, <0: something went wrong)
*
* structure:
*     the following functions/subroutines are called by this routine:
*     from KTCLUS lib: KTCLUS, KTINCL, KTISUB
*     from HzTool lib: HzIdelec
*
* written by:
*     Andreas von Manteuffel (Oct. 1998)
*
***********************************************************************

      Implicit None
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEEP,HZJETCMN.
*
*     MAXHZJETS: maxmial number of jet allowed
*     NUMJETS: number of jets from jet algo
*     NSEL  : number of selected jets
*     IPJET : pointer to selected jets
*     JETS  : Jet variables (eta,phi,et,e,px,py,pz,m) in choosen frame
*     IJETNO: pointer which objects in PHEP common belong to jets
*
      INTEGER MAXHZJETS
      PARAMETER (MAXHZJETS=50)
      INTEGER NSEL,NUMJETS,IPJET(MAXHZJETS),IJETNO(NMXHEP)
      DOUBLE PRECISION JETS(MAXHZJETS,8)
*
      COMMON /HZJETCMN/JETS,NUMJETS,NSEL,IPJET,IJETNO
*
*
*KEND.
*


*
c --- arguments
c --- input:
      integer iflag, ijet, inycut
      real ycut(*)
c --- output:
      integer isubjm(*)
      integer ierr
*
c --- general stuff ---
      character*9 cxxxx
      data cxxxx /'HZSUBJM'/
      save cxxxx
*
C --- KTCLUS stuff ---
      integer IKTPMX
      parameter (IKTPMX=512)
      double precision ppp(4,IKTPMX),ktpjet(4,IKTPMX)
      integer          ktmode,ktreco
      integer          iKTjetno(IKTPMX) ! internal KT jet number
      double precision etjeti,etjetj,help
      real             yy(IKTPMX),ecut
      integer          parttojet(IKTPMX)
      integer          njet,iKTjt
      save njet, iKTjetno,ktpjet
*
c --- some variables
      logical lp
      data lp /.true./
      save lp
      INTEGER loop,count,iel,idum,i,j,k
      integer npart

c ---------------------------------------------------------------------

C --- initializations
      ierr = -1
      do loop=1,iNycut
         isubjm(loop) = 0.
      enddo


      if (iflag.eq.1) then
c ---------------------------------------------------------------------
c     PREPARE CALCULATION
c ---------------------------------------------------------------------

C --- get lepton id
         iel=HZIDELEC(idum)
         IF (iel.le.0) Then
            write(6,*) cxxxx,' lepton not found !'
            goto 9999
         ENDIF

C --- avoid invalid array-access
         if ((NHEP.lt.1).or.(NHEP.gt.NMXHEP)) then
            write(6,*) cxxxx,'invalid number of particles !'
         endif

c --- prepare KTCLUS call
         ktreco=2
         ktmode=3212
         ecut   = 1.
         count=0
         DO loop=1,NHEP
*     skip unstable particles and scattered lepton
           IF ((ISTHEP(loop).eq.1).and.(loop.ne.iel)) THEN
              IF (count.eq.IKTPMX) THEN
                 write(6,*) cxxxx,
     &                'Too many particles for KTCLUS',count
                 GOTO 85
              ELSE
                 count=count+1
                 ppp(1,count) = PHEP(1,loop)
                 ppp(2,count) = PHEP(2,loop)
                 ppp(3,count) = PHEP(3,loop)
                 ppp(4,count) = PHEP(4,loop)
              ENDIF
           ENDIF
         ENDDO
 85    CONTINUE
*
       NPART=count

c --- do KTCLUS call
       call KTCLUS(ktmode,ppp,npart,ecut,yy,*8000)
       call KTINCL(ktreco,ppp,npart,ktpjet,parttojet,NJET,*8000)

       if (NJET.gt.IKTPMX) goto 8000

c --- sort jets in Et
       Do loop=1,NJET
          iKTjetno(loop)=loop
       ENDDO
       do i = 1, NJET
        etjeti = sqrt( ktpjet(1,i)**2 + ktpjet(2,i)**2 )
        do j = (i+1), NJET
         etjetj = sqrt( ktpjet(1,j)**2 + ktpjet(2,j)**2 )
         if( etjetj.gt.etjeti )then
          do k = 1, 4
           help      = ktpjet(k,i)
           ktpjet(k,i) = ktpjet(k,j)
           ktpjet(k,j) = help
          enddo
          k=iKTjetno(i)
          iKTjetno(i)=iKTjetno(j)
          iKTjetno(j)=k
         endif
        enddo ! j
       enddo ! i

      elseif (iflag.eq.2) then
c ---------------------------------------------------------------------
c     SUBJET MULTIPLICITY CALCULATION
c ---------------------------------------------------------------------

c --- check selected jet number
         if ((ijet.lt.1).or.(ijet.gt.NUMJETS)) then
            write(6,*) cxxxx,' invalid jet selection !'
            goto 9999
         endif
c --- get KTCLUS internal number of selected jet (see Et-ordering above)
         iKTjt = iKTjetno(ijet)
         if ((iKTjt.lt.1).or.(iKTjt.gt.IKTPMX)) then
            write(6,*) cxxxx,' internal information corrupted !!!'
            goto 9999
         endif

         call KTISUB(iKTjt, iNycut, ycut, isubjm, *8000)

      else
         write(6,*) cxxxx,' bad subroutine call !'
         goto 9999
      endif

      ierr = 0
      goto 9999

 8000 continue
      write(6,*) cxxxx,' ERROR in KTCLUS !'

 9999 continue
      Return
      End
*CMZ :  0.00/03 29/10/98  11.22.03  by  Tancredi Carli
*-- Author :
      SUBROUTINE HzMghepc (imode)
*************************************************************************
*  purpose:   this subroutine saves (imode=1) or recovers (imode=2) the
*             HEP event prime common (using an internal copie)
*
*  structure: no other subroutines or function are called
*
*  comment:   you should not call this subroutine directly, use
*             HzSvhepc or HzRchepc instead !
*
*  written by: Andreas von Manteuffel (Oct. 1998)
*************************************************************************
      IMPLICIT NONE
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEND.
c --- subroutine specific declarations

c --- argument
      Integer imode

c --- variables for HEP event prime common copie
      Integer xNEVHEP,xNHEP,xISTHEP(NMXHEP),xIDHEP(NMXHEP)
      Integer xJMOHEP(2,NMXHEP),xJDAHEP(2,NMXHEP)
      Double Precision xPHEP(5,NMXHEP),xVHEP(4,NMXHEP)

      Save xNEVHEP,xNHEP,xISTHEP,xIDHEP
      Save xJMOHEP,xJDAHEP
      Save xPHEP,xVHEP

c --- other variables
      Integer ihad, icount
c ------------------------------------

      if (imode.eq.1) then
c --- SAVE THE COMMON
         xNEVHEP = NEVHEP
         xNHEP = NHEP
         do ihad = 1, NMXHEP
            xISTHEP(ihad) = ISTHEP(ihad)
            xIDHEP(ihad) = IDHEP(ihad)
            do icount = 1, 2
               xJMOHEP(icount,ihad) = JMOHEP(icount,ihad)
               xJDAHEP(icount,ihad) = JDAHEP(icount,ihad)
            enddo
            do icount = 1, 5
               xPHEP(icount,ihad) = PHEP(icount,ihad)
            enddo
            do icount = 1, 4
               xVHEP(icount,ihad) = VHEP(icount,ihad)
            enddo
         enddo
      elseif (imode.eq.2) then
c --- RECOVER THE COMMON
         NEVHEP = xNEVHEP
         NHEP = xNHEP
         do ihad = 1, NMXHEP
            ISTHEP(ihad) = xISTHEP(ihad)
            IDHEP(ihad) = xIDHEP(ihad)
            do icount = 1, 2
               JMOHEP(icount,ihad) = xJMOHEP(icount,ihad)
               JDAHEP(icount,ihad) = xJDAHEP(icount,ihad)
            enddo
            do icount = 1, 5
               PHEP(icount,ihad) = xPHEP(icount,ihad)
            enddo
            do icount = 1, 4
               VHEP(icount,ihad) = xVHEP(icount,ihad)
            enddo
         enddo
      else
         write(6,*)'HzHepc: Bad routine call !'
         write(6,*)'HzHepc: This routine should not be called directly,'
         write(6,*)'please use HzSvhepc and HzRchepc instead.'
      endif

      RETURN
      END
*CMZ :  0.00/03 29/10/98  11.19.11  by  Tancredi Carli
*-- Author :
      SUBROUTINE HzRchepc
*************************************************************************
*  purpose:   this subroutine recovers the HEP event prime common
*             from an internal copie (initialized by HzSvhepc)
*             note: usage of this subroutine without calling HzSvhepc
*                   makes no sense (see remarks below) !
*
*  usage:     1. save the HEP event prime common with HzSvhepc
*             2. recover the stored HEP event prime common with HzRchepc
*
*  structure: HzTool subroutine HzMghepc is called
*
*  written by: Andreas von Manteuffel (Oct. 1998)
*************************************************************************
      IMPLICIT NONE
      call HzMghepc(2)
      RETURN
      END
*CMZ :  2.00/00 19/08/99  14.45.43  by  Tancredi Carli
*CMZ :  1.02/08 01/04/99  20.30.58  by  Tancredi Carli
*-- Author :    Tancredi Carli   01/04/99
      FUNCTION HZDOT(P,I,J)
****************************************************************************
* Purpose: Dot product
*          as used by DISENT
*
* Arguments: P(4,7) Event Record
*
* written by: Tancredi Carli on 01/04/99
****************************************************************************
      IMPLICIT NONE
*
C---RETURN THE DOT PRODUCT OF P(*,I) AND P(*,J)
      INTEGER I,J
      DOUBLE PRECISION HZDOT,P(4,7)
      HZDOT=P(4,I)*P(4,J)-P(3,I)*P(3,J)-P(2,I)*P(2,J)-P(1,I)*P(1,J)
*
      RETURN
*
      END
*
*CMZ :  2.00/00 13/08/99  15.27.38  by  Tancredi Carli
*-- Author :
      Function Hzeekin(Itype)
**********************************************************
* Purpose:
* Return kinem. variables
* Input:
* If Itype = 1  -> Q2 of highest Q2 photon
*    Itype = 11 -> Q2 of lowest Q2 photon
*    itype = 2 -> Largest electron (positron) scattering angle
*    itype = 3 -> ybj of highest Q2 photon
*    itype = 13 -> ybj of lowest Q2 photon
*    itype = 4 -> W2
* Photoproduction Author : M. Hayes
* Original Author: N. Brook
* Adapted for e+e-: J. Butterworth
* Electron scattering angle added: R. Taylor
* PYT,PHO,W2 by: J.Elmsheuser
*
* last change: 02 Aug 99
**********************************************************

      IMPLICIT NONE

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.

      INTEGER itype,jgam, kbeam,loop
      DOUBLE PRECISION q21,ybj1,q22,ybj2,pgam1(5),pgam2(5),temp
      DOUBLE PRECISION el,po,ang1,ang2,angle,w2
      INTEGER i1,i2

      DOUBLE PRECISION EHAD(4),WHAD

      hzeekin = -1.0d0

      Jgam = hzeegamn(pgam1,pgam2)
      if(jgam.ne.1) Then
         Write(6,*) 'HZEEKIN: No record of virt. photon found'
         Return
      endif

      kbeam = hzeebeam(i1,i2)
      If(kbeam.ne.1) Then
        Write(6,*) 'HZEEKIN: No record of beam particles'
        Return
      Endif

      q21 = -(pgam1(4)**2-pgam1(3)**2-pgam1(2)**2-pgam1(1)**2)
      ybj1=(phep(4,i2)*pgam1(4) - phep(3,i2)*pgam1(3)
     +        -phep(2,i2)*pgam1(2) - phep(1,i2)*pgam1(1))/
     1    (phep(4,i1)*phep(4,i2) - phep(3,i1)*phep(3,i2)
     2        -phep(2,i1)*phep(2,i2) - phep(1,i1)*phep(1,i2))

      q22 = -(pgam2(4)**2-pgam2(3)**2-pgam2(2)**2-pgam2(1)**2)
      ybj2=(phep(4,i1)*pgam2(4) - phep(3,i1)*pgam2(3)
     +        -phep(2,i1)*pgam2(2) - phep(1,i1)*pgam2(1))/
     1    (phep(4,i2)*phep(4,i1) - phep(3,i2)*phep(3,i1)
     2        -phep(2,i2)*phep(2,i1) - phep(1,i2)*phep(1,i1))


      if (q21.lt.q22) then
         temp=q21
         q21=q22
         q22=temp
         temp=ybj1
         ybj1=ybj2
 1       ybj2=temp
      endif

C The following calls HZPHMANG to determine angle through which e+/e- is
C scattered.

      IF (gen(1:3).eq.'HRW') THEN
         el=7            !actually positron
         po=5            !actually electron
      ELSEIF (gen(1:3).eq.'PYT') THEN
        If ((i1.eq.1).and.(i2.eq.2)) Then
          el=3
          po=4
        ElseIf ((i1.eq.2).and.(i2.eq.1)) Then
          el=4
          po=3
        EndIf
      ELSEIF (gen(1:3).eq.'PHO') THEN
        el=3
        po=5
      ELSE
         Write(6,*)'Hzeekin: Unknown generator ',gen(1:3)
      ENDIF
      ang1=HZPHMANG(phep(3,el),sqrt(phep(1,el)**2+phep(2,el)**2))
      ang2=HZPHMANG(-1.*phep(3,po),sqrt(phep(1,po)**2+phep(2,po)**2))
      IF (ang1.gt.ang2) THEN
         angle=ang1
      ELSE
         angle=ang2
      ENDIF

C ---- Determination of W2 ----
      w2 = (pgam1(4)+pgam2(4))**2-(pgam1(3)+pgam2(3)**2)-
     +     (pgam1(2)+pgam2(2))**2-(pgam1(1)+pgam2(1)**2)

      If(itype.eq.1) Then
         hzeekin = q21
      elseif(itype.eq.11) then
         hzeekin = q22
      elseif(itype.eq.2) then
         hzeekin = angle
      elseif(itype.eq.3) then
         hzeekin = ybj1
      elseif(itype.eq.13) then
         hzeekin = ybj2
      elseif(itype.eq.4) then
         hzeekin = w2
      else
        write(6,*) ' HZEEKIN: itype should be in range 1-4'
      endif
*
      return
      end
*CMZ :  2.00/00 13/08/99  15.28.14  by  Tancredi Carli
*-- Author :
*-- Author :
      Function Hzeebeam(i1,i2)
*******************************************************
* Purpose:
* Find posn of electron and positron beam
* returns
* If find both beams Hzeebeam = 1
* if find only electron beam Hzeebeam = -1
* if find only positron beam Hzeebeam = 0
* Input: none
* Output: i1 pointer to electron
*         i2 pointer to positron
*
* Author: N. Brook
* PHOJET mods : M. Hayes
* Gen="POM" added by H. Jung
* PYTHIA and PHOJET mode: J.Elmsheuser
*
* last change: 02 Aug 99
*******************************************************
      Implicit Double Precision (A-H,O-Z)
      Logical  lelec,lposi,lp
      Data lp/.false./
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*
      hzeebeam = -2
      lelec  = .false.
      lposi  = .false.
      i1=-1
      i2=-1

      If(gen(1:3).eq.'HRW' .or.gen(1:3).eq.'INS' ) Then
        Do Ihep = Nhep,1,-1
          if (lp) then
            write(6,'(A,4F9.3,a,i4,a,i4)') '**hzeebeam: HRW= ',
     +           (PHEP(i,ihep),i=1,4),' ist= ',
     +           Isthep(ihep),' idhep= ',idhep(ihep)
          endif
          If((Isthep(ihep).eq.101.or.Isthep(ihep).eq.102)
     +         .and.idhep(ihep).eq.11) Then
            i1 = ihep
            hzeebeam = hzeebeam + 1
          else If((Isthep(ihep).eq.101.or.Isthep(ihep).eq.102)
     +           .and.idhep(ihep).eq.-11) Then
            i2 = ihep
            hzeebeam = hzeebeam + 2
          Endif
          If(hzeebeam.eq.1) Return
        Enddo
      ElseIf ((gen(1:3).eq.'PYT').or.(gen(1:3).eq.'PHO')) Then
        IF ((idhep(1).eq.11).and.(idhep(2).eq.-11)) Then
          i1 = 1
          i2 = 2
          hzeebeam = hzeebeam + 3
        ElseIf ((idhep(1).eq.-11).and.(idhep(2).eq.11)) Then
          i1 = 2
          i2 = 1
          hzeebeam = hzeebeam + 3
        ElseIf ((idhep(1).eq.11).and.(idhep(2).ne.-11)) Then
          i1 = 1
          hzeebeam = hzeebeam + 1
        ElseIf ((idhep(1).eq.-11).and.(idhep(2).ne.11)) Then
          i1 = 2
          hzeebeam = hzeebeam + 2
        ElseIf ((idhep(2).eq.11).and.(idhep(1).ne.-11)) Then
          i2 = 1
          hzeebeam = hzeebeam + 1
        ElseIf ((idhep(2).eq.-11).and.(idhep(1).ne.11)) Then
          i2 = 2
          hzeebeam = hzeebeam + 2
        Endif
        If(hzeebeam.eq.1) Return
      Else
        write(6,*) '**hzeebeam: generator not found gen=',gen
      Endif
*
      Return
      End
*CMZ :  2.00/00 13/08/99  15.28.43  by  Tancredi Carli
*-- Author :
      Function Hzeegamn(pgam1,pgam2)
*********************************************************
* Purpose:
* Hzipgam flags whether two virtual photons are found
* or not
* Input: none
* Output:
* If found it's 5vec (px,py,px,e,m) for both photons
* are passed back via an argument. pgam1 is the photon
* from the electron, pgam2 is that from the positron.
*
* Original Author: N. Brook
* Modifications for photoproduction : M. Hayes
* Modifications for NLC by J. Butterworth
* PYTHIA and PHOJET modifications: J.Elmsheuser
*
* last change: 02 Aug 99
*********************************************************
      Implicit None
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*
      Integer intnev
      Data intnev/0/
      DOUBLE PRECISION Pgam1(5), Pgam2(5)

      INTEGER ielectron, ipositron, iloop, emother, pmother
*
      intnev=intnev+1
      Hzeegamn = 1
      if(gen(1:3).eq.'HRW') then
	ielectron=-1
        ipositron=-1
	Do iloop=NHEP,1,-1
	  If (IDHEP(iloop).eq.11.and.ISTHEP(iloop).eq.1) Then
	    ielectron=iloop
	  ENDIF
	  If (IDHEP(iloop).eq.-11.and.ISTHEP(iloop).eq.1) Then
	    ipositron=iloop
	  ENDIF
	Enddo
	Do iloop=NHEP,1,-1
	  If (IDHEP(iloop).eq.11) Then
	    emother=iloop
	  ENDIF
	  If (IDHEP(iloop).eq.-11) Then
	    pmother=iloop
	  ENDIF
	Enddo
	IF (ielectron.ne.-1.and.ipositron.ne.-1) Then
          pgam1(1) = phep(1,emother)-phep(1,ielectron)
          pgam1(2) = phep(2,emother)-phep(2,ielectron)
          pgam1(3) = phep(3,emother)-phep(3,ielectron)
          pgam1(4) = phep(4,emother)-phep(4,ielectron)
          pgam1(5) = phep(5,emother)-phep(5,ielectron)
          pgam2(1) = phep(1,pmother)-phep(1,ipositron)
          pgam2(2) = phep(2,pmother)-phep(2,ipositron)
          pgam2(3) = phep(3,pmother)-phep(3,ipositron)
          pgam2(4) = phep(4,pmother)-phep(4,ipositron)
          pgam2(5) = phep(5,pmother)-phep(5,ipositron)
	  return
	else
          hzeegamn = -1
          Write(6,*)
     &         'Hzeegamn: scattered e+/- not found from ',gen(1:3)
          Return
        endif
*
      ElseIf(gen(1:3).eq.'PHO') then
        If ((IDHEP(3).eq.11).and.(IDHEP(5).eq.-11)) Then
          pgam1(1)=phep(1,4)
          pgam1(2)=phep(2,4)
          pgam1(3)=phep(3,4)
          pgam1(4)=phep(4,4)
          pgam1(5)=phep(5,4)
          pgam2(1)=phep(1,6)
          pgam2(2)=phep(2,6)
          pgam2(3)=phep(3,6)
          pgam2(4)=phep(4,6)
          pgam2(5)=phep(5,6)
	else
          hzeegamn = -1
          Write(6,*)
     &         'Hzeegamn: scattered e+/- not found from ',gen(1:3)
          Return
        Endif
*
      ElseIf(gen(1:3).eq.'PYT') then
	ielectron=-1
        ipositron=-1
	If ((IDHEP(3).eq.11).and.(IDHEP(4).eq.-11)) Then
           ielectron=3
           ipositron=4
	ENDIF
	If ((IDHEP(3).eq.-11).and.(IDHEP(4).eq.11)) Then
	   ielectron=4
           ipositron=3
	ENDIF
	If ((IDHEP(1).eq.11).and.(IDHEP(2).eq.-11)) Then
           emother=1
           pmother=2
        EndIf
	If ((IDHEP(1).eq.-11).and.(IDHEP(2).eq.11)) Then
           emother=2
           pmother=1
	ENDIF
	IF (ielectron.ne.-1.and.ipositron.ne.-1) Then
          pgam1(1) = phep(1,emother)-phep(1,ielectron)
          pgam1(2) = phep(2,emother)-phep(2,ielectron)
          pgam1(3) = phep(3,emother)-phep(3,ielectron)
          pgam1(4) = phep(4,emother)-phep(4,ielectron)
          pgam1(5) = phep(5,emother)-phep(5,ielectron)
          pgam2(1) = phep(1,pmother)-phep(1,ipositron)
          pgam2(2) = phep(2,pmother)-phep(2,ipositron)
          pgam2(3) = phep(3,pmother)-phep(3,ipositron)
          pgam2(4) = phep(4,pmother)-phep(4,ipositron)
          pgam2(5) = phep(5,pmother)-phep(5,ipositron)
	  return
	else
          hzeegamn = -1
          Write(6,*)
     &        'Hzeegamn: scattered e+/- not found from ',gen(1:3)
          Return
        endif
*
      else
        hzeegamn = -1
        Write(6,*) 'Hzeegamn: Unknown Generator ',gen(1:3)
        Return
      endif

      Return
      End
*CMZ :  1.01/07 13/10/97  16.29.33  by  Tancredi Carli
*CMZ :  0.00/03 16/01/96  18.10.57  by  Tancredi Carli
*CMZ :  0.00/01 05/01/96  14.13.31  by  HZtool
*-- Author :
      Subroutine Hzluncop
*************************************************************
* Purpose:
* Deal with copying Lund HEPEVT -> HEPEVTP
* Input: none
* Output: none
* Author: N. Brook
*************************************************************
      PARAMETER (NMXHEP=2000)
      Double Precision phepp, vhepp,phep,vhep
      COMMON/HEPEVTP/NEVHEPp,NHEPp,ISTHEPp(NMXHEP),IDHEPp(NMXHEP),
     & JMOHEPp(2,NMXHEP),JDAHEPp(2,NMXHEP),PHEPp(5,NMXHEP),
     1 VHEPp(4,NMXHEP)
*
      COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
      Logical lp
      Data lp/.false./
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*
      NHEPp = NHEP
      NEVHEPp = NEVHEP
      if (lp) write(6,*) ' GEN= ',GEN
      if (lp) write(6,*) ' nhep= ',nhep
      Do ihep = 1, nhep
        isthepp(ihep) = isthep(ihep)
        idhepp(ihep) = idhep(ihep)
        jmohepp(1,ihep) = jmohep(1,ihep)
        jmohepp(2,ihep) = jmohep(2,ihep)
        jdahepp(1,ihep) = jdahep(1,ihep)
        jdahepp(2,ihep) = jdahep(2,ihep)
        do ivec = 1, 5
         phepp(ivec,ihep) = dble(phep(ivec,ihep))
        Enddo
        do ivec = 1, 4
         vhepp(ivec,ihep) = dble(vhep(ivec,ihep))
        Enddo
        ihchrg(ihep) = HZLCHGE(idhep(ihep))
        if (lp) then
         write(6,*) ' ihchrg(ihep)= ',ihchrg(ihep),' id= ',idhep(ihep)
         write(6,*) ' vhep = ', (phepp(ivec,ihep),ivec=1,5)
        endif
      Enddo
*
      Return
      End
*CMZ :  1.02/07 31/03/99  11.28.15  by  Tancredi Carli
*CMZ :  1.01/01 25/03/96  15.06.06  by  Tancredi Carli
*CMZ :  0.00/03 16/01/96  18.07.27  by  Tancredi Carli
*CMZ :  0.00/01 05/01/96  14.14.00  by  HZtool
*-- Author :
      Subroutine hzhrwcop
*************************************************************
* Purpose:
* Deal with copying HERWIG HEPEVT -> HEPEVTP
* Input: none
* Output: none
* Author: N. Brook
* Modified: T. Carli: bug fix in rotation found by M. Hayes 31.3.99
*************************************************************
      PARAMETER (NMXHEP=2000)
      Double Precision phep, vhep, rmass, bfrac, cmmom, etamix, lifetm
      Double Precision phepp, vhepp
*
      COMMON/HEPEVTP/NEVHEPp,NHEPp,ISTHEPp(NMXHEP),IDHEPp(NMXHEP),
     & JMOHEPp(2,NMXHEP),JDAHEPp(2,NMXHEP),PHEPp(5,NMXHEP),
     1 VHEPp(4,NMXHEP)
      COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*
      Double Precision pi, plab(3)
      Data pi/3.1415927/
      Logical lp
      Data lp/.false./
*
      NHEPp = NHEP
      NEVHEPp = NEVHEP
      if (lp) then
       write(6,*) ' Number of particles nhep = ',nhep
      endif
      Do ihep = 1, nhep
        isthepp(ihep) = isthep(ihep)
        idhepp(ihep) = idhep(ihep)
        jmohepp(1,ihep) = jmohep(1,ihep)
        jmohepp(2,ihep) = jmohep(2,ihep)
        jdahepp(1,ihep) = jdahep(1,ihep)
        jdahepp(2,ihep) = jdahep(2,ihep)
        do ivec = 1, 3
         plab(ivec) = phep(ivec,ihep)
        enddo
        call hzphmrot(0.d0,pi,plab,plab)
        do ivec = 1, 3
         phepp(ivec,ihep) = plab(ivec)
        Enddo
        phepp(4,ihep) = phep(4,ihep)
        phepp(5,ihep) = phep(5,ihep)

        if (lp) then
         write(6,*) ihep,' phep= ',(phepp(i,ihep),i=1,4)
        endif

        do ivec = 1, 4
         vhepp(ivec,ihep) = vhep(ivec,ihep)
        Enddo
        ihchrg(ihep) = HZLCHGE(idhep(ihep))
      Enddo
*
      Return
      End
*CMZ :  1.01/15 31/03/98  11.55.21  by  Tancredi Carli
*CMZ :  1.01/07 02/10/97  19.34.00  by  Tancredi Carli
*CMZ :  1.01/04 13/08/96  18.15.45  by   Tancredi Carli
*CMZ :  1.00/03 13/03/96  15.35.19  by  Tancredi Carli
*CMZ :  1.00/02 12/03/96  17.42.42  by  Tancredi Carli
*CMZ :  0.00/03 09/01/96  17.57.28  by  HZtool
*-- Author :

*CMZ :          09/01/96  17.39.02  by  HZtool
*-- Author :
C*********************************************************************

      SUBROUTINE HZLUHEPC(MCONV)
***************************************************************
* extracted from jetset (since Herwig does not know about it) *
* Author: Nick Brook
* Changed: introduced hzlcomp instead of LUCOMP
*           and get rid of LUERR Tancredi Carli
*          declare hzlcomp as integer march 1998
***************************************************************
C...Purpose: to convert JETSET event record contents to or from
C...the standard event record commonblock.
      PARAMETER (NMXHEP=2000)
      Double Precision phep, vhep
      COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     &JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
      COMMON/LUJETS/N,K(4000,5),P(4000,5),V(4000,5)
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)
      SAVE /HEPEVT/
      SAVE /LUJETS/,/LUDAT1/,/LUDAT2/
*
      Integer  HZLCOMP

C...Conversion from JETSET to standard, the easy part.
      IF(MCONV.EQ.1) THEN
        NEVHEP=0
        IF(N.GT.NMXHEP) write(6,*)
     &  '(LUHEPC:) no more space in /HEPEVT/ '
        NHEP=MIN(N,NMXHEP)
        DO 140 I=1,NHEP
        ISTHEP(I)=0
        IF(K(I,1).GE.1.AND.K(I,1).LE.10) ISTHEP(I)=1
        IF(K(I,1).GE.11.AND.K(I,1).LE.20) ISTHEP(I)=2
*        IF(K(I,1).GE.11.AND.K(I,1).LE.20) ISTHEP(I)=k(i,1)
        IF(K(I,1).GE.21.AND.K(I,1).LE.30) ISTHEP(I)=3
        IF(K(I,1).GE.31.AND.K(I,1).LE.100) ISTHEP(I)=K(I,1)
        IDHEP(I)=K(I,2)
        JMOHEP(1,I)=K(I,3)
        JMOHEP(2,I)=0
        IF(K(I,1).NE.3.AND.K(I,1).NE.13.AND.K(I,1).NE.14) THEN
          JDAHEP(1,I)=K(I,4)
          JDAHEP(2,I)=K(I,5)
        ELSE
          JDAHEP(1,I)=0
          JDAHEP(2,I)=0
        ENDIF
        DO 100 J=1,5
        PHEP(J,I)=P(I,J)
  100   CONTINUE
        DO 110 J=1,4
        VHEP(J,I)=V(I,J)
  110   CONTINUE

C...Check if new event (from pileup).
        IF(I.EQ.1) THEN
          INEW=1
        ELSE
          IF(K(I,1).EQ.21.AND.K(I-1,1).NE.21) INEW=I
        ENDIF

C...Fill in missing mother information.
        IF(I.GE.INEW+2.AND.K(I,1).EQ.21.AND.K(I,3).EQ.0) THEN
          IMO1=I-2
          IF(I.GE.INEW+3.AND.K(I-1,1).EQ.21.AND.K(I-1,3).EQ.0)
     &    IMO1=IMO1-1
          JMOHEP(1,I)=IMO1
          JMOHEP(2,I)=IMO1+1
        ELSEIF(K(I,2).GE.91.AND.K(I,2).LE.93) THEN
          I1=K(I,3)-1
  120     I1=I1+1
          IF(I1.GE.I) write(6,*)
     &    '(LUHEPC:) translation of inconsistent event history'
          IF(I1.LT.I.AND.K(I1,1).NE.1.AND.K(I1,1).NE.11) GOTO 120
C          KC=LUCOMP(K(I1,2))
          KC=HZLCOMP(K(I1,2))
          IF(I1.LT.I.AND.KC.EQ.0) GOTO 120
          IF(I1.LT.I.AND.KCHG(KC,2).EQ.0) GOTO 120
          JMOHEP(2,I)=I1
        ELSEIF(K(I,2).EQ.94) THEN
          NJET=2
          IF(NHEP.GE.I+3.AND.K(I+3,3).LE.I) NJET=3
          IF(NHEP.GE.I+4.AND.K(I+4,3).LE.I) NJET=4
          JMOHEP(2,I)=MOD(K(I+NJET,4)/MSTU(5),MSTU(5))
          IF(JMOHEP(2,I).EQ.JMOHEP(1,I)) JMOHEP(2,I)=
     &    MOD(K(I+1,4)/MSTU(5),MSTU(5))
        ENDIF

C...Fill in missing daughter information.
        IF(K(I,2).EQ.94.AND.MSTU(16).NE.2) THEN
          DO 130 I1=JDAHEP(1,I),JDAHEP(2,I)
          I2=MOD(K(I1,4)/MSTU(5),MSTU(5))
          JDAHEP(1,I2)=I
  130     CONTINUE
        ENDIF
        IF(K(I,2).GE.91.AND.K(I,2).LE.94) GOTO 140
        I1=JMOHEP(1,I)
        IF(I1.LE.0.OR.I1.GT.NHEP) GOTO 140
        IF(K(I1,1).NE.13.AND.K(I1,1).NE.14) GOTO 140
        IF(JDAHEP(1,I1).EQ.0) THEN
          JDAHEP(1,I1)=I
        ELSE
          JDAHEP(2,I1)=I
        ENDIF
  140   CONTINUE
        DO 150 I=1,NHEP
        IF(K(I,1).NE.13.AND.K(I,1).NE.14) GOTO 150
        IF(JDAHEP(2,I).EQ.0) JDAHEP(2,I)=JDAHEP(1,I)
  150   CONTINUE

C...Conversion from standard to JETSET, the easy part.
      ELSE
        IF(NHEP.GT.MSTU(4)) write(6,*)
     &  '(LUHEPC:) no more space in /LUJETS/'
        N=MIN(NHEP,MSTU(4))
        NKQ=0
        KQSUM=0
        DO 180 I=1,N
        K(I,1)=0
        IF(ISTHEP(I).EQ.1) K(I,1)=1
        IF(ISTHEP(I).EQ.2) K(I,1)=11
        IF(ISTHEP(I).EQ.3) K(I,1)=21
        K(I,2)=IDHEP(I)
        K(I,3)=JMOHEP(1,I)
        K(I,4)=JDAHEP(1,I)
        K(I,5)=JDAHEP(2,I)
        DO 160 J=1,5
        P(I,J)=PHEP(J,I)
  160   CONTINUE
        DO 170 J=1,4
        V(I,J)=VHEP(J,I)
  170   CONTINUE
        V(I,5)=0.
        IF(ISTHEP(I).EQ.2.AND.PHEP(4,I).GT.PHEP(5,I)) THEN
          I1=JDAHEP(1,I)
          IF(I1.GT.0.AND.I1.LE.NHEP) V(I,5)=(VHEP(4,I1)-VHEP(4,I))*
     &    PHEP(5,I)/PHEP(4,I)
        ENDIF

C...Fill in missing information on colour connection in jet systems.
        IF(ISTHEP(I).EQ.1) THEN
          KC=HZLCOMP(K(I,2))
          KQ=0
          IF(KC.NE.0) KQ=KCHG(KC,2)*ISIGN(1,K(I,2))
          IF(KQ.NE.0) NKQ=NKQ+1
          IF(KQ.NE.2) KQSUM=KQSUM+KQ
          IF(KQ.NE.0.AND.KQSUM.NE.0) THEN
            K(I,1)=2
          ELSEIF(KQ.EQ.2.AND.I.LT.N) THEN
            IF(K(I+1,2).EQ.21) K(I,1)=2
          ENDIF
        ENDIF
  180   CONTINUE
        IF(NKQ.EQ.1.OR.KQSUM.NE.0) write(6,*)
     &  '(LUHEPC:) input parton configuration not colour singlet'
      ENDIF

      END
*CMZ :  1.00/03 03/03/96  14.19.22  by  Mark Hayes
*CMZ :  0.00/03 16/01/96  18.07.27  by  Tancredi Carli
*CMZ :  0.00/01 05/01/96  14.14.00  by  HZtool
*-- Author :
      Subroutine hzphocop
*************************************************************
* Purpose:
* Deal with copying PHOJET HEPEVS -> HEPEVTP
* Input: none
* Output: none
* Author: N. Brook
*************************************************************
      PARAMETER (NMXHEP=2000)
      Double Precision phep, vhep, rmass, bfrac, cmmom, etamix, lifetm
      Double Precision phepp, vhepp
*
      COMMON/HEPEVTP/NEVHEPp,NHEPp,ISTHEPp(NMXHEP),IDHEPp(NMXHEP),
     & JMOHEPp(2,NMXHEP),JDAHEPp(2,NMXHEP),PHEPp(5,NMXHEP),
     1 VHEPp(4,NMXHEP)
      COMMON/HEPEVS/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*
      Double Precision pi, plab(3)
      Data pi/3.1415927/
*
      NHEPp = NHEP
      NEVHEPp = NEVHEP
      Do ihep = 1, nhep
        isthepp(ihep) = isthep(ihep)
        idhepp(ihep) = idhep(ihep)
        jmohepp(1,ihep) = jmohep(1,ihep)
        jmohepp(2,ihep) = jmohep(2,ihep)
        jdahepp(1,ihep) = jdahep(1,ihep)
        jdahepp(2,ihep) = jdahep(2,ihep)
        do ivec = 1, 5
C         plab(ivec) = phep(ivec,ihep)
C         call hzphmrot(0.d0,pi,plab,plab)
C         phepp(ivec,ihep) = plab(ivec)
          phepp(ivec,ihep) = phep(ivec,ihep)
        Enddo
        do ivec = 1, 4
         vhepp(ivec,ihep) = vhep(ivec,ihep)
        Enddo
        ihchrg(ihep) = HZLCHGE(idhep(ihep))
      Enddo
*
      Return
      End
*CMZ :  1.01/05 13/06/97  14.34.14  by  Thorsten Wengler
*-- Author :    Thorsten Wengler   12/06/97
***************************************************************
      SUBROUTINE HZDJHEPC(MCONV)
***************************************************************
* Author :Thorsten Wengler
*
* Adapted from HZLUHEPC for Django using DJHEPC(MCONV) from
* H1 installation of Django 6
***************************************************************
C...Purpose: to convert JETSET event record contents to or from
C...the standard event record commonblock.
      PARAMETER (NMXHEP=2000)
      Double Precision phep, vhep
      COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     &JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
      COMMON/LUJETS/N,K(4000,5),P(4000,5),V(4000,5)
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)
      SAVE /HEPEVT/
      SAVE /LUJETS/,/LUDAT1/,/LUDAT2/
C*TC>
      Integer  HZLCOMP
C*TC<
C...Conversion from JETSET to standard, the easy part.
      IF(MCONV.EQ.1) THEN
        NEVHEP=0
        IF(N.GT.NMXHEP) write(6,*)
     &  '(LUHEPC:) no more space in /HEPEVT/ '
        NHEP=MIN(N,NMXHEP)
        DO 140 I=1,NHEP
        ISTHEP(I)=0
        IF(K(I,1).GE.1.AND.K(I,1).LE.10) ISTHEP(I)=1
C       IF(K(I,1).GE.11.AND.K(I,1).LE.20) ISTHEP(I)=2
        IF(K(I,1).GE.11.AND.K(I,1).LE.20) ISTHEP(I)=k(i,1)
        IF(K(I,1).GE.21.AND.K(I,1).LE.30) ISTHEP(I)=3
        IF(K(I,1).GE.31.AND.K(I,1).LE.100) ISTHEP(I)=K(I,1)
        IDHEP(I)=K(I,2)
        JMOHEP(1,I)=K(I,3)
        JMOHEP(2,I)=0
        IF(K(I,1).NE.3.AND.K(I,1).NE.13.AND.K(I,1).NE.14) THEN
          JDAHEP(1,I)=K(I,4)
          JDAHEP(2,I)=K(I,5)
        ELSE
          JDAHEP(1,I)=0
          JDAHEP(2,I)=0
        ENDIF
CTW       DO 100 J=1,5
CTW 100   PHEP(J,I)=P(I,J)
CTW-->
          DO 100 J = 1, 3
  100     PHEP(J,I)  = -P(I,J)
          PHEP(4,I)  = P(I,4)
          PHEP(5,I)  = P(I,5)
CTW<--
        DO 110 J=1,4
  110   VHEP(J,I)=V(I,J)

C...Check if new event (from pileup).
        IF(I.EQ.1) THEN
          INEW=1
        ELSE
          IF(K(I,1).EQ.21.AND.K(I-1,1).NE.21) INEW=I
        ENDIF

C...Fill in missing mother information.
        IF(I.GE.INEW+2.AND.K(I,1).EQ.21.AND.K(I,3).EQ.0) THEN
          IMO1=I-2
          IF(I.GE.INEW+3.AND.K(I-1,1).EQ.21.AND.K(I-1,3).EQ.0)
     &    IMO1=IMO1-1
          JMOHEP(1,I)=IMO1
          JMOHEP(2,I)=IMO1+1
        ELSEIF(K(I,2).GE.91.AND.K(I,2).LE.93) THEN
          I1=K(I,3)-1
  120     I1=I1+1
          IF(I1.GE.I) write(6,*)
     &    '(LUHEPC:) translation of inconsistent event history'
          IF(I1.LT.I.AND.K(I1,1).NE.1.AND.K(I1,1).NE.11) GOTO 120
          KC=HZLCOMP(K(I1,2))
          IF(I1.LT.I.AND.KC.EQ.0) GOTO 120
          IF(I1.LT.I.AND.KCHG(KC,2).EQ.0) GOTO 120
          JMOHEP(2,I)=I1
        ELSEIF(K(I,2).EQ.94) THEN
          NJET=2
          IF(NHEP.GE.I+3.AND.K(I+3,3).LE.I) NJET=3
          IF(NHEP.GE.I+4.AND.K(I+4,3).LE.I) NJET=4
          JMOHEP(2,I)=MOD(K(I+NJET,4)/MSTU(5),MSTU(5))
          IF(JMOHEP(2,I).EQ.JMOHEP(1,I)) JMOHEP(2,I)=
     &    MOD(K(I+1,4)/MSTU(5),MSTU(5))
        ENDIF

C...Fill in missing daughter information.
        IF(K(I,2).EQ.94.AND.MSTU(16).NE.2) THEN
          DO 130 I1=JDAHEP(1,I),JDAHEP(2,I)
          I2=MOD(K(I1,4)/MSTU(5),MSTU(5))
          JDAHEP(1,I2)=I
  130     CONTINUE
        ENDIF
        IF(K(I,2).GE.91.AND.K(I,2).LE.94) GOTO 140
        I1=JMOHEP(1,I)
        IF(I1.LE.0.OR.I1.GT.NHEP) GOTO 140
        IF(K(I1,1).NE.13.AND.K(I1,1).NE.14) GOTO 140
        IF(JDAHEP(1,I1).EQ.0) THEN
          JDAHEP(1,I1)=I
        ELSE
          JDAHEP(2,I1)=I
        ENDIF
  140   CONTINUE
        DO 150 I=1,NHEP
        IF(K(I,1).NE.13.AND.K(I,1).NE.14) GOTO 150
        IF(JDAHEP(2,I).EQ.0) JDAHEP(2,I)=JDAHEP(1,I)
  150   CONTINUE

C...Conversion from standard to JETSET, the easy part.
      ELSE
        IF(NHEP.GT.MSTU(4)) write(6,*)
     &  '(LUHEPC:) no more space in /LUJETS/'
        N=MIN(NHEP,MSTU(4))
        NKQ=0
        KQSUM=0
        DO 180 I=1,N
        K(I,1)=0
        IF(ISTHEP(I).EQ.1) K(I,1)=1
        IF(ISTHEP(I).EQ.2) K(I,1)=11
        IF(ISTHEP(I).EQ.3) K(I,1)=21
        K(I,2)=IDHEP(I)
        K(I,3)=JMOHEP(1,I)
        K(I,4)=JDAHEP(1,I)
        K(I,5)=JDAHEP(2,I)
        DO 160 J=1,5
        P(I,J)=PHEP(J,I)
  160   CONTINUE
        DO 170 J=1,4
        V(I,J)=VHEP(J,I)
  170   CONTINUE
        V(I,5)=0.
        IF(ISTHEP(I).EQ.2.AND.PHEP(4,I).GT.PHEP(5,I)) THEN
          I1=JDAHEP(1,I)
          IF(I1.GT.0.AND.I1.LE.NHEP) V(I,5)=(VHEP(4,I1)-VHEP(4,I))*
     &    PHEP(5,I)/PHEP(4,I)
        ENDIF

C...Fill in missing information on colour connection in jet systems.
        IF(ISTHEP(I).EQ.1) THEN
          KC=HZLCOMP(K(I,2))
          KQ=0
          IF(KC.NE.0) KQ=KCHG(KC,2)*ISIGN(1,K(I,2))
          IF(KQ.NE.0) NKQ=NKQ+1
          IF(KQ.NE.2) KQSUM=KQSUM+KQ
          IF(KQ.NE.0.AND.KQSUM.NE.0) THEN
            K(I,1)=2
          ELSEIF(KQ.EQ.2.AND.I.LT.N) THEN
            IF(K(I+1,2).EQ.21) K(I,1)=2
          ENDIF
        ENDIF
  180   CONTINUE
        IF(NKQ.EQ.1.OR.KQSUM.NE.0) write(6,*)
     &  '(LUHEPC:) input parton configuration not colour singlet'
      ENDIF

      END
*CMZ :  1.02/01 11/10/98  19.46.00  by  Hannes Jung
*-- Author :
C*********************************************************************

C...PYHEPC
C...Converts PYTHIA event record contents to or from
C...the standard event record commonblock.

      SUBROUTINE HZPYHEPC(MCONV)

C...Double precision and integer declarations.
      IMPLICIT DOUBLE PRECISION(A-H, O-Z)
      INTEGER HZPCOMP
C...Commonblocks.
      COMMON/PYJETS/N,NPAD,K(4000,5),P(4000,5),V(4000,5)
      COMMON/PYDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
      COMMON/PYDAT2/KCHG(500,4),PMAS(500,4),PARF(2000),VCKM(4,4)
      SAVE /PYJETS/,/PYDAT1/,/PYDAT2/
C...HEPEVT commonblock.
cc      PARAMETER (NMXHEP=4000)
c changed for hztool
      PARAMETER (NMXHEP=2000)
      DOUBLE PRECISION PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     &JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
      SAVE /HEPEVTP/

*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
      EXTERNAL HZPCOMP
C...Conversion from PYTHIA to standard, the easy part.
      IF(MCONV.EQ.1) THEN
        NEVHEP=0
        IF(N.GT.NMXHEP) write(6,*)
     &  '(HZPYHEPC:) no more space in /HEPEVT/'
        NHEP=MIN(N,NMXHEP)
        DO 140 I=1,NHEP
          ISTHEP(I)=0
          IF(K(I,1).GE.1.AND.K(I,1).LE.10) ISTHEP(I)=1
          IF(K(I,1).GE.11.AND.K(I,1).LE.20) ISTHEP(I)=2
          IF(K(I,1).GE.21.AND.K(I,1).LE.30) ISTHEP(I)=3
          IF(K(I,1).GE.31.AND.K(I,1).LE.100) ISTHEP(I)=K(I,1)
          IDHEP(I)=K(I,2)
          JMOHEP(1,I)=K(I,3)
          JMOHEP(2,I)=0
          IF(K(I,1).NE.3.AND.K(I,1).NE.13.AND.K(I,1).NE.14) THEN
            JDAHEP(1,I)=K(I,4)
            JDAHEP(2,I)=K(I,5)
          ELSE
            JDAHEP(1,I)=0
            JDAHEP(2,I)=0
          ENDIF
          DO 100 J=1,5
            PHEP(J,I)=P(I,J)
  100     CONTINUE
          DO 110 J=1,4
            VHEP(J,I)=V(I,J)
  110     CONTINUE
c this is included for hztool
          ihchrg(i) = HZLCHGE(idhep(i))
C...Check if new event (from pileup).
          IF(I.EQ.1) THEN
            INEW=1
          ELSE
            IF(K(I,1).EQ.21.AND.K(I-1,1).NE.21) INEW=I
          ENDIF

C...Fill in missing mother information.
          IF(I.GE.INEW+2.AND.K(I,1).EQ.21.AND.K(I,3).EQ.0) THEN
            IMO1=I-2
            IF(I.GE.INEW+3.AND.K(I-1,1).EQ.21.AND.K(I-1,3).EQ.0)
     &      IMO1=IMO1-1
            JMOHEP(1,I)=IMO1
            JMOHEP(2,I)=IMO1+1
          ELSEIF(K(I,2).GE.91.AND.K(I,2).LE.93) THEN
            I1=K(I,3)-1
  120       I1=I1+1
            IF(I1.GE.I) write(6,*)
     &      '(HZPYHEPC:) translation of inconsistent event history'
     &      ,I1,I,K(I,2),K(I,3)
            IF(I1.LT.I.AND.K(I1,1).NE.1.AND.K(I1,1).NE.11) GOTO 120
            KC=HZPCOMP(K(I1,2))
            IF(I1.LT.I.AND.KC.EQ.0) GOTO 120
            IF(I1.LT.I.AND.KCHG(KC,2).EQ.0) GOTO 120
            JMOHEP(2,I)=I1
          ELSEIF(K(I,2).EQ.94) THEN
            NJET=2
            IF(NHEP.GE.I+3.AND.K(I+3,3).LE.I) NJET=3
            IF(NHEP.GE.I+4.AND.K(I+4,3).LE.I) NJET=4
            JMOHEP(2,I)=MOD(K(I+NJET,4)/MSTU(5),MSTU(5))
            IF(JMOHEP(2,I).EQ.JMOHEP(1,I)) JMOHEP(2,I)=
     &      MOD(K(I+1,4)/MSTU(5),MSTU(5))
          ENDIF

C...Fill in missing daughter information.
          IF(K(I,2).EQ.94.AND.MSTU(16).NE.2) THEN
            DO 130 I1=JDAHEP(1,I),JDAHEP(2,I)
              I2=MOD(K(I1,4)/MSTU(5),MSTU(5))
              JDAHEP(1,I2)=I
  130       CONTINUE
          ENDIF
          IF(K(I,2).GE.91.AND.K(I,2).LE.94) GOTO 140
          I1=JMOHEP(1,I)
          IF(I1.LE.0.OR.I1.GT.NHEP) GOTO 140
          IF(K(I1,1).NE.13.AND.K(I1,1).NE.14) GOTO 140
          IF(JDAHEP(1,I1).EQ.0) THEN
            JDAHEP(1,I1)=I
          ELSE
            JDAHEP(2,I1)=I
          ENDIF
  140   CONTINUE
        DO 150 I=1,NHEP
          IF(K(I,1).NE.13.AND.K(I,1).NE.14) GOTO 150
          IF(JDAHEP(2,I).EQ.0) JDAHEP(2,I)=JDAHEP(1,I)
  150   CONTINUE

C...Conversion from standard to PYTHIA, the easy part.
      ELSE
        IF(NHEP.GT.MSTU(4)) write(6,*)
     &  '(HZPYHEPC:) no more space in /PYJETS/'
        N=MIN(NHEP,MSTU(4))
        NKQ=0
        KQSUM=0
        DO 180 I=1,N
          K(I,1)=0
          IF(ISTHEP(I).EQ.1) K(I,1)=1
          IF(ISTHEP(I).EQ.2) K(I,1)=11
          IF(ISTHEP(I).EQ.3) K(I,1)=21
          K(I,2)=IDHEP(I)
          K(I,3)=JMOHEP(1,I)
          K(I,4)=JDAHEP(1,I)
          K(I,5)=JDAHEP(2,I)
          DO 160 J=1,5
            P(I,J)=PHEP(J,I)
  160     CONTINUE
          DO 170 J=1,4
            V(I,J)=VHEP(J,I)
  170     CONTINUE
          V(I,5)=0D0
          IF(ISTHEP(I).EQ.2.AND.PHEP(4,I).GT.PHEP(5,I)) THEN
            I1=JDAHEP(1,I)
            IF(I1.GT.0.AND.I1.LE.NHEP) V(I,5)=(VHEP(4,I1)-VHEP(4,I))*
     &      PHEP(5,I)/PHEP(4,I)
          ENDIF

C...Fill in missing information on colour connection in jet systems.
          IF(ISTHEP(I).EQ.1) THEN
            KC=HZPCOMP(K(I,2))
            KQ=0
            IF(KC.NE.0) KQ=KCHG(KC,2)*ISIGN(1,K(I,2))
            IF(KQ.NE.0) NKQ=NKQ+1
            IF(KQ.NE.2) KQSUM=KQSUM+KQ
            IF(KQ.NE.0.AND.KQSUM.NE.0) THEN
              K(I,1)=2
            ELSEIF(KQ.EQ.2.AND.I.LT.N) THEN
              IF(K(I+1,2).EQ.21) K(I,1)=2
            ENDIF
          ENDIF
  180   CONTINUE
        IF(NKQ.EQ.1.OR.KQSUM.NE.0) write(6,*)
     &  '(HZPYHEPC:) input parton configuration not colour singlet'
      ENDIF

      END
*CMZ :  1.01/13 19/03/98  06.49.03  by  Hannes Jung
*CMZ :  1.01/07 18/03/98  22.44.39  by  Tancredi Carli
*CMZ :  0.00/03 16/01/96  18.10.57  by  Tancredi Carli
*CMZ :  0.00/01 05/01/96  14.13.31  by  HZtool
*-- Author :
      Subroutine Hzpycop
*************************************************************
* Purpose:
* Deal with copying Lund HEPEVT -> HEPEVTP
* Input: none
* Output: none
* Author: N. Brook
*************************************************************
      PARAMETER (NMXHEP=2000)
      Double Precision phepp, vhepp
      COMMON/HEPEVTP/NEVHEPp,NHEPp,ISTHEPp(NMXHEP),IDHEPp(NMXHEP),
     & JMOHEPp(2,NMXHEP),JDAHEPp(2,NMXHEP),PHEPp(5,NMXHEP),
     1 VHEPp(4,NMXHEP)
*
      Double Precision phep, vhep
      COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
      Logical lp
      Data lp/.false./
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*
      NHEPp = NHEP
      NEVHEPp = NEVHEP
      if (lp) write(6,*) ' GEN= ',GEN
      if (lp) write(6,*) ' nhep= ',nhep
      Do ihep = 1, nhep
        isthepp(ihep) = isthep(ihep)
        idhepp(ihep) = idhep(ihep)
        jmohepp(1,ihep) = jmohep(1,ihep)
        jmohepp(2,ihep) = jmohep(2,ihep)
        jdahepp(1,ihep) = jdahep(1,ihep)
        jdahepp(2,ihep) = jdahep(2,ihep)
        do ivec = 1, 5
         phepp(ivec,ihep) = dble(phep(ivec,ihep))
        Enddo
        do ivec = 1, 4
         vhepp(ivec,ihep) = dble(vhep(ivec,ihep))
        Enddo
        ihchrg(ihep) = HZLCHGE(idhep(ihep))
        if (lp) then
         write(6,*) ' ihchrg(ihep)= ',ihchrg(ihep),' id= ',idhep(ihep)
         write(6,*) ' vhep = ', (phepp(ivec,ihep),ivec=1,5)
        endif
      Enddo
*
      Return
      End
*CMZ :  0.00/03 05/10/98  23.32.42  by  Tancredi Carli
*-- Author :
       subroutine hzlijet(njet,jets)
*********************************************
*
*
********************************************
*
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*
*     MAXHZJETS: maxmial number of jet allowed
*     NUMJET: number of jets from jet algo
*     NSEL  : number of selected jets
*     IPJET : pointer to selected jets
*     JETS  : Jet variables (eta,phi,et,e,px,py,pz,m) in choosen frame
*     IJETNO: pointer which objects in PHEP common belong to jets
*
      INTEGER MAXHZJETS
      PARAMETER (MAXHZJETS=50)
      INTEGER NSEL,NUMJETS,IPJET(MAXHZJETS),IJETNO(NMXHEP)
      DOUBLE PRECISION JETS(MAXHZJETS,8)
*
C      COMMON /HZJETCMN/JETS,NUMJETS,NSEL,IPJET
*
       write(6,*) ' # of jets= ',njet
*
       write(6,*) '      eta     phi     Et      px      py ',
     &'     pz       E      Mass'
*
       Do j=1,njet
        write(6,'(i3,8(1x,f7.3))') j,
     &  jets(j,1),jets(j,2),jets(j,3),
     &  jets(j,5),jets(j,6),jets(j,7),jets(j,4),jets(j,8)
       enddo
*
       return
       end
*CMZ :  2.00/04 31/07/2000  17.46.48  by  Tancredi Carli
*CMZ :  1.01/01 25/03/96  15.06.06  by  Tancredi Carli
*CMZ :  0.00/03 16/01/96  18.07.27  by  Tancredi Carli
*CMZ :  0.00/01 05/01/96  14.14.00  by  HZtool
*-- Author :
      Subroutine hzpytcop
*************************************************************
* Purpose:
* when using herwig for partons and pythia/jetset for
* fragmentation and decays, then the 3-momentum-vectors in
* common/hepevtp/ need to be rotated.
*
* Input: none
* Output: none
* Author: G. Grindhammer
*
*************************************************************
      PARAMETER (NMXHEP=2000)
      Double Precision phep, vhep, rmass, bfrac, cmmom, etamix, lifetm
      Double Precision phepp, vhepp
*
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),
     1 VHEP(4,NMXHEP)
*
*KEEP,HERACMN.
*
* HERA common
*
*     GEN: Name of generator
*     XSEC: total cross section (in pb)
*     IHCHRG: charge of particle/parton times 3
*     NTOT : Number of total events
*     WTX  : event weight
*
      Character*8 Gen
      Double Precision Xsec
      Integer ihchrg
      Real    wtx, Ntot
      Common /HERACMN/ Xsec, Gen, ihchrg(nmxhep), Ntot,wtx
*
*KEEP,HZFUNC.
*
* Function declarations for Hztool functions
*
          DOUBLE PRECISION HzPhmang
          DOUBLE PRECISION HzDiskin
          DOUBLE PRECISION HzPhokin
          DOUBLE PRECISION HZETA
          DOUBLE PRECISION HZPHI
          DOUBLE PRECISION HZET
          DOUBLE PRECISION HZPT
          DOUBLE PRECISION HZTHETA
          DOUBLE PRECISION hzeekin
          Integer hzeebeam
          Integer hzeegamn
          Integer HzIpgamn
          Integer HzIdelec
          Integer HzIpgam
          Integer HzIbeam
          Integer HzLchge
          Integer HzLcomp
          Integer HzIdntro
*
*KEND.
*
      Double Precision pi, plab(3)
      Data pi/3.1415927/
      Logical lp
      Data lp/.false./
*
      if (lp) then
       write(6,*) '**hzhrwpyt: Number of particles nhep = ',nhep
      endif
      Do ihep = 1, nhep

        if (lp) write(6,*) ihep,' 1: phep= ',(phep(i,ihep),i=1,4)

        do ivec = 1, 3
           plab(ivec) = phep(ivec,ihep)
        enddo
        call hzphmrot(0.d0,pi,plab,plab)
        do ivec = 1, 3
           phep(ivec,ihep) = plab(ivec)
        enddo

        if (lp) write(6,*) ihep,' 2: phep= ',(phep(i,ihep),i=1,4)

        ihchrg(ihep) = HZLCHGE(idhep(ihep))
      Enddo
*
      Return
      End
*CMZ :  0.00/03 29/10/98  11.19.11  by  Tancredi Carli
*-- Author :
      SUBROUTINE HzSvhepc
*************************************************************************
*  purpose:   this subroutine saves the HEP event prime common to
*             an internal copie
*
*  usage:     1. save the HEP event prime common with HzSvhepc
*             2. recover the stored HEP event prime common with HzRchepc
*
*  structure: HzTool subroutine HzMghepc is called
*
*  written by: Andreas von Manteuffel (Oct. 1998)
*************************************************************************
      IMPLICIT NONE
      call HzMghepc(1)
      RETURN
      END
*CMZ :  2.00/05 23/04/2001  22.28.48  by  Frank-Peter Schilling
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :

      SUBROUTINE HZHCMTOL(IOPT,PLEP2,PHAD2,POUT,P2,Q2,IRET)

       IMPLICIT NONE

*******************************************************************************
* BOOST PARTICLES BETWEEN HADRONIC CMS AND LAB (BOTH DIRECTIONS)
* (wrapping KTFRAM)
*
* Input: IPOT:     0 (boost lab->CMS) 1 (boost CMS->lab)
*        PLEP2(4): 4-vector of of lepton
*        PHAD2(4): 4-vector of of proton
*        POUT2(4): 4-vector of of scattered lepton
*        P2(4):    4-vector of particle before boost
*
* Output: Q2(4):   4-vector of particle after boost
*         IRET:    Error flag (=0: OK)
*
* Author: F.-P.Schilling
*******************************************************************************

      INTEGER N,i,IRET,IOPT
      DOUBLE PRECISION PLEP,PHAD,P(4,1),Q(4,1),p2(4),q2(4),
     &  CMF(4),Z(4),plep2(4),phad2(4),pout(4)

      IRET = 1

      N=1

      do i=1,4
         p(i,1)=p2(i)
      enddo

      plep = plep2(3)
      phad = phad2(3)

C---FIND 4-MOMENTUM OF HADRONIC CMF

      CMF(1)=         -POUT(1)
      CMF(2)=         -POUT(2)
      CMF(3)=    PLEP -POUT(3)+    PHAD
      CMF(4)=ABS(PLEP)-POUT(4)+ABS(PHAD)

C---FIND ROTATION TO PUT INCOMING HADRON BACK ON Z-AXIS

      Z(1)=0.d0
      Z(2)=0.d0
      Z(3)=PHAD
      Z(4)=ABS(PHAD)

      CALL KTFRAM(IOPT,CMF,PHAD,Z,POUT,N,P,Q,*999)
*      CALL KTFRAM(IOPT,CMF,-PHAD,Z,POUT,N,P,Q,*999)

      do i=1,4
         q2(i)=q(i,1)
      enddo

      IRET = 0
      RETURN
 999  print *,'ERROR in HZHCMTOL!!! <<<<<<<<<<<<<<<< !!!'
      iret = 1
      return
      END
*CMZ :  0.00/05 26/01/96  13.21.02  by  Mark Hayes
*-- Author :    Mark Hayes   22/01/96
         Subroutine EUHEPC

*------- Fills arrays suitable for EUCELL jet analysis.
* from HEPEVTP HERA Workshop '95-'96
* Author : M. Hayes
*

      IMPLICIT NONE

      INTEGER Nparts,ncell1,nicell,ifbreh,j
      REAL Vmain,Uxyze
      Parameter (ncell1=500)
      COMMON/EVOKE2/ nicell,Vmain(3),Uxyze(4,ncell1),ifbreh(2,ncell1)
      REAL Eemc0,Ehac0,Etemc0,Ethac0

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEND.

      Integer*4  ibyte(4), cellvector(5)
      Character*5 cellkind
      Real*4  radius(4)/3*10000.,1./

C --- Set cell energy cuts ---------------------------------
      Eemc0  = 0.
      Ehac0  = 0.
      Etemc0 = 0.
      Ethac0 = 0.
C ---

      CALL VZERO(VMAIN,3)

	nicell=0
	Do 40 Nparts=1,NHEP

         If (nicell.ge.ncell1) THEN
           go to 900
	 ENDIF

         If (PHEP(1,Nparts)**2 + PHEP(2,Nparts)**2 .le.0.1E-12) THEN
           go to 400
	 ENDIF

	 IF (ISTHEP(Nparts).eq.1) THEN
          nicell=nicell+1

          Do 30 j=1,4
             uxyze(j,nicell) = REAL(PHEP(j,Nparts))*radius(j)
 30        CONTINUE
           ifbreh(1,nicell)= 0
           ifbreh(2,nicell)= 1
	 ENDIF

 400	CONTINUE
 40	CONTINUE
	
      return

 900  PRINT*,'EUHEPC WARNING - too many particles.  Array truncated.'
      return
      end
*CMZ :  0.00/05 08/09/93  12.52.59  by  Jonathan Butterworth
*-- Author :
      SUBROUTINE PCONRAD(eta,radius)
*
********** just a dummy version ******** include your own if you like.
*                                (this just gives a fixed radius)
      COMMON/EUCONE/ifixr
      Data Iwrote/0/
      Save Iwrote
      Ifixr=1
      If(Iwrote.eq.1) RETURN
      Write(6,*) ' Fixed cone radius used.       You may supply your own
     1 subroutine PCONRAD to vary the cone radius if you like.'
      Iwrote=1
      RETURN
      end
      BLOCK DATA EUCON1
      COMMON/EUCONE/ifixr
      Data ifixr/0/
      end

*CMZ :  1.00/01 21/02/96  13.54.17  by  Tancredi Carli
*-- Author :
C ===============================================================
      SUBROUTINE EUCELL( E1,E2,  E3, E4, E5)
C#      SUBROUTINE EUCELL( E1,E2,  E3, E4, E5)
C#      ======================================
C#************************************************************************
C#
C@# EUCELL : adapted version of LUCELL jet finder ( cone algorithme).
C#
C# GENERAL DESCRIPTION  and METHOD :
C# -- This is an adapted version of LUCELL
C#   It is a simple jet finder in an eta-phi coordinate frame.
C#   A cone algorithm is used.   We don't do more energy smearing.
C#
C#   Energy signals (e.g. UCAL cells) are treated as massless particles.
C#   Groups of 9 cells (matched to cone angle)  are used as 'windows'.
C#   If sufficient integrated ET is found in a given window, the
C#   eta-phi value is used as a candidate for a possible jet direction.
C#   ET is the main jet criterion.  The jet is aligned along a
C#   weighted eta, phi direction if this preserves the jet ET.
C#
C#   The main vertex is taken into account  (default = 0., 0., 0.,).
C#
C#-----------------------------------------------------------------------
C#   USAGE:  from an EAZE job two calls are needed.
C#            CALL EUFILL                  (to fill some arrays)
C#            CALL EUCELL(E1,E2,E3,E4,E5)
C#  After this, optionally,
C#            CALL EUPIC
C#  will give line-printer diagrams of the energy flow and found jets.
C#  The calling program must contain  COMMON/EUJETS/     (see below)
C#
C#  INPUT PARAMETERS:      E1,  E2,      E3,     E4,        E5,
C#  (corresponding to    ..PARU(51)..   (52)    (53)       (54)
C#    in LUCELL)        etamax,etamin   ETmin  ETjet0   cone-radius
C#                     rapidity limits   GeV     GeV      radians
C#                      on cells used                    (if fixed)
C#                   (not on jet found)
C#         Defaults :      3.2, -3.0,    1.0,    2.5,      0.7
C#   (E1 =0. AND E2 =0.), E3 =0., E4 =0., or E5 =0. selects default.
C#   ETmin is the minimum ET of a window that we wish to consider
C#   for a jet search.
C#
C#   In addition, threshold E and Etransverse values for individual
C#   EMC, HAC cells must be stored in EEMC0, EHAC0, ETEMC0, ETHAC0.
C#   (The PUCELL defaults are 0.030, 0.080, 0., 0., respectively.)
C#
C#   OUTPUT DATA:  contained in KEEP SEQUENCE EUJETS :
C# +KEEP, EUJETS.
C#       Parameter (ncusmx=500)
C#       COMMON/EUJETS/ NJET,KJ(50,5),PJ(50,12),ETEMC0,ETHAC0,EEMC0,EHAC0
C#      1, NCUSE,KCUSE(ncusmx,5),PCUSE(ncusmx,10)
C#
C#   where :
C#     NJET = number of jets found (up to 50)
C#     PJ(i,j) = parameters of i-th jet.
C#          j  = 1,2     eta, phi  of cone axis.
C#               3,4     eta, phi (ET weighted calculation, may equal
C#                                 1,2)
C#                5      ET
C#               6-10    Momentum 4-vector and effective mass of jet.
C#                11     'Thrust' value of jet
C#                12     Energy of window used.
C#     KJ(i,j) has
C#          j  = 1,2,3   31, 98, number of jet (1,2,3 etc)
C#                4      100*no. of hac cells in jet + no. of emc cells
C#
C#     NCUSE  = no. of cells above threshold (includ. outside eta range)
C#     PCUSE(i,j) contains their parameters.  Useful ones are:
C#          j  = 1,2      eta, phi
C#               4,5      E, ET
C#               6,7      d(eta), d(phi) (+/-) covered by cell.
C#
C#  YOU MAY VARY THE CONE RADIUS with eta by supplying your own sub-
C#  routine to do this.   It must be called  SUBROUTINE PCONRAD(eta,rad)
C#  and output an angle 'rad' in radians.  It must be loaded to
C#  be used in priority over the default version in the EUCELL package.
C#**********************************************************************
C#   MODIFICATION LOG :
C#
C#*  Feb 94 - code tidied up.
C#***********************************************************************
C#   Nov 95 - cuts for quicker termination of the jet search tuned a bit.
C#          - max no. of iterations reduced.
C#          - quicker termination is now OPTIONAL.
C#            TO SWITCH IT ON, make the fourth parameter (min jet ET0) -ve.
C#            i.e. set -5. instead of 5. to get 5 GeV eT jets with quicker
C#            search termination.
C#***********************************************************************
*
      IMPLICIT Real (A-H,O-Z), Integer(I-N)
      Parameter (ncell1=500)
      COMMON/EVOKE2/ nicell,Vmain(3),Uxyze(4,ncell1),ifbreh(2,ncell1)
      COMMON/EUCONE/ifixr
      COMMON/EUPICN/ etamax,netas,nphi,etamin,IE0
      Parameter (ncusmx=500)
      COMMON/EUJETS/ NJET,KJ(50,5),PJ(50,12),ETEMC0,ETHAC0,EEMC0,EHAC0
     1, NCUSE,KCUSE(ncusmx,5),PCUSE(ncusmx,10)
      DIMENSION ETCELL(32,40), Klist(32,40), etaLIM(41), xyz(3)
     *,E0(2),ET0(2),KCcand(ncusmx)
      Data  par1, par2, par3, par4, par5 /3.2, -3.0, 1.0, 2.5, 0.7/
     1,deta/0.40/, nphi0/16/, pi,twopi/3.140592654,6.283185308/
      Data  indone/0/
      Equivalence (E0(1),Eemc0), (ET0(1),ETemc0)
      Save  dphi,deta,nphi0,pi,twopi,init,NJ

      Logical  termin
*
      termin=.false.
      If(E4.lt.0.) termin=.true.
      ienter=0
      Ifixr=0
      Itmax=12
      If(Indone.eq.0) then
       pi=atan2(0.,-1.)
       if(pi.lt.0.) pi=-pi
       twopi=2.*pi
        Call Uzero(PCUSE,1,10*NCUSMX)
C*TC<
C       Call Uzero(KCUSE,1, 5*NCUSMX)
        do i=1,NCUSMX
         do j=1,5
          KCUSE(i,j)=0
         enddo
        enddo
C*TC>
        Write(6,4)
   4    Format(/' First call to EUCELL, version Nov 95')
        Indone=1
      else
        Call Uzero(PCUSE,1,10*NCUSE)
C*TC<
C        Call Uzero(KCUSE,1, 5*NCUSE)
        do i=1,NCUSE
         do j=1,5
          KCUSE(i,j)=0
         enddo
        enddo
C*TC>
      endif
*
C*TC<
C       Call Uzero(klist,1,1280)
        do i=1,32
         do j=1,40
          klist(i,j)=0
         enddo
        enddo
C*TC>
      Call PCONRAD(0.,rcone0)
*                          -- to find if fixed cone radius is used.
      NJET=0
      If(nicell.eq.0) RETURN
      etamax=E1
      etamin=E2
      If(etamax.le.etamin) then
                    etamax= par1
                    etamin= par2
                      endif
      ETseed=abs(E3)
      If(ETseed.eq.0.) ETseed= par3
      ETjet0=abs(E4)
      If(ETjet0.eq.0.) ETjet0= par4
      cone0 =E5
      If(cone0 .le.0.) cone0 = par5
      If(Ifixr.ne.1) cone0=rcone0
       dphi0=twopi/nphi0
       nphi=nphi0
       If(dphi0.lt..50*cone0) nphi = 3*nphi0/4
       If(dphi0.lt..36*cone0) nphi =   nphi0/2
       If(dphi0.gt..65*cone0) nphi = 3*nphi0/2
       If(dphi0.gt.1.0*cone0) nphi = 2*nphi0
       dphi = twopi/float(nphi)
* --- Try to match cell size to cone size.  Dphi heavily quantized.
      deta=amax1( 0.50*cone0, 0.1)
      neta = max0(3, min0( INT((etamax-etamin)/deta) +1 , 40)  )
      deta1= (etamax-etamin)/neta
      IEhigh = max0(neta-1, 1)
*
*------- load up an array of eta bin boundaries starting from proton end
      eta = etamax
      neta=1
      deta2=deta1
      etalim(1)=etamax
  10  If(ifixr.ne.1) then
        Call PCONRAD(eta,rcone)
        deta2=amax1(0.5*rcone, 0.1)
        endif
      neta=neta+1
      etalim(neta)=etalim(neta-1) - deta2
      If(etalim(neta).gt.etamin.and.neta.lt.41) go to 10
      If(neta.ge.41) Write(6,*) ' EUCELL warning -- cone too small?'
      etafac=1.0001*(etamax-etamin)/(etamax-etalim(neta))
      IE0=0
      Do 15 i=2,neta
      etalim(i) = etamax - (etamax-etalim(i))*etafac
      If(etalim(i).lt.0.and.IE0.eq.0) IE0=i-1
  15  continue
         netas=neta
*
* - First load up the UCAL signals.
      NCUSE = 0
      ETACC=0.
      Do  30 i=1,nicell
      ifbr= ifbreh(1,i)
      ieh = ifbreh(2,i)
      Do 22 j=1,3
  22  xyz(j) = uxyze(j,i) - vmain(j)
      If(vmain(1)**2 + vmain(2)**2.gt.500.) then
          xyz(1) = uxyze(1,i)
          xyz(2) = uxyze(2,i)
          xyz(3) = uxyze(3,i)
               endif
*                         ( bad vertex.)
*
* -- First evaluate the basic quantities.
      x= xyz(1)
      y= xyz(2)
      z= xyz(3)
      r= sqrt(x**2 + y**2)
      rr   = 1./sqrt(r**2 +z**2)
      s = r*rr
      c = z*rr
      ET = uxyze(4,i)*s
*-    ----------- next section won't apply if we're using hadrons. -------
      If(ifbr.ge.1.and.ifbr.le.3.and.ieh.ge.1.and.ieh.le.2) Then
*-                       - In HAC, move longitudinal position in a bit.
        If(ieh.eq.2) then
          If(ifbr.ne.2) z = z - sign( (50. - 40.*abs(c)), z)
          If(ifbr.eq.2) r = r - (45. - 40.*s)
cc        If(ifbr.ne.2) z = z - sign(20.,z)
cc        If(ifbr.eq.2) r = r - 20.
          rr   = 1./sqrt(r**2 +z**2)
          s = r*rr
          c = z*rr
          ET = uxyze(4,i)*s
          endif
* -                                       -- check minimum energy.
        If(uxyze(4,i).lt.E0(ieh)) go to 30
        If(ET.lt.ET0(ieh)) go to 30
        EndIf
*      ---------------------------
      eta = sign(LOG( (1.+ABS(c))/s ),c)
      phi = Atan2(y,x)
      If(ABS(phi).GT.pi) phi = phi-sign(twopi,phi)
      IF(NCUSE.GE.ncell1) NJET=-2
      IF(NCUSE.GE.ncell1) RETURN
      NCUSE=NCUSE+1
      PCUSE(NCUSE,1)=eta
      PCUSE(NCUSE,2)=phi
      PCUSE(NCUSE,4)=uxyze(4,i)
      PCUSE(NCUSE,5)=ET
      PCUSE(NCUSE,6)=0.
      PCUSE(NCUSE,7)=0.
      IE=0
      If(eta.ge.etamin .and. eta.lt.etamax) Then
       ETACC=ETACC+ET
 28    IE=IE+1
       If(IE.gt.41) write(6,*)' SERIOUS warning. EUCELL IE out of range'
       If(IE.gt.41) STOP
         If(eta.lt.etalim(IE+1)) go to 28
       Endif
      KCUSE(NCUSE,1) = IE
      KCUSE(NCUSE,2) = min0(nphi, int((phi+pi)/dphi) + 1 )
      KCUSE(NCUSE,3) = i
      KCUSE(NCUSE,4) = 1 + 99*(ieh-1)
      KCUSE(NCUSE,5) = 0
*                 --- KCUSE(i,5) = or 0 = free, >0 = jet
  30  continue
      If(ETACC.lt.ETjet0) RETURN
      NJ=0
*
C...Put into cells.   Use highest ET as seed for jet attempt.
C                     * * * * Ignore signals already used. * * *
 40   Call Uzero(ETCELL,1,1280)
      IEhigh = max0(neta-1, 1)
      DO 45 I=1,NCUSE
      If(KCUSE(I,1).eq.0.or.KCUSE(I,5).gt.0) go to 45
      IE=KCUSE(I,1)
      IP=KCUSE(I,2)
      ETCELL(IP,IE) = ETCELL(IP,IE) +PCUSE(I,5)
  45  CONTINUE
      ETbest = 0.
      ETAbst = 99.
      PHIbst = 99.
      KLIM=-1
*
C...Look at groups of 9 cells if possible.
  60    EThigh=0.
        IEtop=IEhigh
        IEhigh=0
        DO 90 IP=1,nphi
        ip1=IP+1
        ip2=IP+2
        IF(ip1.gt.nphi) ip1=ip1-nphi
        IF(ip2.gt.nphi) ip2=ip2-nphi
        ip0=IP-1
        ip3=IP+3
        IF(ip0.le.  0 ) ip0=ip0+nphi
        IF(ip3.gt.nphi) ip3=ip3-nphi
        Do 80 IE=1,IEtop
        If(Klist(ip1,IE).lt.KLIM) go to 80
        Klist(ip1,IE) = 0
        E9  =  ETCELL(ip,ie)   + ETCELL(ip1,ie)   + ETCELL(ip2,ie)
     1      +  ETCELL(ip,ie+1) + ETCELL(ip1,ie+1) + ETCELL(ip2,ie+1)
        If(IE.gt.1) E9 =
     2   E9 +  ETCELL(ip,ie-1) + ETCELL(ip1,ie-1) + ETCELL(ip2,ie-1)
        If(E9.lt.ETseed) then
          Klist(ip1,IE)=-2
          Go to 80
          endif
*------ within a broader window see if there could be enough energy.
        IF(termin) THEN
        E25 = E9  + ETCELL(ip0,ie)   +ETCELL(ip3,ie)   +ETCELL(ip0,ie+1)
     1            + ETCELL(ip3,ie+1)
        If(Ie.gt.1)
     1  E25 = E25 + ETCELL(ip0,ie-1) +ETCELL(ip3,ie-1)
        If(Ie.gt.2)
     1  E25 = E25 + ETCELL(ip0,ie-2) +ETCELL(ip1,ie-2)
     2            + ETCELL(ip ,ie-2) +ETCELL(ip2,ie-2) +ETCELL(ip3,ie-2)
        If(Ie.le.neta-2)
     1  E25 = E25 + ETCELL(ip0,ie+2) +ETCELL(ip1,ie+2)
     2            + ETCELL(ip ,ie+2) +ETCELL(ip2,ie+2) +ETCELL(ip3,ie+2)

        If(E25.lt.0.3*ETJET0.or.E25.lt.0.2*ETbest) then
          Klist(ip1,IE)=-3
          Go to 80
          endif
        ENDIF
*
        If(IEhigh.lt.IE) IEhigh=IE
* --               --  aim is to limit maximum of eta scan.
        If(E9.gt.EThigh) then
           IETAS=IE
           IPHIS=ip1
           EThigh=E9
           endif
  80    Continue
  90    Continue
      KLIM=0
      IF(EThigh.lt.ETseed) then
*- No more seeds.  Keep stored best jet if there.  --> Otherwise finish.
         IF(ETbest.lT.ETjet0) go to 210
         NJ=NJ+1
         Klist(IPHISS,IETASS)=-5
         go to 40
*                  ----> look for next jet.
      endif
*
      Klist(IPHIS,IETAS)=-1
      If(IPHIS.gt.nphi) iphis=iphis-nphi
      ETA=0.5*(etalim(IETAS) + etalim(IETAS+1))
      PHI= -pi + (float(IPHIS) -0.5)*dphi
      IF(NJ.GE.500) then
        Write (6,*) 'EUCELL: no more memory left in PJ,KJ '
        NJET=-2
        RETURN
        endif
      Iter =0
      EJmax=0.00
*                         First NT iterations are more tolerant.
      NT=2
* ----------------------- Start of Jet iteration loop.
 150  Iter = Iter +1
      KJ4 =0
      PJ1=ETA
      PJ2=PHI
      PJ3=0.
      PJ4=0.
      PJ5=0.
*
C...Sum up free cells within required distance of initiator.
      If(ifixr.ne.1) call PCONRAD(eta,cone0)
      dcone=amax1(0.1*cone0, 0.1)
      DO 160 IC=1,NCUSE
      KCcand(IC) = 0
      If(KCUSE(IC,1).eq.0) go to 160
      If(KCUSE(IC,5).gt.0.and.KCUSE(IC,5).le.NJ) go to 160
      phic=PCUSE(IC,2)
      IF(abs(phic-phi).GT.pi) phic=phic+SIGN(twopi,phi)
      dazi=phic-phi
      IF( (abs(PCUSE(IC,1)-eta)-PCUSE(IC,6))**2
     1      + (abs(dazi)-PCUSE(IC,7))**2 .GT. cone0**2) go to 160
      KCcand(IC) = 1
      KJ4 = KJ4 +KCUSE(IC,4)
      PJ3 = PJ3 +PCUSE(IC,5)*PCUSE(IC,1)
      PJ4 = PJ4 +PCUSE(IC,5)*PHIC
      PJ5 = PJ5 +PCUSE(IC,5)
  160 CONTINUE
*          --- KJ(n,4) contains 100*no. of hac cells + no. of emc cells
*
      If(PJ5.gt.EJmax) then
       EJmax=PJ5
       EtaJM=eta
       PhiJM=phi
         endif
*
* ------- Stop iterating if it is too bad--------
      IF(termin) THEN
       If((Iter.gt.NT.or.Itmax.le.NT).and.PJ5.LT.0.4*ETjet0) goto 170
       If((Iter.gt.NT.or.Itmax.le.NT).and.EJmax.LT.0.4*ETbest) goto 60
       If((Iter.gt.2*NT.or.Itmax.le.NT).and.PJ5.LT.0.6*ETjet0) goto 170
       If((Iter.gt.2*NT.or.Itmax.le.NT).and.EJmax.LT.0.6*ETbest) goto 60
       ENDIF
      If(PJ5.lt.0.1*ETjet0) go to 170
*                                            (zero division protect)
      PJ3=PJ3/PJ5
      PJ4=PJ4/PJ5
      dazi=abs(PJ4-phi)
      If(ABS(PJ4).GT.pi) PJ4=PJ4-SIGN(twopi,PJ4)
      eta1=PJ3
      If(dazi.gt.pi) dazi=dazi-twopi
      If(Iter.eq.1 .or. (eta1-eta)**2+dazi**2 .gt.dcone**2) then
*--- Another iteration if this is the first, or if jet has changed.
             phi=PJ4
             eta=eta1
             If(Iter.ge.Itmax) go to 170
             Go to 150
           endif
*--- Prepare to accept the jet provisionally.
      If( PJ5.ge.ETjet0.and.PJ5.gt.ETbest) then
           ETAbst=  PJ3
           PHIbst=  PJ4
           ETbest = PJ5
           go to 180
           endif
*--- Otherwise, useless....... look for the next seed.
  170  continue
       If(PJ5.lt.ETjet0) Klist(IPHIS,IETAS)=-4
*                         .... flag cell used as failed seed.
       Go to 60
*----------------------------------------------- end of iteration loop
*
*---------------------- jet has been accepted.  Store its parameters.
*                       (They may be overwritten by a better jet.)
  180 PJ(NJ+1,1) = PJ1
      PJ(NJ+1,2) = PJ2
      PJ(NJ+1,3) = PJ3
      PJ(NJ+1,4) = PJ4
      PJ(NJ+1,5) = PJ5
      DO 190 J=6,9
  190 PJ(NJ+1,J)=0.
      KJ(NJ+1,4)=KJ4
      thr=0.
*-- Collect flagged signals.     KCcand(IC) labels signal in jet.
      DO 200 IC=1,NCUSE
        If(KCUSE(IC,5).gt.NJ) KCUSE(IC,5)=0
        IF(KCcand(IC).eq.0) go to 200
        PJ(NJ+1,6)=PJ(NJ+1,6)+PCUSE(IC,5)*COS(PCUSE(IC,2))
        PJ(NJ+1,7)=PJ(NJ+1,7)+PCUSE(IC,5)*SIN(PCUSE(IC,2))
        PJ(NJ+1,8)=PJ(NJ+1,8)+PCUSE(IC,5)*SINH(PCUSE(IC,1))
        PJ(NJ+1,9)=PJ(NJ+1,9)+PCUSE(IC,5)*COSH(PCUSE(IC,1))
        KCUSE(IC,5)= NJ+1
* calculate a thrust value.
        ce = cos(PCUSE(IC,1)-PJ(NJ+1,1))
        cp = cos(PCUSE(IC,2)-PJ(NJ+1,2))
        thr = thr + PCUSE(IC,5)/sqrt(1./cp**2 +1./ce**2 -1.)
  200   CONTINUE
      PJ(NJ+1,11)=thr/PJ(NJ+1,5)
      PJ(NJ+1,12)=Ethigh
      IETASS=IETAS
      IPHISS=IPHIS
      Go to 60
*------------------------------------------------------------------
*    Finished!   Fill in some more numbers.
 210  NJET=NJ
      DO 250 I=1,NJET
      KJ(I,1)=31
      KJ(I,2)=98
      KJ(I,3)=I
      KJ(I,5)=0
C...Convert to  massive four-vectors.
 250  PJ(I,10)=SQRT(MAX(0.,PJ(I,9)**2-PJ(I,8)**2-PJ(I,7)**2-PJ(I,6)**2))
      RETURN
      END
*CMZ :  1.01/05 29/01/97  13.21.31  by  Tancredi Carli
*CMZ :  0.00/05 17/01/96  10.56.40  by  Mark Hayes
*-- Author :
      SUBROUTINE PXCONE(MODE,NTRAK,ITKDM,PTRAK,CONER,EPSLON,OVLIM,MXJET,
     +                   NJET,PJET,IPASS,IJMUL,IERR)
*.*********************************************************
*. ------
*. PXCONE
*. ------
*.
*.********** Pre Release Version 26.2.93
*.
*. Driver for the Cone  Jet finding algorithm of L.A. del Pozo.
*. Based on algorithm from D.E. Soper.
*. Finds jets inside cone of half angle CONER with energy > EPSLON.
*. Jets which receive more than a fraction OVLIM of their energy from
*. overlaps with other jets are excluded.
*. Output jets are ordered in energy.
*. If MODE.EQ.2 momenta are stored as (eta,phi,<empty>,pt)
*. Usage     :
*.
*.      INTEGER  ITKDM,MXTRK
*.      PARAMETER  (ITKDM=4.or.more,MXTRK=1.or.more)
*.      INTEGER  MXJET, MXTRAK, MXPROT
*.      PARAMETER  (MXJET=10,MXTRAK=500,MXPROT=500)
*.      INTEGER  IPASS (MXTRAK),IJMUL (MXJET)
*.      INTEGER  NTRAK,NJET,IERR,MODE
*.      DOUBLE PRECISION  PTRAK (ITKDM,MXTRK),PJET (5,MXJET)
*.      DOUBLE PRECISION  CONER, EPSLON, OVLIM
*.      NTRAK = 1.to.MXTRAK
*.      CONER   = ...
*.      EPSLON  = ...
*.      OVLIM   = ...
*.      CALL PXCONE (MODE,NTRAK,ITKDM,PTRAK,CONER,EPSLON,OVLIM,MXJET,
*.     +             NJET,PJET,IPASS,IJMUL,IERR)
*.
*. INPUT     :  MODE      2=>e+e-, 1=>hadron-hadron
*.		In e+e- mode you give (px,py,px,e) and in h-h mode
*.		you give (eta,phi,<empty>,pt)
*. INPUT     :  NTRAK     Number of particles
*. INPUT     :  ITKDM     First dimension of PTRAK array
*. INPUT     :  PTRAK     Array of particle 4-momenta (Px,Py,Pz,E)
*. INPUT     :  CONER     Cone size (half angle) in radians
*. INPUT     :  EPSLON    Minimum Jet energy (GeV)
*. INPUT     :  OVLIM     Maximum fraction of overlap energy in a jet
*. INPUT     :  MXJET     Maximum possible number of jets
*. OUTPUT    :  NJET      Number of jets found
*. OUTPUT    :  PJET      5-vectors of jets
*. OUTPUT    :  IPASS(k)  Particle k belongs to jet number IPASS(k)
*.                        IPASS = -1 if not assosciated to a jet
*. OUTPUT    :  IJMUL(i)  Jet i contains IJMUL(i) particles
*. OUTPUT    :  IERR      = 0 if all is OK ;   = -1 otherwise
*.
*. CALLS     : PXSEAR, PXSAME, PXNEW, PXTRY, PXORD, PXUVEC, PXOLAP
*. CALLED    : User
*.
*. AUTHOR    :  L.A. del Pozo
*. CREATED   :  26-Feb-93
*. LAST MOD  :   2-Mar-93
*.
*. Modification Log.
*. 4-Apr-93: M H Seymour  - Change 2d arrays to 1d in PXTRY & PXNEW
*. 2-Apr-93: M H Seymour  - Major changes to add boost-invariant mode
*. 1-Apr-93: M H Seymour  - Increase all array sizes
*. 30-Mar-93: M H Seymour - Change all REAL variables to DOUBLE PRECISION
*. 30-Mar-93: M H Seymour - Change OVLIM into an input parameter
*. 2-Mar-93: L A del Pozo - Fix Bugs in PXOLAP
*. 1-Mar-93: L A del Pozo - Remove Cern library routine calls
*. 1-Mar-93: L A del Pozo - Add Print out of welcome and R and Epsilon
*.
*.*********************************************************
C+SEQ,DECLARE.
*** External Arrays
      INTEGER  ITKDM,MXJET,NTRAK,NJET,IERR,MODE
      INTEGER  IPASS (*),IJMUL (MXJET)
      DOUBLE PRECISION  PTRAK (ITKDM,*),PJET (5,*), CONER, EPSLON, OVLIM
*** Internal Arrays
      INTEGER MXPROT, MXTRAK
      PARAMETER (MXPROT=500, MXTRAK=500)
      DOUBLE PRECISION PP(4,MXTRAK), PU(3,MXTRAK), PJ(4,MXPROT)
      LOGICAL*1 JETLIS(MXPROT,MXTRAK)
*** Used in the routine.
      DOUBLE PRECISION COSR,COS2R, VSEED(3), VEC1(3), VEC2(3),PTSQ,PPSQ,
     +     COSVAL,PXMDPI
      LOGICAL*1 UNSTBL
      INTEGER I,J,N,MU,N1,N2, ITERR
      INTEGER NCALL, NPRINT
      DOUBLE PRECISION ROLD, EPSOLD, OVOLD
      SAVE NCALL,NPRINT,ROLD, EPSOLD, OVOLD
      DATA NCALL,NPRINT /0,0/
      IERR=0
*
*** INITIALIZE
      IF(NCALL.LE.0)  THEN
         ROLD = 0.
         EPSOLD = 0.
         OVOLD = 0.
      ENDIF
      NCALL = NCALL + 1
*
*** Print welcome and Jetfinder parameters
      IF((CONER.NE.ROLD .OR. EPSLON.NE.EPSOLD .OR. OVLIM.NE.OVOLD)
     +     .AND. NPRINT.LE.10) THEN
         WRITE(6,*)
         WRITE(6,1003)' ********** PXCONE: Cone Jet-finder **********'
         WRITE(6,1003)'    Written by Luis Del Pozo of OPAL'
         IF (MODE.EQ.2)
     $   WRITE(6,1003)'    Modified for eta-phi by Mike Seymour'
         WRITE(6,1000)'   Cone Size R = ',CONER,' Radians'
         WRITE(6,1001)'   Min Jet energy Epsilon = ',EPSLON,' GeV'
         WRITE(6,1002)'   Overlap fraction parameter = ',OVLIM
         WRITE(6,1003)' *********************************************'
         WRITE(6,*)
1000     FORMAT(A18,F5.2,A10)
1001     FORMAT(A29,F5.2,A5)
1002     FORMAT(A33,F5.2)
1003     FORMAT(A)
         NPRINT = NPRINT + 1
         ROLD=CONER
         EPSOLD=EPSLON
         OVOLD=OVLIM
      ENDIF
*
*** Copy calling array PTRAK  to internal array PP(4,NTRAK)
*
      IF (NTRAK .GT. MXTRAK) THEN
         WRITE (6,*) ' PXCONE: Ntrak too large'
         IERR=-1
         RETURN
      ENDIF
      IF (MODE.NE.2) THEN
         DO  100 I=1, NTRAK
            DO  101 J=1,4
               PP(J,I)=PTRAK(J,I)
101         CONTINUE
100      CONTINUE
      ELSE
*** Converting to eta,phi,pt if necessary
         DO  104 I=1,NTRAK
            PTSQ=PTRAK(1,I)**2+PTRAK(2,I)**2
            PPSQ=(SQRT(PTSQ+PTRAK(3,I)**2)+ABS(PTRAK(3,I)))**2
            IF (PTSQ.LE.4.25E-18*PPSQ) THEN
               PP(1,I)=20
            ELSE
               PP(1,I)=0.5*LOG(PPSQ/PTSQ)
            ENDIF
            PP(1,I)=SIGN(PP(1,I),PTRAK(3,I))
            IF (PTSQ.EQ.0) THEN
               PP(2,I)=0
            ELSE
               PP(2,I)=ATAN2(PTRAK(2,I),PTRAK(1,I))
            ENDIF
            PP(3,I)=0
            PP(4,I)=SQRT(PTSQ)
            PU(1,I)=PP(1,I)
            PU(2,I)=PP(2,I)
            PU(3,I)=PP(3,I)
104      CONTINUE
      ENDIF
*
*** Zero output variables
*
      NJET=0
      DO 102 I = 1, NTRAK
         DO 103 J = 1, MXPROT
           JETLIS(J,I) = .FALSE.
103      CONTINUE
102   CONTINUE
      CALL PXZERV(4*MXPROT,PJ)
      CALL PXZERI(MXJET,IJMUL)
*
      IF (MODE.NE.2) THEN
         COSR = COS(CONER)
C*TC>
         COS2R = COS(2*CONER)
C*TC<
      ELSE
*** Purely for convenience, work in terms of 1-R**2
         COSR = 1-CONER**2
C*TC>
         COS2R = 1.-4.*coner**2
C*TC<
      ENDIF
C*TC  COS2R = COS(2*CONER)
      UNSTBL = .FALSE.
      IF (MODE.NE.2) THEN
         CALL PXUVEC(NTRAK,PP,PU,IERR)
         IF (IERR .NE. 0) RETURN
      ENDIF
*** Look for jets using particle diretions as seed axes
*
      DO 110 N = 1,NTRAK
        DO 120 MU = 1,3
          VSEED(MU) = PU(MU,N)
120     CONTINUE
        CALL PXSEAR(MODE,COSR,NTRAK,PU,PP,VSEED,
     &                   NJET,JETLIS,PJ,UNSTBL,IERR)
         IF (IERR .NE. 0) RETURN
110   CONTINUE
*** Now look between all pairs of jets as seed axes.
      DO 140 N1 = 1,NJET-1
         VEC1(1)=PJ(1,N1)
         VEC1(2)=PJ(2,N1)
         VEC1(3)=PJ(3,N1)
         IF (MODE.NE.2) CALL PXNORV(3,VEC1,VEC1,ITERR)
         DO 150 N2 = N1+1,NJET
            VEC2(1)=PJ(1,N2)
            VEC2(2)=PJ(2,N2)
            VEC2(3)=PJ(3,N2)
            IF (MODE.NE.2) CALL PXNORV(3,VEC2,VEC2,ITERR)
            CALL PXADDV(3,VEC1,VEC2,VSEED,ITERR)
            IF (MODE.NE.2) THEN
               CALL PXNORV(3,VSEED,VSEED,ITERR)
            ELSE
               VSEED(1)=VSEED(1)/2
               VSEED(2)=VSEED(2)/2
            ENDIF
C---ONLY BOTHER IF THEY ARE BETWEEN 1 AND 2 CONE RADII APART
            IF (MODE.NE.2) THEN
              COSVAL=VEC1(1)*VEC2(1)+VEC1(2)*VEC2(2)+VEC1(3)*VEC2(3)
            ELSE
              IF (ABS(VEC1(1)).GE.20.OR.ABS(VEC2(1)).GE.20) THEN
                COSVAL=-1000
              ELSE
                COSVAL=1-
     +               ((VEC1(1)-VEC2(1))**2+PXMDPI(VEC1(2)-VEC2(2))**2)
              ENDIF
            ENDIF
            IF (COSVAL.LE.COSR.AND.COSVAL.GE.COS2R)
     +      CALL PXSEAR(MODE,COSR,NTRAK,PU,PP,VSEED,NJET,
     +      JETLIS,PJ,UNSTBL,IERR)
            IF (IERR .NE. 0) RETURN
150      CONTINUE
140   CONTINUE
      IF (UNSTBL) THEN
        IERR=-1
        WRITE (6,*) ' PXCONE: Too many iterations to find a proto-jet'
        RETURN
      ENDIF
*** Now put the jet list into order by jet energy, eliminating jets
*** with energy less than EPSLON.
       CALL PXORD(EPSLON,NJET,NTRAK,JETLIS,PJ)
*
*** Take care of jet overlaps
       CALL PXOLAP(MODE,NJET,NTRAK,JETLIS,PJ,PP,OVLIM)
*
*** Order jets again as some have been eliminated, or lost energy.
       CALL PXORD(EPSLON,NJET,NTRAK,JETLIS,PJ)
*
*** All done!, Copy output into output arrays
      IF (NJET .GT. MXJET) THEN
         WRITE (6,*) ' PXCONE:  Found more than MXJET jets'
         IERR=-1
         GOTO 99
      ENDIF
      IF (MODE.NE.2) THEN
         DO 300 I=1, NJET
            DO 310 J=1,4
               PJET(J,I)=PJ(J,I)
310         CONTINUE
300      CONTINUE
      ELSE
         DO 315 I=1, NJET
            PJET(1,I)=PJ(4,I)*COS(PJ(2,I))
            PJET(2,I)=PJ(4,I)*SIN(PJ(2,I))
            PJET(3,I)=PJ(4,I)*SINH(PJ(1,I))
            PJET(4,I)=PJ(4,I)*COSH(PJ(1,I))
 315     CONTINUE
      ENDIF
      DO 320 I=1, NTRAK
         IPASS(I)=-1
         DO 330 J=1, NJET
            IF (JETLIS(J,I)) THEN
               IJMUL(J)=IJMUL(J)+1
               IPASS(I)=J
            ENDIF
330      CONTINUE
320   CONTINUE
99    RETURN
      END
*CMZ :  0.00/05 14/01/96  14.39.50  by  Mark Hayes
*-- Author :
******............................................................******
      SUBROUTINE PXSEAR(MODE,COSR,NTRAK,PU,PP,VSEED,NJET,
     +                JETLIS,PJ,UNSTBL,IERR)
******............................................................******
*
C+SEQ,DECLARE.
      INTEGER MXTRAK, MXPROT
      PARAMETER (MXTRAK=500,MXPROT=500)
      INTEGER NTRAK, IERR, MODE
      DOUBLE PRECISION COSR,PU(3,MXTRAK),PP(4,MXTRAK),VSEED(3)
      LOGICAL*1 UNSTBL
      LOGICAL*1 JETLIS(MXPROT,MXTRAK)
      INTEGER NJET
      DOUBLE PRECISION  PJ(4,MXPROT)
*** Using VSEED as a trial axis , look for a stable jet.
*** Check stable jets against those already found and add to PJ.
*** Will try up to MXITER iterations to get a stable set of particles
*** in the cone.
      INTEGER MU,N,ITER
      LOGICAL*1 PXSAME,PXNEW,OK
      LOGICAL*1 NEWLIS(MXTRAK),OLDLIS(MXTRAK)
      DOUBLE PRECISION OAXIS(3),NAXIS(3),PNEW(4)
      INTEGER MXITER
      PARAMETER(MXITER = 30)
*
      DO 100 MU=1,3
        OAXIS(MU) = VSEED(MU)
100   CONTINUE
      DO 110 N = 1,NTRAK
        OLDLIS(N) = .FALSE.
110   CONTINUE
      DO 120 ITER = 1,MXITER
        CALL PXTRY(MODE,COSR,NTRAK,PU,PP,OAXIS,NAXIS,PNEW,NEWLIS,OK)
*** Return immediately if there were no particles in the cone.
       IF (.NOT.OK) THEN
         RETURN
       ENDIF
       IF(PXSAME(NEWLIS,OLDLIS,NTRAK)) THEN
*** We have a stable jet.
             IF (PXNEW(NEWLIS,JETLIS,NTRAK,NJET)) THEN
*** And the jet is a new one. So add it to our arrays.
*** Check arrays are big anough...
             IF (NJET .EQ. MXPROT) THEN
             WRITE (6,*) ' PXCONE:  Found more than MXPROT proto-jets'
                IERR = -1
                RETURN
             ENDIF
               NJET = NJET + 1
               DO 130 N = 1,NTRAK
                 JETLIS(NJET,N) = NEWLIS(N)
130            CONTINUE
               DO 140 MU=1,4
                 PJ(MU,NJET)=PNEW(MU)
140          CONTINUE
             ENDIF
             RETURN
       ENDIF
*** The jet was not stable, so we iterate again
       DO 150 N=1,NTRAK
         OLDLIS(N)=NEWLIS(N)
150    CONTINUE
       DO 160 MU=1,3
         OAXIS(MU)=NAXIS(MU)
160    CONTINUE
120   CONTINUE
      UNSTBL = .TRUE.
      RETURN
      END
*
*CMZ :  0.00/05 14/01/96  14.39.50  by  Mark Hayes
*-- Author :
******............................................................******
       LOGICAL*1 FUNCTION PXSAME(LIST1,LIST2,N)
******............................................................******
*
       LOGICAL*1 LIST1(*),LIST2(*)
       INTEGER N
*** Returns T if the first N elements of LIST1 are the same as the
*** first N elements of LIST2.
       INTEGER I
*
       PXSAME = .TRUE.
       DO 100 I = 1,N
        IF ( LIST1(I).NEQV.LIST2(I) ) THEN
          PXSAME = .FALSE.
          RETURN
        ENDIF
100    CONTINUE
       RETURN
       END
*
*CMZ :  0.00/05 14/01/96  14.39.50  by  Mark Hayes
*-- Author :
******............................................................******
       LOGICAL*1 FUNCTION PXNEW(TSTLIS,JETLIS,NTRAK,NJET)
******............................................................******
*
      INTEGER MXTRAK,MXPROT
      PARAMETER (MXTRAK=500,MXPROT=500)
       INTEGER NTRAK,NJET
*** Note that although JETLIS is assumed to be a 2d array, it
*** it is used as 1d in this routine for efficiency
       LOGICAL*1 TSTLIS(MXTRAK),JETLIS(MXPROT*MXTRAK)
*** Checks to see if TSTLIS entries correspond to a jet already found
*** and entered in JETLIS
       INTEGER N, I, IN
       LOGICAL*1 MATCH
*
       PXNEW = .TRUE.
       DO 100 I = 1,NJET
          MATCH = .TRUE.
          IN=I-MXPROT
          DO 110 N = 1,NTRAK
            IN=IN+MXPROT
            IF(TSTLIS(N).NEQV.JETLIS(IN)) THEN
             MATCH = .FALSE.
             GO TO 100
            ENDIF
110       CONTINUE
          IF (MATCH) THEN
           PXNEW = .FALSE.
           RETURN
          ENDIF
100    CONTINUE
       RETURN
       END
*
*CMZ :  0.00/05 14/01/96  14.39.50  by  Mark Hayes
*-- Author :
******............................................................******
       SUBROUTINE PXTRY(MODE,COSR,NTRAK,PU,PP,OAXIS,NAXIS,
     +                  PNEW,NEWLIS,OK)
******............................................................******
*
C+SEQ,DECLARE.
      INTEGER MXTRAK
      PARAMETER (MXTRAK=500)
       INTEGER NTRAK,MODE
*** Note that although PU and PP are assumed to be 2d arrays, they
*** are used as 1d in this routine for efficiency
       DOUBLE PRECISION COSR,PU(3*MXTRAK),PP(4*MXTRAK),OAXIS(3),PXMDPI
       LOGICAL*1 OK
       LOGICAL*1 NEWLIS(MXTRAK)
       DOUBLE PRECISION NAXIS(3),PNEW(4)
*** Finds all particles in cone of size COSR about OAXIS direction.
*** Calculates 4-momentum sum of all particles in cone (PNEW) , and
*** returns this as new jet axis NAXIS (Both unit Vectors)
       INTEGER N,MU,NPU,NPP
       DOUBLE PRECISION COSVAL,NORMSQ,NORM
*
       OK = .FALSE.
       DO 100 MU=1,4
          PNEW(MU)=0.0
100    CONTINUE
       NPU=-3
       NPP=-4
       DO 110 N=1,NTRAK
          NPU=NPU+3
          NPP=NPP+4
          IF (MODE.NE.2) THEN
             COSVAL=0.0
             DO 120 MU=1,3
                COSVAL=COSVAL+OAXIS(MU)*PU(MU+NPU)
120          CONTINUE
          ELSE
             IF (ABS(PU(1+NPU)).GE.20.OR.ABS(OAXIS(1)).GE.20) THEN
                COSVAL=-1000
             ELSE
                COSVAL=1-
     +           ((OAXIS(1)-PU(1+NPU))**2+PXMDPI(OAXIS(2)-PU(2+NPU))**2)
             ENDIF
          ENDIF
          IF (COSVAL.GE.COSR)THEN
             NEWLIS(N) = .TRUE.
             OK = .TRUE.
             IF (MODE.NE.2) THEN
                DO 130 MU=1,4
                   PNEW(MU) = PNEW(MU) + PP(MU+NPP)
130             CONTINUE
             ELSE
                PNEW(1)=PNEW(1)
     +              + PP(4+NPP)/(PP(4+NPP)+PNEW(4))*(PP(1+NPP)-PNEW(1))
                PNEW(2)=PNEW(2)
     +              + PP(4+NPP)/(PP(4+NPP)+PNEW(4))
     +               *PXMDPI(PP(2+NPP)-PNEW(2))
                PNEW(4)=PNEW(4)+PP(4+NPP)
             ENDIF
          ELSE
             NEWLIS(N)=.FALSE.
          ENDIF
110   CONTINUE
*** If there are particles in the cone, calc new jet axis
       IF (OK) THEN
          IF (MODE.NE.2) THEN
             NORMSQ = 0.0
             DO 140 MU = 1,3
                NORMSQ = NORMSQ + PNEW(MU)**2
140          CONTINUE
             NORM = SQRT(NORMSQ)
          ELSE
             NORM = 1
          ENDIF
          DO 150 MU=1,3
             NAXIS(MU) = PNEW(MU)/NORM
150       CONTINUE
       ENDIF
       RETURN
       END
*
*CMZ :  0.00/05 14/01/96  14.39.50  by  Mark Hayes
*-- Author :
******............................................................******
       SUBROUTINE PXORD(EPSLON,NJET,NTRAK,JETLIS,PJ)
******............................................................******
*
*** Routine to put jets into order and eliminate tose less than EPSLON
C+SEQ,DECLARE.
      INTEGER MXTRAK,MXPROT
      PARAMETER (MXTRAK=500,MXPROT=500)
       INTEGER I, J, INDEX(MXPROT)
       DOUBLE PRECISION PTEMP(4,MXPROT), ELIST(MXPROT)
       INTEGER NJET,NTRAK
       LOGICAL*1 JETLIS(MXPROT,MXTRAK)
       LOGICAL*1 LOGTMP(MXPROT,MXTRAK)
       DOUBLE PRECISION EPSLON,PJ(4,MXPROT)
*** Puts jets in order of energy: 1 = highest energy etc.
*** Then Eliminate jets with energy below EPSLON
*
*** Copy input arrays.
      DO 100 I=1,NJET
         DO 110 J=1,4
            PTEMP(J,I)=PJ(J,I)
110      CONTINUE
         DO 120 J=1,NTRAK
            LOGTMP(I,J)=JETLIS(I,J)
120      CONTINUE
100   CONTINUE
      DO 150 I=1,NJET
         ELIST(I)=PJ(4,I)
150   CONTINUE
*** Sort the energies...
      CALL PXSORV(NJET,ELIST,INDEX,'I')
*** Fill PJ and JETLIS according to sort ( sort is in ascending order!!)
      DO 200 I=1, NJET
         DO 210 J=1,4
            PJ(J,I)=PTEMP(J,INDEX(NJET+1-I))
210      CONTINUE
         DO 220 J=1,NTRAK
            JETLIS(I,J)=LOGTMP(INDEX(NJET+1-I),J)
220      CONTINUE
200   CONTINUE
** Jets are now in order
*** Now eliminate jets with less than Epsilon energy
      DO 300, I=1, NJET
         IF (PJ(4,I) .LT. EPSLON) THEN
            NJET=NJET-1
            PJ(4,I)=0.
         ENDIF
300   CONTINUE
      RETURN
      END
*CMZ :  0.00/05 14/01/96  14.39.50  by  Mark Hayes
*-- Author :
*
******............................................................******
       SUBROUTINE PXUVEC(NTRAK,PP,PU,IERR)
******............................................................******
*
*** Routine to calculate unit vectors PU of all particles PP
C+SEQ,DECLARE.
      INTEGER MXTRAK
      PARAMETER (MXTRAK=500)
      INTEGER NTRAK, IERR
      DOUBLE PRECISION PP(4,MXTRAK)
      DOUBLE PRECISION PU(3,MXTRAK)
      INTEGER N,MU
      DOUBLE PRECISION MAG
       DO 100 N=1,NTRAK
          MAG=0.0
          DO 110 MU=1,3
             MAG=MAG+PP(MU,N)**2
110       CONTINUE
          MAG=SQRT(MAG)
          IF (MAG.EQ.0.0) THEN
             WRITE(6,*)' PXCONE: An input particle has zero mod(p)'
             IERR=-1
             RETURN
          ENDIF
          DO 120 MU=1,3
           PU(MU,N)=PP(MU,N)/MAG
120       CONTINUE
100    CONTINUE
       RETURN
       END
*
*CMZ :  0.00/05 14/01/96  14.39.50  by  Mark Hayes
*-- Author :
******............................................................******
      SUBROUTINE PXOLAP(MODE,NJET,NTRAK,JETLIS,PJ,PP,OVLIM)
******............................................................******
*
*** Looks for particles assigned to more than 1 jet, and reassigns them
*** If more than a fraction OVLIM of a jet's energy is contained in
*** higher energy jets, that jet is neglected.
*** Particles assigned to the jet closest in angle (a la CDF, Snowmass).
C+SEQ,DECLARE.
      INTEGER MXTRAK, MXPROT
      PARAMETER (MXTRAK=500,MXPROT=500)
      INTEGER NJET, NTRAK, MODE
      LOGICAL*1 JETLIS(MXPROT,MXTRAK)
      DOUBLE PRECISION PJ(4,MXPROT),PP(4,MXTRAK),PXMDPI
      INTEGER I,J,N,MU
      LOGICAL*1 OVELAP
      DOUBLE PRECISION EOVER
      DOUBLE PRECISION OVLIM
      INTEGER ITERR, IJMIN, IJET(MXPROT), NJ
      DOUBLE PRECISION VEC1(3), VEC2(3), COST, THET, THMIN
*
      IF (NJET.LE.1) RETURN
*** Look for jets with large overlaps with higher energy jets.
      DO 100 I = 2,NJET
*** Find overlap energy between jets I and all higher energy jets.
       EOVER = 0.0
       DO 110 N = 1,NTRAK
         OVELAP = .FALSE.
         DO 120 J= 1,I-1
           IF (JETLIS(I,N).AND.JETLIS(J,N)) THEN
            OVELAP = .TRUE.
           ENDIF
120      CONTINUE
         IF (OVELAP) THEN
           EOVER = EOVER + PP(4,N)
         ENDIF
110     CONTINUE
*** Is the fraction of energy shared larger than OVLIM?
        IF (EOVER.GT.OVLIM*PJ(4,I)) THEN
*** De-assign all particles from Jet I
            DO 130 N = 1,NTRAK
              JETLIS(I,N) = .FALSE.
130         CONTINUE
         ENDIF
100   CONTINUE
*** Now there are no big overlaps, assign every particle in
*** more than 1 jet to the closet jet.
*** Any particles now in more than 1 jet are assigned to the CLOSET
*** jet (in angle).
      DO 140 I=1,NTRAK
         NJ=0
         DO 150 J=1, NJET
         IF(JETLIS(J,I)) THEN
            NJ=NJ+1
            IJET(NJ)=J
         ENDIF
150      CONTINUE
         IF (NJ .GT. 1) THEN
*** Particle in > 1 jet - calc angles...
            VEC1(1)=PP(1,I)
            VEC1(2)=PP(2,I)
            VEC1(3)=PP(3,I)
            THMIN=0.
            DO 160 J=1,NJ
               VEC2(1)=PJ(1,IJET(J))
               VEC2(2)=PJ(2,IJET(J))
               VEC2(3)=PJ(3,IJET(J))
               IF (MODE.NE.2) THEN
                  CALL PXANG3(VEC1,VEC2,COST,THET,ITERR)
               ELSE
                  THET=(VEC1(1)-VEC2(1))**2+PXMDPI(VEC1(2)-VEC2(2))**2
               ENDIF
               IF (J .EQ. 1) THEN
                  THMIN=THET
                  IJMIN=IJET(J)
               ELSEIF (THET .LT. THMIN) THEN
                  THMIN=THET
                  IJMIN=IJET(J)
               ENDIF
160         CONTINUE
*** Assign track to IJMIN
            DO 170 J=1,NJET
               JETLIS(J,I) = .FALSE.
170         CONTINUE
            JETLIS(IJMIN,I)=.TRUE.
         ENDIF
140   CONTINUE
*** Recompute PJ
      DO 200 I = 1,NJET
        DO 210 MU = 1,4
          PJ(MU,I) = 0.0
210     CONTINUE
        DO 220 N = 1,NTRAK
          IF( JETLIS(I,N) ) THEN
             IF (MODE.NE.2) THEN
                DO 230 MU = 1,4
                   PJ(MU,I) = PJ(MU,I) + PP(MU,N)
230             CONTINUE
             ELSE
                PJ(1,I)=PJ(1,I)
     +               + PP(4,N)/(PP(4,N)+PJ(4,I))*(PP(1,N)-PJ(1,I))
                PJ(2,I)=PJ(2,I)
     +               + PP(4,N)/(PP(4,N)+PJ(4,I))*PXMDPI(PP(2,N)-PJ(2,I))
                PJ(4,I)=PJ(4,I)+PP(4,N)
             ENDIF
          ENDIF
220     CONTINUE
200   CONTINUE
      RETURN
      END
C-----------------------------------------------------------------------
C     This is a set of routines written by Mike Seymour to provide the
C     services presumably normally provided by standard OPAL routines
C     PXZERV zeroes a vector
C     PXZERI zeroes a vector of integers
C     PXNORV normalizes a vector
C     PXADDV adds two vectors
C     PXSORV sorts a vector (copied from HERWIG)
C     PXANG3 finds the angle (and its cosine) between two vectors
C     PXMDPI moves its argument onto the range [-pi,pi)
C-----------------------------------------------------------------------
      SUBROUTINE PXZERV(N,A)
      INTEGER I,N
      DOUBLE PRECISION A(N)
      DO 10 I=1,N
        A(I)=0
 10   CONTINUE
      END
C-----------------------------------------------------------------------
      SUBROUTINE PXZERI(N,A)
      INTEGER I,N,A(N)
      DO 10 I=1,N
        A(I)=0
 10   CONTINUE
      END
C-----------------------------------------------------------------------
      SUBROUTINE PXNORV(N,A,B,ITERR)
      INTEGER I,N,ITERR
      DOUBLE PRECISION A(N),B(N),C
      C=0
      DO 10 I=1,N
        C=C+A(I)**2
 10   CONTINUE
      IF (C.LE.0) RETURN
      C=1/SQRT(C)
      DO 20 I=1,N
        B(I)=A(I)*C
 20   CONTINUE
      END
C-----------------------------------------------------------------------
      SUBROUTINE PXADDV(N,A,B,C,ITERR)
      INTEGER I,N,ITERR
      DOUBLE PRECISION A(N),B(N),C(N)
      DO 10 I=1,N
        C(I)=A(I)+B(I)
 10   CONTINUE
      END
C-----------------------------------------------------------------------
      SUBROUTINE PXANG3(A,B,COST,THET,ITERR)
      INTEGER ITERR
      DOUBLE PRECISION A(3),B(3),C,COST,THET
      C=(A(1)**2+A(2)**2+A(3)**2)*(B(1)**2+B(2)**2+B(3)**2)
      IF (C.LE.0) RETURN
      C=1/SQRT(C)
      COST=(A(1)*B(1)+A(2)*B(2)+A(3)*B(3))*C
      THET=ACOS(COST)
      END
C-----------------------------------------------------------------------
      SUBROUTINE PXSORV(N,A,K,OPT)
C     Sort A(N) into ascending order
C     OPT = 'I' : return index array K only
C     OTHERWISE : return sorted A and index array K
C-----------------------------------------------------------------------
      INTEGER NMAX
      PARAMETER (NMAX=500)
      INTEGER N,I,J,K(N),IL(NMAX),IR(NMAX)
      CHARACTER OPT
      DOUBLE PRECISION A(N),B(NMAX)
      IF (N.GT.NMAX) STOP 'Sorry, not enough room in Mike''s PXSORV'
      IF (N.EQ.0) RETURN
      IL(1)=0
      IR(1)=0
      DO 10 I=2,N
      IL(I)=0
      IR(I)=0
      J=1
   2  IF(A(I).GT.A(J)) GO TO 5
   3  IF(IL(J).EQ.0) GO TO 4
      J=IL(J)
      GO TO 2
   4  IR(I)=-J
      IL(J)=I
      GO TO 10
   5  IF(IR(J).LE.0) GO TO 6
      J=IR(J)
      GO TO 2
   6  IR(I)=IR(J)
      IR(J)=I
  10  CONTINUE
      I=1
      J=1
      GO TO 8
  20  J=IL(J)
   8  IF(IL(J).GT.0) GO TO 20
   9  K(I)=J
      B(I)=A(J)
      I=I+1
      IF(IR(J)) 12,30,13
  13  J=IR(J)
      GO TO 8
  12  J=-IR(J)
      GO TO 9
  30  IF(OPT.EQ.'I') RETURN
      DO 31 I=1,N
  31  A(I)=B(I)
 999  END
C-----------------------------------------------------------------------
      FUNCTION PXMDPI(PHI)
      IMPLICIT NONE
C---RETURNS PHI, MOVED ONTO THE RANGE [-PI,PI)
      DOUBLE PRECISION PXMDPI,PHI,PI,TWOPI,THRPI,EPS
      PARAMETER (PI=3.141592654,TWOPI=6.283185307,THRPI=9.424777961)
      PARAMETER (EPS=1E-15)
      PXMDPI=PHI
      IF (PXMDPI.LE.PI) THEN
        IF (PXMDPI.GT.-PI) THEN
          GOTO 100
        ELSEIF (PXMDPI.GT.-THRPI) THEN
          PXMDPI=PXMDPI+TWOPI
        ELSE
          PXMDPI=-MOD(PI-PXMDPI,TWOPI)+PI
        ENDIF
      ELSEIF (PXMDPI.LE.THRPI) THEN
        PXMDPI=PXMDPI-TWOPI
      ELSE
        PXMDPI=MOD(PI+PXMDPI,TWOPI)-PI
      ENDIF
 100  IF (ABS(PXMDPI).LT.EPS) PXMDPI=0
      END
C-----------------------------------------------------------------------

*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C     KTCLUS: written by Mike Seymour, July 1992.
C     Last modified October 1997.
C     Please send comments or suggestions to Mike.Seymour@rl.ac.uk
C
C     This is a general-purpose kt clustering package.
C     It can handle ee, ep and pp collisions.
C     It is loosely based on the program of Siggi Bethke.
C
C     The time taken (on a 10MIP machine) is (0.2microsec)*N**3
C     where N is the number of particles.
C     Over 90 percent of this time is used in subroutine KTPMIN, which
C     simply finds the minimum member of a one-dimensional array.
C     It is well worth thinking about optimization: on the SPARCstation
C     a factor of two increase was obtained simply by increasing the
C     optimization level from its default value.
C
C     The approach is to separate the different stages of analysis.
C     KTCLUS does all the clustering and records a merging history.
C     It returns a simple list of the y values at which each merging
C     occured. Then the following routines can be called to give extra
C     information on the most recently analysed event.
C     KTCLUR is identical but includes an R parameter, see below.
C     KTYCUT gives the number of jets at each given YCUT value.
C     KTYSUB gives the number of sub-jets at each given YCUT value.
C     KTBEAM gives same info as KTCLUS but only for merges with the beam
C     KTJOIN gives same info as KTCLUS but for merges of sub-jets.
C     KTRECO reconstructs the jet momenta at a given value of YCUT.
C     It also gives information on which jets at scale YCUT belong to
C     which macro-jets at scale YMAC, for studying sub-jet properties.
C     KTINCL reconstructs the jet momenta according to the inclusive jet
C     definition of Ellis and Soper.
C     KTISUB, KTIJOI and KTIREC are like KTYSUB, KTJOIN and KTRECO,
C     except that they only apply to one inclusive jet at a time,
C     with the pt of that jet automatically used for ECUT.
C     KTWICH gives a list of which particles ended up in which jets.
C     KTWCHS gives the same thing, but only for subjets.
C     Note that the numbering of jets used by these two routines is
C     guaranteed to be the same as that used by KTRECO.
C
C     The collision type and analysis type are indicated by the first
C     argument of KTCLUS. IMODE=<TYPE><ANGLE><MONO><RECOM> where
C     TYPE:  1=>ee, 2=>ep with p in -z direction, 3=>pe, 4=>pp
C     ANGLE: 1=>angular kt def., 2=>DeltaR, 3=>f(DeltaEta,DeltaPhi)
C            where f()=2(cosh(eta)-cos(phi)) is the QCD emission metric
C     MONO:  1=>derive relative pseudoparticle angles from jets
C            2=>monotonic definitions of relative angles
C     RECOM: 1=>E recombination scheme, 2=>pt scheme, 3=>pt**2 scheme
C
C     There are also abbreviated forms for the most common combinations:
C     IMODE=1 => E scheme in e+e-                              (=1111)
C           2 => E scheme in ep                                (=2111)
C           3 => E scheme in pe                                (=3111)
C           4 => E scheme in pp                                (=4111)
C           5 => covariant E scheme in pp                      (=4211)
C           6 => covariant pt-scheme in pp                     (=4212)
C           7 => covariant monotonic pt**2-scheme in pp        (=4223)
C
C     KTRECO no longer needs to reconstruct the momenta according to the
C     same recombination scheme in which they were clustered. Its first
C     argument gives the scheme, taking the same values as RECOM above.
C
C     Note that unlike previous versions, all variables which hold y
C     values have been named in a consistent way:
C     Y()  is the output scale at which jets were merged,
C     YCUT is the input scale at which jets should be counted, and
C          jet-momenta reconstructed etc,
C     YMAC is the input macro-jet scale, used in determining whether
C          or not each jet is a sub-jet.
C     The original scheme defined in our papers is equivalent to always
C     setting YMAC=1.
C     Whenever a YCUT or YMAC variable is used, it is rounded down
C     infinitesimally, so that for example, setting YCUT=Y(2) refers
C     to the scale where the event is 2-jet, even if rounding errors
C     have shifted its value slightly.
C
C     An R parameter can be used in hadron-hadron collisions by
C     calling KTCLUR instead of KTCLUS.  This is as suggested by
C     Ellis and Soper, but implemented slightly differently,
C     as in M.H. Seymour, LU TP 94/2 (submitted to Nucl. Phys. B.).
C     R**2 multiplies the single Kt everywhere it is used.
C     Calling KTCLUR with R=1 is identical to calling KTCLUS.
C     R plays a similar role to the jet radius in a cone-type algorithm,
C     but is scaled up by about 40% (ie R=0.7 in a cone algorithm is
C     similar to this algorithm with R=1).
C     Note that R.EQ.1 must be used for the e+e- and ep versions,
C     and is strongly recommended for the hadron-hadron version.
C     However, R values smaller than 1 have been found to be useful for
C     certain applications, particularly the mass reconstruction of
C     highly-boosted colour-singlets such as high-pt hadronic Ws,
C     as in M.H. Seymour, LU TP 93/8 (to appear in Z. Phys. C.).
C     Situations in which R<1 is useful are likely to also be those in
C     which the inclusive reconstruction method is more useful.
C
C     Also included is a set of routines for doing Lorentz boosts:
C     KTLBST finds the boost matrix to/from the cm frame of a 4-vector
C     KTRROT finds the rotation matrix from one vector to another
C     KTMMUL multiplies together two matrices
C     KTVMUL multiplies a vector by a matrix
C     KTINVT inverts a transformation matrix (nb NOT a general 4 by 4)
C     KTFRAM boosts a list of vectors between two arbitrary frames
C     KTBREI boosts a list of vectors between the lab and Breit frames
C     KTHADR boosts a list of vectors between the lab and hadronic cmf
C       The last two need the momenta in the +z direction of the lepton
C       and hadron beams, and the 4-momentum of the outgoing lepton.
C
C     The main reference is:
C       S. Catani, Yu.L. Dokshitzer, M.H. Seymour and B.R. Webber,
C         Nucl.Phys.B406(1993)187.
C     The ep version was proposed in:
C       S. Catani, Yu.L. Dokshitzer and B.R. Webber,
C         Phys.Lett.285B(1992)291.
C     The inclusive reconstruction method was proposed in:
C       S.D. Ellis and D.E. Soper,
C         Phys.Rev.D48(1993)3160.
C
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
      SUBROUTINE KTCLUS(IMODE,PP,NN,ECUT,Y,*)
      IMPLICIT NONE
C---DO CLUSTER ANALYSIS OF PARTICLES IN PP
C
C   IMODE   = INPUT  : DESCRIBED ABOVE
C   PP(I,J) = INPUT  : 4-MOMENTUM OF Jth PARTICLE: I=1,4 => PX,PY,PZ,E
C   NN      = INPUT  : NUMBER OF PARTICLES
C   ECUT    = INPUT  : DENOMINATOR OF KT MEASURE. IF ZERO, ETOT IS USED
C   Y(J)    = OUTPUT : VALUE OF Y FOR WHICH EVENT CHANGES FROM BEING
C                        J JET TO J-1 JET
C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
C   COULD NOT BE PROCESSED (MOST LIKELY DUE TO TOO MANY PARTICLES)
C
C   NOTE THAT THE MOMENTA ARE DECLARED DOUBLE PRECISION,
C   AND ALL OTHER FLOATING POINT VARIABLES ARE DECLARED REAL
C
      INTEGER IMODE,NN
      DOUBLE PRECISION PP(4,*)
      REAL ECUT,Y(*),ONE
      ONE=1
      CALL KTCLUR(IMODE,PP,NN,ONE,ECUT,Y,*999)
      RETURN
 999  RETURN 1
      END
*CMZ :  1.01/12 08/01/98  13.20.57  by  Tancredi Carli
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTCLUR(IMODE,PP,NN,R,ECUT,Y,*)
      IMPLICIT NONE
C---DO CLUSTER ANALYSIS OF PARTICLES IN PP
C
C   IMODE   = INPUT  : DESCRIBED ABOVE
C   PP(I,J) = INPUT  : 4-MOMENTUM OF Jth PARTICLE: I=1,4 => PX,PY,PZ,E
C   NN      = INPUT  : NUMBER OF PARTICLES
C   R       = INPUT  : ELLIS AND SOPER'S R PARAMETER, SEE ABOVE.
C   ECUT    = INPUT  : DENOMINATOR OF KT MEASURE. IF ZERO, ETOT IS USED
C   Y(J)    = OUTPUT : VALUE OF Y FOR WHICH EVENT CHANGES FROM BEING
C                        J JET TO J-1 JET
C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
C   COULD NOT BE PROCESSED (MOST LIKELY DUE TO TOO MANY PARTICLES)
C
C   NOTE THAT THE MOMENTA ARE DECLARED DOUBLE PRECISION,
C   AND ALL OTHER FLOATING POINT VARIABLES ARE DECLARED REAL
C
      INTEGER NMAX,IM,IMODE,TYPE,ANGL,MONO,RECO,N,I,J,NN,
     &     IMIN,JMIN,KMIN,NUM,HIST,INJET,IABBR,NABBR
      PARAMETER (NMAX=512,NABBR=7)
      DOUBLE PRECISION PP(4,*)
      REAL R,ECUT,Y(*),P,KT,ETOT,RSQ,KTP,KTS,KTPAIR,KTSING,
     &     KTMIN,ETSQ,KTLAST,KTMAX
      LOGICAL FIRST
      CHARACTER TITLE(4,4)*10
C---KT RECORDS THE KT**2 OF EACH MERGING.
C---KTLAST RECORDS FOR EACH MERGING, THE HIGHEST ECUT**2 FOR WHICH THE
C   RESULT IS NOT MERGED WITH THE BEAM (COULD BE LARGER THAN THE
C   KT**2 AT WHICH IT WAS MERGED IF THE KT VALUES ARE NOT MONOTONIC).
C   THIS MAY SOUND POINTLESS, BUT ITS USEFUL FOR DETERMINING WHETHER
C   SUB-JETS SURVIVED TO SCALE Y=YMAC OR NOT.
C---HIST RECORDS MERGING HISTORY:
C   N=>DELETED TRACK N, M*NMAX+N=>MERGED TRACKS M AND N (M<N).
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX),
     &  KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
      DIMENSION INJET(NMAX),IABBR(NABBR)
      DATA FIRST,TITLE,IABBR/.TRUE.,
     &     'e+e-      ','ep        ','pe        ','pp        ',
     &     'angle     ','DeltaR    ','f(DeltaR) ','**********',
     &     'no        ','yes       ','**********','**********',
     &     'E         ','Pt        ','Pt**2     ','**********',
     &     1111,2111,3111,4111,4211,4212,4223/
C---CHECK INPUT
      IM=IMODE
      IF (IM.GE.1.AND.IM.LE.NABBR) IM=IABBR(IM)
      TYPE=MOD(IM/1000,10)
      ANGL=MOD(IM/100 ,10)
      MONO=MOD(IM/10  ,10)
      RECO=MOD(IM     ,10)
      IF (NN.GT.NMAX.OR.NN.LT.1.OR.(NN.LT.2.AND.TYPE.EQ.1))
     &     CALL KTWARN('KTCLUS',100,*999)
      IF (TYPE.LT.1.OR.TYPE.GT.4.OR.ANGL.LT.1.OR.ANGL.GT.3.OR.
     &    MONO.LT.1.OR.MONO.GT.2.OR.RECO.LT.1.OR.RECO.GT.3)
     &     CALL KTWARN('KTCLUS',101,*999)
      IF (FIRST) THEN
         WRITE (6,'(/,1X,54(''*'')/A)')
     &   ' KTCLUS: written by Mike Seymour, July 1992.'
         WRITE (6,'(A)')
     &   ' Last modified October 1997.'
         WRITE (6,'(A)')
     &   ' Please send comments or suggestions to Mike.Seymour@rl.ac.uk'
         WRITE (6,'(/A,I2,2A)')
     &   '       Collision type =',TYPE,' = ',TITLE(TYPE,1)
         WRITE (6,'(A,I2,2A)')
     &   '     Angular variable =',ANGL,' = ',TITLE(ANGL,2)
         WRITE (6,'(A,I2,2A)')
     &   ' Monotonic definition =',MONO,' = ',TITLE(MONO,3)
         WRITE (6,'(A,I2,2A)')
     &   ' Recombination scheme =',RECO,' = ',TITLE(RECO,4)
         IF (R.NE.1) THEN
         WRITE (6,'(A,F5.2)')
     &   '     Radius parameter =',R
         IF (TYPE.NE.4) WRITE (6,'(A)')
     &   ' R.NE.1 is strongly discouraged for this collision type!'
         ENDIF
C*TC>
         WRITE (6,'(A,F5.2)') ' Ecut= ',ecut
C*TC<
         WRITE (6,'(1X,54(''*'')/)')
         FIRST=.FALSE.
      ENDIF
C---COPY PP TO P
      N=NN
      NUM=NN
      CALL KTCOPY(PP,N,P,(RECO.NE.1))
      ETOT=0
      DO 100 I=1,N
         ETOT=ETOT+P(4,I)
 100  CONTINUE
      IF (ETOT.EQ.0) CALL KTWARN('KTCLUS',102,*999)
      IF (ECUT.EQ.0) THEN
         ETSQ=1/ETOT**2
      ELSE
         ETSQ=1/ECUT**2
      ENDIF
      RSQ=R**2
C---CALCULATE ALL PAIR KT's
      DO 210 I=1,N-1
         DO 200 J=I+1,N
            KTP(J,I)=-1
            KTP(I,J)=KTPAIR(ANGL,P(1,I),P(1,J),KTP(J,I))
 200     CONTINUE
 210  CONTINUE
C---CALCULATE ALL SINGLE KT's
      DO 230 I=1,N
         KTS(I)=KTSING(ANGL,TYPE,P(1,I))
 230  CONTINUE
      KTMAX=0
C---MAIN LOOP
 300  CONTINUE
C---FIND MINIMUM MEMBER OF KTP
      CALL KTPMIN(KTP,NMAX,N,IMIN,JMIN)
C---FIND MINIMUM MEMBER OF KTS
      CALL KTSMIN(KTS,NMAX,N,KMIN)
C---STORE Y VALUE OF TRANSITION FROM N TO N-1 JETS
      KTMIN=KTP(IMIN,JMIN)
      IF ((TYPE.GE.2.AND.TYPE.LE.4).AND.
     &     (RSQ*KTS(KMIN).LE.KTMIN.OR.N.EQ.1))
     &     KTMIN=RSQ*KTS(KMIN)
      KT(N)=KTMIN
      Y(N)=KT(N)*ETSQ
C---IF MONO.GT.1, SEQUENCE IS SUPPOSED TO BE MONOTONIC, IF NOT, WARN
      IF (KTMIN.LT.KTMAX.AND.MONO.GT.1) CALL KTWARN('KTCLUS',1,*999)
      IF (KTMIN.GE.KTMAX) KTMAX=KTMIN
C---IF LOWEST KT IS TO A BEAM, THROW IT AWAY AND MOVE LAST ENTRY UP
      IF (KTMIN.EQ.RSQ*KTS(KMIN)) THEN
         CALL KTMOVE(P,KTP,KTS,NMAX,N,KMIN,1)
C---UPDATE HISTORY AND CROSS-REFERENCES
         HIST(N)=KMIN
         INJET(N)=KMIN
         DO 400 I=N,NN
            IF (INJET(I).EQ.KMIN) THEN
               KTLAST(I)=KTMAX
               INJET(I)=0
            ELSEIF (INJET(I).EQ.N) THEN
               INJET(I)=KMIN
            ENDIF
 400     CONTINUE
C---OTHERWISE MERGE JETS IMIN AND JMIN AND MOVE LAST ENTRY UP
      ELSE
         CALL KTMERG(P,KTP,KTS,NMAX,IMIN,JMIN,N,TYPE,ANGL,MONO,RECO)
         CALL KTMOVE(P,KTP,KTS,NMAX,N,JMIN,1)
C---UPDATE HISTORY AND CROSS-REFERENCES
         HIST(N)=IMIN*NMAX+JMIN
         INJET(N)=IMIN
         DO 600 I=N,NN
            IF (INJET(I).EQ.JMIN) THEN
               INJET(I)=IMIN
            ELSEIF (INJET(I).EQ.N) THEN
               INJET(I)=JMIN
            ENDIF
 600     CONTINUE
      ENDIF
C---THATS ALL THERE IS TO IT
      N=N-1
      IF (N.GT.1 .OR. N.GT.0.AND.(TYPE.GE.2.AND.TYPE.LE.4)) GOTO 300
      IF (N.EQ.1) THEN
         KT(N)=1E20
         Y(N)=KT(N)*ETSQ
      ENDIF
      RETURN
 999  RETURN 1
      END
*CMZ :  1.01/13 13/02/98  16.01.06  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTYCUT(ECUT,NY,YCUT,NJET,*)
      IMPLICIT NONE
C---COUNT THE NUMBER OF JETS AT EACH VALUE OF YCUT, FOR EVENT WHICH HAS
C   ALREADY BEEN ANALYSED BY KTCLUS.
C
C   ECUT    = INPUT : DENOMINATOR OF KT MEASURE. IF ZERO, ETOT IS USED
C   NY      = INPUT : NUMBER OF YCUT VALUES
C   YCUT(J) = INPUT : Y VALUES AT WHICH NUMBERS OF JETS ARE COUNTED
C   NJET(J) =OUTPUT : NUMBER OF JETS AT YCUT(J)
C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
C   COULD NOT BE PROCESSED
C
C   NOTE THAT ALL FLOATING POINT VARIABLES ARE DECLARED REAL
C
      INTEGER NY,NJET(NY),NMAX,HIST,I,J,NUM
      PARAMETER (NMAX=512)
      REAL YCUT(NY),ETOT,RSQ,P,KT,KTP,KTS,ETSQ,ECUT,KTLAST,ROUND
      PARAMETER (ROUND=0.99999)
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX),
     &  KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
      IF (ETOT.EQ.0) CALL KTWARN('KTYCUT',100,*999)
      IF (ECUT.EQ.0) THEN
         ETSQ=1/ETOT**2
      ELSE
         ETSQ=1/ECUT**2
      ENDIF
      DO 100 I=1,NY
         NJET(I)=0
 100  CONTINUE
      DO 210 I=NUM,1,-1
         DO 200 J=1,NY
            IF (NJET(J).EQ.0.AND.KT(I)*ETSQ.GE.ROUND*YCUT(J)) NJET(J)=I
 200     CONTINUE
 210  CONTINUE
      RETURN
 999  RETURN 1
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTYSUB(ECUT,NY,YCUT,YMAC,NSUB,*)
      IMPLICIT NONE
C---COUNT THE NUMBER OF SUB-JETS AT EACH VALUE OF YCUT, FOR EVENT WHICH
C   HAS ALREADY BEEN ANALYSED BY KTCLUS.
C   REMEMBER THAT A SUB-JET IS DEFINED AS A JET AT Y=YCUT WHICH HAS NOT
C   YET BEEN MERGED WITH THE BEAM AT Y=YMAC.
C
C   ECUT    = INPUT : DENOMINATOR OF KT MEASURE. IF ZERO, ETOT IS USED
C   NY      = INPUT : NUMBER OF YCUT VALUES
C   YCUT(J) = INPUT : Y VALUES AT WHICH NUMBERS OF SUB-JETS ARE COUNTED
C   YMAC    = INPUT : Y VALUE USED TO DEFINE MACRO-JETS, TO DETERMINE
C                       WHICH JETS ARE SUB-JETS
C   NSUB(J) =OUTPUT : NUMBER OF SUB-JETS AT YCUT(J)
C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
C   COULD NOT BE PROCESSED
C
C   NOTE THAT ALL FLOATING POINT VARIABLES ARE DECLARED REAL
C
      INTEGER NY,NSUB(NY),NMAX,HIST,I,J,NUM
      PARAMETER (NMAX=512)
      REAL YCUT(NY),YMAC,ETOT,RSQ,P,KT,KTP,KTS,ETSQ,ECUT,KTLAST,ROUND
      PARAMETER (ROUND=0.99999)
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX),
     &  KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
      IF (ETOT.EQ.0) CALL KTWARN('KTYSUB',100,*999)
      IF (ECUT.EQ.0) THEN
         ETSQ=1/ETOT**2
      ELSE
         ETSQ=1/ECUT**2
      ENDIF
      DO 100 I=1,NY
         NSUB(I)=0
 100  CONTINUE
      DO 210 I=NUM,1,-1
         DO 200 J=1,NY
            IF (NSUB(J).EQ.0.AND.KT(I)*ETSQ.GE.ROUND*YCUT(J)) NSUB(J)=I
            IF (NSUB(J).NE.0.AND.KTLAST(I)*ETSQ.LT.ROUND*YMAC)
     &          NSUB(J)=NSUB(J)-1
 200     CONTINUE
 210  CONTINUE
      RETURN
 999  RETURN 1
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTBEAM(ECUT,Y,*)
      IMPLICIT NONE
C---GIVE SAME INFORMATION AS LAST CALL TO KTCLUS EXCEPT THAT ONLY
C   TRANSITIONS WHERE A JET WAS MERGED WITH THE BEAM JET ARE RECORDED
C
C   ECUT    = INPUT : DENOMINATOR OF KT MEASURE. IF ZERO, ETOT IS USED
C   Y(J)    =OUTPUT : Y VALUE WHERE Jth HARDEST JET WAS MERGED WITH BEAM
C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
C   COULD NOT BE PROCESSED
C
C   NOTE THAT ALL FLOATING POINT VARIABLES ARE DECLARED REAL
C
      INTEGER NMAX,HIST,NUM,I,J
      PARAMETER (NMAX=512)
      REAL ETOT,RSQ,P,KT,KTP,KTS,ECUT,ETSQ,Y(*),KTLAST
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX),
     &  KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
      IF (ETOT.EQ.0) CALL KTWARN('KTBEAM',100,*999)
      IF (ECUT.EQ.0) THEN
         ETSQ=1/ETOT**2
      ELSE
         ETSQ=1/ECUT**2
      ENDIF
      J=1
      DO 100 I=1,NUM
         IF (HIST(I).LE.NMAX) THEN
            Y(J)=ETSQ*KT(I)
            J=J+1
         ENDIF
 100  CONTINUE
      DO 200 I=J,NUM
         Y(I)=0
 200  CONTINUE
      RETURN
 999  RETURN 1
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98  1
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTJOIN(ECUT,YMAC,Y,*)
      IMPLICIT NONE
C---GIVE SAME INFORMATION AS LAST CALL TO KTCLUS EXCEPT THAT ONLY
C   TRANSITIONS WHERE TWO SUB-JETS WERE JOINED ARE RECORDED
C   REMEMBER THAT A SUB-JET IS DEFINED AS A JET AT Y=YCUT WHICH HAS NOT
C   YET BEEN MERGED WITH THE BEAM AT Y=YMAC.
C
C   ECUT    = INPUT : DENOMINATOR OF KT MEASURE. IF ZERO, ETOT IS USED
C   YMAC    = INPUT : VALUE OF Y USED TO DEFINE MACRO-JETS
C   Y(J)    =OUTPUT : Y VALUE WHERE EVENT CHANGED FROM HAVING
C                         N+J SUB-JETS TO HAVING N+J-1, WHERE N IS
C                         THE NUMBER OF MACRO-JETS AT SCALE YMAC
C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
C   COULD NOT BE PROCESSED
C
C   NOTE THAT ALL FLOATING POINT VARIABLES ARE DECLARED REAL
C
      INTEGER NMAX,HIST,NUM,I,J
      PARAMETER (NMAX=512)
      REAL ETOT,RSQ,P,KT,KTP,KTS,ECUT,ETSQ,Y(*),YMAC,KTLAST,ROUND
      PARAMETER (ROUND=0.99999)
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX),
     &  KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
      IF (ETOT.EQ.0) CALL KTWARN('KTJOIN',100,*999)
      IF (ECUT.EQ.0) THEN
         ETSQ=1/ETOT**2
      ELSE
         ETSQ=1/ECUT**2
      ENDIF
      J=1
      DO 100 I=1,NUM
         IF (HIST(I).GT.NMAX.AND.ETSQ*KTLAST(I).GE.ROUND*YMAC) THEN
            Y(J)=ETSQ*KT(I)
            J=J+1
         ENDIF
 100  CONTINUE
      DO 200 I=J,NUM
         Y(I)=0
 200  CONTINUE
      RETURN
 999  RETURN 1
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTRECO(RECO,PP,NN,ECUT,YCUT,YMAC,PJET,JET,NJET,NSUB,*)
      IMPLICIT NONE
C---RECONSTRUCT KINEMATICS OF JET SYSTEM, WHICH HAS ALREADY BEEN
C   ANALYSED BY KTCLUS. NOTE THAT NO CONSISTENCY CHECK IS MADE: USER
C   IS TRUSTED TO USE THE SAME PP VALUES AS FOR KTCLUS
C
C   RECO     = INPUT : RECOMBINATION SCHEME (NEED NOT BE SAME AS KTCLUS)
C   PP(I,J)  = INPUT : 4-MOMENTUM OF Jth PARTICLE: I=1,4 => PX,PY,PZ,E
C   NN       = INPUT : NUMBER OF PARTICLES
C   ECUT     = INPUT : DENOMINATOR OF KT MEASURE. IF ZERO, ETOT IS USED
C   YCUT     = INPUT : Y VALUE AT WHICH TO RECONSTRUCT JET MOMENTA
C   YMAC     = INPUT : Y VALUE USED TO DEFINE MACRO-JETS, TO DETERMINE
C                        WHICH JETS ARE SUB-JETS
C   PJET(I,J)=OUTPUT : 4-MOMENTUM OF Jth JET AT SCALE YCUT
C   JET(J)   =OUTPUT : THE MACRO-JET WHICH CONTAINS THE Jth JET,
C                        SET TO ZERO IF JET IS NOT A SUB-JET
C   NJET     =OUTPUT : THE NUMBER OF JETS
C   NSUB     =OUTPUT : THE NUMBER OF SUB-JETS (EQUAL TO THE NUMBER OF
C                        NON-ZERO ENTRIES IN JET())
C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
C   COULD NOT BE PROCESSED
C
C   NOTE THAT THE MOMENTA ARE DECLARED DOUBLE PRECISION,
C   AND ALL OTHER FLOATING POINT VARIABLES ARE DECLARED REAL
C
      INTEGER NMAX,RECO,NUM,N,NN,NJET,NSUB,JET(*),HIST,IMIN,JMIN,I,J
      PARAMETER (NMAX=512)
      DOUBLE PRECISION PP(4,*),PJET(4,*)
      REAL ECUT,P,KT,KTP,KTS,ETOT,RSQ,ETSQ,YCUT,YMAC,KTLAST,ROUND
      PARAMETER (ROUND=0.99999)
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX),
     &  KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
C---CHECK INPUT
      IF (RECO.LT.1.OR.RECO.GT.3) CALL KTWARN('KTRECO',100,*999)
C---COPY PP TO P
      N=NN
      IF (NUM.NE.NN) CALL KTWARN('KTRECO',101,*999)
      CALL KTCOPY(PP,N,P,(RECO.NE.1))
      IF (ECUT.EQ.0) THEN
         ETSQ=1/ETOT**2
      ELSE
         ETSQ=1/ECUT**2
      ENDIF
C---KEEP MERGING UNTIL YCUT
 100  IF (ETSQ*KT(N).LT.ROUND*YCUT) THEN
         IF (HIST(N).LE.NMAX) THEN
            CALL KTMOVE(P,KTP,KTS,NMAX,N,HIST(N),0)
         ELSE
            IMIN=HIST(N)/NMAX
            JMIN=HIST(N)-IMIN*NMAX
            CALL KTMERG(P,KTP,KTS,NMAX,IMIN,JMIN,N,0,0,0,RECO)
            CALL KTMOVE(P,KTP,KTS,NMAX,N,JMIN,0)
         ENDIF
         N=N-1
         IF (N.GT.0) GOTO 100
      ENDIF
C---IF YCUT IS TOO LARGE THERE ARE NO JETS
      NJET=N
      NSUB=N
      IF (N.EQ.0) RETURN
C---SET UP OUTPUT MOMENTA
      DO 210 I=1,NJET
         IF (RECO.EQ.1) THEN
            DO 200 J=1,4
               PJET(J,I)=P(J,I)
 200        CONTINUE
         ELSE
            PJET(1,I)=P(6,I)*COS(P(8,I))
            PJET(2,I)=P(6,I)*SIN(P(8,I))
            PJET(3,I)=P(6,I)*SINH(P(7,I))
            PJET(4,I)=P(6,I)*COSH(P(7,I))
         ENDIF
         JET(I)=I
 210  CONTINUE
C---KEEP MERGING UNTIL YMAC TO FIND THE FATE OF EACH JET
 300  IF (ETSQ*KT(N).LT.ROUND*YMAC) THEN
         IF (HIST(N).LE.NMAX) THEN
            IMIN=0
            JMIN=HIST(N)
            NSUB=NSUB-1
         ELSE
            IMIN=HIST(N)/NMAX
            JMIN=HIST(N)-IMIN*NMAX
            IF (ETSQ*KTLAST(N).LT.ROUND*YMAC) NSUB=NSUB-1
         ENDIF
         DO 310 I=1,NJET
            IF (JET(I).EQ.JMIN) JET(I)=IMIN
            IF (JET(I).EQ.N) JET(I)=JMIN
 310     CONTINUE
         N=N-1
         IF (N.GT.0) GOTO 300
      ENDIF
      RETURN
 999  RETURN 1
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTINCL(RECO,PP,NN,PJET,JET,NJET,*)
      IMPLICIT NONE
C---RECONSTRUCT KINEMATICS OF JET SYSTEM, WHICH HAS ALREADY BEEN
C   ANALYSED BY KTCLUS ACCORDING TO THE INCLUSIVE JET DEFINITION. NOTE
C   THAT NO CONSISTENCY CHECK IS MADE: USER IS TRUSTED TO USE THE SAME
C   PP VALUES AS FOR KTCLUS
C
C   RECO     = INPUT : RECOMBINATION SCHEME (NEED NOT BE SAME AS KTCLUS)
C   PP(I,J)  = INPUT : 4-MOMENTUM OF Jth PARTICLE: I=1,4 => PX,PY,PZ,E
C   NN       = INPUT : NUMBER OF PARTICLES
C   PJET(I,J)=OUTPUT : 4-MOMENTUM OF Jth JET AT SCALE YCUT
C   JET(J)   =OUTPUT : THE JET WHICH CONTAINS THE Jth PARTICLE
C   NJET     =OUTPUT : THE NUMBER OF JETS
C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
C   COULD NOT BE PROCESSED
C
C   NOTE THAT THE MOMENTA ARE DECLARED DOUBLE PRECISION,
C   AND ALL OTHER FLOATING POINT VARIABLES ARE DECLARED REAL
C
      INTEGER NMAX,RECO,NUM,N,NN,NJET,JET(*),HIST,IMIN,JMIN,I,J
      PARAMETER (NMAX=512)
      DOUBLE PRECISION PP(4,*),PJET(4,*)
      REAL P,KT,KTP,KTS,ETOT,RSQ,KTLAST
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX),
     &  KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
C---CHECK INPUT
      IF (RECO.LT.1.OR.RECO.GT.3) CALL KTWARN('KTINCL',100,*999)
C---COPY PP TO P
      N=NN
      IF (NUM.NE.NN) CALL KTWARN('KTINCL',101,*999)
      CALL KTCOPY(PP,N,P,(RECO.NE.1))
C---INITIALLY EVERY PARTICLE IS IN ITS OWN JET
      DO 100 I=1,NN
         JET(I)=I
 100  CONTINUE
C---KEEP MERGING TO THE BITTER END
      NJET=0
 200  IF (N.GT.0) THEN
         IF (HIST(N).LE.NMAX) THEN
            IMIN=0
            JMIN=HIST(N)
            NJET=NJET+1
            IF (RECO.EQ.1) THEN
               DO 300 J=1,4
                  PJET(J,NJET)=P(J,JMIN)
 300           CONTINUE
            ELSE
               PJET(1,NJET)=P(6,JMIN)*COS(P(8,JMIN))
               PJET(2,NJET)=P(6,JMIN)*SIN(P(8,JMIN))
               PJET(3,NJET)=P(6,JMIN)*SINH(P(7,JMIN))
               PJET(4,NJET)=P(6,JMIN)*COSH(P(7,JMIN))
            ENDIF
            CALL KTMOVE(P,KTP,KTS,NMAX,N,JMIN,0)
         ELSE
            IMIN=HIST(N)/NMAX
            JMIN=HIST(N)-IMIN*NMAX
            CALL KTMERG(P,KTP,KTS,NMAX,IMIN,JMIN,N,0,0,0,RECO)
            CALL KTMOVE(P,KTP,KTS,NMAX,N,JMIN,0)
         ENDIF
         DO 400 I=1,NN
            IF (JET(I).EQ.JMIN) JET(I)=IMIN
            IF (JET(I).EQ.N) JET(I)=JMIN
            IF (JET(I).EQ.0) JET(I)=-NJET
 400     CONTINUE
         N=N-1
         GOTO 200
      ENDIF
C---FINALLY EVERY PARTICLE MUST BE IN AN INCLUSIVE JET
      DO 500 I=1,NN
C---IF THERE ARE ANY UNASSIGNED PARTICLES SOMETHING MUST HAVE GONE WRONG
         IF (JET(I).GE.0) CALL KTWARN('KTINCL',102,*999)
         JET(I)=-JET(I)
 500  CONTINUE
      RETURN
 999  RETURN 1
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTISUB(N,NY,YCUT,NSUB,*)
      IMPLICIT NONE
C---COUNT THE NUMBER OF SUB-JETS IN THE Nth INCLUSIVE JET OF AN EVENT
C   THAT HAS ALREADY BEEN ANALYSED BY KTCLUS.
C
C   N       = INPUT : WHICH INCLUSIVE JET TO USE
C   NY      = INPUT : NUMBER OF YCUT VALUES
C   YCUT(J) = INPUT : Y VALUES AT WHICH NUMBERS OF SUB-JETS ARE COUNTED
C   NSUB(J) =OUTPUT : NUMBER OF SUB-JETS AT YCUT(J)
C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
C   COULD NOT BE PROCESSED
C
C   NOTE THAT ALL FLOATING POINT VARIABLES ARE DECLARED REAL
C
      INTEGER N,NY,NSUB(NY),NMAX,HIST,I,J,NUM,NM
      PARAMETER (NMAX=512)
      REAL YCUT(NY),ETOT,RSQ,P,KT,KTP,KTS,KTLAST,ROUND
      PARAMETER (ROUND=0.99999)
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX),
     &  KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
      DO 100 I=1,NY
         NSUB(I)=0
 100  CONTINUE
C---FIND WHICH MERGING CORRESPONDS TO THE NTH INCLUSIVE JET
      NM=0
      J=0
      DO 110 I=NUM,1,-1
        IF (HIST(I).LE.NMAX) J=J+1
        IF (J.EQ.N) THEN
          NM=I
          GOTO 120
        ENDIF
 110  CONTINUE
 120  CONTINUE
C---GIVE UP IF THERE ARE LESS THAN N INCLUSIVE JETS
      IF (NM.EQ.0) CALL KTWARN('KTISUB',100,*999)
      DO 210 I=NUM,1,-1
         DO 200 J=1,NY
            IF (NSUB(J).EQ.0.AND.RSQ*KT(I).GE.ROUND*YCUT(J)*KT(NM))
     &          NSUB(J)=I
            IF (NSUB(J).NE.0.AND.KTLAST(I).NE.KTLAST(NM))
     &          NSUB(J)=NSUB(J)-1
 200     CONTINUE
 210  CONTINUE
      RETURN
 999  RETURN 1
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTIJOI(N,Y,*)
      IMPLICIT NONE
C---GIVE SAME INFORMATION AS LAST CALL TO KTCLUS EXCEPT THAT ONLY
C   MERGES OF TWO SUB-JETS INSIDE THE Nth INCLUSIVE JET ARE RECORDED
C
C   N       = INPUT : WHICH INCLUSIVE JET TO USE
C   Y(J)    =OUTPUT : Y VALUE WHERE JET CHANGED FROM HAVING
C                         J+1 SUB-JETS TO HAVING J
C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
C   COULD NOT BE PROCESSED
C
C   NOTE THAT ALL FLOATING POINT VARIABLES ARE DECLARED REAL
C
      INTEGER NMAX,HIST,NUM,I,J,N,NM
      PARAMETER (NMAX=512)
      REAL ETOT,RSQ,P,KT,KTP,KTS,Y(*),KTLAST
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX),
     &  KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
C---FIND WHICH MERGING CORRESPONDS TO THE NTH INCLUSIVE JET
      NM=0
      J=0
      DO 100 I=NUM,1,-1
        IF (HIST(I).LE.NMAX) J=J+1
        IF (J.EQ.N) THEN
          NM=I
          GOTO 105
        ENDIF
 100  CONTINUE
 105  CONTINUE
C---GIVE UP IF THERE ARE LESS THAN N INCLUSIVE JETS
      IF (NM.EQ.0) CALL KTWARN('KTIJOI',100,*999)
      J=1
      DO 110 I=1,NUM
         IF (HIST(I).GT.NMAX.AND.KTLAST(I).EQ.KTLAST(NM)) THEN
            Y(J)=RSQ*KT(I)/KT(NM)
            J=J+1
         ENDIF
 110  CONTINUE
      DO 200 I=J,NUM
         Y(I)=0
 200  CONTINUE
      RETURN
 999  RETURN 1
      END
*CMZ :  1.01/12 08/01/98  12.11.59  by  Tancredi Carli
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTIREC(RECO,PP,NN,N,YCUT,PSUB,NSUB,*)
      IMPLICIT NONE
C---RECONSTRUCT KINEMATICS OF SUB-JET SYSTEM IN THE Nth INCLUSIVE JET
C   OF AN EVENT THAT HAS ALREADY BEEN ANALYSED BY KTCLUS
C
C   RECO     = INPUT : RECOMBINATION SCHEME (NEED NOT BE SAME AS KTCLUS)
C   PP(I,J)  = INPUT : 4-MOMENTUM OF Jth PARTICLE: I=1,4 => PX,PY,PZ,E
C   NN       = INPUT : NUMBER OF PARTICLES
C   N        = INPUT : WHICH INCLUSIVE JET TO USE
C   YCUT     = INPUT : Y VALUE AT WHICH TO RECONSTRUCT JET MOMENTA
C   PSUB(I,J)=OUTPUT : 4-MOMENTUM OF Jth SUB-JET AT SCALE YCUT
C   NSUB     =OUTPUT : THE NUMBER OF SUB-JETS
C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
C   COULD NOT BE PROCESSED
C
C   NOTE THAT THE MOMENTA ARE DECLARED DOUBLE PRECISION,
C   AND ALL OTHER FLOATING POINT VARIABLES ARE DECLARED REAL
C
      INTEGER NMAX,RECO,NUM,NN,NJET,NSUB,JET,HIST,I,J,N,NM
      PARAMETER (NMAX=512)
      DOUBLE PRECISION PP(4,*),PSUB(4,*)
      REAL ECUT,P,KT,KTP,KTS,ETOT,RSQ,YCUT,YMAC,KTLAST
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX),
     &  KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
      DIMENSION JET(NMAX)
C---FIND WHICH MERGING CORRESPONDS TO THE NTH INCLUSIVE JET
      NM=0
      J=0
      DO 100 I=NUM,1,-1
         IF (HIST(I).LE.NMAX) J=J+1
         IF (J.EQ.N) THEN
            NM=I
            GOTO 110
         ENDIF
 100  CONTINUE
 110  CONTINUE
C---GIVE UP IF THERE ARE LESS THAN N INCLUSIVE JETS
      IF (NM.EQ.0) CALL KTWARN('KTIREC',102,*999)
C---RECONSTRUCT THE JETS AT THE APPROPRIATE SCALE
      ECUT=SQRT(KT(NM)/RSQ)
      YMAC=RSQ
      CALL KTRECO(RECO,PP,NN,ECUT,YCUT,YMAC,PSUB,JET,NJET,NSUB,*999)
C---GET RID OF THE ONES THAT DO NOT END UP IN THE JET WE WANT
      NSUB=0
      DO 210 I=1,NJET
         IF (JET(I).EQ.HIST(NM)) THEN
            NSUB=NSUB+1
            DO 200 J=1,4
               PSUB(J,NSUB)=PSUB(J,I)
 200        CONTINUE
         ENDIF
 210  CONTINUE
      RETURN
 999  RETURN 1
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTWICH(ECUT,YCUT,JET,NJET,*)
      IMPLICIT NONE
C---GIVE A LIST OF WHICH JET EACH ORIGINAL PARTICLE ENDED UP IN AT SCALE
C   YCUT, TOGETHER WITH THE NUMBER OF JETS AT THAT SCALE.
C
C   ECUT     = INPUT : DENOMINATOR OF KT MEASURE. IF ZERO, ETOT IS USED
C   YCUT     = INPUT : Y VALUE AT WHICH TO DEFINE JETS
C   JET(J)   =OUTPUT : THE JET WHICH CONTAINS THE Jth PARTICLE,
C                        SET TO ZERO IF IT WAS PUT INTO THE BEAM JETS
C   NJET     =OUTPUT : THE NUMBER OF JETS AT SCALE YCUT (SO JET()
C                        ENTRIES WILL BE IN THE RANGE 0 -> NJET)
C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
C   COULD NOT BE PROCESSED
C
C   NOTE THAT ALL FLOATING POINT VARIABLES ARE DECLARED REAL
C
      INTEGER JET(*),NJET,NTEMP
      REAL ECUT,YCUT
      CALL KTWCHS(ECUT,YCUT,YCUT,JET,NJET,NTEMP,*999)
      RETURN
 999  RETURN 1
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTWCHS(ECUT,YCUT,YMAC,JET,NJET,NSUB,*)
      IMPLICIT NONE
C---GIVE A LIST OF WHICH SUB-JET EACH ORIGINAL PARTICLE ENDED UP IN AT
C   SCALE YCUT, WITH MACRO-JET SCALE YMAC, TOGETHER WITH THE NUMBER OF
C   JETS AT SCALE YCUT AND THE NUMBER OF THEM WHICH ARE SUB-JETS.
C
C   ECUT     = INPUT : DENOMINATOR OF KT MEASURE. IF ZERO, ETOT IS USED
C   YCUT     = INPUT : Y VALUE AT WHICH TO DEFINE JETS
C   YMAC     = INPUT : Y VALUE AT WHICH TO DEFINE MACRO-JETS
C   JET(J)   =OUTPUT : THE JET WHICH CONTAINS THE Jth PARTICLE,
C                        SET TO ZERO IF IT WAS PUT INTO THE BEAM JETS
C   NJET     =OUTPUT : THE NUMBER OF JETS AT SCALE YCUT (SO JET()
C                        ENTRIES WILL BE IN THE RANGE 0 -> NJET)
C   NSUB     =OUTPUT : THE NUMBER OF SUB-JETS AT SCALE YCUT, WITH
C                        MACRO-JETS DEFINED AT SCALE YMAC (SO ONLY NSUB
C                        OF THE JETS 1 -> NJET WILL APPEAR IN JET())
C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
C   COULD NOT BE PROCESSED
C
C   NOTE THAT ALL FLOATING POINT VARIABLES ARE DECLARED REAL
C
      INTEGER NMAX,JET(*),NJET,NSUB,HIST,NUM,I,J,JSUB
      PARAMETER (NMAX=512)
      DOUBLE PRECISION P1(4,NMAX),P2(4,NMAX)
      REAL ECUT,YCUT,YMAC,ZERO,ETOT,RSQ,P,KTP,KTS,KT,KTLAST
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX),
     &  KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
      DIMENSION JSUB(NMAX)
C---THE MOMENTA HAVE TO BEEN GIVEN LEGAL VALUES,
C   EVEN THOUGH THEY WILL NEVER BE USED
      DATA ((P1(J,I),I=1,NMAX),J=1,4),ZERO
     &  /NMAX*1,NMAX*0,NMAX*0,NMAX*1,0/
C---FIRST GET A LIST OF WHICH PARTICLE IS IN WHICH JET AT YCUT
      CALL KTRECO(1,P1,NUM,ECUT,ZERO,YCUT,P2,JET,NJET,NSUB,*999)
C---THEN FIND OUT WHICH JETS ARE SUBJETS
      CALL KTRECO(1,P1,NUM,ECUT,YCUT,YMAC,P2,JSUB,NJET,NSUB,*999)
C---AND MODIFY JET() ACCORDINGLY
      DO 10 I=1,NUM
        IF (JET(I).NE.0) THEN
          IF (JSUB(JET(I)).EQ.0) JET(I)=0
        ENDIF
 10   CONTINUE
      RETURN
 999  RETURN 1
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTFRAM(IOPT,CMF,SIGN,Z,XZ,N,P,Q,*)
      IMPLICIT NONE
C---BOOST PARTICLES IN P TO/FROM FRAME GIVEN BY CMF, Z, XZ.
C---IN THIS FRAME CMZ IS STATIONARY,
C                   Z IS ALONG THE (SIGN)Z-AXIS (SIGN=+ OR -)
C                  XZ IS IN THE X-Z PLANE (WITH POSITIVE X COMPONENT)
C---IF Z HAS LENGTH ZERO, OR SIGN=0, NO ROTATION IS PERFORMED
C---IF XZ HAS ZERO COMPONENT PERPENDICULAR TO Z IN THAT FRAME,
C   NO AZIMUTHAL ROTATION IS PERFORMED
C
C   IOPT    = INPUT  : 0=TO FRAME, 1=FROM FRAME
C   CMF(I)  = INPUT  : 4-MOMENTUM WHICH IS STATIONARY IN THE FRAME
C   SIGN    = INPUT  : DIRECTION OF Z IN THE FRAME, NOTE THAT
C                        ONLY ITS SIGN IS USED, NOT ITS MAGNITUDE
C   Z(I)    = INPUT  : 4-MOMENTUM WHICH LIES ON THE (SIGN)Z-AXIS
C   XZ(I)   = INPUT  : 4-MOMENTUM WHICH LIES IN THE X-Z PLANE
C   N       = INPUT  : NUMBER OF PARTICLES IN P
C   P(I,J)  = INPUT  : 4-MOMENTUM OF JTH PARTICLE BEFORE
C   Q(I,J)  = OUTPUT : 4-MOMENTUM OF JTH PARTICLE AFTER
C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
C   COULD NOT BE PROCESSED
C
C   NOTE THAT ALL MOMENTA ARE DOUBLE PRECISION
C
C   NOTE THAT IT IS SAFE TO CALL WITH P=Q
C
      INTEGER IOPT,I,N
      DOUBLE PRECISION CMF(4),SIGN,Z(4),XZ(4),P(4,N),Q(4,N),
     &  R(4,4),NEW(4),OLD(4)
      IF (IOPT.LT.0.OR.IOPT.GT.1) CALL KTWARN('KTFRAM',200,*999)
C---FIND BOOST TO GET THERE FROM LAB
      CALL KTUNIT(R)
      CALL KTLBST(0,R,CMF,*999)
C---FIND ROTATION TO PUT BOOSTED Z ON THE (SIGN)Z AXIS
      IF (SIGN.NE.0) THEN
        CALL KTVMUL(R,Z,OLD)
        IF (OLD(1).NE.0.OR.OLD(2).NE.0.OR.OLD(3).NE.0) THEN
          NEW(1)=0
          NEW(2)=0
          NEW(3)=SIGN
          NEW(4)=ABS(SIGN)
          CALL KTRROT(R,OLD,NEW,*999)
C---FIND ROTATION TO PUT BOOSTED AND ROTATED XZ INTO X-Z PLANE
          CALL KTVMUL(R,XZ,OLD)
          IF (OLD(1).NE.0.OR.OLD(2).NE.0) THEN
            NEW(1)=1
            NEW(2)=0
            NEW(3)=0
            NEW(4)=1
            OLD(3)=0
C---NOTE THAT A POTENTIALLY AWKWARD SPECIAL CASE IS AVERTED, BECAUSE IF
C   OLD AND NEW ARE EXACTLY BACK-TO-BACK, THE ROTATION AXIS IS UNDEFINED
C   BUT IN THAT CASE KTRROT WILL USE THE Z AXIS, AS REQUIRED
            CALL KTRROT(R,OLD,NEW,*999)
          ENDIF
        ENDIF
      ENDIF
C---INVERT THE TRANSFORMATION IF NECESSARY
      IF (IOPT.EQ.1) CALL KTINVT(R,R)
C---APPLY THE RESULT TO ALL THE VECTORS
      DO 30 I=1,N
        CALL KTVMUL(R,P(1,I),Q(1,I))
 30   CONTINUE
      RETURN
 999  RETURN 1
      END
*CMZ :  1.01/13 25/02/98  12.32.37  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTBREI(IOPT,PLEP,PHAD,POUT,N,P,Q,*)
      IMPLICIT NONE
C---BOOST PARTICLES IN P TO/FROM BREIT FRAME
C
C   IOPT    = INPUT  : 0/2=TO BREIT FRAME, 1/3=FROM BREIT FRAME
C                      0/1=NO AZIMUTHAL ROTATION AFTERWARDS
C                      2/3=LEPTON PLANE ROTATED INTO THE X-Z PLANE
C   PLEP    = INPUT  : MOMENTUM OF INCOMING LEPTON IN +Z DIRECTION
C   PHAD    = INPUT  : MOMENTUM OF INCOMING HADRON IN +Z DIRECTION
C   POUT(I) = INPUT  : 4-MOMENTUM OF OUTGOING LEPTON
C   N       = INPUT  : NUMBER OF PARTICLES IN P
C   P(I,J)  = INPUT  : 4-MOMENTUM OF JTH PARTICLE BEFORE
C   Q(I,J)  = OUTPUT : 4-MOMENTUM OF JTH PARTICLE AFTER
C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
C   COULD NOT BE PROCESSED (MOST LIKELY DUE TO PARTICLES HAVING SMALLER
C   ENERGY THAN MOMENTUM)
C
C   NOTE THAT ALL MOMENTA ARE DOUBLE PRECISION
C
C   NOTE THAT IT IS SAFE TO CALL WITH P=Q
C
      INTEGER IOPT,N
      DOUBLE PRECISION PLEP,PHAD,POUT(4),P(4,N),Q(4,N),
     &  CMF(4),Z(4),XZ(4),DOT,QDQ
C---CHECK INPUT
      IF (IOPT.LT.0.OR.IOPT.GT.3) CALL KTWARN('KTBREI',200,*999)
C---FIND 4-MOMENTUM OF BREIT FRAME (TIMES AN ARBITRARY FACTOR)
      DOT=ABS(PHAD)*(ABS(PLEP)-POUT(4))-PHAD*(PLEP-POUT(3))
      QDQ=(ABS(PLEP)-POUT(4))**2-(PLEP-POUT(3))**2-POUT(2)**2-POUT(1)**2
      CMF(1)=DOT*(         -POUT(1))
      CMF(2)=DOT*(         -POUT(2))
      CMF(3)=DOT*(    PLEP -POUT(3))-QDQ*    PHAD
      CMF(4)=DOT*(ABS(PLEP)-POUT(4))-QDQ*ABS(PHAD)
C---FIND ROTATION TO PUT INCOMING HADRON BACK ON Z-AXIS
      Z(1)=0
      Z(2)=0
      Z(3)=PHAD
      Z(4)=ABS(PHAD)
      XZ(1)=0
      XZ(2)=0
      XZ(3)=0
      XZ(4)=0
C---DO THE BOOST
      IF (IOPT.LE.1) THEN
        CALL KTFRAM(IOPT,CMF,PHAD,Z,XZ,N,P,Q,*999)
      ELSE
        CALL KTFRAM(IOPT-2,CMF,PHAD,Z,POUT,N,P,Q,*999)
      ENDIF
      RETURN
 999  RETURN 1
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTHADR(IOPT,PLEP,PHAD,POUT,N,P,Q,*)
      IMPLICIT NONE
C---BOOST PARTICLES IN P TO/FROM HADRONIC CMF
C
C   ARGUMENTS ARE EXACTLY AS FOR KTBREI
C
C   NOTE THAT ALL MOMENTA ARE DOUBLE PRECISION
C
C   NOTE THAT IT IS SAFE TO CALL WITH P=Q
C
      INTEGER IOPT,N
      DOUBLE PRECISION PLEP,PHAD,POUT(4),P(4,N),Q(4,N),
     &  CMF(4),Z(4),XZ(4)
C---CHECK INPUT
      IF (IOPT.LT.0.OR.IOPT.GT.3) CALL KTWARN('KTHADR',200,*999)
C---FIND 4-MOMENTUM OF HADRONIC CMF
      CMF(1)=         -POUT(1)
      CMF(2)=         -POUT(2)
      CMF(3)=    PLEP -POUT(3)+    PHAD
      CMF(4)=ABS(PLEP)-POUT(4)+ABS(PHAD)
C---FIND ROTATION TO PUT INCOMING HADRON BACK ON Z-AXIS
      Z(1)=0
      Z(2)=0
      Z(3)=PHAD
      Z(4)=ABS(PHAD)
      XZ(1)=0
      XZ(2)=0
      XZ(3)=0
      XZ(4)=0
C---DO THE BOOST
      IF (IOPT.LE.1) THEN
        CALL KTFRAM(IOPT,CMF,PHAD,Z,XZ,N,P,Q,*999)
      ELSE
        CALL KTFRAM(IOPT-2,CMF,PHAD,Z,POUT,N,P,Q,*999)
      ENDIF
      RETURN
 999  RETURN 1
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      FUNCTION KTPAIR(ANGL,P,Q,ANGLE)
      IMPLICIT NONE
C---CALCULATE LOCAL KT OF PAIR, USING ANGULAR SCHEME:
C   1=>ANGULAR, 2=>DeltaR, 3=>f(DeltaEta,DeltaPhi)
C   WHERE f(eta,phi)=2(COSH(eta)-COS(phi)) IS THE QCD EMISSION METRIC
C---IF ANGLE<0, IT IS SET TO THE ANGULAR PART OF THE LOCAL KT ON RETURN
C   IF ANGLE>0, IT IS USED INSTEAD OF THE ANGULAR PART OF THE LOCAL KT
      INTEGER ANGL
      REAL P(9),Q(9),KTPAIR,R,KTMDPI,ANGLE,ETA,PHI,ESQ
C---COMPONENTS OF MOMENTA ARE PX,PY,PZ,E,1/P,PT,ETA,PHI,PT**2
      R=ANGLE
      IF (ANGL.EQ.1) THEN
         IF (R.LE.0) R=2*(1-(P(1)*Q(1)+P(2)*Q(2)+P(3)*Q(3))*(P(5)*Q(5)))
         ESQ=MIN(P(4),Q(4))**2
      ELSEIF (ANGL.EQ.2.OR.ANGL.EQ.3) THEN
         IF (R.LE.0) THEN
            ETA=P(7)-Q(7)
            PHI=KTMDPI(P(8)-Q(8))
            IF (ANGL.EQ.2) THEN
               R=ETA**2+PHI**2
            ELSE
               R=2*(COSH(ETA)-COS(PHI))
            ENDIF
         ENDIF
         ESQ=MIN(P(9),Q(9))
      ELSE
         CALL KTWARN('KTPAIR',200,*999)
         STOP
      ENDIF
      KTPAIR=ESQ*R
      IF (ANGLE.LT.0) ANGLE=R
 999  END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      FUNCTION KTSING(ANGL,TYPE,P)
      IMPLICIT NONE
C---CALCULATE KT OF PARTICLE, USING ANGULAR SCHEME:
C   1=>ANGULAR, 2=>DeltaR, 3=>f(DeltaEta,DeltaPhi)
C---TYPE=1 FOR E+E-, 2 FOR EP, 3 FOR PE, 4 FOR PP
C   FOR EP, PROTON DIRECTION IS DEFINED AS -Z
C   FOR PE, PROTON DIRECTION IS DEFINED AS +Z
      INTEGER ANGL,TYPE
      REAL P(9),KTSING,COSTH,R,SMALL
      DATA SMALL/1E-4/
      IF (ANGL.EQ.1) THEN
         COSTH=P(3)*P(5)
         IF (TYPE.EQ.2) THEN
            COSTH=-COSTH
         ELSEIF (TYPE.EQ.4) THEN
            COSTH=ABS(COSTH)
         ELSEIF (TYPE.NE.1.AND.TYPE.NE.3) THEN
            CALL KTWARN('KTSING',200,*999)
            STOP
         ENDIF
         R=2*(1-COSTH)
C---IF CLOSE TO BEAM, USE APPROX 2*(1-COS(THETA))=SIN**2(THETA)
         IF (R.LT.SMALL) R=(P(1)**2+P(2)**2)*P(5)**2
         KTSING=P(4)**2*R
      ELSEIF (ANGL.EQ.2.OR.ANGL.EQ.3) THEN
         KTSING=P(9)
      ELSE
         CALL KTWARN('KTSING',201,*999)
         STOP
      ENDIF
 999  END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTPMIN(A,NMAX,N,IMIN,JMIN)
      IMPLICIT NONE
C---FIND THE MINIMUM MEMBER OF A(NMAX,NMAX) WITH IMIN < JMIN <= N
      INTEGER NMAX,N,IMIN,JMIN,KMIN,I,J,K
C---REMEMBER THAT A(X+(Y-1)*NMAX)=A(X,Y)
C   THESE LOOPING VARIABLES ARE J=Y-2, I=X+(Y-1)*NMAX
      REAL A(*),AMIN
      K=1+NMAX
      KMIN=K
      AMIN=A(KMIN)
      DO 110 J=0,N-2
         DO 100 I=K,K+J
            IF (A(I).LT.AMIN) THEN
               KMIN=I
               AMIN=A(KMIN)
            ENDIF
 100     CONTINUE
         K=K+NMAX
 110  CONTINUE
      JMIN=KMIN/NMAX+1
      IMIN=KMIN-(JMIN-1)*NMAX
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTSMIN(A,NMAX,N,IMIN)
      IMPLICIT NONE
C---FIND THE MINIMUM MEMBER OF A
      INTEGER N,NMAX,IMIN,I
      REAL A(NMAX)
      IMIN=1
      DO 100 I=1,N
         IF (A(I).LT.A(IMIN)) IMIN=I
 100  CONTINUE
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTCOPY(A,N,B,ONSHLL)
      IMPLICIT NONE
C---COPY FROM A TO B. 5TH=1/(3-MTM), 6TH=PT, 7TH=ETA, 8TH=PHI, 9TH=PT**2
C   IF ONSHLL IS .TRUE. PARTICLE ENTRIES ARE PUT ON-SHELL BY SETTING E=P
      INTEGER I,N
      DOUBLE PRECISION A(4,N)
      LOGICAL ONSHLL
      REAL B(9,N),ETAMAX,SINMIN,EPS
      DATA ETAMAX,SINMIN,EPS/10,0,1E-6/
C---SINMIN GETS CALCULATED ON FIRST CALL
      IF (SINMIN.EQ.0) SINMIN=1/COSH(ETAMAX)
      DO 100 I=1,N
         B(1,I)=A(1,I)
         B(2,I)=A(2,I)
         B(3,I)=A(3,I)
         B(4,I)=A(4,I)
         B(5,I)=SQRT(A(1,I)**2+A(2,I)**2+A(3,I)**2)
         IF (ONSHLL) B(4,I)=B(5,I)
         IF (B(5,I).EQ.0) B(5,I)=1E-10
         B(5,I)=1/B(5,I)
         B(9,I)=A(1,I)**2+A(2,I)**2
         B(6,I)=SQRT(B(9,I))
         B(7,I)=B(6,I)*B(5,I)
         IF (B(7,I).GT.SINMIN) THEN
            B(7,I)=A(4,I)**2-A(3,I)**2
            IF (B(7,I).LE.EPS*B(4,I)**2.OR.ONSHLL) B(7,I)=B(9,I)
            B(7,I)=0.5*LOG((B(4,I)+ABS(B(3,I)))**2/B(7,I))
         ELSE
            B(7,I)=ETAMAX+2
         ENDIF
         B(7,I)=SIGN(B(7,I),B(3,I))
         IF (A(1,I).EQ.0 .AND. A(2,I).EQ.0) THEN
            B(8,I)=0
         ELSE
            B(8,I)=ATAN2(A(2,I),A(1,I))
         ENDIF
 100  CONTINUE
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTMERG(P,KTP,KTS,NMAX,I,J,N,TYPE,ANGL,MONO,RECO)
      IMPLICIT NONE
C---MERGE THE Jth PARTICLE IN P INTO THE Ith PARTICLE
C   J IS ASSUMED GREATER THAN I. P CONTAINS N PARTICLES BEFORE MERGING.
C---ALSO RECALCULATING THE CORRESPONDING KTP AND KTS VALUES IF MONO.GT.0
C   FROM THE RECOMBINED ANGULAR MEASURES IF MONO.GT.1
C---NOTE THAT IF MONO.LE.0, TYPE AND ANGL ARE NOT USED
      INTEGER ANGL,RECO,TYPE,I,J,K,N,NMAX,MONO
      REAL P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX),PT,PTT,
     &     KTMDPI,KTUP,PI,PJ,ANG,KTPAIR,KTSING,ETAMAX,EPS
      KTUP(I,J)=KTP(MAX(I,J),MIN(I,J))
      DATA ETAMAX,EPS/10,1E-6/
      IF (J.LE.I) CALL KTWARN('KTMERG',200,*999)
C---COMBINE ANGULAR MEASURES IF NECESSARY
      IF (MONO.GT.1) THEN
         DO 100 K=1,N
            IF (K.NE.I.AND.K.NE.J) THEN
               IF (RECO.EQ.1) THEN
                  PI=P(4,I)
                  PJ=P(4,J)
               ELSEIF (RECO.EQ.2) THEN
                  PI=P(6,I)
                  PJ=P(6,J)
               ELSEIF (RECO.EQ.3) THEN
                  PI=P(9,I)
                  PJ=P(9,J)
               ELSE
                  CALL KTWARN('KTMERG',201,*999)
                  STOP
               ENDIF
               IF (PI.EQ.0.AND.PJ.EQ.0) THEN
                  PI=1
                  PJ=1
               ENDIF
               KTP(MAX(I,K),MIN(I,K))=
     &              (PI*KTUP(I,K)+PJ*KTUP(J,K))/(PI+PJ)
            ENDIF
 100     CONTINUE
      ENDIF
      IF (RECO.EQ.1) THEN
C---VECTOR ADDITION
         P(1,I)=P(1,I)+P(1,J)
         P(2,I)=P(2,I)+P(2,J)
         P(3,I)=P(3,I)+P(3,J)
         P(4,I)=P(4,I)+P(4,J)
         P(5,I)=SQRT(P(1,I)**2+P(2,I)**2+P(3,I)**2)
         IF (P(5,I).EQ.0) THEN
            P(5,I)=1
         ELSE
            P(5,I)=1/P(5,I)
         ENDIF
      ELSEIF (RECO.EQ.2) THEN
C---PT WEIGHTED ETA-PHI ADDITION
         PT=P(6,I)+P(6,J)
         IF (PT.EQ.0) THEN
            PTT=1
         ELSE
            PTT=1/PT
         ENDIF
         P(7,I)=(P(6,I)*P(7,I)+P(6,J)*P(7,J))*PTT
         P(8,I)=KTMDPI(P(8,I)+P(6,J)*PTT*KTMDPI(P(8,J)-P(8,I)))
         P(6,I)=PT
         P(9,I)=PT**2
      ELSEIF (RECO.EQ.3) THEN
C---PT**2 WEIGHTED ETA-PHI ADDITION
         PT=P(9,I)+P(9,J)
         IF (PT.EQ.0) THEN
            PTT=1
         ELSE
            PTT=1/PT
         ENDIF
         P(7,I)=(P(9,I)*P(7,I)+P(9,J)*P(7,J))*PTT
         P(8,I)=KTMDPI(P(8,I)+P(9,J)*PTT*KTMDPI(P(8,J)-P(8,I)))
         P(6,I)=P(6,I)+P(6,J)
         P(9,I)=P(6,I)**2
      ELSE
         CALL KTWARN('KTMERG',202,*999)
         STOP
      ENDIF
C---IF MONO.GT.0 CALCULATE NEW KT MEASURES. IF MONO.GT.1 USE ANGULAR ONES.
      IF (MONO.LE.0) RETURN
C---CONVERTING BETWEEN 4-MTM AND PT,ETA,PHI IF NECESSARY
      IF (ANGL.NE.1.AND.RECO.EQ.1) THEN
         P(9,I)=P(1,I)**2+P(2,I)**2
         P(7,I)=P(4,I)**2-P(3,I)**2
         IF (P(7,I).LE.EPS*P(4,I)**2) P(7,I)=P(9,I)
         IF (P(7,I).GT.0) THEN
            P(7,I)=0.5*LOG((P(4,I)+ABS(P(3,I)))**2/P(7,I))
            IF (P(7,I).GT.ETAMAX) P(7,I)=ETAMAX+2
         ELSE
            P(7,I)=ETAMAX+2
         ENDIF
         P(7,I)=SIGN(P(7,I),P(3,I))
         IF (P(1,I).NE.0.AND.P(2,I).NE.0) THEN
            P(8,I)=ATAN2(P(2,I),P(1,I))
         ELSE
            P(8,I)=0
         ENDIF
      ELSEIF (ANGL.EQ.1.AND.RECO.NE.1) THEN
         P(1,I)=P(6,I)*COS(P(8,I))
         P(2,I)=P(6,I)*SIN(P(8,I))
         P(3,I)=P(6,I)*SINH(P(7,I))
         P(4,I)=P(6,I)*COSH(P(7,I))
         IF (P(4,I).NE.0) THEN
            P(5,I)=1/P(4,I)
         ELSE
            P(5,I)=1
         ENDIF
      ENDIF
      ANG=0
      DO 200 K=1,N
         IF (K.NE.I.AND.K.NE.J) THEN
            IF (MONO.GT.1) ANG=KTUP(I,K)
            KTP(MIN(I,K),MAX(I,K))=
     &           KTPAIR(ANGL,P(1,I),P(1,K),ANG)
         ENDIF
 200  CONTINUE
      KTS(I)=KTSING(ANGL,TYPE,P(1,I))
 999  END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTMOVE(P,KTP,KTS,NMAX,N,J,IOPT)
      IMPLICIT NONE
C---MOVE THE Nth PARTICLE IN P TO THE Jth POSITION
C---ALSO MOVING KTP AND KTS IF IOPT.GT.0
      INTEGER I,J,N,NMAX,IOPT
      REAL P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX)
      DO 100 I=1,9
         P(I,J)=P(I,N)
 100  CONTINUE
      IF (IOPT.LE.0) RETURN
      DO 110 I=1,J-1
         KTP(I,J)=KTP(I,N)
         KTP(J,I)=KTP(N,I)
 110  CONTINUE
      DO 120 I=J+1,N-1
         KTP(J,I)=KTP(I,N)
         KTP(I,J)=KTP(N,I)
 120  CONTINUE
      KTS(J)=KTS(N)
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTUNIT(R)
      IMPLICIT NONE
C   SET R EQUAL TO THE 4 BY 4 IDENTITY MATRIX
      DOUBLE PRECISION R(4,4)
      INTEGER I,J
      DO 20 I=1,4
        DO 10 J=1,4
          R(I,J)=0
          IF (I.EQ.J) R(I,J)=1
 10     CONTINUE
 20   CONTINUE
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTLBST(IOPT,R,A,*)
      IMPLICIT NONE
C   PREMULTIPLY R BY THE 4 BY 4 MATRIX TO
C   LORENTZ BOOST TO/FROM THE CM FRAME OF A
C   IOPT=0 => TO
C   IOPT=1 => FROM
C
C   LAST ARGUMENT IS LABEL TO JUMP TO IF A IS NOT TIME-LIKE
C
      INTEGER IOPT,I,J
      DOUBLE PRECISION R(4,4),A(4),B(4),C(4,4),M
      DO 10 I=1,4
        B(I)=A(I)
 10   CONTINUE
      M=B(4)**2-B(1)**2-B(2)**2-B(3)**2
      IF (M.LE.0) CALL KTWARN('KTLBST',100,*999)
      M=SQRT(M)
      B(4)=B(4)+M
      M=1/(M*B(4))
      IF (IOPT.EQ.0) THEN
        B(4)=-B(4)
      ELSEIF (IOPT.NE.1) THEN
        CALL KTWARN('KTLBST',200,*999)
        STOP
      ENDIF
      DO 30 I=1,4
        DO 20 J=1,4
          C(I,J)=B(I)*B(J)*M
          IF (I.EQ.J) C(I,J)=C(I,J)+1
 20     CONTINUE
 30   CONTINUE
      C(4,4)=C(4,4)-2
      CALL KTMMUL(C,R,R)
      RETURN
 999  RETURN 1
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTRROT(R,A,B,*)
      IMPLICIT NONE
C   PREMULTIPLY R BY THE 4 BY 4 MATRIX TO
C   ROTATE FROM VECTOR A TO VECTOR B BY THE SHORTEST ROUTE
C   IF THEY ARE EXACTLY BACK-TO-BACK, THE ROTATION AXIS IS THE VECTOR
C   WHICH IS PERPENDICULAR TO THEM AND THE X AXIS, UNLESS THEY ARE
C   PERPENDICULAR TO THE Y AXIS, WHEN IT IS THE VECTOR WHICH IS
C   PERPENDICULAR TO THEM AND THE Y AXIS.
C   NOTE THAT THESE CONDITIONS GUARANTEE THAT IF BOTH ARE PERPENDICULAR
C   TO THE Z AXIS, IT WILL BE USED AS THE ROTATION AXIS.
C
C   LAST ARGUMENT IS LABEL TO JUMP TO IF EITHER HAS LENGTH ZERO
C
      DOUBLE PRECISION R(4,4),M(4,4),A(4),B(4),C(4),D(4),AL,BL,CL,DL,EPS
C---SQRT(2*EPS) IS THE ANGLE IN RADIANS OF THE SMALLEST ALLOWED ROTATION
C   NOTE THAT IF YOU CONVERT THIS PROGRAM TO SINGLE PRECISION, YOU WILL
C   NEED TO INCREASE EPS TO AROUND 0.5E-4
      PARAMETER (EPS=0.5E-6)
      AL=A(1)**2+A(2)**2+A(3)**2
      BL=B(1)**2+B(2)**2+B(3)**2
      IF (AL.LE.0.OR.BL.LE.0) CALL KTWARN('KTRROT',100,*999)
      AL=1/SQRT(AL)
      BL=1/SQRT(BL)
      CL=(A(1)*B(1)+A(2)*B(2)+A(3)*B(3))*AL*BL
C---IF THEY ARE COLLINEAR, DON'T NEED TO DO ANYTHING
      IF (CL.GE.1-EPS) THEN
        RETURN
C---IF THEY ARE BACK-TO-BACK, USE THE AXIS PERP TO THEM AND X AXIS
      ELSEIF (CL.LE.-1+EPS) THEN
        IF (ABS(B(2)).GT.EPS) THEN
          C(1)= 0
          C(2)=-B(3)
          C(3)= B(2)
C---UNLESS THEY ARE PERPENDICULAR TO THE Y AXIS,
        ELSE
          C(1)= B(3)
          C(2)= 0
          C(3)=-B(1)
        ENDIF
C---OTHERWISE FIND ROTATION AXIS
      ELSE
        C(1)=A(2)*B(3)-A(3)*B(2)
        C(2)=A(3)*B(1)-A(1)*B(3)
        C(3)=A(1)*B(2)-A(2)*B(1)
      ENDIF
      CL=C(1)**2+C(2)**2+C(3)**2
      IF (CL.LE.0) CALL KTWARN('KTRROT',101,*999)
      CL=1/SQRT(CL)
C---FIND ROTATION TO INTERMEDIATE AXES FROM A
      D(1)=A(2)*C(3)-A(3)*C(2)
      D(2)=A(3)*C(1)-A(1)*C(3)
      D(3)=A(1)*C(2)-A(2)*C(1)
      DL=AL*CL
      M(1,1)=A(1)*AL
      M(1,2)=A(2)*AL
      M(1,3)=A(3)*AL
      M(1,4)=0
      M(2,1)=C(1)*CL
      M(2,2)=C(2)*CL
      M(2,3)=C(3)*CL
      M(2,4)=0
      M(3,1)=D(1)*DL
      M(3,2)=D(2)*DL
      M(3,3)=D(3)*DL
      M(3,4)=0
      M(4,1)=0
      M(4,2)=0
      M(4,3)=0
      M(4,4)=1
      CALL KTMMUL(M,R,R)
C---AND ROTATION FROM INTERMEDIATE AXES TO B
      D(1)=B(2)*C(3)-B(3)*C(2)
      D(2)=B(3)*C(1)-B(1)*C(3)
      D(3)=B(1)*C(2)-B(2)*C(1)
      DL=BL*CL
      M(1,1)=B(1)*BL
      M(2,1)=B(2)*BL
      M(3,1)=B(3)*BL
      M(1,2)=C(1)*CL
      M(2,2)=C(2)*CL
      M(3,2)=C(3)*CL
      M(1,3)=D(1)*DL
      M(2,3)=D(2)*DL
      M(3,3)=D(3)*DL
      CALL KTMMUL(M,R,R)
      RETURN
 999  RETURN 1
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTVMUL(M,A,B)
      IMPLICIT NONE
C   4 BY 4 MATRIX TIMES 4 VECTOR: B=M*A.
C   ALL ARE DOUBLE PRECISION
C   IT IS SAFE TO CALL WITH B=A
C   FIRST SUBSCRIPT=ROWS, SECOND=COLUMNS
      DOUBLE PRECISION M(4,4),A(4),B(4),C(4)
      INTEGER I,J
      DO 20 I=1,4
        C(I)=0
        DO 10 J=1,4
          C(I)=C(I)+M(I,J)*A(J)
 10     CONTINUE
 20   CONTINUE
      DO 30 I=1,4
        B(I)=C(I)
 30   CONTINUE
      END
*CMZ :  1.01/13 25/02/98  12.38.39  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTMMUL(A,B,C)
      IMPLICIT NONE
C   4 BY 4 MATRIX MULTIPLICATION: C=A*B.
C   ALL ARE DOUBLE PRECISION
C   IT IS SAFE TO CALL WITH C=A OR B.
C   FIRST SUBSCRIPT=ROWS, SECOND=COLUMNS
      DOUBLE PRECISION A(4,4),B(4,4),C(4,4),D(4,4)
      INTEGER I,J,K
      DO 30 I=1,4
        DO 20 J=1,4
          D(I,J)=0
          DO 10 K=1,4
            D(I,J)=D(I,J)+A(I,K)*B(K,J)
 10       CONTINUE
 20     CONTINUE
 30   CONTINUE
      DO 50 I=1,4
        DO 40 J=1,4
          C(I,J)=D(I,J)
 40     CONTINUE
 50   CONTINUE
      END
*CMZ :  1.01/13 25/02/98  12.39.25  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTINVT(A,B)
      IMPLICIT NONE
C---INVERT TRANSFORMATION MATRIX A
C
C   A = INPUT  : 4 BY 4 TRANSFORMATION MATRIX
C   B = OUTPUT : INVERTED TRANSFORMATION MATRIX
C
C   IF A IS NOT A TRANSFORMATION MATRIX YOU WILL GET STRANGE RESULTS
C
C   NOTE THAT IT IS SAFE TO CALL WITH A=B
C
      DOUBLE PRECISION A(4,4),B(4,4),C(4,4)
      INTEGER I,J
C---TRANSPOSE
      DO 20 I=1,4
        DO 10 J=1,4
          C(I,J)=A(J,I)
 10     CONTINUE
 20   CONTINUE
C---NEGATE ENERGY-MOMENTUM MIXING TERMS
      DO 30 I=1,3
        C(4,I)=-C(4,I)
        C(I,4)=-C(I,4)
 30   CONTINUE
C---OUTPUT
      DO 50 I=1,4
        DO 40 J=1,4
          B(I,J)=C(I,J)
 40     CONTINUE
 50   CONTINUE
      END
*CMZ :  1.01/13 25/02/98  12.39.25  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      FUNCTION KTMDPI(PHI)
      IMPLICIT NONE
C---RETURNS PHI, MOVED ONTO THE RANGE [-PI,PI)
      REAL KTMDPI,PHI,PI,TWOPI,THRPI,EPS
      PARAMETER (PI=3.141592654,TWOPI=6.283185307,THRPI=9.424777961)
      PARAMETER (EPS=1E-15)
      KTMDPI=PHI
      IF (KTMDPI.LE.PI) THEN
        IF (KTMDPI.GT.-PI) THEN
          GOTO 100
        ELSEIF (KTMDPI.GT.-THRPI) THEN
          KTMDPI=KTMDPI+TWOPI
        ELSE
          KTMDPI=-MOD(PI-KTMDPI,TWOPI)+PI
        ENDIF
      ELSEIF (KTMDPI.LE.THRPI) THEN
        KTMDPI=KTMDPI-TWOPI
      ELSE
        KTMDPI=MOD(PI+KTMDPI,TWOPI)-PI
      ENDIF
 100  IF (ABS(KTMDPI).LT.EPS) KTMDPI=0
      END
*CMZ :  1.01/13 25/02/98  12.39.25  by  Tancredi Carli
*CMZ :  1.01/12 08/01/98
*-- Author :
C-----------------------------------------------------------------------
      SUBROUTINE KTWARN(SUBRTN,ICODE,*)
C     DEALS WITH ERRORS DURING EXECUTION
C     SUBRTN = NAME OF CALLING SUBROUTINE
C     ICODE  = ERROR CODE:    - 99 PRINT WARNING & CONTINUE
C                          100-199 PRINT WARNING & JUMP
C                          200-    PRINT WARNING & STOP DEAD
C-----------------------------------------------------------------------
      INTEGER ICODE
      CHARACTER*6 SUBRTN
      WRITE (6,10) SUBRTN,ICODE
   10 FORMAT(/' KTWARN CALLED FROM SUBPROGRAM ',A6,': CODE =',I4/)
      IF (ICODE.LT.100) RETURN
      IF (ICODE.LT.200) RETURN 1
      STOP
      END
*CMZ :  1.01/01 28/03/96  16.21.35  by  Tancredi Carli
*CMZ :  1.00/02 04/03/96  13.37.02  by  Unknown
*-- Author :    Armen Buniatian   01/03/96


      SUBROUTINE H1GPCONE(ETALIM,NETA,NPHI,ETINI,ETMIN,ETBIN,ETMAX,
     +                 RJET, NJETS,JETS)
*********************************************************************
*
*      H1-Cone jet finder algorithm
*
*********************************************************************
*
*  INPUT:
*
*  ETALIM = psewdorapidity limit  (+ETALIM   -ETALIM)
*  NETA   = number of psewdorapidity bins in ETA-PHI space (MAX=50)
*  NPHI   = number of PHI  bins in ETA-PHI space (MAX=50)
*  ETINI  = min transvers energy of initiator
*  ETMIN  = Etjet min
*  ETBIN  = bin size for Etjet distribution
*  ETMAX  = Etjet max
*  RJET   = cone size
*
*  OUTPUT :
*
*  NJETS  = number of jets
*  JETS   = REAL ARRAY JETS(10,3)
*  JETS(I,1) = Etjet
*  JETS(I,2) = ETA jet (psewdorapidity)
*  JETS(I,3) = asimuthal angle of jet axes (0 - 2*PI)
*********************************************************************
*
      PARAMETER (MAXCE=50,PI=3.141593)
      REAL JETS(10,3),CELL(MAXCE,MAXCE)
      INTEGER LOCK(MAXCE,MAXCE)
      REAL DPHI
*
*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEND.
*
      IF(NETA.GT.MAXCE) THEN
              PRINT *,'TO BIG NETA'
              GOTO 99
      ENDIF
      IF(NPHI.GT.MAXCE) THEN
              PRINT *,'TO BIG NPHI'
              GOTO 99
      ENDIF
*
*
*     Internal 'jet' steering:
*
*         Ecut for the cell Et energy |Et cell| > ETCUT
*
      ETCUT = 0.050
*
*
*
      NJETS = 0
      MAXCEQ = MAXCE*MAXCE
      CALL VZERO(JETS,30)
      CALL VZERO(CELL,MAXCEQ)
C*TC>
C      CALL VZERO(LOCK,MAXCEQ)
      do i=1,MAXCE
       do j=1,maxce
        lock(i,j)=0
       enddo
      enddo
C*TC>
*

      BINETA = 2.*ETALIM/FLOAT(NETA)
      BINPHI = 2.*PI/FLOAT(NPHI)
      NBETA = RJET/BINETA + 1
      NBPHI = RJET/BINPHI + 1
*
*     Fill CELL() here
*==================================================================
*
        NTRK  = NHEP
        ITRK0 = 1
c       write(6,*) NHEP,PHEP(1,1),PHEP(2,1),PHEP(3,1),
c    * PHEP(4,1),PHEP(5,1)
*===================================================================
        COEF=1.
* Is Z axis in the proton direction?
        DO ITRK=1,NHEP
          PZ   = PHEP(3,itrk)
          ICOD = IDHEP(itrk)
          if(ICOD.eq.2212) then
             IF(PZ.lt.0.) COEF=-1.
          endif
        ENDDO

        DO 100 ITRK = ITRK0, NTRK
          PX   = PHEP(1,itrk)
          PY   = PHEP(2,itrk)
          PZ   = PHEP(3,itrk)*COEF
          E    = PHEP(4,itrk)
          AM   = PHEP(5,itrk)
          ICOD = IDHEP(itrk)
          ISTA = ISTHEP(itrk)
c         write(6,*)'PX,PY,PZ,E,AM,ICOD,ISTA=',
c    *    itrk,PX,PY,PZ,E,AM,ICOD,ISTA
*     neutrino
          IF(ICOD.EQ.12 .OR. ICOD.EQ.14 .OR. ICOD.EQ.16) GO TO 100
          IF(ISTA.NE.1) GO TO 100
          PXY= SQRT(PX**2 + PY**2)
          IF(PXY.LT.1.E-8) GO TO 100
          P  = SQRT(PXY**2 + PZ**2)
          IF(ABS(P).LE.1.E-8 ) GO TO 100
          THETA = ACOS (PZ/P )
          IF(THETA.LT.1.E-8) GO TO 100
          IF(ABS(THETA-PI).LT.1.E-6) GO TO 100
          ETA = -ALOG(TAN(THETA/2.))
          IF(ABS(ETA).GT.ETALIM) GOTO 100
          PHI   = ATAN2(PY,PX)
          IF(PHI.LT.0.) PHI = 2 * PI + PHI
          ET = E*SIN(THETA)
          IETA = 1 + INT((ETALIM+ETA)/BINETA)
          IF(IETA.GT.NETA) IETA=NETA
          IPHI = 1 + INT(PHI/BINPHI)
          IF(IPHI.GT.NPHI) IPHI=NPHI
          CELL(IETA,IPHI) = ET + CELL(IETA,IPHI)
100     CONTINUE
*
*====================================================================
*

      IETMAX = NINT(ETMAX)
      IETMIN = NINT(ETMIN)
      IETBIN = NINT(ETBIN)
      NSTEPS=INT((etmax-etmin)/etbin)
      ETMAX0=ETMIN+ETBIN*NSTEPS
*
* Lock cells with Et<Etcut
      do 21 i=1,NETA
       do 22 j=1,nphi
            IF(ABS(CELL(I,J)).LT.ETCUT) LOCK(I,J) = 2
22     continue
21    continue
*
*     loop over Etjet distribution
      DO 80 IETM = 1,nsteps
      ETMIN1=ETMAX0-IETM*ETBIN

*     unlock not used initiator cells
        DO 47 I=1,NETA
          DO 44 J=1,NPHI
            IF(LOCK(I,J).EQ.1)  LOCK(I,J) = 0
44        CONTINUE
47      CONTINUE
*
*          Find a jet initiator
10    CONTINUE


* what is a total Et in unlocked cells?
      etrem=0.
      DO 57 I=1,NETA
         DO 54 J=1,NPHI
            if(LOCK(I,J).NE.2) etrem=etrem+cell(i,j)
54       CONTINUE
57    CONTINUE
*
* if total Et in unlocked cells is smaller than THRESHOULD...
*
        if(etrem.lt.etmin1) go to 80


      ET1 = 0.0
      IET1 = 0
      JET1 = 0
      DO 17 I=1,NETA
        DO 14 J=1,NPHI
          IF(LOCK(I,J).NE.0)     GOTO 14
          IF(CELL(I,J).LT.ETINI) GOTO 14
          IF(ET1.GE.CELL(I,J))   GOTO 14
          ET1 = CELL(I,J)
          IET1 = I
          JET1 = J
 14     CONTINUE
 17   CONTINUE

*
      IF(ET1.LT.ETINI) GOTO 80
      ETAET1 = -ETALIM + BINETA*FLOAT(IET1) - BINETA/2.0
      PHIET1 =           BINPHI*FLOAT(JET1) - BINPHI/2.0
      LOCK(IET1,JET1) = 1
*
*       Collect cells
*
      IMIN = MAX0(1,IET1-NBETA)
      IMAX = MIN0(NETA,IET1+NBETA)
*
      ETJET = 0.
      DO 27 I=IMIN,IMAX
        DO 24 J=1,NPHI
          IF(LOCK(I,J).GT.1) GOTO 24
          ETA = -ETALIM + BINETA*FLOAT(I) - BINETA/2.0
          PHI =           BINPHI*FLOAT(J) - BINPHI/2.0
          DPHI = ABS(PHI-PHIET1)
          IF(DPHI.GT.PI) DPHI = 2.*PI - DPHI
          DR=SQRT((ETA-ETAET1)**2+DPHI**2)
          IF(DR.GT.RJET) GOTO 24
c         write(6,*)' etaet1,phiet1,dr',etaet1,phiet1,dr
          ETJET = ETJET + CELL(I,J)
c         print '(''cell:'',4F6.2)',cell(i,j),eta,phi,etjet
 24     CONTINUE
 27   CONTINUE
*
      IF(ETJET.LT.ETMIN1) GOTO 10
*
*        Correct Eta and Phi
*
      ETAJET = 0.
      PHIJET = 0.
      ETPOS =  0.
      XJET = 0.
      YJET = 0.
*
      DO 37 I=IMIN,IMAX
        ETA = -ETALIM + BINETA*FLOAT(I) - BINETA/2.0
        DO 34 J=1,NPHI
          IF(LOCK(I,J).GT.1)   GOTO 34
          PHI =       BINPHI*FLOAT(J) - BINPHI/2.0
          DPHI = ABS(PHI-PHIET1)
          IF(DPHI.GT.PI) DPHI = 2.*PI - DPHI
          DR=SQRT((ETA-ETAET1)**2+(DPHI)**2)
          IF(DR.GT.RJET) GOTO 34
          LOCK(I,J) = 2
          IF(CELL(I,J).LE.0.0) GOTO 34
c         print '(''cell:'',3F6.2)',cell(i,j),eta,phi
          ETPOS = ETPOS + CELL(I,J)
          ETAJET = ETAJET + ETA*CELL(I,J)
          XJET = XJET + COS(PHI)*CELL(I,J)
          YJET = YJET + SIN(PHI)*CELL(I,J)
c         print '(''jet :'',3F6.2)',etpos,etajet/etpos,atan2(yjet,xjet)
 34     CONTINUE
 37   CONTINUE
      IF(ETPOS.GT.0.0) THEN
        ETAJET = ETAJET/ETPOS
        XJET = XJET / ETPOS
        YJET = YJET / ETPOS
        PHIJET = ATAN2(YJET,XJET)
        IF(PHIJET.LT.0.0) PHIJET = 2.*PI + PHIJET
      ELSE
        PRINT *,' to many negative energy cells ??????'
        GOTO 10
      ENDIF
*

      DPHI = PHIJET-PHIET1
      IF(DPHI.LT.-PI) DPHI = - DPHI- PI*2.
      IF(DPHI.GT.PI)  DPHI = PI*2.- DPHI
      IF(NJETS.LT.10) THEN
        NJETS = NJETS + 1
        JETS(NJETS,1) = ETJET
        JETS(NJETS,2) = ETAJET
        JETS(NJETS,3) = PHIJET
      ELSE
        PRINT *,'to many jets !!!!!??????'
        GOTO 99
      ENDIF
*
      IF(ETJET.GE.ETMIN1) GOTO 10
*
 80   CONTINUE
 99   CONTINUE
      RETURN
      END
*CMZ :  1.01/02 09/04/96  15.43.52  by  Tancredi Carli
*-- Author : Tancredi Carli
      SUBROUTINE JCLUST(EVIS,XJCUT,JMODE,NPI,PI,NP,P)
********************************************************
* Jade algorithmn:                                     *
* Input:                                               *
* EVIS; visible energy                                 *
* XJCUT: Energy fraction xcut=xjcut*w**2               *
* Jmode: 1: m= ENi*ENj*(1-costh)
*        2: m=2*min(ENi**2,ENJ**2)*(1-costh))
* NPI= number of particles to be considered            *
* PI(4,N) particle to be joined                        *
*                                                      *
*                                                      *
********************************************************
      Implicit none
*
      Logical lp
      Data lp/.false./
      Real SM,XCUT,XJCUT,EVIS
      Integer lleng,i,j,l,jmode,nj,iposs,nn
      PARAMETER (SM=1.E-10)
      PARAMETER (LLENG=2000)
C     COMMON/PPLUND/N,NJ,P(5,LLENG),K(5,LLENG)
*
      Real PRMIN,P1,P2,COSTH,PMASS,AJETM2
      Integer mxjet,imin,jmin,npi,np
      PARAMETER (MXJET=95)
      Real PI(4,LLENG),P(5,LLENG)
      Integer IFLAG(LLENG)
*
      LOGICAL LBEGIN
************************************************************************
**********  STEERING PARAMETERS OF   JET FINDING ALGORITHMS ************
************************************************************************
*
*
      DATA LBEGIN/.TRUE./
*
******* THE ONLY ONE PARAMETER FOR THIS ALGORITHM ************
*
      IF (LBEGIN) THEN
 1000 FORMAT(1H1 / 2(' ===============',44X)/2(' |    JCLUST   |',44X)/
     &2(' ===============',44X)//2X,//
     &'  ========THE ONLY PARAMETER OF THIS ALGORITHM =============='//
     &'                         XCUT   =', F11.5//)
      WRITE(6,1000) XJCUT
 1100 FORMAT(77X, '*************'/
     &       ' THE PARAMETERS OF THIS ALGORITHM YOU CAN ',
     &'CHANGE IN THE MAIN PROGRAM UNIT    |  A N A L  |  BY ',
     &'ASIGNIG THE PARAMETERS '/77X, '*************'//)
      WRITE(6,1100)
       LBEGIN = .FALSE.
      ENDIF
*
*  XCUT IS REDEFINED WITH THE HELP OF ENERGY VISIBLE IN THE EVENT
*
      XCUT=XJCUT*EVIS**2
*
      if (lp) then
       write(6,*) ' jmode= ',jmode,' evis= ',evis
       write(6,*) ' xcut= ',xcut,' xjcut= ',xjcut
       write(6,*) ' npi= ',npi
      endif
*
      Do i=1,npi
       IFLAG(i)=1
      enddo
*
      IMIN=0
      JMIN=0
   20 CONTINUE
*
* MAIN LOOP
*
      PRMIN=1.0E20
*
      DO 100 I=1,NPI-1
*
C      if (lp) then
C       write(6,*) i,' pi= ',PI(4,i),PI(1,i),PI(2,i),PI(3,i)
C      endif
*
      IF(IFLAG(I).GT.999) GO TO 100
      DO 200 J=I+1,NPI
      IF(IFLAG(J).GT.999) GO TO 200
*
* CALCULATE INVARIANT MASS-SQUARED AND FIND PAIR WHICH GIVES LOWEST
* 2. FORMULA USED BY JADE; ALL MASSES ARE PIONS
*
      P1=SQRT(PI(1,I)**2+PI(2,I)**2+PI(3,I)**2)
      P2=SQRT(PI(1,J)**2+PI(2,J)**2+PI(3,J)**2)
      COSTH=(PI(1,I)*PI(1,J)+PI(2,I)*PI(2,J)+PI(3,I)*PI(3,J))/(P1*P2)
      IF(JMODE.EQ.1) THEN
       PMASS=2.*PI(4,I)*PI(4,J)*(1.-COSTH)
      ELSEIF(JMODE.EQ.2) THEN
       PMASS=2.0*AMIN1(PI(4,I)**2,PI(4,J)**2)*(1.-COSTH)
      ENDIF
      IF(PMASS.LT.PRMIN) THEN
       PRMIN=PMASS
       IMIN=I
       JMIN=J
      END IF
*
* COUNT PAIRS WHOSE MASS EXCEEDS XCUT
*     IF(PMASS.GT.XCUT) NCLUS=NCLUS+1
*
  200 CONTINUE
  100 CONTINUE
*
* STOP PROCESS IF ALL PAIRS HAVE MASSES WHICH EXCEED XCUT
*
      IF(PRMIN.GT.XCUT) GO TO 500
*
* COMBINE LOWEST MASS PAIR INTO A PSEUDOPARTICLE WITH INDEX OF THE FIRST
* PARTICLE AND FLAG THE SECOND PARTICLE AS DEAD.
*
      IFLAG(IMIN)=IFLAG(IMIN)+IFLAG(JMIN)
      IFLAG(JMIN)=1000
*
      DO 300 L=1,4
      PI(L,IMIN)=PI(L,IMIN)+PI(L,JMIN)
  300 CONTINUE
      GO TO 20
*
  500 CONTINUE
*
* NOW FIND THE JETS: ALL PSEUDOPARTICLES
*
      NP=0
      DO 600 IPOSS=1,NPI
* SKIP DEAD PARTICLES.
      if (lp) then
C       write(6,*) iposs,' pi= ', PI(1,IPOSS),PI(2,IPOSS),
C     &            PI(3,IPOSS),PI(4,IPOSS),' ifl= ',IFLAG(IPOSS)
      endif
      IF(IFLAG(IPOSS).GT.999) GO TO 600
      NP=NP+1
*
      P(1,NP) = PI(1,IPOSS)
      P(2,NP) = PI(2,IPOSS)
      P(3,NP) = PI(3,IPOSS)
      P(4,NP) = PI(4,IPOSS)
*
      AJETM2 = P(4,NP)**2-P(1,NP)**2-P(2,NP)**2-P(3,NP)**2
*     IF(AJETM2.GT.0.) P(5,NP) = SQRT(AJETM2)
      IF(AJETM2.LT.0.)THEN
       P(5,NP)=0.
      ELSE
       P(5,NP)=SQRT(AJETM2)
      ENDIF
*
C      if (lp) then
C       write(6,*) np,' p= ', P(1,np),P(2,np),
C     &                    P(3,np),P(4,np),P(5,np)
C      endif
*
  600 CONTINUE
*
      RETURN
      END
*CMZ :  1.01/08 16/10/97  11.23.17  by  Tancredi Carli
*-- Author :
C $RCSfile: jadejet.f,v $ $Revision: 1.4 $ $Date: 1997/01/09 12:01:44 $
C{{{}}}
C{{{  dist
      FUNCTION dist(A,I,B,J,IDIS)
C{{{  description
CN  dist -- subroutine for jadejet
CS  NOT FOR EXTERNAL CALLING, v = dist (a,i,b,j,idis)
CA  Thomas Hadig
CT  $Date: 1997/01/09 12:01:44 $
CV  $Revision: 1.4 $
CF  $RCSfile: jadejet.f,v $
CI. a(4,*) -- array 1
CI. i -- index of array 1
CI. b(4,*) -- array 2
CI. j -- index of array 2
CI. idis -- distance measure (1 : JADE, 2 : E,P,E0)
CO. dist -- distance between two particles
CP  No options available
CB  No bugs known
CD  dist -- calculates the distance between  the particles i of array a
CD+ and j of array b using the distance measure defined by idis.
C*
C}}}

      IMPLICIT NONE
      DOUBLE PRECISION A(4,*),B(4,*)
      INTEGER I,J,IDIS
C 1 : JADE .... 2 Ei Ej ( 1- cos (theta_ij))
C 2 : E,P,E0 .. (p_i + p_j)^2

      DOUBLE PRECISION dist

      DOUBLE PRECISION AP2,VP2
      DOUBLE PRECISION C(4)

      IF (IDIS.eq.1) THEN
        IF ((AP2(A,I).lt.1d-10).or.(AP2(B,J).lt.1d-10)) THEN
          dist=0d0
        ELSE
          dist = 2D0 * A(4,I) * B(4,J) * (1D0 -
     +     (A(1,I)*B(1,J) + A(2,I)*B(2,J) + A(3,I)*B(3,J)) /
     +      sqrt(AP2(A,I)*AP2(B,J)) )
        ENDIF
      ELSEIF (IDIS.eq.2) THEN
        C(1)=A(1,I)+B(1,J)
        C(2)=A(2,I)+B(2,J)
        C(3)=A(3,I)+B(3,J)
        C(4)=A(4,I)+B(4,J)
        dist = C(4)*C(4)-VP2(C)
      ELSE
        WRITE (*,*) 'DIST: unknown distance scheme'
        STOP
      ENDIF

      RETURN
      END
*CMZ :  1.01/07 02/10/97  12eV#_f-g
*-- Author :
C}}}
C{{{  jade
      SUBROUTINE JADEJET(P,NPA,YCUT,SCALE,IDIS,IRECOM,NUM,V)
C{{{  description
CN  jadejet -- jade jet algorithm
CS  call jadejet(p,npa,ycut,scale,idis,irecom,num*,v*)
CA  Thomas Hadig
CT  $Date: 1997/01/09 12:01:44 $
CV  $Revision: 1.4 $
CF  $RCSfile: jadejet.f,v $
CI. P(4,*) -- array of input vectors
CI. NPA -- number of input vectors
CI. YCUT -- cut value for second step
CI. SCALE -- value used to scale kt (Q**2)
CI. IDIS -- distance measure ( 1: JADE, 2 : E,P,E0)
CI. IRECOM -- recombination scheme (1 : E/JADE, 2 : E0, 3 : P)
CO. NUM -- number of jets
CO. V -- array of jets
CP  No options available
CB  No bugs known
CD  jadejet -- calculates the number of jets and the jet vectors for the
CD+ jade algorithm.
C}}}

      IMPLICIT NONE

      DOUBLE PRECISION P(4,*),V(4,*),YCUT,SCALE
      INTEGER NUM,NPA,IRECOM,IDIS

      double precision yij,mat(4,4)
      integer i,j,k,l

      double precision dist

C{{{  copy all particles
      do i=1,NPA
        call dvcopy(P,i,V,i)
      enddo
      NUM=NPA
C}}}
100   continue
C{{{  get all yij, and lowest yij
      yij=1D100
      do i=1,NUM
        do j=1,i-1
          mat(i,j)=dist(V,i,V,j,IDIS)
          if (mat(i,j).lt.yij) then
            yij=mat(i,j)
            k=i
            l=j
          endif
        enddo
      enddo
C}}}
C{{{  stop or go on ?
      if (yij.gt.SCALE*YCUT) goto 101
      if (k.le.l) then
        write (*,*) 'kt : internal error'
        stop
      endif
C add k+l -> l
      call dvadd(V,k,V,l,IRECOM)
C remove k from list
102   continue
      if (k.lt.NUM) then
        call dvcopy (V,k+1,V,k)
        k=k+1
        goto 102
      endif
      NUM=NUM-1
      goto 100
C}}}

101   continue
      RETURN
      END
*CMZ :  1.01/07 02/10/97  12+u~l4e>QL
*-- Author :
C}}}
c----------------------------------------
C{{{  vcopy
      SUBROUTINE dvcopy(A,I,B,J)
C{{{  description
CN  vcopy -- copy a vector
CS  call dvcopy (a,i,b,j)
CA  Thomas Hadig
CT  $Date: 1996/11/29 09:33:38 $
CV  $Revision: 1.3 $
CF  $RCSfile: support.f,v $
CI. A(4,*) -- array 1
CI. I -- index for array 1
CI. B(4,*) -- array 2
CI. J -- index for array 2
CO. None
CP  No options available
CB  No bugs known
CD  dvcopy -- copies vector i of array a to vector j of array b
C*
C}}}

      IMPLICIT NONE

      DOUBLE PRECISION A(4,*),B(4,*)
      INTEGER I,J

      B(1,J)=A(1,I)
      B(2,J)=A(2,I)
      B(3,J)=A(3,I)
      B(4,J)=A(4,I)
      RETURN
      END
*CMZ :  1.01/15 12/08/98  19.34.23  by  Tancredi Carli
*-- Author :
C}}}
c---------- -----------------------------------------
C{{{  vadd
      SUBROUTINE dvadd(A,I,B,J,IRECOM)
C{{{  description
CN  vadd -- add two vectors
CS  call vadd (a,i,b,j,IRECOM)
CA  Thomas Hadig
CT  $Date: 1996/11/29 09:33:38 $
CV  $Revision: 1.3 $
CF  $RCSfile: support.f,v $
CI. A(4,*) -- array 1
CI. I -- index for array 1
CI. B(4,*) -- array 2
CI. J -- index for array 2
CI. IRECOM -- recombination scheme (1 : E/JADE, 2 : E0, 3 : P)
CO. None
CP  No options available
CB  No bugs known
CD  vadd -- adds vector j of array b to vector i of array a (result is in
CD+ vector i of array a). You can use the
CD+ irecom -- input to select a recombination scheme.
C*
C}}}

      IMPLICIT NONE
      DOUBLE PRECISION A(4,*),B(4,*)
      INTEGER I,J,IRECOM
C IRECOM : recombination scheme
C  1 : E/JADE .... 4-vector addition, not massless
C  2 : E0 ........ momentum rescaling, massless
C  3 : P ......... energy rescaling, massless

      DOUBLE PRECISION AP2
      DOUBLE PRECISION FAC

      B(1,J)=A(1,I)+B(1,J)
      B(2,J)=A(2,I)+B(2,J)
      B(3,J)=A(3,I)+B(3,J)
      B(4,J)=A(4,I)+B(4,J)
      IF (IRECOM.eq.1) THEN
        CONTINUE
      ELSEIF (IRECOM.eq.2) THEN
        FAC=SQRT(AP2(B,J))/B(4,J)
        B(1,J)=B(1,J)*FAC
        B(2,J)=B(2,J)*FAC
        B(3,J)=B(3,J)*FAC
      ELSEIF (IRECOM.eq.3) THEN
        B(4,J)=SQRT(AP2(B,J))
      ELSE
        WRITE (*,*) 'VADD: unknown scheme'
        STOP
      ENDIF
      RETURN
      END
*CMZ :  1.01/07 02/10/97  12ppf;D!1>cx*8Dm
*-- Author :
C}}}
c----------------------------------------
C{{{  vp2
      FUNCTION VP2 (P)
C{{{  description
CN  vp2 -- calculates the squared momentum of a vector
CS  v = vp2 (p)
CA  Thomas Hadig
CT  $Date: 1996/11/29 09:33:38 $
CV  $Revision: 1.3 $
CF  $RCSfile: support.f,v $
CI. P(4) -- vector
CO. vp2 -- squared momentum of a vector
CP  No options available
CB  No bugs known
CD  vp2 -- calculates the squared momentum of a vector
C*
C}}}

      IMPLICIT NONE

      DOUBLE PRECISION VP2

      DOUBLE PRECISION P(4)

      VP2 = P(1)**2 + P(2)**2 + P(3)**2
      RETURN
      END
*CMZ :  1.01/15 12/08/98  19.35.19  by  Tancredi Carli
*-- Author :
C}}}
C----------------------------------------
C{{{  ap2
      FUNCTION AP2 (P,I)
C{{{  description
CN  ap2 -- calculates the squared momentum of a vector
CS  v = ap2 (p,i)
CA  Thomas Hadig
CT  $Date: 1996/11/29 09:33:38 $
CV  $Revision: 1.3 $
CF  $RCSfile: support.f,v $
CI. P(4,*) -- array of vectors
CI. I -- index of vector
CO. ap2 -- squared momentum of a vector
CP  No options available
CB  No bugs known
CD  ap2 -- calculates the squared momentum of a vector
C*
C}}}

      IMPLICIT NONE

      DOUBLE PRECISION AP2

      DOUBLE PRECISION P(4,*)
      INTEGER          I

      AP2 = P(1,I)**2 + P(2,I)**2 + P(3,I)**2
      RETURN
      END
*CMZ :  1.01/13 13/02/98  16.11.24  by  Tancredi Carli
*-- Author :    J.Kurzhoefer 19/07/93
*
      SUBROUTINE H1QGCONE(RAPMAX,NRAPB,NAZMB,ETMIN,ETSMIN,RJET,
     +                  NJETS,AJETS)
C---------------------------------------------------------------------
C     Cone algorithm using a pseudorapidity and phi grid. The sequence
C     of jet building is determined by the pt of the jet.
C---------------------------------------------------------------------

      PARAMETER (MAXCE=110,MAXJET=10,MAXJTMP=10000)
      REAL CELL(MAXCE,MAXCE),JETPT(MAXJTMP)
      REAL QQPI,QQ2PI
      PARAMETER (QQPI=3.141593, QQ2PI=QQPI*2.)
      INTEGER LOCK(MAXCE,MAXCE),JETCELL(MAXJTMP,2),INDEX(MAXJTMP)
      REAL AJETS(MAXJET,3)
      PARAMETER (SMALL=1.E-20)

*KEEP,HEPEVTP.
*
* HEP event prime common
* (for explanation see manual)
      Integer NMXHEP
      PARAMETER (NMXHEP=2000)
      Integer NEVHEP,NHEP,ISTHEP,IDHEP
      Integer JMOHEP,JDAHEP
      Double Precision PHEP,VHEP
      COMMON/HEPEVTP/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     & JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
*
*KEND.

      NJETS = 0
      JETCAND = 0
C Control some input parameters
      IF(NRAPB.GT.MAXCE) THEN
         PRINT *,'H1QGCONE: TOO MANY ETA CELLS'
         GOTO 99
      ENDIF
      IF(NAZMB.GT.MAXCE) THEN
         PRINT *,'H1QGCONE: TOO MANY PHI CELLS'
         GOTO 99
      ENDIF
C Initialize some arrays
      MAXCEQ = MAXCE*MAXCE

      CALL VZERO(CELL,MAXCEQ)
      CALL VZERO(JETPT,MAXJTMP)
      CALL VZERO(AJETS,3*MAXJET)
      DO 3 I=1,MAXCE
         DO 5 J=1,MAXCE
            LOCK(I,J) = 0
 5       CONTINUE
 3    CONTINUE

*
      BINETA = 2.*RAPMAX/FLOAT(NRAPB)
      BINPHI = 2.*QQPI/FLOAT(NAZMB)
      NBETA = RJET/BINETA + 1
      NBPHI = RJET/BINPHI + 1
*
*     Fill the cell grid here
*==================================================================
*
        COEF=1.
* Is Z axis in the proton direction?
        DO I=1,NHEP
          PZ   = PHEP(3,I)
          ICOD = IDHEP(I)
          IF (ICOD.EQ.2212) then
            IF (PZ.LT.0.) COEF=-1.
          END IF
        ENDDO
*
      DO 10 I=1,NHEP
         X  = PHEP(1,I)
         Y  = PHEP(2,I)
         Z  = PHEP(3,I)*COEF
         E  = PHEP(4,I)
	 ISTA = ISTHEP(I)
	 IF(ISTA.NE.1) GO TO 10
         PT = SQRT(X**2+Y**2)
         IF(PT.LE.SMALL) GOTO 10
         ETA=SIGN(LOG((SQRT(PT**2+Z**2)
     *                +ABS(Z))/PT),Z)
         IF(ABS(ETA).GT.RAPMAX) THEN
            GOTO 10
         ENDIF
         PHI = ATAN2(Y,X)
         IF(PHI.LT.0.) PHI = QQ2PI + PHI
         IETA = MIN(NRAPB,1 + INT((RAPMAX+ETA)/BINETA))
         IPHI = MIN(NAZMB,1 + INT(PHI/BINPHI))
         CELL(IETA,IPHI) = SIGN(1.0,E)*PT + CELL(IETA,IPHI)
 10   CONTINUE
*
****************************************************************
*
C     loop over all cells
*
      ET1 = 0.0
      IET1 = 0
      JET1 = 0
      DO 60 ICELL=1,NRAPB
         DO 70 JCELL=1,NAZMB
            IF(CELL(ICELL,JCELL).LT.ETMIN) GOTO 70
C If the cell can be used as a jet initiator, build the jet
            ET1 = CELL(ICELL,JCELL)
            IET1 = ICELL
            JET1 = JCELL
            ETAET1 = -RAPMAX + BINETA*FLOAT(IET1) - BINETA/2.0
            PHIET1 =           BINPHI*FLOAT(JET1) - BINPHI/2.0

*
*     Collect cells
*
            IMIN = MAX0(1,IET1-NBETA)
            IMAX = MIN0(NRAPB,IET1+NBETA)
*
            ETJET = 0.
            DO 80 II=IMIN,IMAX
               DO 90 JJ=1,NAZMB
                  IF(CELL(II,JJ).EQ.0.) GOTO 90
                  ETA = -RAPMAX + BINETA*FLOAT(II) - BINETA/2.0
                  PHI =           BINPHI*FLOAT(JJ) - BINPHI/2.0
                  DPHI = ABS(PHI-PHIET1)
                  IF(DPHI.GT.QQPI) DPHI = QQ2PI - DPHI
                  DR=SQRT((ETA-ETAET1)**2+DPHI**2)
                  IF(DR.GT.RJET) GOTO 90
                  ETJET = ETJET + CELL(II,JJ)
 90            CONTINUE
 80         CONTINUE
*
C If the PT of the jet is above ETSMIN, store jet parameter
            IF (ETJET.LT.ETSMIN) GOTO 70
            JETCAND=JETCAND+1
            IF (JETCAND.GT.MAXJTMP) THEN
               JETCAND=JETCAND-1
               PRINT *,'H1QGCONE: TOO MANY TEMPORARY JETS'
            ENDIF
            JETPT(JETCAND)=ETJET
            JETCELL(JETCAND,1)=IET1
            JETCELL(JETCAND,2)=JET1
 70      CONTINUE
 60   CONTINUE
*
C  If no jet was found the work is done
      IF (JETCAND.EQ.0) GOTO 99

C Sort the jet candidates using CERNLIB ROUTINE M101
      CALL SORTZV(JETPT,INDEX,JETCAND,1,0,0)

C Build the jet with the highest pt
 150  ETJET = JETPT(INDEX(JETCAND))
      IET1 = JETCELL(INDEX(JETCAND),1)
      JET1 = JETCELL(INDEX(JETCAND),2)

      ETAET1 = -RAPMAX + BINETA*FLOAT(IET1) - BINETA/2.0
      PHIET1 =           BINPHI*FLOAT(JET1) - BINPHI/2.0

      IMIN = MAX0(1,IET1-NBETA)
      IMAX = MIN0(NRAPB,IET1+NBETA)

*        Correct Eta and Phi
*
         ETAJET = 0.
         PHIJET = 0.
         ETJETD = 0.
*
         DO 100 I=IMIN,IMAX
            ETA = -RAPMAX + BINETA*FLOAT(I) - BINETA/2.0
            DO 110 J=1,NAZMB
               IF (CELL(I,J).EQ.0.) GOTO 110
               IF (LOCK(I,J).GT.1)   GOTO 110
               PHI =       BINPHI*FLOAT(J) - BINPHI/2.0
               DPHI = PHI-PHIET1
               IF(ABS(DPHI).GT.QQPI) DPHI = DPHI-SIGN(QQ2PI,DPHI)
               DR=SQRT((ETA-ETAET1)**2+(DPHI)**2)
               IF(DR.GT.RJET) GOTO 110
               LOCK(I,J) = 2
               ETAJET = ETAJET + ETA *MAX(0.,CELL(I,J))
               PHIJET = PHIJET + DPHI*MAX(0.,CELL(I,J))
               ETJETD = ETJETD +      MAX(0.,CELL(I,J))
 110        CONTINUE
 100     CONTINUE

         ETAJET = ETAJET / ETJETD
         PHIJET = PHIJET / ETJETD + PHIET1
         IF (PHIJET.GT.QQ2PI) PHIJET = PHIJET - QQ2PI
         IF (PHIJET.LT.0.) PHIJET = PHIJET + QQ2PI
*
         IF (NJETS.LT.MAXJET) THEN
            NJETS = NJETS + 1
            AJETS(NJETS,1) = ETJET
            AJETS(NJETS,2) = ETAJET
            AJETS(NJETS,3) = PHIJET
         ELSE
            PRINT *,'H1QGCONE: too many jets !'
            GOTO 99
         ENDIF
*
* One jet built means one jet candidates less
         JETCAND = JETCAND - 1
         IF (JETCAND.EQ.0) GOTO 200

C There are still jets left, so recalculate the next jet

 160     IET1 = JETCELL(INDEX(JETCAND),1)
         JET1 = JETCELL(INDEX(JETCAND),2)

         ETAET1 = -RAPMAX + BINETA*FLOAT(IET1) - BINETA/2.0
         PHIET1 =           BINPHI*FLOAT(JET1) - BINPHI/2.0

         IMIN = MAX0(1,IET1-NBETA)
         IMAX = MIN0(NRAPB,IET1+NBETA)

         ETJET = 0.
         DO 130 II=IMIN,IMAX
            DO 140 JJ=1,NAZMB
C Don't use already used cells for new jets
               IF (LOCK(II,JJ).EQ.2) GOTO 140
               IF(CELL(II,JJ).EQ.0.) GOTO 140
               ETA = -RAPMAX + BINETA*FLOAT(II) - BINETA/2.0
               PHI =           BINPHI*FLOAT(JJ) - BINPHI/2.0
               DPHI = ABS(PHI-PHIET1)
               IF(DPHI.GT.QQPI) DPHI = QQ2PI - DPHI
               DR=SQRT((ETA-ETAET1)**2+DPHI**2)
               IF(DR.GT.RJET) GOTO 140
               ETJET = ETJET + CELL(II,JJ)
 140        CONTINUE
 130     CONTINUE
         JETPT(INDEX(JETCAND)) = ETJET

* Now there are several cases
C Only one jet is left and its pt is above ETSMIN => build jet
        IF ((ETJET.GT.ETSMIN).AND.(JETCAND.EQ.1)) GOTO 150
C Only one jet is left and its pt is below ETSMIN => work done
        IF (JETCAND.EQ.1) GOTO 200
C The coreccted jet is below ETSMIN => recalculate the next one
C and forget this one.
        IF (ETJET.LT.ETSMIN) THEN
           JETCAND=JETCAND-1
           GOTO 160
        ENDIF
C The recalculated pt of the jet is still higher than the
C original pt of the next lower pt jet => build jet
        IF (ETJET.GT.JETPT(INDEX(JETCAND-1))) GOTO 150
C Else recalculate also all remaining jets
        NEWJET=0
        DO 170 III=1,JETCAND-1
         IET1 = JETCELL(INDEX(III),1)
         JET1 = JETCELL(INDEX(III),2)

         ETAET1 = -RAPMAX + BINETA*FLOAT(IET1) - BINETA/2.0
         PHIET1 =           BINPHI*FLOAT(JET1) - BINPHI/2.0

         IMIN = MAX0(1,IET1-NBETA)
         IMAX = MIN0(NRAPB,IET1+NBETA)

         ETJET = 0.
         DO 180 II=IMIN,IMAX
            DO 190 JJ=1,NAZMB
               IF(CELL(II,JJ).EQ.0.) GOTO 190
C Don't use already used cells for new jets
               IF (LOCK(II,JJ).EQ.2) GOTO 190
               ETA = -RAPMAX + BINETA*FLOAT(II) - BINETA/2.0
               PHI =           BINPHI*FLOAT(JJ) - BINPHI/2.0
               DPHI = ABS(PHI-PHIET1)
               IF(DPHI.GT.QQPI) DPHI = QQ2PI - DPHI
               DR=SQRT((ETA-ETAET1)**2+DPHI**2)
               IF(DR.GT.RJET) GOTO 190
               ETJET = ETJET + CELL(II,JJ)
 190        CONTINUE
 180     CONTINUE

C If the PT of the jet is above ETSMIN, store jet parameter
         IF (ETJET.GT.ETSMIN) THEN
            NEWJET=NEWJET+1
            JETPT(INDEX(NEWJET))=ETJET
            JETCELL(INDEX(NEWJET),1)=IET1
            JETCELL(INDEX(NEWJET),2)=JET1
         ENDIF
 170  CONTINUE
C     If due to the used cell one jet is now below ETSMIN, the jet is
c     deleted. At the end the last jet that was calculated before has
c     to be appended at the end of the actual jet list.
      IF (NEWJET.NE.JETCAND-1) THEN
         NEWJET = NEWJET+1
         JETPT(INDEX(NEWJET)) = JETPT(INDEX(JETCAND))
         JETCELL(INDEX(NEWJET),1) = JETCELL(INDEX(JETCAND),1)
         JETCELL(INDEX(NEWJET),2) = JETCELL(INDEX(JETCAND),2)
         JETCAND=NEWJET
      ENDIF
C     Sort again and then start building the jet with the highest pt
      CALL SORTZV(JETPT,INDEX,JETCAND,1,0,1)
      GOTO 150

* At this point all jets are built (deleted the rest for HZTOOL version)
 200  CONTINUE
 99   CONTINUE
      RETURN
      END
*CMZ :  2.00/00 13/08/99  17.13.07  by  Tancredi Carli
*CMZ :  1.01/15 04/06/98
*-- Author :
      SubRoutine CFilpagp (icellpa,Err)
      Implicit None
C
C *********************************************************
C
C PURPOSE:       Fill CluCom from Caltru for the CDF algorithm.
C CALLED FROM:   CCCOFL
C COMMUNICATION:
C AUTHOR:        Paul de Jong, NIKHEF-H, 08-01-1992.
C *********************************************************
C --DATE--:--NAME--:--MODIFICATIONS------------------------
c 17.3.93 :  G.C.  : hadrons in HCM
C *********************************************************
C
*
* .. Calorimeter common with data card keys.
*
      Logical Lccdb(6), Lccal, Lcclu(4), Lolddata, Lsamp(6), Lnob, Lnos
      Logical First_of_all, First_physics, New_Run, New_Run_Physics
      Logical Test_Trigger, Run_Corrupt, NOC5, UNOGAF, UNOBOR, BADBOR,
     +        BADGAF
      Real    Rcslf(10), Rcslb(10), Rcslr(10), Rcslg(10), Aimpar(25),
     +        Jadepar(20), Cdfpar(20), Condspar(10), Canpar(10),
     +        Rzscut(5),Timecut(2)
      Integer Icana, Iclhi, Icldb(4), Iescale
      Character*12 Object_Type
*
      COMMON / CKey / Lccdb, Lccal, Lcclu, Lolddata, Lsamp,
     +          Lnob, Lnos, First_of_all, First_physics, New_Run,
     +          New_Run_Physics, Test_Trigger, Run_Corrupt, NOC5,
     +          UNOGAF, UNOBOR, BADGAF, BADBOR,
     +          Rcslf, Rcslb, Rcslr,
     +          Rcslg, Aimpar, Jadepar, Cdfpar, Condspar, Canpar,
     +          Rzscut, Timecut,Icana, Iclhi, Icldb, Iescale,
     +          Object_Type
C
*
* .. Calorimeter common for CluClu steering parameters.
*
      Integer Ndis,Nscale,Nmass,Nelecspec,Nrecomb,Nmcalc,Ibeamp
      Real    Djoinpt,Yjoinwinv,Dinit,Converg,Emcccut,Hacccut,Emcpcut,
     ,        Hacpcut,Emclcut,Haclcut,Djoinmass,Yjoinevis
*
      Common/CluPar/Ndis,Nscale,Nmass,Nelecspec,Nrecomb,Nmcalc,
     ,              Djoinpt,Yjoinwinv,Dinit,Converg,Emcccut,
     ,              Hacccut,Emcpcut,Hacpcut,Emclcut,Haclcut,
     ,              Djoinmass,Yjoinevis,Ibeamp
C.
*
* .. Calorimeter common for cluster finding a la LuClus (CluClu).
*
      Integer Nsblock, Npart
      Parameter (Nsblock = 4000)
      Integer KC(Nsblock,5)
      Real    PC(Nsblock,5), VC(Nsblock,5)
*
      COMMON/CluCom/Npart,KC,PC,VC
C.
      INTEGER CPsPar,CPsPar_9999
      INTEGER CPsPar_ID
      CHARACTER*4 CPsPar_Type
      REAL CPsPar_E,CPsPar_Px,CPsPar_Py,CPsPar_Pz

      COMMON/CPsPar/CPsPar,CPsPar_ID,CPsPar_Type,CPsPar_E,CPsPar_Px,
     +   CPsPar_Py,CPsPar_Pz,CPsPar_9999

C
C .. Calorimeter common for special treatment of electron in jet finding.
C
      Integer Ifound
C
      Common/Cfound/Ifound
C.
C
C .. Common block for the CDF-like jet algorithm.
C
      Integer Nseed, Nnoseed, MaxIter, Imode
      Real EtSeedcut,EtSneedcut,RadPC,Radius,Frac,ESeedcut,ESneedcut
C
      Common /CDFCom/ EtSeedcut,EtSneedcut,RadPC,Radius,MaxIter,Frac,
     ,                Imode,Nseed,Nnoseed,ESeedcut,ESneedcut
C.
*
*.. Parameter specifications for logical unit numbers
*
        Integer Lp, Lgeom, Lout, Lin, Lcards, LHBook, Lanal, Lpdst
        integer Levtsum
        Parameter (Lp=6)
        Parameter (Lgeom=8)
        Parameter (Lout=9)
        Parameter (Lcards=7)
        Parameter (LHBook=51)
        Parameter (Levtsum=52)
        Parameter (Lpdst=6)
        Parameter (Lanal=88)
       real PucellP
       COMMON/MORSUB/PUCELLP(10,1000)
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c   1 = electron                                              c
c   2 = proton                                                c
c   3 = final electron                                        c
c   4 = photon/Z0                                             c
c   5 = Proton + photon                                       c
c  13 = Photon/Z0 in Hadronic System                          c
c  14 = Proton in Hadronic System                             c
c  15 = electron in Hadronic System                           c
c  16 = scattered electron in Hadronic System                 c
c  101-nch = hadrons in LAB                                   c
c  101+nch-2*nch = hadrons in Hadronic System                 c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
C
      INTEGER I, J, Err, Ielc, Ipart, Idum
      REAL Phi,X,Y,Z,R,Et,E
      LOGICAL ERROR, First
      real eta,pi
      integer ievj,iend
      Data First /.TRUE./
      Data ievj/49/
      integer icellpa,maxcell
C
C
      pi=4.*atan(1.)
C
      Err=0
      Do 25 J=1,5
         Do 10 I=1,Nsblock
            KC(I,J)=0
            VC(I,J)=0.
            PC(I,J)=0.
10    Continue
25    Continue
c
C
C Loop over all hit cells.
C
       ievj=ievj+1
       Npart=0
       Nseed=0
       Nnoseed=0
c---------------
      Do 200 I=1,icellpa
c         maxcell=100+icellpa
          maxcell=100
C----------------
         E   = pucellp(4,i+maxcell)
         ETA = pucellp(6,i+maxcell)
         Et  = pucellp(7,i+maxcell)
         PHI = pucellp(8,i+maxcell)

         if(E.gt.1000.) goto 200
         If (Imode.EQ.1) Then
            If (Et.LT.EtSneedcut) GoTo 200
         Else if (Imode.EQ.2) Then
            If (E.LT.ESneedcut) GoTo 200
         Endif
         Ipart=0
         If (Npart.EQ.0) Then
            Ipart=1
            GoTo 400
         Endif
         Do 300 J=1,Npart
            If (Imode.EQ.1) Then
               If (PC(J,3).GT.Et) GoTo 300
            Else if (Imode.EQ.2) Then
               If (PC(J,4).GT.E) GoTo 300
            Endif
            Ipart=J
            GoTo 301
  300    Continue
  301    If (Ipart.EQ.0) Ipart=Npart+1
         Do 500 J=Npart,Ipart,-1
            PC(J+1,1)=PC(J,1)
            PC(J+1,2)=PC(J,2)
            PC(J+1,3)=PC(J,3)
            PC(J+1,4)=PC(J,4)
            PC(J+1,5)=PC(J,5)
            KC(J+1,1)=KC(J,1)
            KC(J+1,2)=KC(J,2)
            VC(J+1,5)=VC(J,5)
  500    Continue
  400    PC(Ipart,1)=eta
         PC(Ipart,2)=Phi
         PC(Ipart,3)=ET
         PC(Ipart,4)=E
         PC(Ipart,5)=0.
         KC(Ipart,1)=0
         VC(Ipart,5)=i
         Npart=Npart+1
         If (Imode.EQ.1) Then
         If (PC(Ipart,3).GT.EtSeedcut) Then
            KC(Ipart,2)=2
            Nseed=Nseed+1
         Else if (PC(Ipart,3).GT.EtSNeedcut) Then
            KC(Ipart,2)=0
            Nnoseed=Nnoseed+1
         Else
            KC(Ipart,2)=0
         Endif
         Else if (Imode.EQ.2) Then
         If (PC(Ipart,4).GT.ESeedcut) Then
            KC(Ipart,2)=2
            Nseed=Nseed+1
          Else if (PC(Ipart,4).GT.ESNeedcut) Then
            KC(Ipart,2)=0
            Nnoseed=Nnoseed+1
         Else
            KC(Ipart,2)=0
         Endif
         Endif
  200 Continue

c
      RETURN
      END
*CMZ :  2.00/00 13/08/99  17.13.41  by  Tancredi Carli
*CMZ :  1.01/15 04/06/98  2
*-- Author :
      SubRoutine CluHad (Nrjet, IErr)
      Implicit None
C
C ************************************************************************
C
C PURPOSE:       To subdivide the hit calorimeter cells into jets/clusters.
C                CDF-like algorithm.
C CALLED FROM:   CccOfl
C COMMUNICATION: Common blocks CluCom, CDFCom and CluPar
C AUTHOR:        Paul de Jong, NIKHEF-H, 08-01-92
C ************************************************************************
C --DATE--:--NAME--:--MODIFICATIONS---------------------------------------
C
C ************************************************************************
C
C ... Physical constant specifications
        Real
     +    PiBy2,  Pi,  TwoPi, SoL, SoLcmns
        PARAMETER (PiBy2    = 1.570796)
        PARAMETER (Pi       = 3.141593)
        PARAMETER (TwoPi    = 6.283185)
        PARAMETER (SoL      = 299792458.)
        PARAMETER (SoLcmns  = 29.9792458)
        Double Precision
     +    DPiBy2, DPi, DTwoPi, DSoL, DSoLcmns
        PARAMETER (DPiBy2   = 1.570796D0)
        PARAMETER (DPi      = 3.141593D0)
        PARAMETER (DTwoPi   = 6.283185D0)
        PARAMETER (DSoL     = 299792458.D0)
        PARAMETER (DSoLcmns = 29.9792458D0)
C
*
* .. Calorimeter common for cluster finding a la LuClus (CluClu).
*
      Integer Nsblock, Npart
      Parameter (Nsblock = 4000)
      Integer KC(Nsblock,5)
      Real    PC(Nsblock,5), VC(Nsblock,5)
*
      COMMON/CluCom/Npart,KC,PC,VC
C.
*
* .. Calorimeter common for CluClu steering parameters.
*
      Integer Ndis,Nscale,Nmass,Nelecspec,Nrecomb,Nmcalc,Ibeamp
      Real    Djoinpt,Yjoinwinv,Dinit,Converg,Emcccut,Hacccut,Emcpcut,
     ,        Hacpcut,Emclcut,Haclcut,Djoinmass,Yjoinevis
*
      Common/CluPar/Ndis,Nscale,Nmass,Nelecspec,Nrecomb,Nmcalc,
     ,              Djoinpt,Yjoinwinv,Dinit,Converg,Emcccut,
     ,              Hacccut,Emcpcut,Hacpcut,Emclcut,Haclcut,
     ,              Djoinmass,Yjoinevis,Ibeamp
C.
C
C .. Common block for the CDF-like jet algorithm.
C
      Integer Nseed, Nnoseed, MaxIter, Imode
      Real EtSeedcut,EtSneedcut,RadPC,Radius,Frac,ESeedcut,ESneedcut
C
      Common /CDFCom/ EtSeedcut,EtSneedcut,RadPC,Radius,MaxIter,Frac,
     ,                Imode,Nseed,Nnoseed,ESeedcut,ESneedcut
C.
*
*.. Parameter specifications for logical unit numbers
*
        Integer Lp, Lgeom, Lout, Lin, Lcards, LHBook, Lanal, Lpdst
        integer Levtsum
        Parameter (Lp=6)
        Parameter (Lgeom=8)
        Parameter (Lout=9)
        Parameter (Lcards=7)
        Parameter (LHBook=51)
        Parameter (Levtsum=52)
        Parameter (Lpdst=6)
        Parameter (Lanal=88)
*
*.. Common to handle the Units specified by Adamo
*
        Common/ ZRUNIT / Lin
*
* .. Calorimeter common for CluClu output parameters.
*
      Integer Nfirst,Nused,Nprec
      Real    Winv,Tgen,Dmin
*
      Common/CluOut/Nfirst,Nused,Nprec,Winv,Tgen,Dmin
C.
C
      Integer K,L,M,Ncel,Iteration
      Real Deta,Deta1,Deta2,Dphi,Dphi1,Dphi2,Dist1,Dist2,SumE,SumEt,
     ,     SumEta,SumPhi,Phimax,Phimin,TPhi,Eoverlap
      Integer IErr,Nrjet,I,J,I1,I2,ITRY1,ITRY2,IREC,IDEL,IORI,IEMP
      REAL PS(5),PSS,RINIT,R2T,R2M,R2J,R2,R2MAX,R2MIN,PEMAX,
     ,     PSJT,TSAV,R2ACC,PMAX,EVISIB
      Integer NSAV,NP,NPRE,NREM,NJET,IJET,ISPL,IMIN1,IMIN2,NLOOP
      Integer NEDIT,IMAX,IMIN,INEW,ITRY
      Real Type,PiMass,Charge,Life,Ub(10)
      Integer Nwb, Name(5), Idum, Icjet, Icjet1, Icjet2
      Logical First, Ready
      Data First /.TRUE./
C
      IErr=0
C
C Loop over the seed cells and arrange them in preclusters.
C
      Ijet=0
      Do 100 I=1,Nseed
         If (KC(I,2).NE.2) GoTo 100
         Ijet=Ijet+1
         KC(I,1)=Ijet
         KC(I,2)=0
         Do 110 J=I+1,Nseed
            If (KC(J,2).NE.2) GoTo 110
            Deta=Abs(PC(I,1)-PC(J,1))
            Dphi=Abs(PC(I,2)-PC(J,2))
            If (Dphi.GT.Pi) Dphi=Twopi-Dphi
            If (Sqrt(Deta**2+Dphi**2).LE.RadPC) Then
               KC(J,1)=KC(I,1)
               KC(J,2)=0
            Endif
  110    Continue
  100 Continue
C
C Check for safety margin
C
      If ((Npart+2*Ijet).GT.Nsblock) Then
         Write(Lp,1001)
 1001    Format(' CluHad: Overflow in common block!')
         IErr=5
         GoTo 999
      Endif
C
C Calculate the centres of the preclusters from the contributing cells
C
      Do 120 I=1,Ijet
         SumE=0.
         SumEt=0.
         Sumeta=0.
         Sumphi=0.
         Ncel=0
         Phimax=0.
         Phimin=Twopi
         Do 130 J=1,Nseed
            If (KC(J,1).EQ.I) Then
               SumE=SumE+PC(J,4)
               SumEt=SumEt+PC(J,3)
               If (Imode.EQ.1) Then
                  Sumeta=Sumeta+PC(J,1)*PC(J,3)
                  Sumphi=Sumphi+PC(J,2)*PC(J,3)
               Else if (Imode.EQ.2) Then
                  Sumeta=Sumeta+PC(J,1)*PC(J,4)
                  Sumphi=Sumphi+PC(J,2)*PC(J,4)
               Endif
               If (PC(J,2).GT.Phimax) Phimax=PC(J,2)
               If (PC(J,2).LT.Phimin) Phimin=PC(J,2)
               Ncel=Ncel+1
            Endif
  130    Continue
         If (SumEt.LE.0.) Then
            Write(Lp,1003)
 1003       Format(' CluHad: Et = 0.?')
            SumEt=1.
            SumE=1.
         Endif
         If (Imode.EQ.1) Then
            PC(Npart+I,1)=Sumeta/SumEt
            PC(Npart+I,2)=Sumphi/SumEt
         Else if (Imode.EQ.2) Then
            PC(Npart+I,1)=Sumeta/SumE
            PC(Npart+I,2)=Sumphi/SumE
         Endif
         If ((Phimax-Phimin).GT.(3*Pi/2.)) Then
            Sumphi=0.
            Do 135 J=1,Nseed
               If (KC(J,1).EQ.I) Then
                  If (PC(J,2).GT.Pi) Then
                     TPhi=PC(J,2)-Twopi
                  Else
                     TPhi=PC(J,2)
                  Endif
                  If (Imode.EQ.1) Then
                     Sumphi=Sumphi+TPhi*PC(J,3)
                  Else if (Imode.EQ.2) Then
                     Sumphi=Sumphi+TPhi*PC(J,4)
                  Endif
               Endif
  135       Continue
            If (Imode.EQ.1) Then
               PC(Npart+I,2)=Sumphi/SumEt
            Else if (Imode.EQ.2) Then
               PC(Npart+I,2)=Sumphi/SumE
            Endif
            If (PC(Npart+I,2).LT.0.) PC(Npart+I,2)=
     +            PC(Npart+I,2)+Twopi
         Endif
         PC(Npart+I,3)=SumEt
         PC(Npart+I,4)=SumE
         PC(Npart+I,5)=REAL(I)
         KC(Npart+I,1)=Ncel
         KC(Npart+I,2)=3
  120 Continue
C
C We now have the preclusters with their centres. For each cluster we now
C assign cells to it if they are within the required distance.
C
      Iteration=0
    5 Ready=.TRUE.
      Iteration=Iteration+1
C
C .. reset the counter
C
      Do 10 I=1,Nsblock
         PC(I,5)=0.
   10 Continue
      Do 140 I=1,Ijet
         Do 150 J=1,Npart
            Deta=Abs(PC(Npart+I,1)-PC(J,1))
            Dphi=Abs(PC(Npart+I,2)-PC(J,2))
            If (Dphi.GT.Pi) Dphi=Twopi-Dphi
            If (Sqrt(Deta**2+Dphi**2).LE.Radius) Then
               PC(J,5)=PC(J,5)+1.
               If (PC(J,5).GE.9.) Then
                  PC(J,5)=8.
                  Write(Lp,1004)
 1004             Format(' CluHad: Overflow in counter!')
                  IErr=6
               Endif
               If (PC(J,5).GE.6.) Then
                  If (INT(VC(J,INT(PC(J,5)-5.))).NE.I) Ready=.FALSE.
                  VC(J,INT(PC(J,5)-5.))=REAL(I)
               Else
                  If (KC(J,INT(PC(J,5))).NE.I) Ready=.FALSE.
                  KC(J,INT(PC(J,5)))=I
               Endif
            Endif
  150    Continue
  140 Continue
C
C .. also check the counter for convergence
C
      Do 155 J=1,Npart
         If (INT(PC(J,5)).NE.INT(VC(J,4))) Ready=.FALSE.
         VC(J,4)=PC(J,5)
  155 Continue
C
C .. reevaluate the jet centres based on the new list
C
      Do 160 I=1,Ijet
         SumE=0.
         SumEt=0.
         Sumeta=0.
         Sumphi=0.
         Ncel=0
         Phimax=0.
         Phimin=Twopi
         Do 170 J=1,Npart
            Do 180 K=1,INT(PC(J,5))
               If (K.GE.6) Then
                  Icjet = INT(VC(J,K-5))
               Else
                  Icjet = KC(J,K)
               Endif
               If (Icjet.EQ.I) Then
                  SumE=SumE+PC(J,4)
                  SumEt=SumEt+PC(J,3)
                  If (Imode.EQ.1) Then
                     Sumeta=Sumeta+PC(J,1)*PC(J,3)
                     Sumphi=Sumphi+PC(J,2)*PC(J,3)
                  Else if (Imode.EQ.2) Then
                     Sumeta=Sumeta+PC(J,1)*PC(J,4)
                     Sumphi=Sumphi+PC(J,2)*PC(J,4)
                  Endif
                  If (PC(J,2).GT.Phimax) Phimax=PC(J,2)
                  If (PC(J,2).LT.Phimin) Phimin=PC(J,2)
                  Ncel=Ncel+1
               Endif
  180       Continue
  170    Continue
         If (SumEt.LE.0.) Then
            Write(Lp,1003)
            SumEt=1.
            SumE=1.
         Endif
         If (Imode.EQ.1) Then
            PC(Npart+I,1)=Sumeta/SumEt
            PC(Npart+I,2)=Sumphi/SumEt
         Else if (Imode.EQ.2) Then
            PC(Npart+I,1)=Sumeta/SumE
            PC(Npart+I,2)=Sumphi/SumE
         Endif
         If ((Phimax-Phimin).GT.(3*Pi/2.)) Then
            Sumphi=0.
            Do 175 J=1,Npart
               Do 185 K=1,INT(PC(J,5))
                  If (K.GE.6) Then
                     Icjet = INT(VC(J,K-5))
                  Else
                     Icjet = KC(J,K)
                  Endif
                  If (Icjet.EQ.I) Then
                     If (PC(J,2).GT.Pi) Then
                        TPhi=PC(J,2)-Twopi
                     Else
                        TPhi=PC(J,2)
                     Endif
                     If (Imode.EQ.1) Then
                        Sumphi=Sumphi+TPhi*PC(J,3)
                     Else if (Imode.EQ.2) Then
                        Sumphi=Sumphi+TPhi*PC(J,4)
                     Endif
                  Endif
  185          Continue
  175       Continue
            If (Imode.EQ.1) Then
               PC(Npart+I,2)=Sumphi/SumEt
            Else if (Imode.EQ.2) Then
               PC(Npart+I,2)=Sumphi/SumE
            Endif
            If (PC(Npart+I,2).LT.0.) PC(Npart+I,2)=
     +            PC(Npart+I,2)+Twopi
         Endif
         PC(Npart+I,3)=SumEt
         PC(Npart+I,4)=SumE
         PC(Npart+I,5)=REAL(I)
         KC(Npart+I,1)=Ncel
         KC(Npart+I,2)=3
  160 Continue
C
C Repeat the iteration if list has changed, but cut off at MAXITER iterations
C
      If ((.NOT.Ready).AND.Iteration.LT.MaxIter) GoTo 5
C
C Resolve overlaps. If the amount of overlapping energy is more than some
C fraction (typically 75%) of the energy of the smallest cluster, the
C clusters are merged, otherwise the cells are assigned to the closest cluster
C
C...Reorder jets according to Et
C
      DO 460 I=Npart+1,Npart+IJET
      DO 460 J=1,5
         VC(I,J)=PC(I,J)
         VC(I+IJET,J)=REAL(KC(I,J))
  460 CONTINUE
      DO 490 INEW=Npart+1,Npart+IJET
         PEMAX=0.
         DO 470 ITRY=Npart+1,Npart+IJET
            IF(VC(ITRY,3).LE.PEMAX) GOTO 470
            IMAX=ITRY
            PEMAX=VC(ITRY,3)
  470    CONTINUE
         DO 480 J=1,5
            KC(INEW,J)=INT(VC(IMAX+IJET,J))
            PC(INEW,J)=VC(IMAX,J)
  480    CONTINUE
         VC(IMAX,3)=-1.
  490 CONTINUE
C
      Do 190 I=1,Ijet
         Do 200 J=Ijet,I+1,-1
            Eoverlap=0.
            Do 210 K=1,Npart
               If (PC(K,5).LE.1.) GoTo 210
               Do 220 L=1,INT(PC(K,5))
               Do 220 M=1,INT(PC(K,5))
                  If (L.GE.6) Then
                     Icjet1 = INT(VC(K,L-5))
                  Else
                     Icjet1 = KC(K,L)
                  Endif
                  If (M.GE.6) Then
                     Icjet2 = INT(VC(K,M-5))
                  Else
                     Icjet2 = KC(K,M)
                  Endif
                  If ((Icjet1.EQ.INT(PC(Npart+I,5))).AND.
     .                (Icjet2.EQ.INT(PC(Npart+J,5)))) Then
                     Eoverlap=Eoverlap+PC(K,4)
                     GoTo 210
                  Endif
  220          Continue
  210       Continue
            If (Eoverlap.LE.0.) GoTo 200
            If (Eoverlap.GE.Frac*MIN(PC(Npart+I,4),
     ,            PC(Npart+J,4))) Then
C
C .. merge !
C
               Do 230 K=1,Npart
                  Do 240 L=1,INT(PC(K,5))
                     If (L.GE.6) Then
                        If (INT(VC(K,L-5)).EQ.INT(PC(Npart+J,5))) Then
                           VC(K,L-5)=PC(Npart+I,5)
                        Endif
                     Else
                        If (KC(K,L).EQ.INT(PC(Npart+J,5))) Then
                           KC(K,L)=INT(PC(Npart+I,5))
                        Endif
                     Endif
  240             Continue
  230          Continue
            Else
C
C .. assign each cell to the closest jet
C
               Do 250 K=1,Npart
                  Deta1=Abs(PC(Npart+I,1)-PC(K,1))
                  Dphi1=Abs(PC(Npart+I,2)-PC(K,2))
                  If (Dphi1.GT.Pi) Dphi1=Twopi-Dphi1
                  Dist1=Sqrt(Deta1**2+Dphi1**2)
                  Deta2=Abs(PC(Npart+J,1)-PC(K,1))
                  Dphi2=Abs(PC(Npart+J,2)-PC(K,2))
                  If (Dphi2.GT.Pi) Dphi2=Twopi-Dphi2
                  Dist2=Sqrt(Deta2**2+Dphi2**2)
                  If (Dist1.LE.Dist2) Then
                     Do 260 L=1,INT(PC(K,5))
                        If (L.GE.6) Then
                         If (INT(VC(K,L-5)).EQ.INT(PC(Npart+J,5))) Then
                            VC(K,L-5)=PC(Npart+I,5)
                         Endif
                        Else
                           If (KC(K,L).EQ.INT(PC(Npart+J,5))) Then
                              KC(K,L)=INT(PC(Npart+I,5))
                           Endif
                        Endif
  260                Continue
                  Else
                     Do 270 L=1,INT(PC(K,5))
                        If (L.GE.6) Then
                         If (INT(VC(K,L-5)).EQ.INT(PC(Npart+I,5))) Then
                            VC(K,L-5)=PC(Npart+J,5)
                         Endif
                        Else
                           If (KC(K,L).EQ.INT(PC(Npart+I,5))) Then
                              KC(K,L)=INT(PC(Npart+J,5))
                           Endif
                        Endif
  270                Continue
                  Endif
  250          Continue
            Endif
  200    Continue
  190 Continue
C
C Recalculate the centres from the new lists, and clean up.
C
      Nrjet=0
      Do 280 I=1,Ijet
         SumE=0.
         SumEt=0.
         Sumeta=0.
         Sumphi=0.
         Ncel=0
         Phimax=0.
         Phimin=Twopi
         Do 290 J=1,Npart
            If (INT(PC(J,5)).LE.0) GoTo 290
            If (KC(J,1).EQ.INT(PC(Npart+I,5))) Then
               SumE=SumE+PC(J,4)
               SumEt=SumEt+PC(J,3)
               If (Imode.EQ.1) Then
                  Sumeta=Sumeta+PC(J,1)*PC(J,3)
                  Sumphi=Sumphi+PC(J,2)*PC(J,3)
               Else if (Imode.EQ.2) Then
                  Sumeta=Sumeta+PC(J,1)*PC(J,4)
                  Sumphi=Sumphi+PC(J,2)*PC(J,4)
               Endif
               If (PC(J,2).GT.Phimax) Phimax=PC(J,2)
               If (PC(J,2).LT.Phimin) Phimin=PC(J,2)
               Ncel=Ncel+1
            Endif
  290    Continue
         If (Ncel.LE.0) Then
            Do 300 J=1,5
               PC(Npart+I,J)=0.
               KC(Npart+I,J)=0
  300       Continue
         Else
            Nrjet=Nrjet+1
            If (SumEt.LE.0.) Then
               Write(Lp,1003)
               SumEt=1.
               SumE=1.
            Endif
            If (Imode.EQ.1) Then
               PC(Npart+I,1)=Sumeta/SumEt
               PC(Npart+I,2)=Sumphi/SumEt
            Else if (Imode.EQ.2) Then
               PC(Npart+I,1)=Sumeta/SumE
               PC(Npart+I,2)=Sumphi/SumE
            Endif
            If ((Phimax-Phimin).GT.(3*Pi/2.)) Then
               Sumphi=0.
               Do 305 J=1,Npart
                  If (KC(J,1).EQ.INT(PC(Npart+I,5))) Then
                     If (PC(J,2).GT.Pi) Then
                        TPhi=PC(J,2)-Twopi
                     Else
                        TPhi=PC(J,2)
                     Endif
                     If (Imode.EQ.1) Then
                        Sumphi=Sumphi+TPhi*PC(J,3)
                     Else if (Imode.EQ.2) Then
                        Sumphi=Sumphi+TPhi*PC(J,4)
                     Endif
                  Endif
  305          Continue
               If (Imode.EQ.1) Then
                  PC(Npart+I,2)=Sumphi/SumEt
               Else if (Imode.EQ.2) Then
                  PC(Npart+I,2)=Sumphi/SumE
               Endif
               If (PC(Npart+I,2).LT.0.) PC(Npart+I,2)=
     +               PC(Npart+I,2)+Twopi
            Endif
            PC(Npart+I,3)=SumEt
            PC(Npart+I,4)=SumE
            KC(Npart+I,1)=Ncel
            KC(Npart+I,2)=3
         Endif
  280 Continue
C
C...Finally reorder jets according to Et
C
      DO 310 I=Npart+1,Npart+IJET
      DO 310 J=1,5
         VC(I,J)=PC(I,J)
         VC(I+IJET,J)=REAL(KC(I,J))
  310 CONTINUE
      DO 320 INEW=Npart+1,Npart+IJET
         PEMAX=-0.001
         DO 330 ITRY=Npart+1,Npart+IJET
            IF(VC(ITRY,3).LE.PEMAX) GOTO 330
            IMAX=ITRY
            PEMAX=VC(ITRY,3)
  330    CONTINUE
         DO 340 J=1,5
            KC(INEW,J)=INT(VC(IMAX+IJET,J))
            PC(INEW,J)=VC(IMAX,J)
  340    CONTINUE
         VC(IMAX,3)=-1.
  320 CONTINUE
C
      Npart=Npart+Nrjet
C
  999 continue
      RETURN
      END
*CMZ :  2.00/00 13/08/99  17.14.07  by  Tancredi Carli
*CMZ :  1.01/15 04/06/98  2
*-- Author :
      Subroutine Convpagp(nrclus,Ierr)
c
c Author G.Cases 14/12/93
c
      Implicit None
*
* .. Calorimeter common for cluster finding a la LuClus (CluClu).
*
      Integer Nsblock, Npart
      Parameter (Nsblock = 4000)
      Integer KC(Nsblock,5)
      Real    PC(Nsblock,5), VC(Nsblock,5)
*
      COMMON/CluCom/Npart,KC,PC,VC
C.
       integer njet1
       real PGJET1
       COMMON/GENJET1/NJET1,PGJET1(20,15)
       real rapmin,etcut,rcone,ecut,rapmax
       parameter (rapmin=-4.)    ! rapidity cut (d=2.0)
       parameter (rapmax=4.)    ! rapidity cut max
       parameter (etcut=2.0)     ! et cut (d=4.0)
       parameter (ecut=0.)    ! et cut
       real Pucellp
       COMMON/MORSUB/PucellP(10,1000)
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c   1 = electron                                              c
c   2 = proton                                                c
c   3 = final electron                                        c
c   4 = photon/Z0                                             c
c   5 = Proton + photon                                       c
c  13 = Photon/Z0 in Hadronic System                          c
c  14 = Proton in Hadronic System                             c
c  15 = electron in Hadronic System                           c
c  16 = scattered electron in Hadronic System                 c
c  101-nch = hadrons in LAB                                   c
c  101+nch-2*nch = hadrons in Hadronic System                 c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
      INTEGER ZREVT,ZREVT_9999
      INTEGER ZREVT_ID,ZREVT_RunNr,ZREVT_EvtNr,ZREVT_Time,ZREVT_TrgMsk,
     +   ZREVT_SelMsk

      COMMON/ZREVT/ZREVT,ZREVT_ID,ZREVT_RunNr,ZREVT_EvtNr(3),
     +   ZREVT_Time(2),ZREVT_TrgMsk(3),ZREVT_SelMsk(3),ZREVT_9999

C
       integer i,j,k,nrclus,ierr,nfinal
       real theta,phi,E,ET,eta,pt
       real deg,atg2
       real x,y,z,px,py,pz,rcl

       deg=180./3.14159
       nfinal=0
       njet1=0

       call vzero(pgjet1,300)

       Do i=Npart-NrClus+1,Npart
          theta=2*atan(exp(-PC(i,1)))
          phi=PC(i,2)
          E=PC(i,4)
          ET=PC(i,3)
c----
          pucellp(1,903) = E*sin(theta)*cos(phi)
          pucellp(2,903) = E*sin(theta)*sin(phi)
          pucellp(3,903) = E*cos(theta)
          pucellp(4,903) = E
          pucellp(5,903) = 0.
          PT=SQRT(PUCELLP(1,903)**2+PUCELLP(2,903)**2)
c
          ETA=PC(i,1)
c
          if(ET.gt.etcut.and.E.gt.ecut) then
             if (eta.gt.rapmin.and.eta.lt.rapmax) then
                nfinal=nfinal+1
                do j=1,5
                   PGJET1(nfinal,j)=pucellp(j,903)
                enddo
                PGJET1(nfinal,6)=ETA
                PGJET1(nfinal,7)=PT
                PGJET1(nfinal,8)=atan2(PGJET1(nfinal,2),
     +               PGJET1(nfinal,1))
                PGJET1(nfinal,9)=PC(i,1)
                PGJET1(nfinal,10)=ET
                PGJET1(nfinal,11)=phi
         endif
      endif
c
      enddo

      njet1=nfinal
      ierr=0

      return
      end
*CMZ :  2.00/00 13/08/99  17.14.37  by  Tancredi Carli
*CMZ :  1.01/15 04/06/98  2
*-- Author :
      subroutine Had_to_HCM(nch)
c
c  Boost Hadrons to HCM frame (G. Cases: 3.11.95)
c

      Implicit None

      real pucellP
      COMMON/MORSUB/pucellP(10,1000)
      integer nch,i,istable
      real PT,Theta,eta,Phi
      real deg,pi
      real fbeam_pipe,rbeam_pipe
      pi=3.141592654
      fbeam_pipe=0.
      rbeam_pipe=180.
      deg=180./pi

c       istable=100+nch
       istable=100
c
      if(nch.gt.0) then
c        call lor(1,5,15)
c        call lor(2,5,14)
c        call lor(3,5,16)
c        call lor(4,5,13)
        do i=1,nch
c          call lor(100+i,5,istable+i) ! boost
c---
          PT=sqrt(pucellp(1,istable+i)**2+pucellp(2,istable+i)**2)
          Theta=acos(pucellp(3,istable+i)
     +          /sqrt(PT**2+pucellp(3,istable+i)**2))
          eta=-alog(tan(theta/2.))
          PHI=atan2(PUCELLP(2,istable+i),PUCELLP(1,istable+i))
          if (PHI.lt.0.) then
              PHI = PHI + 2*3.141592654
          endif
c          if(theta*deg.gt.fbeam_pipe.and.theta*deg.lt.rbeam_pipe)
c     +                             then
          pucellp(6,istable+i)=ETA
          pucellp(7,istable+i)=PT
          pucellp(8,istable+i)=PHI
c
c---
c          endif
        enddo
      endif
c
      return
      end
*CMZ :  2.00/00 13/08/99  17.15.03  by  Tancredi Carli
*CMZ :  1.01/15 04/06/98  2
*-- Author :
      SubRoutine PACELLgp (Operation,EnergyCuts,NrClus,IErr,icell)
C ========================================================
C#-------------------------------------------------------------------
C#
C#     Modified version for finding jets in Hadronic center of mass
C#       and particles (G.Cases: 10.7.94)
C#
C#      SubRoutine PUCELL (Operation,EnergyCuts,NrClus,IErr)
C#
C@#    PUCELL : Find jets using a cone algorithm in pseudorapidity-phi.
C
C#    Find jets using a cone algorithm in pseudorapidity-phi.
C#    These kind of algorithms are generally used in p-pbar
C#    experiments (UA1/CDF). The jet is defined as a cone with
C#    fixed radius in pseudorapidity-azimuth space. The implemented
C#    version corresponds to the "Snowmass convention".
C#    Table Caltru is the starting point; results are stored in
C#    tables Cidclu and Cidcel. Position and energy are given, but not the
C#    class; this can be done using routine PCIdCl. Cuts on the energy of
C#    cells and cluster seeds can be applied.
C#
C#    Calls routines CFILHA, CLUHAD, CEMPHA and CCLCOP from CCRECON.
C#
C#    Author:     Paul de Jong
C#
C#    Input:
C#                Table Caltru     (cells with energy)
C#
C#                Real Operation(10)    Steering parameters
C#                                1: Mode of operation
C#                                   <= 1. : E_T  (d)
C#                                   >  1. : E
C#                                2: Precluster Cone Radius (0.7)
C#                                3: Cluster Cone Radius (0.7)
C#                                4: Maximum number of iterations (20)
C#                                5: Minimum overlap fraction for merge (0.75)
C#                                6-10 ineffective
C#                     values < 0. : default taken
C#
C#                Real EnergyCuts(10)   (in GeV)
C#                                1: EMC cell energy cut      (0.03)
C#                                2: HAC cell energy cut      (0.08)
C#                                3: Seed cell energy (E_T) cut  (1.0 (0.3))
C#                                4-10 ineffective
C#                     values < 0. : default taken
C#
C#    Output
C#                Table Cidclu     (clusters, no 'class')
C#
C#                Table Cidcel     (link cells-clusters)
C#
C#                NrClus : number of clusters found
C#
C#                IErr : error flag
C#                       0: no error
C#                       1: geometry not set up properly
C#                       2: error during clustering
C#
C#    Restrictions:  CAL geometry set up a la CCGEOM needed.
C#                   The CCRECON library needs to be linked.
C#                   Block Data CCBLDA required.
C#
C#    Documentation: ZEUS-Note 92-019
C#
C#    Default parameters and cuts can be chosen by setting them to
C#    negative values:  CALL VFILL (EnergyCuts,10,-1.)
C#                      CALL VFILL (Operation,10,-1.)
C#
C#-------------------------------------------------------------------
C ========================================================
      Implicit None
C
      INTEGER CUCELL,CUCELL_9999
      INTEGER CUCELL_ID,CUCELL_Volu,CUCELL_rotm,CUCELL_tmed,CUCELL_Nr
      REAL CUCELL_x,CUCELL_y,CUCELL_z

      COMMON/CUCELL/CUCELL,CUCELL_ID,CUCELL_Nr,CUCELL_x,CUCELL_y,
     +   CUCELL_z,CUCELL_Volu,CUCELL_rotm,CUCELL_tmed,CUCELL_9999

      INTEGER CCAdJa,CCAdJa_9999
      INTEGER CCAdJa_ID,CCAdJa_No,CCAdJa_par

      COMMON/CCAdJa/CCAdJa,CCAdJa_ID,CCAdJa_No,CCAdJa_par(30),
     +   CCAdJa_9999

      INTEGER Cidclu,Cidclu_9999
      INTEGER Cidclu_ID,Cidclu_CR1obj
      CHARACTER*8 Cidclu_class
      REAL Cidclu_x,Cidclu_y,Cidclu_z,Cidclu_E,Cidclu_radius,Cidclu_cx,
     +   Cidclu_cy,Cidclu_cz,Cidclu_Eemc,Cidclu_Cemc,Cidclu_Ehac1,
     +   Cidclu_Chac1,Cidclu_Ehac2,Cidclu_Chac2

      COMMON/Cidclu/Cidclu,Cidclu_ID,Cidclu_class,Cidclu_x,Cidclu_y,
     +   Cidclu_z,Cidclu_E,Cidclu_radius,Cidclu_cx,Cidclu_cy,Cidclu_cz,
     +   Cidclu_Eemc,Cidclu_Cemc(3),Cidclu_Ehac1,Cidclu_Chac1(3),
     +   Cidclu_Ehac2,Cidclu_Chac2(3),Cidclu_CR1obj,Cidclu_9999

      INTEGER Cidcel,Cidcel_9999
      INTEGER Cidcel_ID,Cidcel_Caltru,Cidcel_Cidclu
      REAL Cidcel_fraction

      COMMON/Cidcel/Cidcel,Cidcel_ID,Cidcel_fraction,Cidcel_Caltru,
     +   Cidcel_Cidclu,Cidcel_9999

*
* .. Calorimeter common for cluster finding a la LuClus (CluClu).
*
      Integer Nsblock, Npart
      Parameter (Nsblock = 4000)
      Integer KC(Nsblock,5)
      Real    PC(Nsblock,5), VC(Nsblock,5)
*
      COMMON/CluCom/Npart,KC,PC,VC
C.
*
* .. Calorimeter common for CluClu steering parameters.
*
      Integer Ndis,Nscale,Nmass,Nelecspec,Nrecomb,Nmcalc,Ibeamp
      Real    Djoinpt,Yjoinwinv,Dinit,Converg,Emcccut,Hacccut,Emcpcut,
     ,        Hacpcut,Emclcut,Haclcut,Djoinmass,Yjoinevis
*
      Common/CluPar/Ndis,Nscale,Nmass,Nelecspec,Nrecomb,Nmcalc,
     ,              Djoinpt,Yjoinwinv,Dinit,Converg,Emcccut,
     ,              Hacccut,Emcpcut,Hacpcut,Emclcut,Haclcut,
     ,              Djoinmass,Yjoinevis,Ibeamp
C.
*
* .. Calorimeter common for CluClu output parameters.
*
      Integer Nfirst,Nused,Nprec
      Real    Winv,Tgen,Dmin
*
      Common/CluOut/Nfirst,Nused,Nprec,Winv,Tgen,Dmin
C.
C
C .. Calorimeter common for special treatment of electron in jet finding.
C
      Integer Ifound
C
      Common/Cfound/Ifound
C.
C
C .. Common block for the CDF-like jet algorithm.
C
      Integer Nseed, Nnoseed, MaxIter, Imode
      Real EtSeedcut,EtSneedcut,RadPC,Radius,Frac,ESeedcut,ESneedcut
C
      Common /CDFCom/ EtSeedcut,EtSneedcut,RadPC,Radius,MaxIter,Frac,
     ,                Imode,Nseed,Nnoseed,ESeedcut,ESneedcut
C.
      INTEGER Cclust,Cclust_9999
      INTEGER Cclust_ID
      REAL Cclust_x,Cclust_y,Cclust_z,Cclust_slctx,Cclust_slcty,
     +   Cclust_slctz,Cclust_E,Cclust_radius,Cclust_slctradius,
     +   Cclust_cx,Cclust_cy,Cclust_cz

      COMMON/Cclust/Cclust,Cclust_ID,Cclust_x,Cclust_y,Cclust_z,
     +   Cclust_slctx,Cclust_slcty,Cclust_slctz,Cclust_E,Cclust_radius,
     +   Cclust_slctradius,Cclust_cx,Cclust_cy,Cclust_cz,Cclust_9999

C
      Integer I, NrClus, IErr, MyErr
      Character*4 Modes(2)
      Real EnergyCuts(10), Operation(10)
      Logical OK, Lprint
      Data Modes / 'E_T' , 'E' /
      Data Lprint /.TRUE./
      integer icell
C
C Check geometry
C
      NrClus = 0
      IErr = 0
C
C Overrule steering parameters and energy cuts.
C
      If (Operation(1).GE.0.) Then
         If (Operation(1).LE.1.) Then
            Imode = 1
         Else
            Imode = 2
         Endif
      Endif
      If (Operation(2).GE.0.) RadPC = Operation(2)
      If (Operation(3).GE.0.) Radius = Operation(3)
C .. Some protection might be needed here
      If (RadPC.LT.0.1) Then
         RadPC = 0.1
         Write (6,*) ' PUCELL warning: Precluster radius set to ',RadPC
      Endif
      If (Radius.LT.0.1) Then
         Radius = 0.1
         Write (6,*) ' PUCELL warning: Cluster radius set to ',Radius
      Endif
      If (RadPC.GT.Radius) Then
         RadPC = Radius
         Write (6,*) ' PUCELL warning: precluster radius set to ',RadPC
      Endif
      If (Radius/RadPC.GT.3.) Then
         RadPC = Radius/3.
         Write (6,*) ' PUCELL warning: precluster radius set to ',RadPC
      Endif
      If (Operation(4).GE.0.) MaxIter = Int(Operation(4))
      If (MaxIter.LT.1) MaxIter=1
      If (Operation(5).GE.0.) Frac = Operation(5)
      If (Frac.GT.1.) Frac=1.
      If (EnergyCuts(1).GE.0.) Emcccut = EnergyCuts(1)
      If (EnergyCuts(2).GE.0.) Hacccut = EnergyCuts(2)
      If (EnergyCuts(3).GE.0.) Then
         If (Imode.EQ.1) Then
            EtSeedcut = EnergyCuts(3)
            EtSneedcut = 0.0001
         Else
            ESeedcut = EnergyCuts(3)
            ESneedcut = 0.0001
         Endif
      Endif
C
C Protect against absolute zero
C
      If (Emcccut.LE.0.) Emcccut = 0.0001
      If (Hacccut.LE.0.) Hacccut = 0.0001
      If (EtSeedcut.LE.0.) EtSeedcut = 0.0001
      If (ESeedcut.LE.0.) ESeedcut = 0.0001
C
C First time: print some info
C
      If (Lprint) Then
         Lprint = .FALSE.
         Write(6,1000)
         Write(6,1001) Modes(Imode),RadPC,Radius,MaxIter,Frac
         If (Imode.LE.1) Then
            Write(6,1002) Emcccut, Hacccut, EtSeedcut
         Else
            Write(6,1002) Emcccut, Hacccut, ESeedcut
         Endif
      Endif
C
C Fill common block
C
      Call CFilpagp (icell,MyErr)
      If (MyErr.NE.0) Then
         IErr = 2
         Write (6,*) ' PACEgp reports error ',MyErr,' in CFilPAHa'
         Return
      Endif
C
C Perform the jet finding
C
      Call CluHad (NrClus,MyErr)
      If (MyErr.NE.0) Then
         IErr = 2
         Write (6,*) ' PACEgp reports error ',MyErr,' in CLUHad'
         Return
      Endif
C----
      call Convpagp(Nrclus,Myerr)

      If (MyErr.NE.0) Then
         IErr = 2
         Write (6,*) ' PUCEgp reports error ',MyErr,' in Convpagp'
         Return
      Endif

C
c
      Return
C
 1000 Format(////,
     ,    7X,' PUCEgp searches for jets with cone algorithm',/,
     ,    7X,'----------------------------------------------',/)
 1001 Format(/,
     ,    6X,'Clustering in E_T or E : ................  ',A4,/,
     ,    6X,'Precluster cone radius ..................  ',F8.3,/,
     ,    6X,'Jet cone radius .........................  ',F8.3,/,
     ,    6X,'Maximum number of iterations ............  ',I8,/,
     ,    6X,'Minimum energy fraction for merge .......  ',F8.3)
C
 1002 Format(/,
     ,    6X,'The following energy cuts are applied:  ',/,
     ,    6X,'EMC cell energy cut ..................[GeV]',F8.3,/,
     ,    6X,'HAC cell energy cut ..................[GeV]',F8.3,/,
     ,    6X,'Cluster seed cell energy cut .........[GeV]',F8.3)
C
      End
*CMZ :  2.00/03 26/05/2000  17.50.25  by  Klaus Rabbertz
*CMZ :  1.02/00 02/10/98  12.12.08  by  Tancredi Carli
*-- Author :    Klaus Rabbertz   22/11/96
      SUBROUTINE DEVSHP(QPART,NPART,Q2,EVSHP,NCURR,ECQ)
************************************************************************
*                                                                      *
*   DEVSHP                                                             *
*   purpose: calculate event shapes in the current hemisphere          *
*            (y for both hemispheres) of the Breit frame               *
*                                                                      *
*   called by: user                                                    *
*                                                                      *
*   input : - Breit frame input 4 vectors: QPART (E,p)                 *
*           - # of vectors               : NPART                       *
*           - Q^2                        : Q2                          *
*                                                                      *
*   output: - event shape array EVSHP containing:                      *
*              1: thrust like in e+e-, but only 1 hemisphere!          *
*              2: sum_i(|p_z|)/(Q/2) => thrust axis = (0,0,-1) (Webber)*
*              3: sum_i(|p_z|)/sum_i(|p|) => thrust axis = (0,0,-1)    *
*              4: jet broadening sum_i(p_t)/(Q/2)/2                    *
*              5: jet broadening sum_i(p_t)/sum_i(|p|)/2               *
*              6: jet mass (sum_i(E)^2-sum_i(p_x)^2-...)/(2Q/2)^2      *
*              7: jet mass (sum_i(E)^2-sum_i(p_x)^2-...)/(2E)^2        *
*              8: C parameter 3*(l1*l2+l2*l3+l3*l1) with l1,l2,l3      *
*                 eigen values of sum_i(p_i^j*p_i^k/|p_i|)/(Q/2)       *
*              9: C parameter 3*(l1*l2+l2*l3+l3*l1) with l1,l2,l3      *
*                 eigen values of sum_i(p_i^j*p_i^k/|p_i|)/sum_i(|p|)  *
*             10: y_kt for Q^2 scale (KTCLUS package)                  *
*             11: y_kt for fixed scale of 49.GeV^2 (KTCLUS package)    *
*             12: y_fJade for Q^2 scale                                *
*             13: y_fJade for fixed scale of 49.GeV^2                  *
*           - # of vectors in the curr. hemisph.: NCURR                *
*           - sum_i(E)/Q: ECQ                                          *
*                                                                      *
*   written by: Klaus Rabbertz, 22/11/96 15.20.00                      *
************************************************************************
      IMPLICIT NONE

C-----------------------------------------------------------------------
*KEEP,QJMACS.
C------------ /QJMACS/ --- Buffer for jet and topological routines -----
         INTEGER JTBIMX,JTBOMX,JPARMX,JTBI,JTBIT,JTBO,JTBOF
         DOUBLE PRECISION QPI,QTBIR,QPO,QTBOR
         PARAMETER (JTBIMX =10000,JTBOMX = 30,JPARMX = 5)
         COMMON /QCTBUF/QPI(5,JTBIMX),QTBIR(JPARMX,JTBIMX),
     +                  QPO(5,JTBOMX),QTBOR(JPARMX,JTBOMX),
     +                  JTBI,JTBIT(JTBIMX),
     +                  JTBO,JTBOF(JPARMX,JTBIMX)
C     jtbi       number of input vectors (max : jtbimx).
C     qpi(i,j)   particle input vector j; i=1,2,3,4:px,py,pz,e; i=5 free
C     jtbit(j)   pointer to corresponding q-vector
C     qtbir(k,j) scalar input k for each input vector j
C     jtbo       number of output jets   (max : jtbomx)
C     qpo(i,j)   jet output vector (jet axis) i=1,2,3,4:px,py,pz,e
C     jtbof(k,i) number of jet for input particle i in multiplet k
C     qtbor(k,j) scalar output result k for each jet j (k_max : jparmx)
C                (will be stored as user words in Q_vector)
*
*KEND.
C-----------------------------------------------------------------------
      DOUBLE PRECISION DSMALL
      PARAMETER(DSMALL = 1.D-15)
      INTEGER NEVSHP
      PARAMETER (NEVSHP=13)
      DOUBLE PRECISION FS
      PARAMETER (FS=7.D0)

      INTEGER NPART,NCURR
      DOUBLE PRECISION QPART(4,2000),Q2,EVSHP(NEVSHP),ECQ
* !!!!!!!!!!!!!! changes in line above !!!!!!!!!!!!!
      CHARACTER*80 JTEXT
      INTEGER I,J,IERR
      DOUBLE PRECISION QS,ES,PXS,PYS,PZS,PS,PTS,MS
      DOUBLE PRECISION QJI(4,JTBIMX)
      REAL YC(JTBIMX)

*---initialization
      DO I=1,NEVSHP
         EVSHP(I) = -1.D0
      ENDDO
      NCURR = 0
      ECQ = 0.D0

      JTBI = 0
      ES  = 0.D0
      PXS = 0.D0
      PYS = 0.D0
      PZS = 0.D0
      PS  = 0.D0
      PTS = 0.D0

*---check input
      IF (NPART.LE.0.OR.NPART.GT.JTBIMX) THEN
         WRITE(JTEXT,*)'S: DEVSHP: Illegal nr. of vectors:',NPART
         WRITE(*,*)JTEXT
ckr         CALL ERRLOG(9701,JTEXT)
ckr         RETURN
         STOP
      ENDIF
      IF (Q2.LT.1.D-3) THEN
         WRITE(JTEXT,*)'S: DEVSHP: Q^2 value too low:',Q2
         WRITE(*,*)JTEXT
ckr         CALL ERRLOG(9702,JTEXT)
ckr         RETURN
         STOP
      ENDIF

*---copy qpart to qpi if in current hemisphere, count E,pt,...
      DO I=1,NPART
         IF (QPART(4,I).LT.0.D0) THEN
            JTBI = JTBI + 1
            ES   = ES   + QPART(1,I)
            PXS  = PXS  + QPART(2,I)
            PYS  = PYS  + QPART(3,I)
            PZS  = PZS  + QPART(4,I)
            PS   = PS   + SQRT(QPART(2,I)**2+QPART(3,I)**2+
     &           QPART(4,I)**2)
            PTS  = PTS  + SQRT(QPART(2,I)**2+QPART(3,I)**2)
            DO J=1,3
               QPI(J,JTBI) = QPART(J+1,I)
            ENDDO
            QPI(4,JTBI) = QPART(1,I)
         ENDIF
      ENDDO
      NCURR = JTBI

*---calculate event shapes
      QS = SQRT(Q2)
      IF (NCURR.GT.0) THEN
         ECQ   = ES/QS
*---(1-thrust)_C (a la e+e-)
         CALL DGTHRU
         EVSHP(1) = 1.D0 - QTBOR(1,1)
*---(1-thrust)_Q (a la Webber)
         EVSHP(2) = 1.D0 - 2.D0*ABS(PZS)/QS
*---(1-thrust)_P (a la KR)
         IF (PS.GT.DSMALL) THEN
            EVSHP(3) = 1.D0 - ABS(PZS)/PS
         ELSE
            EVSHP(3) = 0.D0
            WRITE(JTEXT,*)'W: DEVSHP: sum_p value too low:',PS
            WRITE(*,*)JTEXT
ckr            CALL ERRLOG(9703,JTEXT)
         ENDIF
*---jet broadening_Q and _P
         EVSHP(4) = PTS/QS
         IF (PS.GT.DSMALL) THEN
            EVSHP(5) = PTS/PS/2.D0
         ELSE
            EVSHP(5) = 0.D0
            WRITE(JTEXT,*)'W: DEVSHP: sum_p value too low:',PS
            WRITE(*,*)JTEXT
ckr            CALL ERRLOG(9703,JTEXT)
         ENDIF
*---jet mass_Q and _E
         MS = (ES**2-PXS**2-PYS**2-PZS**2)
         EVSHP(6) = MS/Q2
         IF (ES.GT.DSMALL) THEN
            EVSHP(7) = MS/ES**2/4.D0
         ELSE
            EVSHP(7) = 0.D0
            WRITE(JTEXT,*)'W: DEVSHP: sum_E value too low:',ES
            WRITE(*,*)JTEXT
ckr            CALL ERRLOG(9704,JTEXT)
         ENDIF
*---C parameter_Q and _P
         CALL DGEIG(2,IERR)
         IF (IERR.EQ.0) THEN
            EVSHP(9) = 3.D0*(QTBOR(1,1)*QTBOR(1,2) +
     &                       QTBOR(1,2)*QTBOR(1,3) +
     &                       QTBOR(1,3)*QTBOR(1,1))
            EVSHP(8) = EVSHP(9)*4.D0*PS**2/Q2
         ELSE
            EVSHP(8) = 0.D0
            EVSHP(9) = 0.D0
            WRITE(JTEXT,*)'W: DEVSHP: error in DGEIG:',IERR
            WRITE(*,*)JTEXT
ckr            CALL ERRLOG(9705,JTEXT)
         ENDIF
      ENDIF
*---y_kt
*---copy complete qpart to qji (KTCLUS needs QJI(4,.))
      EVSHP(10) = 0.D0
      EVSHP(11) = 0.D0
      IF (NPART.GT.1) THEN
         DO I=1,NPART
            DO J=1,3
               QJI(J,I) = QPART(J+1,I)
            ENDDO
            QJI(4,I) = QPART(1,I)
         ENDDO
*---Q2 scale
         CALL KTCLUS(3,QJI,NPART,REAL(QS),YC,*999)
         EVSHP(10) = DBLE(YC(2))
*---fixed scale
         CALL KTCLUS(3,QJI,NPART,REAL(FS),YC,*999)
         EVSHP(11) = DBLE(YC(2))
      ENDIF

*---y_fJade
*---copy complete qpart to qpi, qpi(i,1)="remnant"
      QPI(1,1) = 0.D0
      QPI(2,1) = 0.D0
      QPI(3,1) = QS/2.D0
      QPI(4,1) = QS/2.D0
      JTBI = 1
      DO I=1,NPART
         JTBI = JTBI + 1
         DO J=1,3
            QPI(J,JTBI) = QPART(J+1,I)
         ENDDO
         QPI(4,JTBI) = QPART(1,I)
      ENDDO
*---Q2 scale
      CALL DGFJAD(1,QS)
      EVSHP(12) = QTBOR(1,2)
*---fixed scale
      CALL DGFJAD(1,FS)
      EVSHP(13) = QTBOR(1,2)

      RETURN

 999  WRITE(JTEXT,*)'S: DEVSHP: Error in KTCLUS!'
      WRITE(*,*)JTEXT
ckr      CALL ERRLOG(9706,JTEXT)
      STOP

      END
*CMZ :  0.03/03 29/08/91  11.05.17  by  Peter Schleper
*-- Author :    C.Jacobsson   15/05/91
      SUBROUTINE DGTHRU
C-----------------------------------------------------------------------
C
C   topological event analysis: thrust
C
C   Author:     H. Albrecht. feb 82
C   Changed by: C.Jacobsson for H1PHAN 910513
C   Changed by: K. Rabbertz for DISENT: implicit none           22.11.96
C                                       single -> double prec.
C
C-----------------------------------------------------------------------

ckr
      IMPLICIT NONE
ckr

*KEEP,QJMACS.
C------------ /QJMACS/ --- Buffer for jet and topological routines -----
         INTEGER JTBIMX,JTBOMX,JPARMX,JTBI,JTBIT,JTBO,JTBOF
         DOUBLE PRECISION QPI,QTBIR,QPO,QTBOR
         PARAMETER (JTBIMX =10000,JTBOMX = 30,JPARMX = 5)
         COMMON /QCTBUF/QPI(5,JTBIMX),QTBIR(JPARMX,JTBIMX),
     +                  QPO(5,JTBOMX),QTBOR(JPARMX,JTBOMX),
     +                  JTBI,JTBIT(JTBIMX),
     +                  JTBO,JTBOF(JPARMX,JTBIMX)
C     jtbi       number of input vectors (max : jtbimx).
C     qpi(i,j)   particle input vector j; i=1,2,3,4:px,py,pz,e; i=5 free
C     jtbit(j)   pointer to corresponding q-vector
C     qtbir(k,j) scalar input k for each input vector j
C     jtbo       number of output jets   (max : jtbomx)
C     qpo(i,j)   jet output vector (jet axis) i=1,2,3,4:px,py,pz,e
C     jtbof(k,i) number of jet for input particle i in multiplet k
C     qtbor(k,j) scalar output result k for each jet j (k_max : jparmx)
C                (will be stored as user words in Q_vector)
*
*KEND.
C-----------------------------------------------------------------------
ckr add. declaration
      INTEGER I,J,L,ITER
      DOUBLE PRECISION VCX,VCY,VCZ,VLX,VLY,VLZ,VMX,VMY,VMZ
      DOUBLE PRECISION VNX,VNY,VNZ,VNEW,VMAX,VSUM
ckr ende
      DATA VMX,VMY,VMZ/999999.D0,999999.D0,999999.D0/

* MORE THAN 2 TRACKS
      IF (JTBI.GT.2) THEN

        VMAX = 0.D0
        DO 30 I=1,JTBI-1
          DO 20 J=I+1,JTBI
            VCX = QPI(2,I) * QPI(3,J) - QPI(2,J) * QPI(3,I)
            VCY = QPI(3,I) * QPI(1,J) - QPI(3,J) * QPI(1,I)
            VCZ = QPI(1,I) * QPI(2,J) - QPI(1,J) * QPI(2,I)
            VLX = 0.D0
            VLY = 0.D0
            VLZ = 0.D0

            DO 10 L=1,JTBI
              IF (L .EQ. I .OR. L .EQ. J)  GO TO 10
              IF (QPI(1,L) * VCX + QPI(2,L) * VCY +
     &            QPI(3,L) * VCZ .GE. 0.D0)  THEN
                VLX = VLX + QPI(1,L)
                VLY = VLY + QPI(2,L)
                VLZ = VLZ + QPI(3,L)
              ELSE
                VLX = VLX - QPI(1,L)
                VLY = VLY - QPI(2,L)
                VLZ = VLZ - QPI(3,L)
              ENDIF
10          CONTINUE

*           make all four sign-combinations for I,J

            VNX = VLX + QPI(1,J) + QPI(1,I)
            VNY = VLY + QPI(2,J) + QPI(2,I)
            VNZ = VLZ + QPI(3,J) + QPI(3,I)
            VNEW = VNX**2 + VNY**2 + VNZ**2
            IF (VNEW .GT. VMAX)  THEN
              VMAX = VNEW
              VMX = VNX
              VMY = VNY
              VMZ = VNZ
            ENDIF

            VNX = VLX + QPI(1,J) - QPI(1,I)
            VNY = VLY + QPI(2,J) - QPI(2,I)
            VNZ = VLZ + QPI(3,J) - QPI(3,I)
            VNEW = VNX**2 + VNY**2 + VNZ**2
            IF (VNEW .GT. VMAX)  THEN
              VMAX = VNEW
              VMX = VNX
              VMY = VNY
              VMZ = VNZ
            ENDIF

            VNX = VLX - QPI(1,J) + QPI(1,I)
            VNY = VLY - QPI(2,J) + QPI(2,I)
            VNZ = VLZ - QPI(3,J) + QPI(3,I)
            VNEW = VNX**2 + VNY**2 + VNZ**2
            IF (VNEW .GT. VMAX)  THEN
              VMAX = VNEW
              VMX = VNX
              VMY = VNY
              VMZ = VNZ
            ENDIF

            VNX = VLX - QPI(1,J) - QPI(1,I)
            VNY = VLY - QPI(2,J) - QPI(2,I)
            VNZ = VLZ - QPI(3,J) - QPI(3,I)
            VNEW = VNX**2 + VNY**2 + VNZ**2
            IF (VNEW .GT. VMAX)  THEN
              VMAX = VNEW
              VMX = VNX
              VMY = VNY
              VMZ = VNZ
            ENDIF
20        CONTINUE
30      CONTINUE

*       sum momenta of all particles and iterate

        DO 50 ITER=1,4
          QPO(1,1) = 0.D0
          QPO(2,1) = 0.D0
          QPO(3,1) = 0.D0
          DO 40  I=1,JTBI
            IF (VMX * QPI(1,I) + VMY * QPI(2,I) +
     +          VMZ * QPI(3,I) .GE. 0.D0)  THEN
              QPO(1,1) = QPO(1,1) + QPI(1,I)
              QPO(2,1) = QPO(2,1) + QPI(2,I)
              QPO(3,1) = QPO(3,1) + QPI(3,I)
            ELSE
              QPO(1,1) = QPO(1,1) - QPI(1,I)
              QPO(2,1) = QPO(2,1) - QPI(2,I)
              QPO(3,1) = QPO(3,1) - QPI(3,I)
            ENDIF
40        CONTINUE
          VNEW = QPO(1,1)**2 + QPO(2,1)**2 + QPO(3,1)**2
          IF (VNEW .EQ. VMAX)  GO TO 70
          VMAX = VNEW
          VMX = QPO(1,1)
          VMY = QPO(2,1)
          VMZ = QPO(3,1)
50      CONTINUE

* ONLY TWO TRACKS
      ELSEIF (JTBI.EQ.2) THEN

        IF (QPI(1,1) * QPI(1,2) + QPI(2,1) * QPI(2,2) +
     &      QPI(3,1) * QPI(3,2) .GE. 0.D0)  THEN
          QPO(1,1) = QPI(1,1) + QPI(1,2)
          QPO(2,1) = QPI(2,1) + QPI(2,2)
          QPO(3,1) = QPI(3,1) + QPI(3,2)
        ELSE
          QPO(1,1) = QPI(1,1) - QPI(1,2)
          QPO(2,1) = QPI(2,1) - QPI(2,2)
          QPO(3,1) = QPI(3,1) - QPI(3,2)
        ENDIF

* ONLY ONE TRACK
      ELSEIF (JTBI.EQ.1) THEN

        QPO(1,1) = QPI(1,1)
        QPO(2,1) = QPI(2,1)
        QPO(3,1) = QPI(3,1)

* NO TRACKS
      ELSE

        QPO(1,1) = 0.D0
        QPO(2,1) = 0.D0
        QPO(3,1) = 0.D0
        QPO(4,1) = 0.D0
        QTBOR(1,1) = 0.D0
        JTBO = 1
        GOTO 1000

      ENDIF


      VNEW = QPO(1,1)**2 + QPO(2,1)**2 + QPO(3,1)**2

*     normalize thrust -division by total momentum

   70 VSUM = 0.D0
      DO 80 I=1,JTBI
        JTBOF(1,I) = 1
   80   VSUM = VSUM + SQRT (QPI(1,I)**2 + QPI(2,I)**2 + QPI(3,I)**2)
      QTBOR(1,1) = SQRT (VNEW) / VSUM
      QPO(4,1) = SQRT (QPO(1,1)**2 + QPO(2,1)**2 + QPO(3,1)**2)
      JTBO = 1

1000  RETURN
      END
*CMZ :  2.00/03 06/06/2000  16.41.49  by  Tancredi Carli
*CMZ :  0.03/00 15/05/91  21.34.12  by  Unknown
*-- Author :    C.Jacobsson   15/05/91
***********************************************************************
      SUBROUTINE DGEIG(NOPT,IERR)
C----------------------------------------------------------------------
C   Author      : E. Blucher            27-FEB-1989 (QGSPHE)
C   Changed by  : C. Jacobsson, H1KCJA, 13-APR-1991
C   Changed by  : K. Rabbertz           21-JUL-1997
C
C   Libraries required: CERNLIB (DEISRS1,DTRED2,DTQL2)
C
C   Description
C   ===========
C  Calculate eigenvalues and eigenvectors
C  from momentum vectors stored in QCTBUF.
C  Two different normalizations can be used.
C  For NOPT = 1,2 sqrt(sum_i |p(i)^2|) resp. (sum_i |p(i)|) > 10^-6
C  has to be fulfilled.
C
C  Input:  NOPT = 1: TT(j,k)=1/P**2*SUMi:p(j,i)*p(k,i)
C               = 2: TT(j,k)=(sum_i p(j,i)*p(k,i)/|p(i)|)/(sum_i |p(i)|)
C
C  Output: QPO(1,1),(2,1),(3,1)   = major axis
C          QPO(1,2),(2,2),(3,2)   = semi-major axis
C          QPO(1,3),(2,3),(3,3)   = minor axis
C          QTBOR(1,1),(1,2),(1,3) = eigenvalues in descending order
C          Note: For equal eigenvalues the eigenvectors are not
C                uniquely determined.
C  Errors: IERR = 1: sqrt(sum_i |p(i)^2|) <= 10^-6
C          IERR = 2: (sum_i |p(i)|)       <= 10^-6
C          IERR = 3: error in DEIGRS1
C----------------------------------------------------------------------

ckr
      IMPLICIT NONE
ckr

*KEEP,QJMACS.
C------------ /QJMACS/ --- Buffer for jet and topological routines -----
         INTEGER JTBIMX,JTBOMX,JPARMX,JTBI,JTBIT,JTBO,JTBOF
         DOUBLE PRECISION QPI,QTBIR,QPO,QTBOR
         PARAMETER (JTBIMX =10000,JTBOMX = 30,JPARMX = 5)
         COMMON /QCTBUF/QPI(5,JTBIMX),QTBIR(JPARMX,JTBIMX),
     +                  QPO(5,JTBOMX),QTBOR(JPARMX,JTBOMX),
     +                  JTBI,JTBIT(JTBIMX),
     +                  JTBO,JTBOF(JPARMX,JTBIMX)
C     jtbi       number of input vectors (max : jtbimx).
C     qpi(i,j)   particle input vector j; i=1,2,3,4:px,py,pz,e; i=5 free
C     jtbit(j)   pointer to corresponding q-vector
C     qtbir(k,j) scalar input k for each input vector j
C     jtbo       number of output jets   (max : jtbomx)
C     qpo(i,j)   jet output vector (jet axis) i=1,2,3,4:px,py,pz,e
C     jtbof(k,i) number of jet for input particle i in multiplet k
C     qtbor(k,j) scalar output result k for each jet j (k_max : jparmx)
C                (will be stored as user words in Q_vector)
*
*KEND.
C----------------------------------------------------------------------
ckr add. declaration
      INTEGER NOPT,IERR
      CHARACTER*80 JTEXT
      INTEGER I,J,K
      INTEGER IND(3)
      DOUBLE PRECISION PA,SUMP,SUMT
      DOUBLE PRECISION EVAL(3),EVEC(3,3),P(3),TT(3,3),WK(14)
ckr ende

*---initialization
      IERR = 0
      JTBO = 3
      DO I=1,JTBO
         QPO(1,I) = 0.D0
         QPO(2,I) = 0.D0
         QPO(3,I) = 0.D0
         QPO(4,I) = 0.D0
         QTBOR(1,I) = 0.D0
      ENDDO

*---compute momentum tensor TT
      SUMP = 0.D0
      DO J=1,3
         DO I=1,3
            TT(I,J) = 0.D0
         ENDDO
      ENDDO
      DO I=1,JTBI
         P(1) = QPI(1,I)
         P(2) = QPI(2,I)
         P(3) = QPI(3,I)
         PA   = SQRT(P(1)**2+P(2)**2+P(3)**2)
         SUMP = SUMP + PA
         DO J=1,3
            DO K=1,J
               IF (NOPT.EQ.1) THEN
                  TT(J,K) = TT(J,K) + P(J)*P(K)
               ELSE
                  IF (PA.GT.1.D-10) THEN
                     TT(J,K) = TT(J,K) + P(J)*P(K)/PA
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      TT(1,2) = TT(2,1)
      TT(1,3) = TT(3,1)
      TT(2,3) = TT(3,2)

*---do the normalization
*---minimal total momentum required
      IF (NOPT.EQ.1) THEN
         SUMT = TT(1,1) + TT(2,2) + TT(3,3)
         IF (SQRT(SUMT).GT.1.D-10) THEN
            DO J=1,3
               DO I=1,3
                  TT(I,J) = 1.D0/SUMT*TT(I,J)
               ENDDO
            ENDDO
         ELSE
            IERR = 1
            WRITE(JTEXT,*)'W: DGEIG: sqrt(sum_i |p(i)^2|) too low:',SUMT
            WRITE(*,*)JTEXT
ckr            CALL ERRLOG(9707,JTEXT)
            RETURN
         ENDIF
      ELSE
         IF (SUMP.GT.1.D-10) THEN
            DO J=1,3
               DO I=1,3
                  TT(I,J) = 1.D0/SUMP*TT(I,J)
               ENDDO
            ENDDO
         ELSE
            IERR = 2
            WRITE(JTEXT,*)'W: DGEIG: (sum_i |p(i)|) too low:',SUMP
            WRITE(*,*)JTEXT
ckr            CALL ERRLOG(9708,JTEXT)
            RETURN
         ENDIF
      ENDIF

*---calculate the eigenvectors and -values
*---(attention: EISRS1 may cause underflow exceptions!)
      CALL DEISRS1(3,3,TT,EVAL,EVEC,IERR,WK)
      IF (IERR.NE.0) THEN
         WRITE(JTEXT,*)'W: DGEIG: calc. of eigen val./vect. failed',
     &        IERR
         WRITE(*,*)JTEXT
ckr         CALL ERRLOG(9709,JTEXT)
         IERR = 3
         RETURN
      ENDIF

*---put them in descending order
      IF (EVAL(1).GE.MAX(EVAL(2),EVAL(3))) THEN
         IND(1) = 1
         IF (EVAL(2).GE.EVAL(3)) THEN
            IND(2) = 2
            IND(3) = 3
         ELSE
            IND(2) = 3
            IND(3) = 2
         ENDIF
      ELSEIF (MIN(EVAL(2),EVAL(3)).GT.EVAL(1)) THEN
         IND(3) = 1
         IF (EVAL(2).GE.EVAL(3)) THEN
            IND(1) = 2
            IND(2) = 3
         ELSE
            IND(1) = 3
            IND(2) = 2
         ENDIF
      ELSE
         IND(2) = 1
         IF (EVAL(2).GE.EVAL(3)) THEN
            IND(1) = 2
            IND(3) = 3
         ELSE
            IND(1) = 3
            IND(3) = 2
         ENDIF
      ENDIF

*---store major axis, semi-major axis, minor axis,
*---and eigenvalues in descending order
      DO I=1,JTBO
         QPO(1,I) = EVEC(1,IND(I))
         QPO(2,I) = EVEC(2,IND(I))
         QPO(3,I) = EVEC(3,IND(I))
         QPO(4,I) = 1.D0
         QTBOR(1,I) = EVAL(IND(I))
      ENDDO

      RETURN
      END
*CMZ :  1.02/01 23/10/98  17.59.07  by  Tancredi Carli
*CMZ :  1.02/00 02/10/98  17.58.49  by  Tancredi Carli
*-- Author :    Klaus Rabbertz   18/08/97
      SUBROUTINE DGFJAD(NJETS,SC)
************************************************************************
*                                                                       *
*   DGFJAD                                                             *
*   purpose: calculate y_ij values for the factorizable JADE jet       *
*            algorithm (Breit frame, Q^2 or fixed scale)               *
*                                                                      *
*   called by: user                                                    *
*                                                                      *
*   input : - Breit frame input 4 vectors and number: via common QCTBUF*
*             (first vector has to be the "remnant"=(0,0,Q/2,Q/2))     *
*           - # of jets to reconstruct: NJETS + 1 (remnant)            *
*           - scale (Q, fixed value)  : SC                             *
*                                                                      *
*   output: - NJETS+1 output jets in QPO, common QCTBUF                *
*           - y_ij value for transition N+1 -> N jets QTBOR(1,N),      *
*             common QCTBUF (filled for all N with N <= NJETS+1)       *
*                                                                      *
*   written by: Klaus Rabbertz, 18/08/97 15.40.00                      *
************************************************************************

ckr
      IMPLICIT NONE
ckr

*KEEP,QJMACS.
C------------ /QJMACS/ --- Buffer for jet and topological routines -----
         INTEGER JTBIMX,JTBOMX,JPARMX,JTBI,JTBIT,JTBO,JTBOF
         DOUBLE PRECISION QPI,QTBIR,QPO,QTBOR
         PARAMETER (JTBIMX =10000,JTBOMX = 30,JPARMX = 5)
         COMMON /QCTBUF/QPI(5,JTBIMX),QTBIR(JPARMX,JTBIMX),
     +                  QPO(5,JTBOMX),QTBOR(JPARMX,JTBOMX),
     +                  JTBI,JTBIT(JTBIMX),
     +                  JTBO,JTBOF(JPARMX,JTBIMX)
C     jtbi       number of input vectors (max : jtbimx).
C     qpi(i,j)   particle input vector j; i=1,2,3,4:px,py,pz,e; i=5 free
C     jtbit(j)   pointer to corresponding q-vector
C     qtbir(k,j) scalar input k for each input vector j
C     jtbo       number of output jets   (max : jtbomx)
C     qpo(i,j)   jet output vector (jet axis) i=1,2,3,4:px,py,pz,e
C     jtbof(k,i) number of jet for input particle i in multiplet k
C     qtbor(k,j) scalar output result k for each jet j (k_max : jparmx)
C                (will be stored as user words in Q_vector)
*
*KEND.
C----------------------------------------------------------------------
ckr add. declaration
      INTEGER NJETS
      DOUBLE PRECISION SC
      INTEGER I,J,JTBW,ICL,JCL
      DOUBLE PRECISION DMIN,DIST,SKAL
      DOUBLE PRECISION QPW(5,JTBIMX)
ckr ende

*---initialization
      JTBW = JTBI
      DO J=1,JTBI
         DO I=1,4
            QPW(I,J) = QPI(I,J)
         ENDDO
         QPW(5,J) = SQRT(QPI(1,J)**2+QPI(2,J)**2+QPI(3,J)**2)
         QTBIR(1,J) = 0.D0
      ENDDO
      JTBO = NJETS+1
      DO J=JTBI+1,JTBO
         DO I=1,5
            QPW(I,J) = 0.D0
         ENDDO
         QTBIR(1,J) = 0.D0
      ENDDO
      DO J=1,JTBO
         DO I=1,4
            QPO(I,J) = 0.D0
         ENDDO
         QTBOR(1,J) = 0.D0
      ENDDO

*---only 1 initial 4 vector
      IF (JTBI.LE.1) THEN
         DO I=1,4
            QPO(I,1) = QPW(I,1)
         ENDDO
         QTBOR(1,1) = 0.D0
         RETURN

*---# output 4 vectors >= # input 4 vectors
      ELSEIF (JTBO.GE.JTBI) THEN
         DO J=1,JTBI
            DO I=1,4
               QPO(I,J) = QPW(I,J)
            ENDDO
         ENDDO
      ENDIF

*---find minimal distance
 10   DMIN = 1.D6
      DO I=1,JTBW-1
         DO J=I+1,JTBW
            IF (QPW(5,I).GT.1.D-6.AND.QPW(5,J).GT.1.D-6) THEN
               SKAL = QPW(1,I)*QPW(1,J)+QPW(2,I)*QPW(2,J)+
     &                QPW(3,I)*QPW(3,J)
               DIST = 2.D0*QPW(4,I)*QPW(4,J)*
     &                (1.D0-SKAL/QPW(5,I)/QPW(5,J))
            ELSE
               DIST = 0.D0
            ENDIF
            IF (DIST.LT.DMIN) THEN
               DMIN = DIST
               ICL  = I
               JCL  = J
            ENDIF
         ENDDO
      ENDDO

*---recombine
      IF (ICL.GT.1) THEN
         DO J=1,4
            QPW(J,ICL) = QPW(J,ICL) + QPW(J,JCL)
         ENDDO
         QPW(5,ICL) = SQRT(QPW(1,ICL)**2+QPW(2,ICL)**2+QPW(3,ICL)**2)
      ENDIF
      DO I=JCL,JTBW-1
         DO J=1,5
            QPW(J,I) = QPW(J,I+1)
         ENDDO
      ENDDO
      JTBW = JTBW-1
      QTBIR(1,JTBW) = DMIN/SC**2

*---store final recombined jets according to NJETS
*---(can only be true for JTBI < JTBO)
      IF (JTBW.EQ.JTBO) THEN
         DO J=1,JTBO
            DO I=1,4
               QPO(I,J) = QPW(I,J)
            ENDDO
         ENDDO
      ENDIF

*---cluster until only remnant left
      IF (JTBW.GT.1) GOTO 10

*---store y values
      DO I=1,JTBO
         QTBOR(1,I) = QTBIR(1,I)
      ENDDO

      RETURN
      END
*CMZ :  1.02/01 23/10/98  18.01.17  by  Tancredi Carli
*CMZ :  1.02/00 02/10/98  by  Tancredi Carli
*-- Author :
*
* $Id: eisrs1.F,v 1.1.1.1 1996/04/01 15:02:39 mclareni Exp $
*
* $Log: eisrs1.F,v $
* Revision 1.1.1.1  1996/04/01 15:02:39  mclareni
* Mathlib  gen
*
*
*#include "gen/pilot.h"
      SUBROUTINE DEISRS1(NM,N,AR,WR,ZR,IERR,WORK)
C     ALL EIGENVALUES AND CORRESPONDING EIGENVECTORS OF A REAL
C     SYMMETRIC MATRIX
C
ckr
      IMPLICIT NONE
      INTEGER NM,N,IERR
      DOUBLE PRECISION AR(NM,NM),WR(N),ZR(NM,NM),WORK(1)
ckr
      CALL DTRED2(NM,N,AR,WR,WORK,ZR)
      CALL DTQL2(NM,N,WR,WORK,ZR,IERR)
      RETURN
      END
*CMZ :  1.02/01 23/10/98  18.03.56  by  Tancredi Carli
*CMZ :     1.02/00 02/10/98  23/10/98  18.03.33  by  Tancredi Carli
*-- Author :
*
*  $Id: tred2.F,v 1.1.1.1  1996/04/01 15:02:38 mclareni Exp $
*
* $Log: tred2.F,v $
* Revision 1.1.1.1  1996/04/01 15:02:38  mclareni
* Mathlib gen
*
*
*#include "gen/pilot.h"
      SUBROUTINE DTRED2(NM,N,A,D,E,Z)
ckr
      IMPLICIT NONE
      INTEGER I,J,K,L,N,II,NM,JP1
      DOUBLE PRECISION A(NM,N),D(N),E(N),Z(NM,N)
      DOUBLE PRECISION F,G,H,HH,SCALE
ckr      REAL A(NM,N),D(N),E(N),Z(NM,N)
ckr      REAL F,G,H,HH,SCALE
ckr
      DO 100 I = 1, N
         DO 100 J = 1, I
            Z(I,J) = A(I,J)
  100 CONTINUE
      IF (N .EQ. 1) GO TO 320
      DO 300 II = 2, N
         I = N + 2 - II
         L = I - 1
         H = 0.0
         SCALE = 0.0
         IF (L .LT. 2) GO TO 130
         DO 120 K = 1, L
  120    SCALE = SCALE + ABS(Z(I,K))
         IF (SCALE .NE. 0.0) GO TO 140
  130    E(I) = Z(I,L)
         GO TO 290
  140    DO 150 K = 1, L
            Z(I,K) = Z(I,K) / SCALE
            H = H + Z(I,K) * Z(I,K)
  150    CONTINUE
         F = Z(I,L)
         G = -SIGN(SQRT(H),F)
         E(I) = SCALE * G
         H = H - F * G
         Z(I,L) = F - G
         F = 0.0
         DO 240 J = 1, L
            Z(J,I) = Z(I,J) / (SCALE * H)
            G = 0.0
            DO 180 K = 1, J
  180       G = G + Z(J,K) * Z(I,K)
            JP1 = J + 1
            IF (L .LT. JP1) GO TO 220
            DO 200 K = JP1, L
  200       G = G + Z(K,J) * Z(I,K)
  220       E(J) = G / H
            F = F + E(J) * Z(I,J)
  240    CONTINUE
         HH = F / (H + H)
         DO 260 J = 1, L
            F = Z(I,J)
            G = E(J) - HH * F
            E(J) = G
            DO 260 K = 1, J
               Z(J,K) = Z(J,K) - F * E(K) - G * Z(I,K)
  260    CONTINUE
         DO 280 K = 1, L
  280    Z(I,K) = SCALE * Z(I,K)
  290    D(I) = H
  300 CONTINUE
  320 D(1) = 0.0
      E(1) = 0.0
      DO 500 I = 1, N
         L = I - 1
         IF (D(I) .EQ. 0.0) GO TO 380
         DO 360 J = 1, L
            G = 0.0
            DO 340 K = 1, L
  340       G = G + Z(I,K) * Z(K,J)
            DO 360 K = 1, L
               Z(K,J) = Z(K,J) - G * Z(K,I)
  360    CONTINUE
  380    D(I) = Z(I,I)
         Z(I,I) = 1.0
         IF (L .LT. 1) GO TO 500
         DO 400 J = 1, L
            Z(I,J) = 0.0
            Z(J,I) = 0.0
  400    CONTINUE
  500 CONTINUE
      RETURN
      END
*CMZ :  1.02/01 23/10/98  18.05.00  by  Tancredi Carli
*CMZ :       1.02/00 02/10/98   23/10/98  18.04.38  by  Tancredi Carli
*-- Author :
*
*   $Id: tql2.F,v 1.1.1.1 1996/04/01 15:02:37 mclareni Exp $
*
* $Log: tql2.F,v $
* Revision 1.1.1.1  1996/04/01 15:02:37  mclareni
* Mathlib gen
*
*
*#include "gen/pilot.h"
      SUBROUTINE DTQL2(NM,N,D,E,Z,IERR)
ckr
      IMPLICIT NONE
ckr
      INTEGER I,J,K,L,M,N,II,NM,MML,IERR
ckr
      DOUBLE PRECISION D(N),E(N),Z(NM,N)
      DOUBLE PRECISION B,C,F,G,H,P,R,S,MACHEP
ckr      REAL D(N),E(N),Z(NM,N)
ckr      REAL B,C,F,G,H,P,R,S,MACHEP
ckr
*#if defined(CERNLIB_CDC)
      MACHEP=2.**(-47)
*#endif
*#if !defined(CERNLIB_CDC)
      MACHEP=2.**(-23)
*#endif
      IERR = 0
      IF (N .EQ. 1) GO TO 1001
      DO 100 I = 2, N
  100 E(I-1) = E(I)
      F = 0.0
      B = 0.0
      E(N) = 0.0
      DO 240 L = 1, N
         J = 0
         H = MACHEP * (ABS(D(L)) + ABS(E(L)))
         IF (B .LT. H) B = H
         DO 110 M = L, N
            IF (ABS(E(M)) .LE. B) GO TO 120
  110    CONTINUE
  120    IF (M .EQ. L) GO TO 220
  130    IF (J .EQ. 30) GO TO 1000
         J = J + 1
         P = (D(L+1) - D(L)) / (2.0 * E(L))
         R = SQRT(P*P+1.0)
         H = D(L) - E(L) / (P + SIGN(R,P))
         DO 140 I = L, N
  140    D(I) = D(I) - H
         F = F + H
         P = D(M)
         C = 1.0
         S = 0.0
         MML = M - L
         DO 200 II = 1, MML
            I = M - II
            G = C * E(I)
            H = C * P
            IF (ABS(P) .LT. ABS(E(I))) GO TO 150
            C = E(I) / P
            R = SQRT(C*C+1.0)
            E(I+1) = S * P * R
            S = C / R
            C = 1.0 / R
            GO TO 160
  150       C = P / E(I)
            R = SQRT(C*C+1.0)
            E(I+1) = S * E(I) * R
            S = 1.0 / R
            C = C * S
  160       P = C * D(I) - S * G
            D(I+1) = H + S * (C * G + S * D(I))
            DO 180 K = 1, N
               H = Z(K,I+1)
               Z(K,I+1) = S * Z(K,I) + C * H
               Z(K,I) = C * Z(K,I) - S * H
  180       CONTINUE
  200    CONTINUE
         E(L) = S * P
         D(L) = C * P
         IF (ABS(E(L)) .GT. B) GO TO 130
  220    D(L) = D(L) + F
  240 CONTINUE
      DO 300 II = 2, N
         I = II - 1
         K = I
         P = D(I)
         DO 260 J = II, N
            IF (D(J) .GE. P) GO TO 260
            K = J
            P = D(J)
  260    CONTINUE
         IF (K .EQ. I) GO TO 300
         D(K) = D(I)
         D(I) = P
         DO 280 J = 1, N
            P = Z(J,I)
            Z(J,I) = Z(J,K)
            Z(J,K) = P
  280    CONTINUE
  300 CONTINUE
      GO TO 1001
 1000 IERR = L
 1001 RETURN
      END
*CMZ :  2.00/04 31/07/2000  21.11.45  by  Tancredi Carli
*CMZ :  0.05/01 23/01/92  11.42.05  by  M. Erdmann
*-- Author :    G. Knies   24/07/91
      SUBROUTINE HEDECI (NX,NINI,IFLAG)
C----------------------------------------------------------------
C    PURPOSE:
C    INITIALIZE CONTROL COMMON FOR DECO
C
C        INPUT:  NX = no of final state vectors for the event
C        OUTPUT: COMMON QCTBUF
C
C
C   AUTHOR: G.KNIES, 24/04/91
c     modific. 26/06/91  all trax selection buisiness removed
c     modific. 19/07/91  for revised /qctbuf/
*D: QEDECI 00500 gk. add some safety
*D: QEDECI 00501 me. remove blank lines after end statement
C14/02.99 QEDECI => HEDECI for HZTOOL environment:
C14/02/99 initialize al reqired control parameters for running of DECO
C14/02/99 via CALL HEDECO, CALL HEDECX
C----------------------------------------------------------------
*
*    THE INPUT MOMENTA ARE TO BE FILLED INTO
*     COMMON/QCTBUF/..,QPI(I,IEVT) ELSEWHERE, afterwards
*    THE TOTAL NUMBER OF INPUT TRAX NX is supposed to be known
*#**********************************************************************

*KEEP,QJMACS.
C------------ /QJMACS/ --- Buffer for jet and topological routines -----
         INTEGER JTBIMX,JTBOMX,JPARMX,JTBI,JTBIT,JTBO,JTBOF
         DOUBLE PRECISION QPI,QTBIR,QPO,QTBOR
         PARAMETER (JTBIMX =10000,JTBOMX = 30,JPARMX = 5)
         COMMON /QCTBUF/QPI(5,JTBIMX),QTBIR(JPARMX,JTBIMX),
     +                  QPO(5,JTBOMX),QTBOR(JPARMX,JTBOMX),
     +                  JTBI,JTBIT(JTBIMX),
     +                  JTBO,JTBOF(JPARMX,JTBIMX)
C     jtbi       number of input vectors (max : jtbimx).
C     qpi(i,j)   particle input vector j; i=1,2,3,4:px,py,pz,e; i=5 free
C     jtbit(j)   pointer to corresponding q-vector
C     qtbir(k,j) scalar input k for each input vector j
C     jtbo       number of output jets   (max : jtbomx)
C     qpo(i,j)   jet output vector (jet axis) i=1,2,3,4:px,py,pz,e
C     jtbof(k,i) number of jet for input particle i in multiplet k
C     qtbor(k,j) scalar output result k for each jet j (k_max : jparmx)
C                (will be stored as user words in Q_vector)
*
*KEEP,DECOMA.
        INTEGER IPTMAX,IPTOT,ITRTOT,ITRSRC,MEVENT
     1,JETF,IFRAME,ITROFF,INIMUL,IDPREV, NCON, NPRI, IFLAGG, JETFU
     2,IREV
     3,MAXMUL,JORD,IFUPOS,MINPA,MAXCHA,ITERIJ,NEVPRI,MODUS
      COMMON/QCOCOM/IPTMAX,IPTOT,ITRTOT,ITRSRC,MEVENT
     1,JETF(10),JETNAM(10),IFRAME(10),ITROFF(10),INIMUL(10),IDPREV(10)
     2,IREV(10)
     3,MAXMUL,JORD,IFUPOS,MINPA,MAXCHA,ITERIJ(5),ECONF,NEVPRI,MODUS
      CHARACTER*4 JETNAM
      CHARACTER*7 JETNA

      PARAMETER (JPTMAX=150)
      PARAMETER (JFROFF=JPTMAX+50)
        REAL PJET,FTOP,LPJ
      COMMON/QRECOM/ PJET(10,15,10),FTOP(5,10),LPJ(JPTMAX+2,15,10)
*
*KEND.
*
      Integer NX,IFLAG,NINI
************************************************************************



         IFLAG=0
         IF(NINI.eq.2) goto 100
* initialize control common/QCOCOM/
         IPTMAX=JPTMAX
c... check if no more than JPTMAX particles
            IF (NX.GT.IPTMAX) GOTO 199
         JTBI=NX
         IFUPOS= 0
c14/02/99 fill deco jets into qctbuf
         modus=1
          DO 1 I=1,10
         JETF(I)=0
         IFRAME(I)=0
         ITROFF(I)=0
         JETNAM(I)='NULL'
         INIMUL(I)=10
         IDPREV(I)=-1
    1    CONTINUE
         ECONF=30.
         MINPA=1
         ITRSRC=0
C reset input qpi(i, ievt)
         DO 12 I=1,IPTMAX+50
         DO 13 K=1,5
         QTBIR(K,I)=0.
   13    QPI(K,I)=0.
   12    CONTINUE
         DO 6 I=1,JTBOMX
         DO 5 K=1,5
    5    QPO(K,I)=0.
         DO 6 K=1,JPARMX
         QTBOR(K,I)=0.
    6    CONTINUE
* branch for h1phan
       RETURN
c hier to fill jet vector 1, as initialisation for minimization
 100   NP=JTBI
          IF (JTBI.LT.MAXMUL) MAXMUL=JTBI
* sum up  accepted event momentum vector
               IEVT=IPTMAX+1
      DO 110 I=1,NP
      DO 101 I2=1,4
            QPI(I2,IEVT) = QPI(I2,IEVT)+QPI(I2,I)
  101 CONTINUE
            IF(QTBIR(1,I).EQ.0.)
     1      QTBIR(3,IEVT) = QTBIR(3,IEVT) + 1
  110       QTBIR(1,IEVT) = QTBIR(1,IEVT)+QTBIR(1,I)
      QPI(5,IEVT)=QPI(1,IEVT)**2 + QPI(2,IEVT)**2 + QPI(3,IEVT)**2
      QPI(5,IEVT)=SQRT(QPI(4,IEVT)**2 - QPI(5,IEVT))
         IF(NEVPRI.GE.2) THEN
         PRINT *,('EDECI,TRAX',I,(QPI(K,I),K=1,5),QTBIR(1,I),I=1,JTBI)
         PRINT *,IEVT,(QPI(JJ,IEVT),JJ=1,5),QTBIR(1,IEVT),QTBIR(3,IEVT)
         PRINT *,'EDECI, TOTAL NUMBER AND INDEX OF TRAX',
     1 JTBI, (JTBIT(I),I=1,JTBI)
         ENDIF
*
*****
      RETURN

 199  CONTINUE
      IFLAG=1
      PRINT *,'*** PROBLEM *** MORE THAN 150 TRAX IN EVENT:',MEVENT
     1,'EVENT IGNORED'
      RETURN
      END
*CMZ :  2.00/04 31/07/2000  21.11.45  by  Tancredi Carli
*CMZ :  0.03/03 05/08/91  16.48.18  by  G. Knies
*-- Author :    G. Knies   24/07/91
         SUBROUTINE HEDECO (JETFU,NAMJET,ICMS,INIMU,IPREV,IREVE)
C----------------------------------------------------------------
C   PURPOSE:
C        REQUEST FOR AN EVENT DECOMPOSITION
C        SPECIFICATION OF THE DECO MODE
*     the option of boosting the input vectors into a different LORENTZ
*     frame has been removed, for HZTOOL environment, 14/02/99
C        INPUT: COMMON/QCTBUF/ TRAX VECTORS QPI(5,I) AT 1=<I<=ITBI
C               MODE-SPECIFYING PARAMETERS AS ARGUMENTS
C        OUTPUT: COMMON /QCTBUF/ TRAX VECTORS IN REQUESTED DECO FRAME
C                COMMON/ECOCOM/
C
C   AUTHOR: G.KNIES, 24/04/91
C    adapted for HZTOOL environment, 14/02/99, G.K.
C----------------------------------------------------------------
*
*  MODIFICATIONS
*   12/06/91 charge and mass included into transformed event QPI vector
************************************************************************

*SEQ, BCS.
*KEEP,QJMACS.
C------------ /QJMACS/ --- Buffer for jet and topological routines -----
         INTEGER JTBIMX,JTBOMX,JPARMX,JTBI,JTBIT,JTBO,JTBOF
         DOUBLE PRECISION QPI,QTBIR,QPO,QTBOR
         PARAMETER (JTBIMX =10000,JTBOMX = 30,JPARMX = 5)
         COMMON /QCTBUF/QPI(5,JTBIMX),QTBIR(JPARMX,JTBIMX),
     +                  QPO(5,JTBOMX),QTBOR(JPARMX,JTBOMX),
     +                  JTBI,JTBIT(JTBIMX),
     +                  JTBO,JTBOF(JPARMX,JTBIMX)
C     jtbi       number of input vectors (max : jtbimx).
C     qpi(i,j)   particle input vector j; i=1,2,3,4:px,py,pz,e; i=5 free
C     jtbit(j)   pointer to corresponding q-vector
C     qtbir(k,j) scalar input k for each input vector j
C     jtbo       number of output jets   (max : jtbomx)
C     qpo(i,j)   jet output vector (jet axis) i=1,2,3,4:px,py,pz,e
C     jtbof(k,i) number of jet for input particle i in multiplet k
C     qtbor(k,j) scalar output result k for each jet j (k_max : jparmx)
C                (will be stored as user words in Q_vector)
*
*KEEP,DECOMA.
        INTEGER IPTMAX,IPTOT,ITRTOT,ITRSRC,MEVENT
     1,JETF,IFRAME,ITROFF,INIMUL,IDPREV, NCON, NPRI, IFLAGG, JETFU
     2,IREV
     3,MAXMUL,JORD,IFUPOS,MINPA,MAXCHA,ITERIJ,NEVPRI,MODUS
      COMMON/QCOCOM/IPTMAX,IPTOT,ITRTOT,ITRSRC,MEVENT
     1,JETF(10),JETNAM(10),IFRAME(10),ITROFF(10),INIMUL(10),IDPREV(10)
     2,IREV(10)
     3,MAXMUL,JORD,IFUPOS,MINPA,MAXCHA,ITERIJ(5),ECONF,NEVPRI,MODUS
      CHARACTER*4 JETNAM
      CHARACTER*7 JETNA

      PARAMETER (JPTMAX=150)
      PARAMETER (JFROFF=JPTMAX+50)
        REAL PJET,FTOP,LPJ
      COMMON/QRECOM/ PJET(10,15,10),FTOP(5,10),LPJ(JPTMAX+2,15,10)
*
*KEND.
*
      CHARACTER*4 NAMJET
************************************************************************
C  increment call nr. ifupos = jet FUnction POSition in calling sequence
      IFUPOS=IFUPOS+1
      IF(IFUPOS.GT.10) GOTO 99
      JETF(IFUPOS)=JETFU
      JETNAM(IFUPOS)=NAMJET
      IFRAME(IFUPOS)=ICMS
      INIMUL(IFUPOS)=INIMU
      IDPREV(IFUPOS)= -1
      IF(INIMU.EQ.0) IDPREV(IFUPOS)= IPREV
      IREV(IFUPOS)=IREVE
C  allocate appropriate qpi range;
C   for DECO of event as given in qpi(,1...): itroff=0
      IF(ICMS.EQ.0)   THEN
                      ITROFF(IFUPOS)=0
                      ENDIF

  100 RETURN
   99 PRINT *,'TOO MANY JET FUNCTION CALLS, CALL IGNORED.'
      RETURN
      END
*CMZ :  2.00/04 31/07/2000  21.11.45  by  Tancredi Carli
*CMZ :  0.03/03 16/08/91  13.43.37  by  G. Knies
*-- Author :    G. KNIES   24/07/91
      SUBROUTINE HEDECX(IFLAG)
************************************************************************
* * SR EDECX , HEDECX for HZTOOL
* * PURPOSE:                                                           *
*      EXECUTE EVENT DECO LOOPS                                        *
*       over all multiplets from 2 =< jetmul <=maxmul                  *
*            over all requested jet functions (jetf(indec)> 0)         *
*      CALLS EVENT DECO AND RESULT SAVING ROUTINES (jetmul,indec)      *
* * INPUT:  MOMENTUM VECTORS OF AN EVENT, IN /QCTBUF/                  *
*           INSTRUCTIONS ON DECOMPOSITION MODES, IN /QCOCOM/           *
* * OUTPUT: JET VECTORS,PARTICLE MEMBER LISTS OF JETS,                 *
*           TOPOLOGICAL JET FUNCTION VALUES                            *
*           FOR UP TO 4 MULTIPLETS (2-5)                               *
*           FOR UP TO 10 JETFUNCTIONS                                  *
*           in common/QRECOM/                                          *
* * AUTHOR: GERHARD KNIES   04-02-1991                                 *
*           modific. 19-07-91 for h1phan environment                   *
*           modific. 08-08-91 for L=1 bank and test print              *
*
*     14/02/99: adapted for HZTOOL environment: remved CALL QESAVE     *
C **********************************************************************

*KEEP,DECOMA.
        INTEGER IPTMAX,IPTOT,ITRTOT,ITRSRC,MEVENT
     1,JETF,IFRAME,ITROFF,INIMUL,IDPREV, NCON, NPRI, IFLAGG, JETFU
     2,IREV
     3,MAXMUL,JORD,IFUPOS,MINPA,MAXCHA,ITERIJ,NEVPRI,MODUS
      COMMON/QCOCOM/IPTMAX,IPTOT,ITRTOT,ITRSRC,MEVENT
     1,JETF(10),JETNAM(10),IFRAME(10),ITROFF(10),INIMUL(10),IDPREV(10)
     2,IREV(10)
     3,MAXMUL,JORD,IFUPOS,MINPA,MAXCHA,ITERIJ(5),ECONF,NEVPRI,MODUS
      CHARACTER*4 JETNAM
      CHARACTER*7 JETNA

      PARAMETER (JPTMAX=150)
      PARAMETER (JFROFF=JPTMAX+50)
        REAL PJET,FTOP,LPJ
      COMMON/QRECOM/ PJET(10,15,10),FTOP(5,10),LPJ(JPTMAX+2,15,10)
*
*KEEP,QJMACS.
C------------ /QJMACS/ --- Buffer for jet and topological routines -----
         INTEGER JTBIMX,JTBOMX,JPARMX,JTBI,JTBIT,JTBO,JTBOF
         DOUBLE PRECISION QPI,QTBIR,QPO,QTBOR
         PARAMETER (JTBIMX =10000,JTBOMX = 30,JPARMX = 5)
         COMMON /QCTBUF/QPI(5,JTBIMX),QTBIR(JPARMX,JTBIMX),
     +                  QPO(5,JTBOMX),QTBOR(JPARMX,JTBOMX),
     +                  JTBI,JTBIT(JTBIMX),
     +                  JTBO,JTBOF(JPARMX,JTBIMX)
C     jtbi       number of input vectors (max : jtbimx).
C     qpi(i,j)   particle input vector j; i=1,2,3,4:px,py,pz,e; i=5 free
C     jtbit(j)   pointer to corresponding q-vector
C     qtbir(k,j) scalar input k for each input vector j
C     jtbo       number of output jets   (max : jtbomx)
C     qpo(i,j)   jet output vector (jet axis) i=1,2,3,4:px,py,pz,e
C     jtbof(k,i) number of jet for input particle i in multiplet k
C     qtbor(k,j) scalar output result k for each jet j (k_max : jparmx)
C                (will be stored as user words in Q_vector)
*
*KEND.
*
      DIMENSION ITBOR(JPARMX,JTBOMX)
      EQUIVALENCE(QTBOR(1,1),ITBOR(1,1))
      CHARACTER*4 NAMOUL
C  ***  DECOMPOSE EVENTS INTO  SUBSETS
C  WITH GROWING MULTIPLICITY L, I.E. INTO 2-, 3-, 4-AND 5-JET SYSTEMS
C  THE EVENT WILL BE DECOMPOSED INTO A SEQUENCE OF JET MULTIPLETS
C   MULTIPLETS L             JET NAMES JND
C   FULL EVENT=1             1,
C               =>2            2,3,
C                  =>3             4,5,6,
C                     =>4                7,8,9,10,
C                        =>5                      11,12,13,14,15
C
C  *******************  OUTPUT PARAMETERS   **************************
C   THE RESULTS OF THE DECOMPOSITION ARE:
C   1. JET MEMBER LIST:
C     ITR = LPJ(I,JND,INDEC)  FOR QPI(,ITR) 2<I FOR TRAX I IN JET JND
C   2. JET MOMENTA
c      PJET(K,JND,INDEC)
c    K=1,..5  px,..m
C      6      charge
C      7      neutrals
C      8      momentum
C    JND=1,..15; JETS for DECOMPOSITION from call nr. INDEC
C **********************************************************************
C
C   DECO IS CONTROLLED BY THE CHOICE OF THE JET FUNCTION "JETFU",
C    PARAMETER JETFU SELECTS THE JETFUNCTION TO BE MINIMIZED
C     JETFU    1    (2)     3    4   (5)     6     7  8  9  10  *****
C             -P  (-BETA)   M   M**2 (PETEE) USER   USER USER
C
C   DECO CAN BE INFLUENCED BY SOME BOUNDARY CONDITIONS.
C    MAXMUL = JET MULTIPLICITY UP TO WHICH THE DECOMPOSITION
C     IS TO BE PERFORMED. MAXMUL<=5
C    MINPA = MINIMUM NO OF PARTICLES IN A JET
C   (EC2: A CUT-OFF PARAMETER FOR BETA; NOT USED)
C   IFRAME CONTROLS THE FRAME OF REFERENCE IN WHICH TO DECOMPOSE
C       for initial sign of life
      IF(NEVPRI.LE.1) GOTO 1
      DO 2 I=1,10
      IF(JETF(I).EQ.0) GOTO 2
      PRINT *,'EDECX, INDEC=',I,' JETFU=',JETF(I),' JETNAME=',JETNAM(I)
     1,' IFRAME=',IFRAME(I),'ITROFF=',ITROFF(I),'INIMU=',INIMUL(I)
     2,'MAXMUL',MAXMUL
   2  CONTINUE
      DO 3 I=1,JTBI
      IF(QPI(4,I).LE.0.) GOTO 3
      PRINT *,'EDECX1, TRAX#, QX,Y,Z,E,M=',I,(QPI(K,I),K=1,5)
   3  CONTINUE
   1  CONTINUE
C

************************************************************************
*       CLEAR AND INITIALIZE JET LISTS LPJ(I,JET,INDEX)   0<I<153      *
*                            JET VECTORS PJET(K,JET,INDEX) 0<K<11      *
************************************************************************
C clear ...
      DO 13 INDEC=1,10
      IF(JETF(INDEC).LE.0) GOTO 13
      DO 19 L=1,5
      FTOP(L,INDEC)=0.
   19 CONTINUE
      DO 12 JND=1,15
      DO 11 I11=1,IPTMAX+2
      LPJ(I11,JND,INDEC)=0
   11 CONTINUE
      DO 14 I14=1,10
   14 PJET(I14,JND,INDEC)=0.
   12 CONTINUE
   13 CONTINUE
C INITIALIZE JET MEMBER LIST LPJ(I>2,JND=1,INDEC)
C    SETTLE STARTING JET ADDRESS JP, AND VECTOR PJET(,JP,INDEC)
C    FOR ALL REQUESTED DECO MODES INDEC
      IEVT=1+IPTMAX
      DO 15 INDEC=1,10
      IF(JETF(INDEC).LE.0) GOTO 15
      JP = 1
      LPJ(1,1,INDEC)=JTBI
      LPJ(2,1,INDEC)=JP
      DO 16 I=1,JTBI
      LPJ(I+2,1,INDEC)=I
   16 CONTINUE
      DO 17 K=1,5
   17 PJET(K,JP,INDEC)=QPI(K,ITROFF(INDEC) + IEVT)
      PJET(6,JP,INDEC)=QTBIR(1,ITROFF(INDEC) + IEVT)
c  save and test print initialisation
      IF(JETF(INDEC).EQ.4) FTOP(1,INDEC)=PJET(5,1,INDEC)**2
      IF(JETF(INDEC).EQ.3) FTOP(1,INDEC)=PJET(5,1,INDEC)
      JETMUL=1
C14/02/99      CALL QESAVE(INDEC,JETMUL)
      IF(MODUS.EQ.1)  CALL HEPHAN(INDEC,JETMUL)
         IF(NEVPRI.GE.1) THEN
         DFTOP=0.
         NAMOUL=JETNAM(INDEC)
         FTOPO=FTOP(JETMUL,INDEC)
         PRINT *,'MULTIPLET=',JETMUL,' INDEC=',INDEC
     1,'JET NAME=',NAMOUL,' TOPOL FU =',FTOPO,'CHANGE=',DFTOP
      JND=1
      PRINT *,'JET NAME,#,MOM,CH,NPJ='
     1,NAMOUL,JND,(PJET(K,JND,INDEC),K=1,6),LPJ(1,JND,INDEC)
         ENDIF
   15 CONTINUE

************************************************************************
*       MINIMIZATION PART                                              *
************************************************************************
* ------   JET MULTIPLICITY LOOP   ------------------------------------*
*
      DO 100 JETMUL=2,MAXMUL
C                           DECOMPOSITION :  JETMUL-1 => JETMUL
C   range of jet numbers: JNDL =< JND =< JNDH
      JNDH=JETMUL*(JETMUL+1)/2
      JTMLM1=JETMUL-1
      JNDL=JNDH-JTMLM1
      JNDHM1=JNDH-1
      JNDLM1=JNDL-1
C
*-------   JET FUNCTIONS LOOP JETFU(INDEC)  ---------------------------*
*
      DO 110 INDEC=1,10
      JETFU=JETF(INDEC)
      IF (JETFU.LE.0) GOTO 110
      NAMOUL=JETNAM(INDEC)
      INIMU=INIMUL(INDEC)
      IF(INDEC.EQ.1) INIMU= -1
************************************************************************
*          INITIALIZE STARTING CONFIGURATION FOR JETMUL FROM           *
*            - (same jetfu, Previos jetMul)  IDECPM,inimul=-1          *
*            - (Previos jetFu, same jetmul)  IDECPF,inimul= 0          *
************************************************************************
      IF(NEVPRI.GE.2)
     1PRINT *,'EDECX3, INIMU=',INIMU,'INDEC=',INDEC,'JND=',JNDL,JNDH
     2,'JETFU=',JETFU
      IF(INIMU.EQ.-1) CALL QDECPM(JETMUL,INDEC)
      IF(INIMU.EQ.0) CALL QDECPF(JETMUL,INDEC,IDPREV(INDEC))
        FTOPO=0.
************************************************************************
*      DO DECOMPOSITION UNTIL MIN VALUE OF EVENT SHAPE FUNCTION FOUND  *
************************************************************************
       CALL QEMIN1(JETMUL,INDEC,DFTOP,FTOPO)
      FTOP(JETMUL,INDEC)=FTOPO
C
          IF(NEVPRI.GE.2)THEN
         PRINT *,'**DECO** 1. MINIMUM, MULTIPLET=',JETMUL,'INDEC=',INDEC
     1,'JET NAME=',JETNAM(INDEC),'TOPOL FU =',FTOPO,'CHANGE=',DFTOP
      DO 103 J=1,JETMUL
      JND=J+JNDLM1
      IF(PJET(4,JND,INDEC).LE.0.) GOTO 103
      PRINT *,'JET NAME,#,MOM,CH,NPJ='
     1,NAMOUL,J,(PJET(K,JND,INDEC),K=1,6),LPJ(1,JND,INDEC)
 103  CONTINUE
          ENDIF
C
************************************************************************
*      GO REVERSE GEAR, IF REQUESTED, FOR MREV STEPS                   *
************************************************************************
      IF(IREV(INDEC).LT.1) GOTO 101
       MREV=LPJ(1,1,INDEC)*0.13
       CALL QEMIN2(JETMUL,INDEC,DFT,FT,MREV,NEW,IFLAG)
      IF (IFLAG.NE.0) GOTO 99
      IF(NEW.EQ.0) GOTO 101
      FTOPO=FT
      FTOP(JETMUL,INDEC)=FTOPO
      DFTOP=DFTOP + DFT
          IF(NEVPRI.GE.2)THEN
         PRINT *,'**DECO** 2. MINIMUM FOUND'
          ENDIF
C
 101    CONTINUE
         IF(NEVPRI.GE.1) THEN
         PRINT *,'MULTIPLET=',JETMUL,' INDEC=',INDEC
     1,'JET NAME=',JETNAM(INDEC),' TOPOL FU =',FTOPO,'CHANGE=',DFTOP
      DO 104 J=1,JETMUL
      JND=J+JNDLM1
      IF(PJET(4,JND,INDEC).LE.0.) GOTO 104
      PRINT *,'JET NAME,#,MOM,CH,NPJ='
     1,NAMOUL,J,(PJET(K,JND,INDEC),K=1,6),LPJ(1,JND,INDEC)
 104  CONTINUE
         ENDIF
C                                                  END JET FUNCTION LOOP
C                        SAVE RESULT FOR THIS MULTIPLET AND JET FUNCTION
C  FILL MULTIPLET BANK
C14/02/99      CALL QESAVE(INDEC,JETMUL)
C  FILL QCTBUF, HEPHAN does not invoke any PHAN stuff, except for qctbuf
      IF(MODUS.EQ.1)  CALL HEPHAN(INDEC,JETMUL)
 110    CONTINUE
C                                              END JET MULTIPLICITY LOOP
 100    CONTINUE
      RETURN
C ERROR EXIT
  99  CONTINUE
      PRINT *,'** ERROR ** WITH EMIN2, AT L=',JETMUL,'INDEC=',INDEC
      RETURN
      END
*CMZ :  2.00/04 31/07/2000  21.11.45  by  Tancredi Carli
*CMZ :  0.03/03 16/08/91  13.31.06  by  G. Knies
*-- Author :    G. Knies   24/07/91
         SUBROUTINE HEPHAN(INDEC,JETMUL)
C----------------------------------------------------------------
C        Write result from EVENT DECOMPOSITION algorithm EVDECO
C             for ONE JET FUNCTION(INDEC) and ONE MULTIPLET(JETMUL)
C             to common/QCTBUF/
C
C        INPUT:
C               COMMON/RECOM/,/COCOM/
C        OUTPUT:
C               COMMON/QCTBUF/
C         QPO(1,2,3,4,5;JND) is the 4-vector of jet JND>1
C         QTBOR(1,2,3,4,5;JND) has charge(1),no of particles(2)
C         JTBOF(L,I) jet # to which particle I is asigned in multipl. L
C
C
C   AUTHOR: G.KNIES, 22/07/91
C----------------------------------------------------------------
*

*SEQ, BCS.

*KEEP,DECOMA.
      COMMON/QCOCOM/IPTMAX,IPTOT,ITRTOT,ITRSRC,MEVENT
     1,JETF(10),JETNAM(10),IFRAME(10),ITROFF(10),INIMUL(10),IDPREV(10)
     2,IREV(10)
     3,MAXMUL,JORD,IFUPOS,MINPA,MAXCHA,ITERIJ(5),ECONF,NEVPRI,MODUS
      CHARACTER*4 JETNAM

      PARAMETER (JPTMAX=150)
      PARAMETER (JFROFF=JPTMAX+50)
      COMMON/QRECOM/ PJET(10,15,10),FTOP(5,10),LPJ(JPTMAX+2,15,10)
*KEND.

*KEEP,QJMACS.
C------------ /QJMACS/ --- Buffer for jet and topological routines -----
         INTEGER JTBIMX,JTBOMX,JPARMX,JTBI,JTBIT,JTBO,JTBOF
         DOUBLE PRECISION QPI,QTBIR,QPO,QTBOR
         PARAMETER (JTBIMX =10000,JTBOMX = 30,JPARMX = 5)
         COMMON /QCTBUF/QPI(5,JTBIMX),QTBIR(JPARMX,JTBIMX),
     +                  QPO(5,JTBOMX),QTBOR(JPARMX,JTBOMX),
     +                  JTBI,JTBIT(JTBIMX),
     +                  JTBO,JTBOF(JPARMX,JTBIMX)
C     jtbi       number of input vectors (max : jtbimx).
C     qpi(i,j)   particle input vector j; i=1,2,3,4:px,py,pz,e; i=5 free
C     jtbit(j)   pointer to corresponding q-vector
C     qtbir(k,j) scalar input k for each input vector j
C     jtbo       number of output jets   (max : jtbomx)
C     qpo(i,j)   jet output vector (jet axis) i=1,2,3,4:px,py,pz,e
C     jtbof(k,i) number of jet for input particle i in multiplet k
C     qtbor(k,j) scalar output result k for each jet j (k_max : jparmx)
C                (will be stored as user words in Q_vector)
*
*KEND.
      DIMENSION ITBOR(5,JTBOMX)
      EQUIVALENCE(QTBOR(1,1),ITBOR(1,1))

*                                                  *******************

C  FILL QCTBUF
C     JTBO       NUMBER OF OUTPUT JETS (<=15)
C     QPO(K,J)   MOMENTUM VECTOR FOR JET J (j=2, ... ,jtbo
C                  K=1,2,3,4:PX,PY,PZ,E; 5=mass,
C                  J= (2,3);(4,5,6);(7,8,9,10);(11,12,13,14,15)
C                for L= 2      3        4             5, multiplet
C     JTBOF(L,I) JET # JL TO WHICH PARTICLE I BELONGS IN MULTIPLET L
C                 (JL= 1,2; 1,2,3; 1,2,3,4; 1,2,3,4,5)
C     QTBOR(K,J)  FURTHER INFORMATION ON JET J
C                 k=1=charge,2=particles,3=neutrals,
*
      JNDH=JETMUL*(JETMUL+1)/2
      JNDLM1=JNDH - JETMUL
      JTBO=JNDH
      DO 102 J=1,JETMUL
      JND=J+JNDLM1
      NPJ=LPJ(1,JND,INDEC)
      ITBOR(2,JND)=NPJ
      QTBOR(1,JND)=PJET(6,JND,INDEC)
      DO 103 I=1,NPJ
      IPA=LPJ(2+I,JND,INDEC)
      JTBOF(JETMUL,IPA)=J
C         IPA=THE QPI(,IPA) PARTICLE AT POSITION I IN JET J
C         LPJ: INPUT MOMENTUM QPI(,LPJ(I))
  103 CONTINUE
C
      DO 104 I=1,5
      QPO(I,JND)=PJET(I,JND,INDEC)
  104 CONTINUE
  102 CONTINUE
      QTBOR(2,1)=FTOP(JETMUL,INDEC)
          IF(NEVPRI.GE.2)THEN
      PRINT *,'QCTBUF MADE, FOR MULTIPLET',JETMUL
     1,' TOPOL FU=',JETNAM(INDEC),' INDEC=',INDEC
            IF(JETMUL.EQ.MAXMUL) THEN
      DO 200 I=1,JTBI
      PRINT *,' QPI(1-5,I), I,IVEC=',I,JTBIT(I),(QPI(K,I),K=1,5)
      PRINT *,' QTBIR(1-5,I), I=',I,(QTBIR(K,I),K=1,5)
      PRINT *,' JET MEMBERSHIP IN L=1-5:',(JTBOF(L,I),L=1,5)
  200 CONTINUE
             ENDIF
      DO 201 J=1,JTBOMX
      PRINT *,' QPO(1-5,J), J=',J,(QPO(K,J),K=1,5)
      PRINT *,' QTBOR(1-5,J), J=',J,(QTBOR(K,J),K=1,5)
  201 CONTINUE
          ENDIF



         RETURN
         END
*CMZ :  2.00/04 31/07/2000  21.11.45  by  Tancredi Carli
*CMZ :  0.05/00 16/12/91  20.44.49  by  M. Erdmann
*-- Author :    C. Jacobsson   24/07/91
*-- Author :    G. KNIES       24/07/91
      SUBROUTINE HGDECO(NAMOUT,JETFU,MAXML,NCON,NPRI,IFLAG)
************************************************************************
*      QGDECO IS THE MAIN ROUTINE FOR EVENT DECOMPOSITION
*      HGDECO is for use in HZTOOL environment, 15/02/99, G.K.
**         when called in H1PHAN, from sr. QJDECO
*      the input arguments are
*       NAMOUT CHARACTER*7 the multiplet (jet)name given in HZ97210
C14/02/99 or in HZ97210
*       NAMOUT characters 1..4 are used as name for multiplet banks
*       eg. NAMOUT='MSQDECO' using m**2 as jet function in DECo method
*        the result for multiplet L then is in qctbuf/ ..,qpo(,)
*        the jets of multiplet L listen to 'MSQDECOL', L=2,3,4,or 5
*            in H1PHAN.
*
*       JETFU  selects the topological function
*              1=invariant n-dimensional thrust
*              3=sum of jet masses
*              4=sum of jet (masses)**2
*       MAXML  set the maximum of jet multiplicity up to which DECO goes
*               2=< MAXMUL<=5
*       NPRI   print out level: 0=none,1=jet results,2=details for debug
*       IFLAG  NE.0  if no decomposition done because of problems
*
*D: QGDECO 00500 gk. cosmetics
c14/02/99  call for QEDECI removed, is transferred to sr HZ97210
******************************************************************

*KEEP,QJMACS.
C------------ /QJMACS/ --- Buffer for jet and topological routines -----
         INTEGER JTBIMX,JTBOMX,JPARMX,JTBI,JTBIT,JTBO,JTBOF
         DOUBLE PRECISION QPI,QTBIR,QPO,QTBOR
         PARAMETER (JTBIMX =10000,JTBOMX = 30,JPARMX = 5)
         COMMON /QCTBUF/QPI(5,JTBIMX),QTBIR(JPARMX,JTBIMX),
     +                  QPO(5,JTBOMX),QTBOR(JPARMX,JTBOMX),
     +                  JTBI,JTBIT(JTBIMX),
     +                  JTBO,JTBOF(JPARMX,JTBIMX)
C     jtbi       number of input vectors (max : jtbimx).
C     qpi(i,j)   particle input vector j; i=1,2,3,4:px,py,pz,e; i=5 free
C     jtbit(j)   pointer to corresponding q-vector
C     qtbir(k,j) scalar input k for each input vector j
C     jtbo       number of output jets   (max : jtbomx)
C     qpo(i,j)   jet output vector (jet axis) i=1,2,3,4:px,py,pz,e
C     jtbof(k,i) number of jet for input particle i in multiplet k
C     qtbor(k,j) scalar output result k for each jet j (k_max : jparmx)
C                (will be stored as user words in Q_vector)
*
*KEEP,DECOMA.
        INTEGER IPTMAX,IPTOT,ITRTOT,ITRSRC,MEVENT
     1,JETF,IFRAME,ITROFF,INIMUL,IDPREV, NCON, NPRI, IFLAGG, JETFU
     2,IREV
     3,MAXMUL,JORD,IFUPOS,MINPA,MAXCHA,ITERIJ,NEVPRI,MODUS
      COMMON/QCOCOM/IPTMAX,IPTOT,ITRTOT,ITRSRC,MEVENT
     1,JETF(10),JETNAM(10),IFRAME(10),ITROFF(10),INIMUL(10),IDPREV(10)
     2,IREV(10)
     3,MAXMUL,JORD,IFUPOS,MINPA,MAXCHA,ITERIJ(5),ECONF,NEVPRI,MODUS
      CHARACTER*4 JETNAM
      CHARACTER*7 JETNA

      PARAMETER (JPTMAX=150)
      PARAMETER (JFROFF=JPTMAX+50)
        REAL PJET,FTOP,LPJ
      COMMON/QRECOM/ PJET(10,15,10),FTOP(5,10),LPJ(JPTMAX+2,15,10)
*
*KEND.
*
      CHARACTER*4 NJETFU
      CHARACTER*7 NAMOUT
      DATA NCALL/0/
      NCALL=NCALL+1
      IFLAG=0
      MEVENT=NCALL
      MODE=1
C  to be set by user
      NEVPRI=NPRI
      MAXMUL=MAXML
      IF(NCALL.LE.1)
     1PRINT *,'*** ART DECO for EVENT DECOMPOSITION into JETS ***'
      IF(NCALL.LE.1)
     2PRINT *,' *** TOPOL FU NR.',JETFU,'MAX. MULTIPLET=',MAXML,'***'
      IF(NPRI.GE.1)
     1PRINT *,'* ART DECO CALL#',NCALL,'JETFU#',JETFU,'MAXMUL=',MAXML
*      CALL HEDECI(MODE,IFLAG)
*        SUBROUTINE EDECI (NAMIN.NUMIN,MODE,NCON,IFLAG)
*       IF (IFLAG.NE.0) THEN
*        PRINT *,'DECO INITIALISATION FAILED FOR EVENT:',NCALL
*        RETURN
*       ENDIF
      ICMS=0
      INIMU=-1
      IPREV=1
      IREVER=NCON
      NJETFU=NAMOUT(:4)
      CALL HEDECO(JETFU,NJETFU,ICMS,INIMU,IPREV,IREVER)
      INDEX=1
      CALL HEDECX(IFLAG)
      IF (IFLAG.NE.0) PRINT *,'** ERROR ** IN EDECX'
      RETURN
      END
*CMZ :  2.00/04 31/07/2000  21.11.45  by  Tancredi Carli
*CMZ :  2.03/09 02/11/96  23.51.48  by  Joerg Marks
*CMZ :  1.06/00 07/03/94  21.45.36  by  P. Schleper
*CMZ :  1.01/02 12/05/92  10.27.54  by  M. Erdmann
*CMZ :  1.00/00 10/03/92  14.25.00  by  M. Erdmann
*CMZ :          07/03/94  19.12.56  by  G. Knies
*-- Author :    G. Knies   07/03/94
      SUBROUTINE QDECPM(JETML,INDEC)
      INTEGER JETML,INDEC
************************************************************************
*   PURPOSE:
*      DOES INITIALIZATION FOR DECOMPOSITION
*       idecPM initializes deco step from Previos Multiplet
*       idecSM initializes deco step from Same Multiplet of previosly
*        performed deco with another topological function(jetfu(index))
*        here index < indec !
*      SEARCHES FOR (1.) MINIMUM,
*        without repeated migration of a particle
*
*  AUTHOR: Gerhard Knies,
C
C     VERSION OF 31/1/91  CAN BE CALLED FOR JETMULTIPL    2<=JETMUL<=5
C     VERSION OF 15/2/91  CAN BE CALLED JETFUNCTION INDEX 1<=INDEC<=10
C     VERSION OF 10/6/91  covariant N-directional thrust included
C  ***************  INPUT PARAMETERS  ********************************
C  *
C   JETMUL = THE RESULTING MULTIPLICITY OF JETS,
C     COLD START: THE I=JETMUL-1 RESULT IS STARTING CONFIGURATION
C     WARM START: REFINEMENT OF A J=JETMUL MULTPLICITY DECOMPOSITION
C   MAXMUL = THE MAXIMUM NUMBER OF JETS INTO WHICH THE EVENT SHALL
C     BE DECOMPOSED.
C     IF JETMUL > MAXMUL, ONLY INITIALISATION OF STARTING CONFIGURATION.
C   MINPA  = MINIMUM NUMBER OF PARTICLES REQUESTED FOR A JET
C
C     VIA COMMON/QCTBUF/
C   JTBI  = NUMBER OF INPUT VECTORS FOR CURRENT EVENT (MAX : JTBIMX)
C   QPI(I,IPA) THE INPUT PARTICLE MOMENTUM VECTORS, 1=<IPA<=JTBI
C               I=1,2,3,4,5: PX,PY,PZ,E,M; I=6: CHARGE
C  *
C  *******************  OUTPUT PARAMETERS   **************************
C  *
C   PJET(10,15,10) provides space for ALL RESULTING JETS
C    CONTENT of PJET(K,JND,INDEC)
C    K=1,..5  px,..m
C      6      charge
C      7      neutrals
C      8      momentum
C  *
C  ****************  INTERNAL PARAMETERS  **************************
C  *
C   THE (INTERNAL) JET "NAMES" ARE "JND":
C    1-JET DECO: JND = 1 (TRIVIAL, UNDECOMPOSED EVENT)
C    2-JET DECO: JND = 2,3
C    3-JET DECO: JND = 4,5,6
C    4-JET DECO: JND = 7,8,9,10
C    5-JET DECO: JND = 11,12,13,14,15
C    JINDH = HIGHEST JET NAME AT JND= JETMUL*(JETMUL+1)/2
C    JINDL = LOWEST JET NAME AT JND = JINDH - (JETMUL-1)
C
C   LIST OF PARTICLE ASSIGNMENTS TO JETS IN ARRAY LPJ(I,JND,INDEC)
C    LPJ(I,JND,INDEC) = IPA INDEX FOR PARTICLES IN SUBSET JND, AT I>2
C    LPJ(1,JND,INDEC) = (CURRENT) NO. OF PARTICLES IN JET JND
C    LPJ(2,JND,INDEC) = JND (redundant)
C  *
C  *********************************************************************
C
C   THE DECOMPOSITION
C    IS CONTROLLED BY THE CHOICE OF THE JET FUNCTION "JETFU",
C    AND CAN BE INFLUENCED BY SOME BOUNDARY CONDITIONS.
C   JETFU SELECTS THE JETFUNCTION TO BE MINIMIZED
C     JETFU    1     2      3    4    5      6     7  8  9  10  *****
C             -P   -BETA    M   M**2  PETEE  USER   USER USER
C
c
C                                                        INTERNAL ARRAYS
C     LDC(I)     NO OF CURRENT VALID PARTICLES IN SET I
C     LDA(I)     NO OF ORIGINAL + IMMIGRATED PARTICLES IN SET I
C
*D: QEMIN1 10000 gk. data statement added to avoid compilat.complaints
*D: QEMIN1 10102 me. lower case to upper case
*D: QEMIN1 10600 ps. remove unreachable code
*D: QEMIN1 20309 jm. fix compiler bug on the VAX found by S.B.
*KEEP,DECOMA.
      COMMON/QCOCOM/IPTMAX,IPTOT,ITRTOT,ITRSRC,MEVENT
     1,JETF(10),JETNAM(10),IFRAME(10),ITROFF(10),INIMUL(10),IDPREV(10)
     2,IREV(10)
     3,MAXMUL,JORD,IFUPOS,MINPA,MAXCHA,ITERIJ(5),ECONF,NEVPRI,MODUS
      CHARACTER*4 JETNAM

      PARAMETER (JPTMAX=150)
      PARAMETER (JFROFF=JPTMAX+50)
      COMMON/QRECOM/ PJET(10,15,10),FTOP(5,10),LPJ(JPTMAX+2,15,10)
*KEND.

*KEEP,QJMACS.
C------------ /QJMACS/ --- Buffer for jet and topological routines -----
         INTEGER JTBIMX,JTBOMX,JPARMX,JTBI,JTBIT,JTBO,JTBOF
         DOUBLE PRECISION QPI,QTBIR,QPO,QTBOR
         PARAMETER (JTBIMX =10000,JTBOMX = 30,JPARMX = 5)
         COMMON /QCTBUF/QPI(5,JTBIMX),QTBIR(JPARMX,JTBIMX),
     +                  QPO(5,JTBOMX),QTBOR(JPARMX,JTBOMX),
     +                  JTBI,JTBIT(JTBIMX),
     +                  JTBO,JTBOF(JPARMX,JTBIMX)
C     jtbi       number of input vectors (max : jtbimx).
C     qpi(i,j)   particle input vector j; i=1,2,3,4:px,py,pz,e; i=5 free
C     jtbit(j)   pointer to corresponding q-vector
C     qtbir(k,j) scalar input k for each input vector j
C     jtbo       number of output jets   (max : jtbomx)
C     qpo(i,j)   jet output vector (jet axis) i=1,2,3,4:px,py,pz,e
C     jtbof(k,i) number of jet for input particle i in multiplet k
C     qtbor(k,j) scalar output result k for each jet j (k_max : jparmx)
C                (will be stored as user words in Q_vector)
*
*KEND.
       INTEGER JETMUL
       DIMENSION LDC(5),NHLS(5),IDP(5),LD(2*JPTMAX+2,5),LDA(5)
       DIMENSION P(5,JPTMAX+50),PR(5,JPTMAX+50)
       EQUIVALENCE (P(1,1),QPI(1,1))
       EQUIVALENCE (PR(1,1),QTBIR(1,1))
C
C
      DATA JCAL/0/
      DATA JND,JNDL,JNDH,JNDLM1,JETFU,NEVENT /0,0,0,0,0,0/
      SAVE JETMUL

      JETFU=JETF(INDEC)

      JETMUL = JETML
************************************************************************
*                                                                      *
*      INITIALIZE JET MULTIPLET FROM PREVIOUS (LOWER) MULTIPLET        *
*      OF THE SAME JET FUNCTION                                        *
************************************************************************
C                          THE RANGE OF JET NAMES JND FOR CURRENT JETMUL
    8 JNDH=JETMUL*(JETMUL+1)/2
      JTMLM1=JETMUL-1
      JNDL=JNDH-JTMLM1
      JNDHM1=JNDH-1
      JNDLM1=JNDL-1
C                           INITIALIZE JET MEMBER LISTS FOR THE NEW JETS
      DO 3 I=1,IPTMAX+2
      LPJ(I,JNDH,INDEC)=0
 3    CONTINUE
      DO 1 J=JNDL,JNDHM1
      IMAX=LPJ(1,J-JTMLM1,INDEC)+2
      DO 2 I=1,IPTMAX+2
      LPJ(I,J,INDEC)=0
      IF(I.GT.IMAX) GOTO 2
      LPJ(I,J,INDEC)=LPJ(I,J-JTMLM1,INDEC)
  2   CONTINUE
      JND =LPJ(2,J-JTMLM1,INDEC) + JTMLM1
      LPJ(2,J,INDEC)=JND
C     CALL SETP(JND-JTMLM1,JND)
      DO 5 I=1,6
  5   PJET(I,JND,INDEC)=PJET(I,JND-JTMLM1,INDEC)
  1   CONTINUE
      LPJ(2,JNDH,INDEC)=LPJ(2,JNDHM1,INDEC)+1
C   AND THE NEW VIRGIN JET MOMENTUM
      DO 6 I=1,10
      PJET(I,JND+1,INDEC)=0.
  6   CONTINUE
      EC2=ECONF
      DMMT=0.
           IF(NEVPRI.GE.2) THEN
             PRINT *,'INI"ON FROM PREVIOS MULT FINISHED'
             PRINT *,
     1 JNDL,'=< JND <=',JNDH,('JET#,-LIST LPJ=',JND,(LPJ(I,JND,INDEC),
     2I=1,(LPJ(1,JND,INDEC)+2)),JND=JNDL,JNDH)
                           ENDIF
      RETURN
************************************************************************
*      ENTRY POINT IDECSM                                              *
*      INITIALIZE JET MULTIPLET FROM PREVIOS JET DECOMPOSITION INDEX,  *
*      BUT SAME MULTIPLET
************************************************************************
       ENTRY QDECPF(JTMUL,INDEC,INDEX)
C     IF(INIMUL.EQ.1) CALL IDECPF(JETMUL,INDEC,INDEX,DFJET) in sr edecx
       IF(INDEX.LE.0) GOTO 99
       IF(INDEX.GE.INDEC) GOTO 99
       IF(JTMUL.EQ.JETMUL) GOTO 7
       IF(JTMUL.NE.(JETMUL+1)) GOTO 99
       INDEC=INDEX
       JETMUL=JTMUL
       GOTO 8
    7 CONTINUE
      DO 21 J=JNDL,JNDH
      IMAX=LPJ(1,J,INDEX)+2
      DO 22 I=1,IPTMAX+2
      LPJ(I,J,INDEC)=0
      IF(I.GT.IMAX) GOTO 22
      LPJ(I,J,INDEC)=LPJ(I,J,INDEX)
  22   CONTINUE
  21   CONTINUE
C                                                 INITIALIZE JET MOMENTA
      JPL=LPJ(2,JNDL,INDEC)
      JPH=LPJ(2,JNDH,INDEC)
C     CALL SETP(J-20*(INDEX-INDEC),J)
      DO 24 J=JPL,JPH
      DO 25 I=1,10
  25  PJET(I,J,INDEC)=PJET(I,J,INDEX)
  24   CONTINUE
      EC2=ECONF
      DMMT=0.
*070394    IF(NEVENT.GE.2) THEN
*            PRINT *,'QEMIN1, INI"ON FROM PREVIOS JET FUNCTION '
*            PRINT *,
*    1 JNDL,'=< JND <=',JNDH,('JET#,-LIST LPJ=',JND,(LPJ(I,JND,INDEC),
*    2I=1,(LPJ(1,JND,INDEC)+2)),JND=JNDL,JNDH)
*     PRINT *,'PJET NR + VEC :'
*     PRINT *,(JND,(PJET(K,JND,INDEC),K=1,6),JND=JNDL,JNDH)
*                          ENDIF
      RETURN
************************************************************************
*                                                                      *
*      ENTRY POINT EMIN1                                               *
*      M I N I M I Z A T I O N    L O O P                              *
*                                                                      *
************************************************************************
      ENTRY QEMIN1(JETML,INDEC,DFTOP,FTOPO)
*     mepj=0(1) for multiple exchange of a particle between jets
C               forbidden(allowed)
      JETMUL = JETML
      EC2=ECONF
  9   CONTINUE
      IF(JCAL.GT.0) GOTO 1001
      JCAL=JCAL+1
      WRITE(6,1000) INDEC
 1001  CONTINUE
 1000 FORMAT(' ****  MEMBER EMIN1 IN ACTION ****   for INDEC=',I4)
C**   IF(MAXMUL.LT.5)  RETURN
C  LDC(I) =CURRENT # OF PARTICLES IN SET I
C  LDA(I) =# OF PARTICLES IN SET I AT START + THE IMMIGRANTS
C  NHLS(I)=# OF PARTICLES IN SET I AT START
C  IDP(I) = P - VECTOR INDEX FOR SET #I
C  MINPA IS THE MINIMUM NUMBER OF PARTICLES TO BE LEFT IN A JET

      DO 10 J=1,5
      IDP(J)=0
      LDC(J)=0
      LDA(J)=0
      NHLS(J)=0
  10  CONTINUE
      DO 11 J=1,JETMUL
      IDP(J)=LPJ(2,JNDLM1+J,INDEC)
      LDC(J)=LPJ(1,JNDLM1+J,INDEC)
      LDA(J)=LPJ(1,JNDLM1+J,INDEC)
      NHLS(J)=LPJ(1,JNDLM1+J,INDEC)
  11  CONTINUE
      DO 12 I=1,5
      DO 14 J=1,2*IPTMAX+2
 14   LD(J,I)=0
 12   CONTINUE
      DO 13 J=1,JETMUL
      LD(1,J)=LPJ(1,JNDLM1+J,INDEC)
      LD(2,J)=LPJ(2,JNDLM1+J,INDEC)
      DO 13 K=3,IPTMAX+2
      LD(K,J)=LPJ(K,JNDLM1+J,INDEC) + ITROFF(INDEC)
 13   CONTINUE
C* Event 4-vector
      J1=LPJ(2,1,INDEC)
      EVE=PJET(4,J1,INDEC)
      EVX=PJET(1,J1,INDEC)
      EVY=PJET(2,J1,INDEC)
      EVZ=PJET(3,J1,INDEC)
      EVS=PJET(5,J1,INDEC)**2
C                                    M I N I M I Z A T I O N   S T A R T
      DMMT=0.
  15  CONTINUE
C                                       M I N I M I Z A T I O N  L O O P
C   LOOK FOR THAT PARICLE TRANSITION FROM ANY (HOME) JET TO
C   ANY (TARGET) JET YIELDING THE LARGEST REDUCTION OF THE JETFUNCTION
      DMM=0.
C INDEX OF BEST HOME SET
      IHBEST=0
C INDEX OF BEST TARGET SET
      ITBEST=0
C INDEX OF BEST PARTICLE TO FLIP
      IPBEST=0
       FTOPO=0.
C                                             H O M E  S E T  L O O P  I
       DO 100 I=1,JETMUL
C                                                      HOME JET SELECTED
C                  ENOUGH PARTICLES IN HOME JET FOR FURTHER EMIGRATION ?
       IF(LDC(I).LE.MINPA) GOTO 100
C IF ONLY ORIGINAL MEMBERS OF HOMESET ARE ADMITTED FOR MIGRATION
       NHL=NHLS(I)+2
C IF ORIGINAL MEMBERS OF HOMESET AND IMMIGRANTS ARE ADMITTED
Cc     NHL=LDA(I)+2
       IPH=IDP(I)
C      CALL FMEQ(DMH0,IPH,EC2,JETFU)
C         CALCULATE CONTRIBUTION OF PRESENT HOME JET TO THE JET FUNCTION
       HE = PJET(4,IPH,INDEC)
       HX = PJET(1,IPH,INDEC)
       HY = PJET(2,IPH,INDEC)
       HZ = PJET(3,IPH,INDEC)
       EJH = HE*HE
       PJH = HX*HX + HY*HY + HZ*HZ
       SJH = EJH - PJH
C  GO TO THE REQUESTED JET FUNCTION
       GOTO (301,302,303,304,310,310,310,310,310,310),JETFU
  301   PJHC=HE*EVE-HX*EVX-HY*EVY-HZ*EVZ
        PJHC = PJHC*PJHC/EVS - SJH
        IF(PJHC.LT.0.) PJHC=0.
        DMH0=-SQRT(PJHC)
        GOTO 16
  302   FMEQ=EJH-PJH
        FMEQ=FMEQ/(EJH+EC2)
        DMH0=-SQRT(1.-FMEQ)
        GOTO 16
  303   FMEQ=EJH-PJH
C because of rounding errors when beam pipe particles present
        IF(FMEQ.LT.0.) FMEQ=0.
        DMH0=SQRT(FMEQ)
        GOTO 16
  304   DMH0=EJH-PJH
        GOTO 16
  310   DMH0=0.

   16 CONTINUE
        FTOPO=FTOPO + DMH0
       IF(NHL.LE.2) GOTO 100

C                                         T A R G E T  S E T  L O O P  J
         DO 110 J=1,JETMUL
C                                                    TARGET JET SELECTED
         IF(J.EQ.I) GOTO 110
         IPT=IDP(J)
C        CALL FMEQ(DMT0,IPT,EC2,JETFU)
C      CALCULATE CONTRIBUTION OF SELECTED TARGET JET TO THE JET FUNCTION
       TE=PJET(4,IPT,INDEC)
       TX = PJET(1,IPT,INDEC)
       TY = PJET(2,IPT,INDEC)
       TZ = PJET(3,IPT,INDEC)
       EJT = TE*TE
       PJT = TX*TX + TY*TY + TZ*TZ
       SJT = EJT - PJT
C                                       GO TO THE REQUESTED JET FUNCTION
       GOTO (311,312,313,314,320,320,320,320,320,320),JETFU
  311   PJTC=TE*EVE-TX*EVX-TY*EVY-TZ*EVZ
        PJTC = PJTC*PJTC/EVS - SJT
        IF(PJTC.LT.0) PJTC=0.
        DMT0=-SQRT(PJTC)
        GOTO 17
  312   FMEQ=EJT-PJT
        FMEQ=FMEQ/(EJT+EC2)
        DMT0=-SQRT(1.-FMEQ)
        GOTO 17
  313   FMEQ=EJT-PJT
C because of rounding errors when virgin target jet empty:
        IF(FMEQ.LT.0.) FMEQ=0.
        DMT0=SQRT(FMEQ)
        GOTO 17
  314   DMT0=EJT-PJT
        GOTO 17
  320   DMT0=0.
   17    DMIJ=DMH0 + DMT0
C  ************************  P A R T I C E L  S E A R C H   L O O P  IJP
C  *                                                                   *
        DO 111 ILH=3,NHL
        IJP=LD(ILH,I)
C                              TEST PARTICLE IJP FROM HOME SET SELECTED
        IF(IJP.LE.0) GOTO 111
C       CALL AFMEQ(DMT1,IPT,IJP,EC2,JETFU)
C   CALCULATE JET FUNCTION FOR TARGET JET + IMMIGRATED TEST PARTICLE
       TNE=TE + P(4,IJP)
       TNX=TX + P(1,IJP)
       TNY=TY + P(2,IJP)
       TNZ=TZ + P(3,IJP)
       ENJ = TNE*TNE
       PNJ = TNX*TNX + TNY*TNY + TNZ*TNZ
       SNJ = ENJ - PNJ
       GOTO (321,322,323,324,330,330,330,330,330,330),JETFU
  321   PJTC=TNE*EVE-TNX*EVX-TNY*EVY-TNZ*EVZ
        PJTC = PJTC*PJTC/EVS - SNJ
        IF(PJTC.LT.0.) PJTC=0.
        DMT1=-SQRT(PJTC)
        GOTO 18
  322   FMEQ=ENJ-PNJ
        FMEQ=FMEQ/(ENJ+EC2)
        DMT1=-SQRT(1.-FMEQ)
        GOTO 18
  323   FMEQ=ENJ-PNJ
C because of rounding errors when virgin target jet empty:
        IF(FMEQ.LT.0.) FMEQ=0.
        DMT1=SQRT(FMEQ)
        GOTO 18
  324   DMT1=ENJ-PNJ
        GOTO 18
  330   DMT1=0.
   18  CONTINUE
C       CALL SFMEQ(DMH1,IPH,IJP,EC2,JETFU)
C   CALCULATE JET FUNCTION FOR HOME JET - EMIGRATED TEST PARTICLE
       ENJ=(HE-P(4,IJP))*(HE-P(4,IJP))
       PNJ=(HX-P(1,IJP))*(HX-P(1,IJP))
     1   +(HY-P(2,IJP))*(HY-P(2,IJP))
     2   +(HZ-P(3,IJP))*(HZ-P(3,IJP))
       HNE=HE - P(4,IJP)
       HNX=HX - P(1,IJP)
       HNY=HY - P(2,IJP)
       HNZ=HZ - P(3,IJP)
       ENJ = HNE*HNE
       PNJ = HNX*HNX + HNY*HNY + HNZ*HNZ
       SNJ = ENJ - PNJ
       GOTO (331,332,333,334,340,340,340,340,340,340),JETFU
  331   PJHC=HNE*EVE-HNX*EVX-HNY*EVY-HNZ*EVZ
        PJHC = PJHC*PJHC/EVS - SNJ
        IF(PJHC.LT.0.) PJHC=0.
        DMH1=-SQRT(PJHC)
        GOTO 19
  332   FMEQ=ENJ-PNJ
        FMEQ=FMEQ/(ENJ+EC2)
        DMH1=-SQRT(1.-FMEQ)
        GOTO 19
  333   FMEQ=ENJ-PNJ
C because of rounding errors when NEARLY  jet empty:
        IF(FMEQ.LT.0.) FMEQ=0.
        DMH1=SQRT(FMEQ)
        GOTO 19
  334   DMH1=ENJ-PNJ
        GOTO 19
  340   DMH1=0.
C  IS JET FUNCTION WITH CURRENT TEST PARICLE
C    SMALLER THAN FOR ANY PREVIOS ONE ? -- THEN REMEMBER IT!
   19  DM = DMH1 + DMT1 - DMIJ
         IF(DM.GE.DMM) GOTO 111
         DMM=DM
         IHBEST=I
         ITBEST=J
         IPBEST=ILH
C                                                                 *
C *****************  END PARTICLE SEARCH LOOP *********************
 111     CONTINUE
C                                                                  *
C *****************  END TARGET JET LOOP ***************************
 110    CONTINUE
C                                                                   *
C *****************  END HOME JET LOOP ******************************
 100   CONTINUE
C   DMM WAS THE REDUCTION IN JET FUNCTION ACHIEVED FOR THE BEST
C    PARTICLE MIGRATION BETWEEN ANY TWO JETS.
C   DMMT IS THE REDUCTION ACCUMULATED SINCE BEGINNING THE DECOMPOSITION
      DMMT=DMMT+DMM
      IF(NEVPRI.GE.2)
     1PRINT *,'QEMIN1, END OF SEARCH LOOP, DMM=',DMM
     2,'PART. I FROM HOME TO TARGET JET',LD(IPBEST,IHBEST)
     3,IHBEST,ITBEST
      IF(DMM.EQ.0)  GOTO  200
C   A  B E T T E R  S O L U T I O N  H A S  B E E N  F O U N D
C    F L I P  P A R T I C E L P(,IJ)  F R O M
C         IJ =  LD(ILH,IH)=>LD(ILT,JT)
      IH=IHBEST
      JT=ITBEST
      ILH=IPBEST
      IJ=LD(ILH,IH)
CC    IF(IJ.LE.0) GOTO 200
      LDC(IH)=LDC(IH) - 1
      LDC(JT)=LDC(JT) + 1
      LDA(JT)=LDA(JT) + 1
      ILT=LDA(JT)+2
      LD(ILT,JT)=LD(ILH,IH)
      LD(ILH,IH)=-LD(ILH,IH)
      IPH=IDP(IH)
      IPT=IDP(JT)
C  PARTICEL IJ HAS BEEN INVALIDATED IN LD(HOME)
C  PARTICEL IJ HAS BEEN ADDED     TO LD(TARGET)
C  UPDATE FOUR MOMENTA OF MODIFIED JETS
C     CALL SUB(IPH,IJ,IPH)
C     CALL ADD(IPT,IJ,IPT)
      DO 130 I=1,4
      PJET(I,IPH,INDEC)=PJET(I,IPH,INDEC)-P(I,IJ)
      PJET(I,IPT,INDEC)=PJET(I,IPT,INDEC)+P(I,IJ)
  130 CONTINUE
      PJET(6,IPH,INDEC)=PJET(6,IPH,INDEC)-PR(1,IJ)
      PJET(6,IPT,INDEC)=PJET(6,IPT,INDEC)+PR(1,IJ)
C    N O W  S E A R C H  F O R  N E X T  B E S T  F L I P
      GOTO 15
 200  CONTINUE
C   NO BETTER VALUE OF THE JET FUNCTION HAS BEEN FOUND
C    BY TRYING A NEW JET ASSIGNMENT FOR EACH SINGLE PARTICLE.
C    E N D  O F  M I N I M I Z A T I O N
C   D E C O M P O S I T I O N  D O N E
      DFTOP=DMMT
C   C O M P R E S S  LD   A R R A Y S
      DO 30 J=1,JETMUL
      LDC(J)=0
       DO 31 I=3,2*IPTMAX+2
       M1=LD(I,J)
       IF(M1.LE.0) GOTO 31
       LDC(J)=LDC(J) + 1
       LDCJ=LDC(J)
       LD(LDCJ+2,J)=M1
  31   CONTINUE
      NL3=LDC(J)+3
      IF(NL3.GT.(2*IPTMAX+2)) GOTO 30
      DO 32 I=NL3,2*IPTMAX+2
  32  LD(I,J)=0
  30  LD(1,J)=LDC(J)
      DO 40 J=1,JETMUL
      JP=JNDLM1+J
      LPJ(1,JP,INDEC)=LD(1,J)
      LPJ(2,JP,INDEC)=LD(2,J)
      DO 41 I=1,IPTMAX+2
C  UPDATE JET MEMBER LISTINGS
      LPJ(I,JP,INDEC)=LD(I,J) - ITROFF(INDEC)
   41 CONTINUE
      JND=LPJ(2,JP,INDEC)
C  ADD M AND |P| TO JET VECTORS
      EJ=PJET(4,JND,INDEC)**2
      PJ=0.
      DO 42 I=1,3
      PJ=PJ+PJET(I,JND,INDEC)**2
   42 CONTINUE
      SMSQ=EJ-PJ
      IF (SMSQ.LT.0.) SMSQ=0.
      PJET(5,JND,INDEC)=SQRT(SMSQ)
C because of rounding errors when NEARLY  jet empty:
      PJET(8,JND,INDEC)=SQRT(PJ)
  40  CONTINUE
      RETURN
  99  RETURN
      END
*CMZ :  2.00/04 31/07/2000  21.11.45  by  Tancredi Carli
*CMZ :  1.01/02 12/05/92  10.27.55  by  M. Erdmann
*CMZ :  0.05/00 16/12/91  20.44.48  by  M. Erdmann
*-- Author :    C. Jacobsson   24/07/91
      SUBROUTINE QEMIN2 (JETMUL,INDEC,DMMT,FTOPO,MREV,NEW,IFLAG)
**********************************************************************
*    PURPOSE
*     SEARCH FOR A BETTER MINIMUM THAN A PREVIOS ONE
*       by climbing up along the shallowest slope, for up to mrev steps
*       if 'down' step is found, it tries to find a minimum from
*       there along the steepest slope down
*
C* AUTHOR: G. KNIES  13-06-91
C     VERSION OF 31/1/91  CAN BE CALLED FOR JETMULTIPL    2<=JETMUL<=5
C     VERSION OF 15/2/91  CAN BE CALLED JETFUNCTION INDEX 1<=INDEC<=10
C     VERSION OF 10/6/91  covariant N-directional thrust included
C     VERSION OF 13/6/91  can go reverse to search for 2. minimum
C     VERSION OF 19/6/91  reject min2 if not deeper than min1
C     VERSION OF 11/11/91  Test on index<2*jptmax for ijp,ij,ldjc
*D: QEMIN2 00500 gk. add some safety
C  ***************  INPUT PARAMETERS  ********************************
C  *
C   JETMUL = CURRENT MULTIPLICITY OF JETS,
C   INDEC = POSITION OF CALL FOR CURRENT JETFUNCTION
C   MREV = LIMIT FOR 'CLIMBING' REVERS STEPS
C     WARM START: REFINEMENT OF A J=JETMUL MULTPLICITY DECOMPOSITION
C     BE DECOMPOSED.
C   MINPA  = MINIMUM NUMBER OF PARTICLES REQUESTED FOR A JET
C
C     VIA COMMON/QCTBUF/
C   JTBI  = NUMBER OF INPUT VECTORS FOR CURRENT EVENT (MAX : JTBIMX)
C   QPI(I,IPA) THE INPUT PARTICLE MOMENTUM VECTORS, 1=<IPA<=JTBI
C               I=1,2,3,4,5: PX,PY,PZ,E,M; I=6: CHARGE
C  *
C  *******************  OUTPUT PARAMETERS   **************************
C  *
C     DMMT = CHANGE in value of jetfunction
C     NEW  = 0(no)/1(an) decline of jetfunction found
C  *
C  ****************  INTERNAL PARAMETERS  **************************
C  *
C   THE (INTERNAL) JET "NAMES" ARE "JND":
C    1-JET DECO: JND = 1 (TRIVIAL, UNDECOMPOSED EVENT)
C    2-JET DECO: JND = 2,3
C    3-JET DECO: JND = 4,5,6
C    4-JET DECO: JND = 7,8,9,10
C    5-JET DECO: JND = 11,12,13,14,15
C    JINDH = HIGHEST JET NAME AT JND= JETMUL*(JETMUL+1)/2
C    JINDL = LOWEST JET NAME AT JND = JINDH - (JETMUL-1)
C
C   LIST OF PARTICLE ASSIGNMENTS TO JETS IN ARRAY LPJ(I,JND,INDEC)
C    LPJ(I,JND,INDEC) = IPA INDEX FOR PARTICLES IN SUBSET JND, AT I>2
C    LPJ(1,JND,INDEC) = (CURRENT) NO. OF PARTICLES IN JET JND
C    LPJ(2,JND,INDEC) = ICJ FOR MOMENTUM VECTOR OF CURRENT JET JND
C  *
C  *********************************************************************
C
C   THE DECOMPOSITION
C    IS CONTROLLED BY THE CHOICE OF THE JET FUNCTION "JETFU",
C    AND CAN BE INFLUENCED BY SOME BOUNDARY CONDITIONS.
C   JETFU SELECTS THE JETFUNCTION TO BE MINIMIZED
C     JETFU    1     2      3    4    5      6     7  8  9  10  *****
C             -P   -BETA    M   M**2  PETEE  USER   USER USER
C

C                                                        INTERNAL ARRAYS
C     LDC(I)     NO OF CURRENT VALID PARTICLES IN SET I
C     LDA(I)     NO OF ORIGINAL + IMMIGRATED PARTICLES IN SET I
*D: QEMIN2 10102 me. lower case to upper case

*KEEP,DECOMA.
        INTEGER IPTMAX,IPTOT,ITRTOT,ITRSRC,MEVENT
     1,JETF,IFRAME,ITROFF,INIMUL,IDPREV, NCON, NPRI, IFLAGG, JETFU
     2,IREV
     3,MAXMUL,JORD,IFUPOS,MINPA,MAXCHA,ITERIJ,NEVPRI,MODUS
      COMMON/QCOCOM/IPTMAX,IPTOT,ITRTOT,ITRSRC,MEVENT
     1,JETF(10),JETNAM(10),IFRAME(10),ITROFF(10),INIMUL(10),IDPREV(10)
     2,IREV(10)
     3,MAXMUL,JORD,IFUPOS,MINPA,MAXCHA,ITERIJ(5),ECONF,NEVPRI,MODUS
      CHARACTER*4 JETNAM
      CHARACTER*7 JETNA

      PARAMETER (JPTMAX=150)
      PARAMETER (JFROFF=JPTMAX+50)
        REAL PJET,FTOP,LPJ
      COMMON/QRECOM/ PJET(10,15,10),FTOP(5,10),LPJ(JPTMAX+2,15,10)
*
*KEEP,QJMACS.
C------------ /QJMACS/ --- Buffer for jet and topological routines -----
         INTEGER JTBIMX,JTBOMX,JPARMX,JTBI,JTBIT,JTBO,JTBOF
         DOUBLE PRECISION QPI,QTBIR,QPO,QTBOR
         PARAMETER (JTBIMX =10000,JTBOMX = 30,JPARMX = 5)
         COMMON /QCTBUF/QPI(5,JTBIMX),QTBIR(JPARMX,JTBIMX),
     +                  QPO(5,JTBOMX),QTBOR(JPARMX,JTBOMX),
     +                  JTBI,JTBIT(JTBIMX),
     +                  JTBO,JTBOF(JPARMX,JTBIMX)
C     jtbi       number of input vectors (max : jtbimx).
C     qpi(i,j)   particle input vector j; i=1,2,3,4:px,py,pz,e; i=5 free
C     jtbit(j)   pointer to corresponding q-vector
C     qtbir(k,j) scalar input k for each input vector j
C     jtbo       number of output jets   (max : jtbomx)
C     qpo(i,j)   jet output vector (jet axis) i=1,2,3,4:px,py,pz,e
C     jtbof(k,i) number of jet for input particle i in multiplet k
C     qtbor(k,j) scalar output result k for each jet j (k_max : jparmx)
C                (will be stored as user words in Q_vector)
*
*KEND.
*
       DIMENSION LDC(5),NHLS(5),IDP(5),LD(2*JPTMAX+2,5),LDA(5)
       DIMENSION TJET(10,15)
       DIMENSION P(5,2*JPTMAX),PR(5,2*JPTMAX)
       EQUIVALENCE (P(1,1),QPI(1,1))
       EQUIVALENCE (PR(1,1),QTBIR(1,1))
       LOGICAL DOWN
C
C
      DATA JCAL/0/
C and only to satisfy the silly compiler I initialize
      DATA IJP/0/
      IFLAG=0
      DOWN=.FALSE.
      JETFU=JETF(INDEC)

************************************************************************
*                                                                      *
*      INITIALIZE JET MULTIPLET FROM THE ALREADY ACHIEVED MINIMUM      *
*      OF THE SAME JET FUNCTION AND MULTIPLET                          *
************************************************************************
C  number of backward steps
      NREV=0
C                          THE RANGE OF JET NAMES JND FOR CURRENT JETMUL
      JNDH=JETMUL*(JETMUL+1)/2
      JTMLM1=JETMUL-1
      JNDL=JNDH-JTMLM1
      JNDHM1=JNDH-1
      JNDLM1=JNDL-1
C   JET MEMBER LISTS and momenta are already existing -
      EC2=ECONF
      DMMT=0.
           IF(NEVPRI.GE.2) THEN
             PRINT *,'INI"ON FROM PREVIOS MULT FINISHED'
             PRINT *,
     1 JNDL,'=< JND <=',JNDH,('JET#,-LIST LPJ=',JND,(LPJ(I,JND,INDEC),
     2I=1,(LPJ(1,JND,INDEC)+2)),JND=JNDL,JNDH)
                           ENDIF
************************************************************************
*                                                                      *
*   R E V E R S E   M I N I M I Z A T I O N    L O O P                 *
*                                                                      *
************************************************************************
      IF(JCAL.GT.0) GOTO 1001
      JCAL=JCAL+1
      WRITE(6,1000) INDEC
 1001  CONTINUE
 1000 FORMAT(' ****  MEMBER EMIN2 IN ACTION ****   for INDEC=',I4)
C  LDC(I) =CURRENT # OF PARTICLES IN SET I
C  LDA(I) =# OF PARTICLES IN SET I AT START + THE IMMIGRANTS
C  NHLS(I)=# OF PARTICLES IN SET I AT START
C  IDP(I) = P - VECTOR INDEX FOR SET #I
C  MINPA IS THE MINIMUM NUMBER OF PARTICLES TO BE LEFT IN A JET

      DO 1  J=1,5
      IDP(J)=0
      LDC(J)=0
      LDA(J)=0
      NHLS(J)=0
  1   CONTINUE
      DO 2  J=1,JETMUL
      JP = JNDLM1+J
      IDP(J)=LPJ(2,JP,INDEC)
      LDC(J)=LPJ(1,JP,INDEC)
      LDA(J)=LPJ(1,JP,INDEC)
      NHLS(J)=LPJ(1,JP,INDEC)
      DO 3 K=1,10
  3   TJET(K,JP)=PJET(K,JP,INDEC)
  2   CONTINUE
      DO 4 I=1,5
      DO 5 J=1,2*IPTMAX+2
  5   LD(J,I)=0
  4   CONTINUE
      DO 6 J=1,JETMUL
      LD(1,J)=LPJ(1,JNDLM1+J,INDEC)
      LD(2,J)=LPJ(2,JNDLM1+J,INDEC)
      DO 7 K=3,IPTMAX+2
  7   LD(K,J)=LPJ(K,JNDLM1+J,INDEC) + ITROFF(INDEC)
  6   CONTINUE
C* Event 4-vector
      J1=LPJ(2,1,INDEC)
      EVE=PJET(4,J1,INDEC)
      EVX=PJET(1,J1,INDEC)
      EVY=PJET(2,J1,INDEC)
      EVZ=PJET(3,J1,INDEC)
      EVS=PJET(5,J1,INDEC)**2
C                                    M I N I M I Z A T I O N   S T A R T
      DMMT=0.
      DMML=0.
  15  CONTINUE
C  set sufficient high initial value for minimum chance of jet function
      DMM=100000.
C                                       M I N I M I Z A T I O N  L O O P
C   LOOK FOR THAT PARICLE TRANSITION FROM ANY (HOME) JET TO
C   ANY (TARGET) JET YIELDING THE SMALLEST INCREASE OF THE JETFUNCTION
CCC   DMM=0.
C INDEX OF BEST HOME SET
      IHBEST=0
C INDEX OF BEST TARGET SET
      ITBEST=0
C INDEX OF BEST PARTICLE TO FLIP
      IPBEST=0
      FTOPO=0.
C                                             H O M E  S E T  L O O P  I
       DO 100 I=1,JETMUL
C                                                      HOME JET SELECTED
C                  ENOUGH PARTICLES IN HOME JET FOR FURTHER EMIGRATION ?
       IF(LDC(I).LE.MINPA) GOTO 100
C IF ONLY ORIGINAL MEMBERS OF HOMESET ARE ADMITTED FOR MIGRATION
       NHL=NHLS(I)+2
C IF ORIGINAL MEMBERS OF HOMESET AND IMMIGRANTS ARE ADMITTED
       IF(DOWN .AND. IREV(INDEC).EQ.2) NHL=LDA(I)+2
       IF(NHL.LE.2) GOTO 100
       IPH=IDP(I)
C      CALL FMEQ(DMH0,IPH,EC2,JETFU)
C         CALCULATE CONTRIBUTION OF PRESENT HOME JET TO THE JET FUNCTION
       HE = TJET(4,IPH)
       HX = TJET(1,IPH)
       HY = TJET(2,IPH)
       HZ = TJET(3,IPH)
       EJH = HE*HE
       PJH = HX*HX + HY*HY + HZ*HZ
       SJH = EJH - PJH
C  GO TO THE REQUESTED JET FUNCTION
       GOTO (301,302,303,304,310,310,310,310,310,310),JETFU
  301   PJHC=HE*EVE-HX*EVX-HY*EVY-HZ*EVZ
        PJHC = PJHC*PJHC/EVS - SJH
        IF(PJHC.LT.0.) PJHC=0.
        DMH0=-SQRT(PJHC)
        GOTO 16
  302   FMEQ=EJH-PJH
        FMEQ=FMEQ/(EJH+EC2)
        DMH0=-SQRT(1.-FMEQ)
        GOTO 16
  303   FMEQ=EJH-PJH
C because of rounding errors when beam pipe particles present
        IF(FMEQ.LT.0.) FMEQ=0.
        DMH0=SQRT(FMEQ)
        GOTO 16
  304   DMH0=EJH-PJH
        GOTO 16
  310   DMH0=0.

   16 CONTINUE
        FTOPO=FTOPO+DMH0

C                                         T A R G E T  S E T  L O O P  J
         DO 110 J=1,JETMUL
C                                                    TARGET JET SELECTED
         IF(J.EQ.I) GOTO 110
         IPT=IDP(J)
C        CALL FMEQ(DMT0,IPT,EC2,JETFU)
C      CALCULATE CONTRIBUTION OF SELECTED TARGET JET TO THE JET FUNCTION
       TE = TJET(4,IPT)
       TX = TJET(1,IPT)
       TY = TJET(2,IPT)
       TZ = TJET(3,IPT)
       EJT = TE*TE
       PJT = TX*TX + TY*TY + TZ*TZ
       SJT = EJT - PJT
C                                       GO TO THE REQUESTED JET FUNCTION
       GOTO (311,312,313,314,320,320,320,320,320,320),JETFU
  311   PJTC=TE*EVE-TX*EVX-TY*EVY-TZ*EVZ
        PJTC = PJTC*PJTC/EVS - SJT
        IF(PJTC.LT.0) PJTC=0.
        DMT0=-SQRT(PJTC)
        GOTO 17
  312   FMEQ=EJT-PJT
        FMEQ=FMEQ/(EJT+EC2)
        DMT0=-SQRT(1.-FMEQ)
        GOTO 17
  313   FMEQ=EJT-PJT
C because of rounding errors when virgin target jet empty:
        IF(FMEQ.LT.0.) FMEQ=0.
        DMT0=SQRT(FMEQ)
        GOTO 17
  314   DMT0=EJT-PJT
        GOTO 17
  320   DMT0=0.
   17    DMIJ=DMH0 + DMT0
C  ************************  P A R T I C E L  S E A R C H   L O O P  IJP
C  *                                                                   *
        DO 111 ILH=3,NHL
        IJP=LD(ILH,I)
C                              TEST PARTICLE IJP FROM HOME SET SELECTED
        IF(IJP.LE.0) GOTO 111
        IF(IJP.GT.(2*JPTMAX)) GOTO 99
C       CALL AFMEQ(DMT1,IPT,IJP,EC2,JETFU)
C   CALCULATE JET FUNCTION FOR TARGET JET + IMMIGRATED TEST PARTICLE
       TNE=TE + P(4,IJP)
       TNX=TX + P(1,IJP)
       TNY=TY + P(2,IJP)
       TNZ=TZ + P(3,IJP)
       ENJ = TNE*TNE
       PNJ = TNX*TNX + TNY*TNY + TNZ*TNZ
       SNJ = ENJ - PNJ
       GOTO (321,322,323,324,330,330,330,330,330,330),JETFU
  321   PJTC=TNE*EVE-TNX*EVX-TNY*EVY-TNZ*EVZ
        PJTC = PJTC*PJTC/EVS - SNJ
        IF(PJTC.LT.0.) PJTC=0.
        DMT1=-SQRT(PJTC)
        GOTO 18
  322   FMEQ=ENJ-PNJ
        FMEQ=FMEQ/(ENJ+EC2)
        DMT1=-SQRT(1.-FMEQ)
        GOTO 18
  323   FMEQ=ENJ-PNJ
C because of rounding errors when virgin target jet empty:
        IF(FMEQ.LT.0.) FMEQ=0.
        DMT1=SQRT(FMEQ)
        GOTO 18
  324   DMT1=ENJ-PNJ
        GOTO 18
  330   DMT1=0.
   18  CONTINUE
C       CALL SFMEQ(DMH1,IPH,IJP,EC2,JETFU)
C   CALCULATE JET FUNCTION FOR HOME JET - EMIGRATED TEST PARTICLE
       HNE=HE - P(4,IJP)
       HNX=HX - P(1,IJP)
       HNY=HY - P(2,IJP)
       HNZ=HZ - P(3,IJP)
       ENJ = HNE*HNE
       PNJ = HNX*HNX + HNY*HNY + HNZ*HNZ
       SNJ = ENJ - PNJ
       GOTO (331,332,333,334,340,340,340,340,340,340),JETFU
  331   PJHC=HNE*EVE-HNX*EVX-HNY*EVY-HNZ*EVZ
        PJHC = PJHC*PJHC/EVS - SNJ
        IF(PJHC.LT.0.) PJHC=0.
        DMH1=-SQRT(PJHC)
        GOTO 19
  332   FMEQ=ENJ-PNJ
        FMEQ=FMEQ/(ENJ+EC2)
        DMH1=-SQRT(1.-FMEQ)
        GOTO 19
  333   FMEQ=ENJ-PNJ
C because of rounding errors when NEARLY  jet empty:
        IF(FMEQ.LT.0.) FMEQ=0.
        DMH1=SQRT(FMEQ)
        GOTO 19
  334   DMH1=ENJ-PNJ
        GOTO 19
  340   DMH1=0.
C  IS JET FUNCTION WITH CURRENT TEST PARICLE
C    SMALLER THAN FOR ANY PREVIOS ONE ? -- THEN REMEMBER IT!
   19  DM = DMH1 + DMT1 - DMIJ
         IF(DM.GE.DMM) GOTO 111
         DMM=DM
         IHBEST=I
         ITBEST=J
         IPBEST=ILH
C                                                                 *
C *****************  END PARTICLE SEARCH LOOP *********************
 111     CONTINUE
C                                                                  *
C *****************  END TARGET JET LOOP ***************************
 110    CONTINUE
C                                                                   *
C *****************  END HOME JET LOOP ******************************
 100   CONTINUE
C   DMM WAS THE REDUCTION IN JET FUNCTION ACHIEVED FOR THE BEST
C    PARTICLE MIGRATION BETWEEN ANY TWO JETS.
C   DMMT IS THE REDUCTION ACCUMULATED SINCE BEGINNING THE DECOMPOSITION
      IF(DOWN .AND. DMM.GE.0.) GOTO 200
      DMMT=DMMT+DMM
C   F O R   T H E  B E S T   S O L U T I O N   F O U N D
C    F L I P  P A R T I C E L P(,IJ)  F R O M
C         IJ =  LD(ILH,IH)=>LD(ILT,JT)
      IH=IHBEST
      JT=ITBEST
      ILH=IPBEST
      IJ=LD(ILH,IH)
      IF(IJ.GE.(2*JPTMAX)) GOTO 99
      IPH=IDP(IH)
      IPT=IDP(JT)
      IF(NEVPRI.GE.2)
     1PRINT *,'QEMIN2, SEARCH END, DMM,DMML=',DMM,DMML
     2,'I,HJ, TJ',LD(IPBEST,IHBEST)
     3,IHBEST,ITBEST
C     IF(IJ.LE.0) GOTO 200
      LDC(IH)=LDC(IH) - 1
      LDC(JT)=LDC(JT) + 1
      LDA(JT)=LDA(JT) + 1
      ILT=LDA(JT)+2
      LD(ILT,JT)=LD(ILH,IH)
      LD(ILH,IH)=-LD(ILH,IH)
C  PARTICEL IJ HAS BEEN INVALIDATED IN LD(HOME)
C  PARTICEL IJ HAS BEEN ADDED     TO LD(TARGET)
C  UPDATE FOUR MOMENTA OF MODIFIED JETS
C     CALL SUB(IPH,IJ,IPH)
C     CALL ADD(IPT,IJ,IPT)
      DO 130 I=1,4
      TJET(I,IPH)=TJET(I,IPH)-P(I,IJ)
      TJET(I,IPT)=TJET(I,IPT)+P(I,IJ)
  130 CONTINUE
      TJET(6,IPH)=TJET(6,IPH)-PR(1,IJ)
      TJET(6,IPT)=TJET(6,IPT)+PR(1,IJ)
C  particle with the smallest increment to the jet function is flipped
C  if jet function got smaller (success!), reverse search is ended .
      IF(DMM.LE.0)  GOTO  131
      IF(DMM.GT.DMML) NREV=NREV+1
      DMML=DMM
C  check if maximum number of steps reached (no hint for 2. min. found)
      IF(NREV.GT.MREV) GOTO 50
C    N O W  S E A R C H  F O R  N E X T  B E S T  F L I P
      GOTO 15
 131  DOWN=.TRUE.
      GOTO 15
 200  CONTINUE
C   2. MINIMUM  HAS BEEN REACHED , CHECK IF LOWER THAN MIN1
      IF(DMMT.GE.0.) GOTO 50
C   C O M P R E S S  LD   A R R A Y S
      DO 30 J=1,JETMUL
      LDC(J)=0
       DO 31 I=3,2*IPTMAX+2
       M1=LD(I,J)
       IF(M1.LE.0) GOTO 31
       LDC(J)=LDC(J) + 1
       LDCJ=LDC(J)
      IF(LDCJ.GT.(2*JPTMAX)) GOTO 99
       LD(LDCJ+2,J)=M1
  31   CONTINUE
      NL3=LDC(J)+3
      IF(NL3.GT.(2*JPTMAX+2)) GOTO 99
      DO 32 I=NL3,2*IPTMAX+2
  32  LD(I,J)=0
  30  LD(1,J)=LDC(J)
      DO 40 J=1,JETMUL
      JP=JNDLM1+J
      LPJ(1,JP,INDEC)=LD(1,J)
      LPJ(2,JP,INDEC)=LD(2,J)
C  UPDATE JET VECTORS
      DO 43 K=1,10
   43 PJET(K,JP,INDEC)=TJET(K,JP)
C  UPDATE JET MEMBER LISTINGS
      DO 41 I=1,IPTMAX+2
      LPJ(I,JP,INDEC)=LD(I,J) - ITROFF(INDEC)
   41 CONTINUE
      JND=LPJ(2,JP,INDEC)

C  ADD M AND |P| TO JET VECTORS
      EJ=PJET(4,JND,INDEC)**2
      PJ=0.
      DO 42 I=1,3
      PJ=PJ+PJET(I,JND,INDEC)**2
   42 CONTINUE
      SMSQ=EJ-PJ
      IF (SMSQ.LT.0.) SMSQ=0.
      PJET(5,JND,INDEC)=SQRT(SMSQ)
C because of rounding errors when NEARLY  jet empty:
      PJET(8,JND,INDEC)=SQRT(PJ)
  40  CONTINUE
      NEW=1
      RETURN
  50  NEW=0
C no better minimum found
      RETURN
  99  CONTINUE
      PRINT *,'QEMIN2: IJP OUT OF RANGE:',IJP
      IFLAG=1
      RETURN
      END
